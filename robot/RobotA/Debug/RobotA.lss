
RobotA.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001b360  00080000  00080000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0009b360  0009b360  0002b360  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     000009bc  20070000  0009b368  00030000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          00001348  200709bc  0009bd24  000309bc  2**2
                  ALLOC
  4 .ARM.attributes 00000029  00000000  00000000  000309bc  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  000309e5  2**0
                  CONTENTS, READONLY
  6 .debug_info   0004f642  00000000  00000000  00030a3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000a905  00000000  00000000  00080080  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00015293  00000000  00000000  0008a985  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000027c0  00000000  00000000  0009fc18  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000024b0  00000000  00000000  000a23d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0002dcb5  00000000  00000000  000a4888  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000320a7  00000000  00000000  000d253d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00076ecc  00000000  00000000  001045e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000b74c  00000000  00000000  0017b4b0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00080000 <_sfixed>:
   80000:	20088000 	.word	0x20088000
   80004:	0008220d 	.word	0x0008220d
   80008:	00087831 	.word	0x00087831
   8000c:	00082f41 	.word	0x00082f41
   80010:	00087831 	.word	0x00087831
   80014:	00082f55 	.word	0x00082f55
   80018:	00082f69 	.word	0x00082f69
	...
   8002c:	00087839 	.word	0x00087839
   80030:	00087831 	.word	0x00087831
   80034:	00000000 	.word	0x00000000
   80038:	00087849 	.word	0x00087849
   8003c:	00087859 	.word	0x00087859
   80040:	00087831 	.word	0x00087831
   80044:	00087831 	.word	0x00087831
   80048:	00087831 	.word	0x00087831
   8004c:	00087831 	.word	0x00087831
   80050:	00087831 	.word	0x00087831
   80054:	00087831 	.word	0x00087831
   80058:	00087831 	.word	0x00087831
   8005c:	00087831 	.word	0x00087831
   80060:	00081809 	.word	0x00081809
   80064:	00087831 	.word	0x00087831
   80068:	00000000 	.word	0x00000000
   8006c:	00087831 	.word	0x00087831
   80070:	00087831 	.word	0x00087831
   80074:	00087831 	.word	0x00087831
   80078:	00087831 	.word	0x00087831
	...
   80084:	00081845 	.word	0x00081845
   80088:	0008185d 	.word	0x0008185d
   8008c:	00087831 	.word	0x00087831
   80090:	00081875 	.word	0x00081875
   80094:	00087831 	.word	0x00087831
   80098:	00087831 	.word	0x00087831
   8009c:	00087831 	.word	0x00087831
   800a0:	00087831 	.word	0x00087831
   800a4:	00000000 	.word	0x00000000
   800a8:	00087831 	.word	0x00087831
   800ac:	00082c15 	.word	0x00082c15
   800b0:	00082a9d 	.word	0x00082a9d
   800b4:	00082bf9 	.word	0x00082bf9
   800b8:	00082ba5 	.word	0x00082ba5
   800bc:	00082bc1 	.word	0x00082bc1
   800c0:	00082bdd 	.word	0x00082bdd
   800c4:	00082ac1 	.word	0x00082ac1
   800c8:	00082ae5 	.word	0x00082ae5
   800cc:	00082b09 	.word	0x00082b09
   800d0:	00087831 	.word	0x00087831
   800d4:	00087831 	.word	0x00087831
   800d8:	00087831 	.word	0x00087831
   800dc:	00087831 	.word	0x00087831
   800e0:	000904cd 	.word	0x000904cd
   800e4:	00087831 	.word	0x00087831
   800e8:	00087831 	.word	0x00087831
   800ec:	00087831 	.word	0x00087831
   800f0:	00087831 	.word	0x00087831

000800f4 <__do_global_dtors_aux>:
   800f4:	b510      	push	{r4, lr}
   800f6:	4c05      	ldr	r4, [pc, #20]	; (8010c <__do_global_dtors_aux+0x18>)
   800f8:	7823      	ldrb	r3, [r4, #0]
   800fa:	b933      	cbnz	r3, 8010a <__do_global_dtors_aux+0x16>
   800fc:	4b04      	ldr	r3, [pc, #16]	; (80110 <__do_global_dtors_aux+0x1c>)
   800fe:	b113      	cbz	r3, 80106 <__do_global_dtors_aux+0x12>
   80100:	4804      	ldr	r0, [pc, #16]	; (80114 <__do_global_dtors_aux+0x20>)
   80102:	f3af 8000 	nop.w
   80106:	2301      	movs	r3, #1
   80108:	7023      	strb	r3, [r4, #0]
   8010a:	bd10      	pop	{r4, pc}
   8010c:	200709bc 	.word	0x200709bc
   80110:	00000000 	.word	0x00000000
   80114:	0009b368 	.word	0x0009b368

00080118 <frame_dummy>:
   80118:	4b08      	ldr	r3, [pc, #32]	; (8013c <frame_dummy+0x24>)
   8011a:	b510      	push	{r4, lr}
   8011c:	b11b      	cbz	r3, 80126 <frame_dummy+0xe>
   8011e:	4908      	ldr	r1, [pc, #32]	; (80140 <frame_dummy+0x28>)
   80120:	4808      	ldr	r0, [pc, #32]	; (80144 <frame_dummy+0x2c>)
   80122:	f3af 8000 	nop.w
   80126:	4808      	ldr	r0, [pc, #32]	; (80148 <frame_dummy+0x30>)
   80128:	6803      	ldr	r3, [r0, #0]
   8012a:	b903      	cbnz	r3, 8012e <frame_dummy+0x16>
   8012c:	bd10      	pop	{r4, pc}
   8012e:	4b07      	ldr	r3, [pc, #28]	; (8014c <frame_dummy+0x34>)
   80130:	2b00      	cmp	r3, #0
   80132:	d0fb      	beq.n	8012c <frame_dummy+0x14>
   80134:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   80138:	4718      	bx	r3
   8013a:	bf00      	nop
   8013c:	00000000 	.word	0x00000000
   80140:	200709c0 	.word	0x200709c0
   80144:	0009b368 	.word	0x0009b368
   80148:	0009b368 	.word	0x0009b368
   8014c:	00000000 	.word	0x00000000

00080150 <setup>:
TaskHandle_t xIdleHandle = NULL;

//------------------------------------------------------------------------------
void
setup ()
{
   80150:	b508      	push	{r3, lr}
  ROBOT.boot();
   80152:	4802      	ldr	r0, [pc, #8]	; (8015c <setup+0xc>)
   80154:	4b02      	ldr	r3, [pc, #8]	; (80160 <setup+0x10>)
   80156:	4798      	blx	r3
   80158:	bd08      	pop	{r3, pc}
   8015a:	bf00      	nop
   8015c:	200709d8 	.word	0x200709d8
   80160:	00080225 	.word	0x00080225

00080164 <loop>:
}

//------------------------------------------------------------------------------
void
loop ()
{
   80164:	e7fe      	b.n	80164 <loop>
   80166:	bf00      	nop

00080168 <_ZN3ard9Robot2017D1Ev>:
   * by this class constructor.
   *
   * Most members are public as this class aims at gathering all object references
   * It would be a pain (and stupid) to catch all them with non-const getter
   */
  class Robot2017
   80168:	4770      	bx	lr
   8016a:	bf00      	nop

0008016c <_Z18veryFast_interruptv>:
Robot2017 Robot2017::instance = Robot2017 ();

//Use this interrupt to execute periodic stuff that shall run at a very high frequency (typically steppers)
//Obviously at such a frequence a Thread is too heavy as the context-switch duration would be higher than the period
void veryFast_interrupt()
{
   8016c:	b508      	push	{r3, lr}
//  digitalWrite(DEBUG_1, 1); //uncomment to check period and delay with oscilloscope
  Robot2017::getInstance().nav.updateFromInterrupt();
   8016e:	4802      	ldr	r0, [pc, #8]	; (80178 <_Z18veryFast_interruptv+0xc>)
   80170:	4b02      	ldr	r3, [pc, #8]	; (8017c <_Z18veryFast_interruptv+0x10>)
   80172:	4798      	blx	r3
   80174:	bd08      	pop	{r3, pc}
   80176:	bf00      	nop
   80178:	20070ae4 	.word	0x20070ae4
   8017c:	00086355 	.word	0x00086355

00080180 <_Z14fast_interruptv>:
}

//Use this interrupt to execute period stuff that shall run at a high frequency
//At this frequence a Thread is quite heavy as the context-switch duration would be roughtly equal to the period
void fast_interrupt()
{
   80180:	b508      	push	{r3, lr}
//  digitalWrite(DEBUG_2, 1); //uncomment to check period and delay with oscilloscope
  gpioToolsIsrCallback(PERIOD_FAST_IT_US);
   80182:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   80186:	4b01      	ldr	r3, [pc, #4]	; (8018c <_Z14fast_interruptv+0xc>)
   80188:	4798      	blx	r3
   8018a:	bd08      	pop	{r3, pc}
   8018c:	00084669 	.word	0x00084669

00080190 <_ZN3ard9Robot2017C1Ev>:
//  digitalWrite(DEBUG_2, 0); //uncomment to check period and delay with oscilloscope
}

Robot2017::Robot2017 () :
   80190:	b538      	push	{r3, r4, r5, lr}
   80192:	4604      	mov	r4, r0
    hmi (50 /* ms */),
    log(LogThread::getInstance()),
    teleop(),
    actuators(),
    strategy(),
    nav()
   80194:	2132      	movs	r1, #50	; 0x32
   80196:	4b11      	ldr	r3, [pc, #68]	; (801dc <_ZN3ard9Robot2017C1Ev+0x4c>)
   80198:	4798      	blx	r3
   8019a:	4b11      	ldr	r3, [pc, #68]	; (801e0 <_ZN3ard9Robot2017C1Ev+0x50>)
   8019c:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
   801a0:	f104 00f4 	add.w	r0, r4, #244	; 0xf4
   801a4:	4b0f      	ldr	r3, [pc, #60]	; (801e4 <_ZN3ard9Robot2017C1Ev+0x54>)
   801a6:	4798      	blx	r3
   801a8:	2300      	movs	r3, #0
   801aa:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
   801ae:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
  class Robot2017;

  class ActuatorThread : public IThread
  {
  public:
    ActuatorThread () = default;
   801b2:	4a0d      	ldr	r2, [pc, #52]	; (801e8 <_ZN3ard9Robot2017C1Ev+0x58>)
   801b4:	f8c4 20f8 	str.w	r2, [r4, #248]	; 0xf8
   801b8:	f884 3108 	strb.w	r3, [r4, #264]	; 0x108
  class Robot2017;

  class StrategyThread : public IThread
  {
  public:
    StrategyThread () = default;
   801bc:	4b0b      	ldr	r3, [pc, #44]	; (801ec <_ZN3ard9Robot2017C1Ev+0x5c>)
   801be:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   801c2:	f504 7586 	add.w	r5, r4, #268	; 0x10c
   801c6:	4628      	mov	r0, r5
   801c8:	4b09      	ldr	r3, [pc, #36]	; (801f0 <_ZN3ard9Robot2017C1Ev+0x60>)
   801ca:	4798      	blx	r3
{
  actuators.addMiniThread(&nav);
   801cc:	4629      	mov	r1, r5
   801ce:	f104 00f8 	add.w	r0, r4, #248	; 0xf8
   801d2:	4b08      	ldr	r3, [pc, #32]	; (801f4 <_ZN3ard9Robot2017C1Ev+0x64>)
   801d4:	4798      	blx	r3
}
   801d6:	4620      	mov	r0, r4
   801d8:	bd38      	pop	{r3, r4, r5, pc}
   801da:	bf00      	nop
   801dc:	00084dad 	.word	0x00084dad
   801e0:	20071450 	.word	0x20071450
   801e4:	00086bd1 	.word	0x00086bd1
   801e8:	0009aab0 	.word	0x0009aab0
   801ec:	0009ac2c 	.word	0x0009ac2c
   801f0:	00085aa1 	.word	0x00085aa1
   801f4:	00086d49 	.word	0x00086d49

000801f8 <_GLOBAL__sub_I__ZN3ard9Robot20178instanceE>:
  Timer6.start(PERIOD_VERY_FAST_IT_US);
  Timer7.start(PERIOD_FAST_IT_US);

  //init OS
  g_ArdOs.init();//this function never ends
}
   801f8:	b510      	push	{r4, lr}
#include "BSP.h"

using namespace ard;

//singleton instanciation
Robot2017 Robot2017::instance = Robot2017 ();
   801fa:	4c05      	ldr	r4, [pc, #20]	; (80210 <_GLOBAL__sub_I__ZN3ard9Robot20178instanceE+0x18>)
   801fc:	4620      	mov	r0, r4
   801fe:	4b05      	ldr	r3, [pc, #20]	; (80214 <_GLOBAL__sub_I__ZN3ard9Robot20178instanceE+0x1c>)
   80200:	4798      	blx	r3
   80202:	4a05      	ldr	r2, [pc, #20]	; (80218 <_GLOBAL__sub_I__ZN3ard9Robot20178instanceE+0x20>)
   80204:	4905      	ldr	r1, [pc, #20]	; (8021c <_GLOBAL__sub_I__ZN3ard9Robot20178instanceE+0x24>)
   80206:	4620      	mov	r0, r4
   80208:	4b05      	ldr	r3, [pc, #20]	; (80220 <_GLOBAL__sub_I__ZN3ard9Robot20178instanceE+0x28>)
   8020a:	4798      	blx	r3
   8020c:	bd10      	pop	{r4, pc}
   8020e:	bf00      	nop
   80210:	200709d8 	.word	0x200709d8
   80214:	00080191 	.word	0x00080191
   80218:	20070064 	.word	0x20070064
   8021c:	00080169 	.word	0x00080169
   80220:	000909cd 	.word	0x000909cd

00080224 <_ZN3ard9Robot20174bootEv>:
  actuators.addMiniThread(&nav);
}

void
Robot2017::boot ()
{
   80224:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   80226:	4604      	mov	r4, r0
  init_bsp();
   80228:	4b1a      	ldr	r3, [pc, #104]	; (80294 <_ZN3ard9Robot20174bootEv+0x70>)
   8022a:	4798      	blx	r3

  gpioInit();
   8022c:	4b1a      	ldr	r3, [pc, #104]	; (80298 <_ZN3ard9Robot20174bootEv+0x74>)
   8022e:	4798      	blx	r3

  //Map fast periodic functions to timers interrupts
  Timer6.attachInterrupt(veryFast_interrupt);
   80230:	4e1a      	ldr	r6, [pc, #104]	; (8029c <_ZN3ard9Robot20174bootEv+0x78>)
   80232:	491b      	ldr	r1, [pc, #108]	; (802a0 <_ZN3ard9Robot20174bootEv+0x7c>)
   80234:	4630      	mov	r0, r6
   80236:	4f1b      	ldr	r7, [pc, #108]	; (802a4 <_ZN3ard9Robot20174bootEv+0x80>)
   80238:	47b8      	blx	r7
  Timer7.attachInterrupt(fast_interrupt);
   8023a:	4d1b      	ldr	r5, [pc, #108]	; (802a8 <_ZN3ard9Robot20174bootEv+0x84>)
   8023c:	491b      	ldr	r1, [pc, #108]	; (802ac <_ZN3ard9Robot20174bootEv+0x88>)
   8023e:	4628      	mov	r0, r5
   80240:	47b8      	blx	r7

  //Init debug serial link
  Serial.begin (/*baurate = */250000);
   80242:	491b      	ldr	r1, [pc, #108]	; (802b0 <_ZN3ard9Robot20174bootEv+0x8c>)
   80244:	481b      	ldr	r0, [pc, #108]	; (802b4 <_ZN3ard9Robot20174bootEv+0x90>)
   80246:	4b1c      	ldr	r3, [pc, #112]	; (802b8 <_ZN3ard9Robot20174bootEv+0x94>)
   80248:	4798      	blx	r3

  //Threads init
  hmi.init();
   8024a:	4620      	mov	r0, r4
   8024c:	4b1b      	ldr	r3, [pc, #108]	; (802bc <_ZN3ard9Robot20174bootEv+0x98>)
   8024e:	4798      	blx	r3
  hmi.ledDue_Tx.slowBlink(); //TODO pour le debug pour verifier que le thread est vivant
   80250:	f104 0054 	add.w	r0, r4, #84	; 0x54
   80254:	4b1a      	ldr	r3, [pc, #104]	; (802c0 <_ZN3ard9Robot20174bootEv+0x9c>)
   80256:	4798      	blx	r3

  log.init ();
   80258:	f8d4 00f0 	ldr.w	r0, [r4, #240]	; 0xf0
   8025c:	6803      	ldr	r3, [r0, #0]
   8025e:	681b      	ldr	r3, [r3, #0]
   80260:	4798      	blx	r3
  teleop.init ();
   80262:	f104 00f4 	add.w	r0, r4, #244	; 0xf4
   80266:	4b17      	ldr	r3, [pc, #92]	; (802c4 <_ZN3ard9Robot20174bootEv+0xa0>)
   80268:	4798      	blx	r3
  actuators.init ();
   8026a:	f104 00f8 	add.w	r0, r4, #248	; 0xf8
   8026e:	4b16      	ldr	r3, [pc, #88]	; (802c8 <_ZN3ard9Robot20174bootEv+0xa4>)
   80270:	4798      	blx	r3
  strategy.init();
   80272:	f504 7082 	add.w	r0, r4, #260	; 0x104
   80276:	4b15      	ldr	r3, [pc, #84]	; (802cc <_ZN3ard9Robot20174bootEv+0xa8>)
   80278:	4798      	blx	r3

  //Start everything
  Timer6.start(PERIOD_VERY_FAST_IT_US);
   8027a:	2132      	movs	r1, #50	; 0x32
   8027c:	4630      	mov	r0, r6
   8027e:	4c14      	ldr	r4, [pc, #80]	; (802d0 <_ZN3ard9Robot20174bootEv+0xac>)
   80280:	47a0      	blx	r4
  Timer7.start(PERIOD_FAST_IT_US);
   80282:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   80286:	4628      	mov	r0, r5
   80288:	47a0      	blx	r4

  //init OS
  g_ArdOs.init();//this function never ends
   8028a:	4812      	ldr	r0, [pc, #72]	; (802d4 <_ZN3ard9Robot20174bootEv+0xb0>)
   8028c:	4b12      	ldr	r3, [pc, #72]	; (802d8 <_ZN3ard9Robot20174bootEv+0xb4>)
   8028e:	4798      	blx	r3
   80290:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   80292:	bf00      	nop
   80294:	000820d9 	.word	0x000820d9
   80298:	000846ad 	.word	0x000846ad
   8029c:	200711ac 	.word	0x200711ac
   802a0:	0008016d 	.word	0x0008016d
   802a4:	00082401 	.word	0x00082401
   802a8:	200711b0 	.word	0x200711b0
   802ac:	00080181 	.word	0x00080181
   802b0:	0003d090 	.word	0x0003d090
   802b4:	20070dd8 	.word	0x20070dd8
   802b8:	000805dd 	.word	0x000805dd
   802bc:	00084e9d 	.word	0x00084e9d
   802c0:	00084c91 	.word	0x00084c91
   802c4:	00086bf9 	.word	0x00086bf9
   802c8:	00086c99 	.word	0x00086c99
   802cc:	00086ff5 	.word	0x00086ff5
   802d0:	00082429 	.word	0x00082429
   802d4:	200713a8 	.word	0x200713a8
   802d8:	000832cd 	.word	0x000832cd

000802dc <initVariant>:
*/

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }
   802dc:	b480      	push	{r7}
   802de:	af00      	add	r7, sp, #0
   802e0:	bf00      	nop
   802e2:	46bd      	mov	sp, r7
   802e4:	bc80      	pop	{r7}
   802e6:	4770      	bx	lr

000802e8 <main>:

/*
 * \brief Main entry point of Arduino application
 */
int main( void )
{
   802e8:	b580      	push	{r7, lr}
   802ea:	af00      	add	r7, sp, #0
	// Initialize watchdog
	watchdogSetup();
   802ec:	4b0a      	ldr	r3, [pc, #40]	; (80318 <main+0x30>)
   802ee:	4798      	blx	r3

	init();
   802f0:	4b0a      	ldr	r3, [pc, #40]	; (8031c <main+0x34>)
   802f2:	4798      	blx	r3

	initVariant();
   802f4:	4b0a      	ldr	r3, [pc, #40]	; (80320 <main+0x38>)
   802f6:	4798      	blx	r3

	delay(1);
   802f8:	2001      	movs	r0, #1
   802fa:	4b0a      	ldr	r3, [pc, #40]	; (80324 <main+0x3c>)
   802fc:	4798      	blx	r3

#if defined(USBCON)
	USBDevice.attach();
   802fe:	480a      	ldr	r0, [pc, #40]	; (80328 <main+0x40>)
   80300:	4b0a      	ldr	r3, [pc, #40]	; (8032c <main+0x44>)
   80302:	4798      	blx	r3
#endif

	setup();
   80304:	4b0a      	ldr	r3, [pc, #40]	; (80330 <main+0x48>)
   80306:	4798      	blx	r3

	for (;;)
	{
		loop();
   80308:	4b0a      	ldr	r3, [pc, #40]	; (80334 <main+0x4c>)
   8030a:	4798      	blx	r3
		if (serialEventRun) serialEventRun();
   8030c:	4b0a      	ldr	r3, [pc, #40]	; (80338 <main+0x50>)
   8030e:	2b00      	cmp	r3, #0
   80310:	d0fa      	beq.n	80308 <main+0x20>
   80312:	4b09      	ldr	r3, [pc, #36]	; (80338 <main+0x50>)
   80314:	4798      	blx	r3
	USBDevice.attach();
#endif

	setup();

	for (;;)
   80316:	e7f7      	b.n	80308 <main+0x20>
   80318:	00081b99 	.word	0x00081b99
   8031c:	00081921 	.word	0x00081921
   80320:	000802dd 	.word	0x000802dd
   80324:	00081c7d 	.word	0x00081c7d
   80328:	20070c74 	.word	0x20070c74
   8032c:	000816dd 	.word	0x000816dd
   80330:	00080151 	.word	0x00080151
   80334:	00080165 	.word	0x00080165
   80338:	0008188d 	.word	0x0008188d

0008033c <_sbrk>:
extern void _exit( int status ) ;
extern void _kill( int pid, int sig ) ;
extern int _getpid ( void ) ;

extern caddr_t _sbrk ( int incr )
{
   8033c:	b480      	push	{r7}
   8033e:	b085      	sub	sp, #20
   80340:	af00      	add	r7, sp, #0
   80342:	6078      	str	r0, [r7, #4]
    static unsigned char *heap = NULL ;
    unsigned char *prev_heap ;

    if ( heap == NULL )
   80344:	4b0a      	ldr	r3, [pc, #40]	; (80370 <_sbrk+0x34>)
   80346:	681b      	ldr	r3, [r3, #0]
   80348:	2b00      	cmp	r3, #0
   8034a:	d102      	bne.n	80352 <_sbrk+0x16>
    {
        heap = (unsigned char *)&_end ;
   8034c:	4b08      	ldr	r3, [pc, #32]	; (80370 <_sbrk+0x34>)
   8034e:	4a09      	ldr	r2, [pc, #36]	; (80374 <_sbrk+0x38>)
   80350:	601a      	str	r2, [r3, #0]
    }
    prev_heap = heap;
   80352:	4b07      	ldr	r3, [pc, #28]	; (80370 <_sbrk+0x34>)
   80354:	681b      	ldr	r3, [r3, #0]
   80356:	60fb      	str	r3, [r7, #12]

    heap += incr ;
   80358:	4b05      	ldr	r3, [pc, #20]	; (80370 <_sbrk+0x34>)
   8035a:	681a      	ldr	r2, [r3, #0]
   8035c:	687b      	ldr	r3, [r7, #4]
   8035e:	4413      	add	r3, r2
   80360:	4a03      	ldr	r2, [pc, #12]	; (80370 <_sbrk+0x34>)
   80362:	6013      	str	r3, [r2, #0]

    return (caddr_t) prev_heap ;
   80364:	68fb      	ldr	r3, [r7, #12]
}
   80366:	4618      	mov	r0, r3
   80368:	3714      	adds	r7, #20
   8036a:	46bd      	mov	sp, r7
   8036c:	bc80      	pop	{r7}
   8036e:	4770      	bx	lr
   80370:	20070c58 	.word	0x20070c58
   80374:	20071d04 	.word	0x20071d04

00080378 <link>:

extern int link( UNUSED(char *cOld), UNUSED(char *cNew) )
{
   80378:	b480      	push	{r7}
   8037a:	b083      	sub	sp, #12
   8037c:	af00      	add	r7, sp, #0
   8037e:	6078      	str	r0, [r7, #4]
   80380:	6039      	str	r1, [r7, #0]
    return -1 ;
   80382:	f04f 33ff 	mov.w	r3, #4294967295
}
   80386:	4618      	mov	r0, r3
   80388:	370c      	adds	r7, #12
   8038a:	46bd      	mov	sp, r7
   8038c:	bc80      	pop	{r7}
   8038e:	4770      	bx	lr

00080390 <_close>:

extern int _close( UNUSED(int file) )
{
   80390:	b480      	push	{r7}
   80392:	b083      	sub	sp, #12
   80394:	af00      	add	r7, sp, #0
   80396:	6078      	str	r0, [r7, #4]
    return -1 ;
   80398:	f04f 33ff 	mov.w	r3, #4294967295
}
   8039c:	4618      	mov	r0, r3
   8039e:	370c      	adds	r7, #12
   803a0:	46bd      	mov	sp, r7
   803a2:	bc80      	pop	{r7}
   803a4:	4770      	bx	lr
   803a6:	bf00      	nop

000803a8 <_fstat>:

extern int _fstat( UNUSED(int file), struct stat *st )
{
   803a8:	b480      	push	{r7}
   803aa:	b083      	sub	sp, #12
   803ac:	af00      	add	r7, sp, #0
   803ae:	6078      	str	r0, [r7, #4]
   803b0:	6039      	str	r1, [r7, #0]
    st->st_mode = S_IFCHR ;
   803b2:	683b      	ldr	r3, [r7, #0]
   803b4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   803b8:	605a      	str	r2, [r3, #4]

    return 0 ;
   803ba:	2300      	movs	r3, #0
}
   803bc:	4618      	mov	r0, r3
   803be:	370c      	adds	r7, #12
   803c0:	46bd      	mov	sp, r7
   803c2:	bc80      	pop	{r7}
   803c4:	4770      	bx	lr
   803c6:	bf00      	nop

000803c8 <_isatty>:

extern int _isatty( UNUSED(int file) )
{
   803c8:	b480      	push	{r7}
   803ca:	b083      	sub	sp, #12
   803cc:	af00      	add	r7, sp, #0
   803ce:	6078      	str	r0, [r7, #4]
    return 1 ;
   803d0:	2301      	movs	r3, #1
}
   803d2:	4618      	mov	r0, r3
   803d4:	370c      	adds	r7, #12
   803d6:	46bd      	mov	sp, r7
   803d8:	bc80      	pop	{r7}
   803da:	4770      	bx	lr

000803dc <_lseek>:

extern int _lseek( UNUSED(int file), UNUSED(int ptr), UNUSED(int dir) )
{
   803dc:	b480      	push	{r7}
   803de:	b085      	sub	sp, #20
   803e0:	af00      	add	r7, sp, #0
   803e2:	60f8      	str	r0, [r7, #12]
   803e4:	60b9      	str	r1, [r7, #8]
   803e6:	607a      	str	r2, [r7, #4]
    return 0 ;
   803e8:	2300      	movs	r3, #0
}
   803ea:	4618      	mov	r0, r3
   803ec:	3714      	adds	r7, #20
   803ee:	46bd      	mov	sp, r7
   803f0:	bc80      	pop	{r7}
   803f2:	4770      	bx	lr

000803f4 <_read>:

extern int _read(UNUSED(int file), UNUSED(char *ptr), UNUSED(int len) )
{
   803f4:	b480      	push	{r7}
   803f6:	b085      	sub	sp, #20
   803f8:	af00      	add	r7, sp, #0
   803fa:	60f8      	str	r0, [r7, #12]
   803fc:	60b9      	str	r1, [r7, #8]
   803fe:	607a      	str	r2, [r7, #4]
    return 0 ;
   80400:	2300      	movs	r3, #0
}
   80402:	4618      	mov	r0, r3
   80404:	3714      	adds	r7, #20
   80406:	46bd      	mov	sp, r7
   80408:	bc80      	pop	{r7}
   8040a:	4770      	bx	lr

0008040c <_write>:

extern int _write( UNUSED(int file), char *ptr, int len )
{
   8040c:	b480      	push	{r7}
   8040e:	b087      	sub	sp, #28
   80410:	af00      	add	r7, sp, #0
   80412:	60f8      	str	r0, [r7, #12]
   80414:	60b9      	str	r1, [r7, #8]
   80416:	607a      	str	r2, [r7, #4]
    int iIndex ;


//    for ( ; *ptr != 0 ; ptr++ )
    for ( iIndex=0 ; iIndex < len ; iIndex++, ptr++ )
   80418:	2300      	movs	r3, #0
   8041a:	617b      	str	r3, [r7, #20]
   8041c:	e010      	b.n	80440 <_write+0x34>
    {
//        UART_PutChar( *ptr ) ;

		// Check if the transmitter is ready
		  while ((UART->UART_SR & UART_SR_TXRDY) != UART_SR_TXRDY)
   8041e:	bf00      	nop
   80420:	4b0c      	ldr	r3, [pc, #48]	; (80454 <_write+0x48>)
   80422:	695b      	ldr	r3, [r3, #20]
   80424:	f003 0302 	and.w	r3, r3, #2
   80428:	2b00      	cmp	r3, #0
   8042a:	d0f9      	beq.n	80420 <_write+0x14>
			;

		  // Send character
		  UART->UART_THR = *ptr;
   8042c:	4a09      	ldr	r2, [pc, #36]	; (80454 <_write+0x48>)
   8042e:	68bb      	ldr	r3, [r7, #8]
   80430:	781b      	ldrb	r3, [r3, #0]
   80432:	61d3      	str	r3, [r2, #28]
{
    int iIndex ;


//    for ( ; *ptr != 0 ; ptr++ )
    for ( iIndex=0 ; iIndex < len ; iIndex++, ptr++ )
   80434:	697b      	ldr	r3, [r7, #20]
   80436:	3301      	adds	r3, #1
   80438:	617b      	str	r3, [r7, #20]
   8043a:	68bb      	ldr	r3, [r7, #8]
   8043c:	3301      	adds	r3, #1
   8043e:	60bb      	str	r3, [r7, #8]
   80440:	697a      	ldr	r2, [r7, #20]
   80442:	687b      	ldr	r3, [r7, #4]
   80444:	429a      	cmp	r2, r3
   80446:	dbea      	blt.n	8041e <_write+0x12>

		  // Send character
		  UART->UART_THR = *ptr;
    }

    return iIndex ;
   80448:	697b      	ldr	r3, [r7, #20]
}
   8044a:	4618      	mov	r0, r3
   8044c:	371c      	adds	r7, #28
   8044e:	46bd      	mov	sp, r7
   80450:	bc80      	pop	{r7}
   80452:	4770      	bx	lr
   80454:	400e0800 	.word	0x400e0800

00080458 <_exit>:

extern void _exit( int status )
{
   80458:	b580      	push	{r7, lr}
   8045a:	b082      	sub	sp, #8
   8045c:	af00      	add	r7, sp, #0
   8045e:	6078      	str	r0, [r7, #4]
    printf( "Exiting with status %d.\n", status ) ;
   80460:	6879      	ldr	r1, [r7, #4]
   80462:	4802      	ldr	r0, [pc, #8]	; (8046c <_exit+0x14>)
   80464:	4b02      	ldr	r3, [pc, #8]	; (80470 <_exit+0x18>)
   80466:	4798      	blx	r3

    for ( ; ; ) ;
   80468:	e7fe      	b.n	80468 <_exit+0x10>
   8046a:	bf00      	nop
   8046c:	00099470 	.word	0x00099470
   80470:	0009350d 	.word	0x0009350d

00080474 <_kill>:
}

extern void _kill( UNUSED(int pid), UNUSED(int sig) )
{
   80474:	b480      	push	{r7}
   80476:	b083      	sub	sp, #12
   80478:	af00      	add	r7, sp, #0
   8047a:	6078      	str	r0, [r7, #4]
   8047c:	6039      	str	r1, [r7, #0]
    return ;
   8047e:	bf00      	nop
}
   80480:	370c      	adds	r7, #12
   80482:	46bd      	mov	sp, r7
   80484:	bc80      	pop	{r7}
   80486:	4770      	bx	lr

00080488 <_getpid>:

extern int _getpid ( void )
{
   80488:	b480      	push	{r7}
   8048a:	af00      	add	r7, sp, #0
    return -1 ;
   8048c:	f04f 33ff 	mov.w	r3, #4294967295
}
   80490:	4618      	mov	r0, r3
   80492:	46bd      	mov	sp, r7
   80494:	bc80      	pop	{r7}
   80496:	4770      	bx	lr

00080498 <_ZN5PrintC1Ev>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
   80498:	b480      	push	{r7}
   8049a:	b083      	sub	sp, #12
   8049c:	af00      	add	r7, sp, #0
   8049e:	6078      	str	r0, [r7, #4]
   804a0:	4a05      	ldr	r2, [pc, #20]	; (804b8 <_ZN5PrintC1Ev+0x20>)
   804a2:	687b      	ldr	r3, [r7, #4]
   804a4:	601a      	str	r2, [r3, #0]
   804a6:	687b      	ldr	r3, [r7, #4]
   804a8:	2200      	movs	r2, #0
   804aa:	605a      	str	r2, [r3, #4]
   804ac:	687b      	ldr	r3, [r7, #4]
   804ae:	4618      	mov	r0, r3
   804b0:	370c      	adds	r7, #12
   804b2:	46bd      	mov	sp, r7
   804b4:	bc80      	pop	{r7}
   804b6:	4770      	bx	lr
   804b8:	0009ac58 	.word	0x0009ac58

000804bc <_ZN6StreamC1Ev>:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
   804bc:	b580      	push	{r7, lr}
   804be:	b082      	sub	sp, #8
   804c0:	af00      	add	r7, sp, #0
   804c2:	6078      	str	r0, [r7, #4]
   804c4:	687b      	ldr	r3, [r7, #4]
   804c6:	4618      	mov	r0, r3
   804c8:	4b06      	ldr	r3, [pc, #24]	; (804e4 <_ZN6StreamC1Ev+0x28>)
   804ca:	4798      	blx	r3
   804cc:	4a06      	ldr	r2, [pc, #24]	; (804e8 <_ZN6StreamC1Ev+0x2c>)
   804ce:	687b      	ldr	r3, [r7, #4]
   804d0:	601a      	str	r2, [r3, #0]
   804d2:	687b      	ldr	r3, [r7, #4]
   804d4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   804d8:	609a      	str	r2, [r3, #8]
   804da:	687b      	ldr	r3, [r7, #4]
   804dc:	4618      	mov	r0, r3
   804de:	3708      	adds	r7, #8
   804e0:	46bd      	mov	sp, r7
   804e2:	bd80      	pop	{r7, pc}
   804e4:	00080499 	.word	0x00080499
   804e8:	000994ec 	.word	0x000994ec

000804ec <NVIC_EnableIRQ>:
    The interrupt number cannot be a negative value.

    \param [in]      IRQn  Number of the external interrupt to enable
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   804ec:	b480      	push	{r7}
   804ee:	b083      	sub	sp, #12
   804f0:	af00      	add	r7, sp, #0
   804f2:	4603      	mov	r3, r0
   804f4:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   804f6:	4908      	ldr	r1, [pc, #32]	; (80518 <NVIC_EnableIRQ+0x2c>)
   804f8:	f997 3007 	ldrsb.w	r3, [r7, #7]
   804fc:	095b      	lsrs	r3, r3, #5
   804fe:	79fa      	ldrb	r2, [r7, #7]
   80500:	f002 021f 	and.w	r2, r2, #31
   80504:	2001      	movs	r0, #1
   80506:	fa00 f202 	lsl.w	r2, r0, r2
   8050a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   8050e:	bf00      	nop
   80510:	370c      	adds	r7, #12
   80512:	46bd      	mov	sp, r7
   80514:	bc80      	pop	{r7}
   80516:	4770      	bx	lr
   80518:	e000e100 	.word	0xe000e100

0008051c <NVIC_DisableIRQ>:
    The interrupt number cannot be a negative value.

    \param [in]      IRQn  Number of the external interrupt to disable
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
   8051c:	b480      	push	{r7}
   8051e:	b083      	sub	sp, #12
   80520:	af00      	add	r7, sp, #0
   80522:	4603      	mov	r3, r0
   80524:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
   80526:	4909      	ldr	r1, [pc, #36]	; (8054c <NVIC_DisableIRQ+0x30>)
   80528:	f997 3007 	ldrsb.w	r3, [r7, #7]
   8052c:	095b      	lsrs	r3, r3, #5
   8052e:	79fa      	ldrb	r2, [r7, #7]
   80530:	f002 021f 	and.w	r2, r2, #31
   80534:	2001      	movs	r0, #1
   80536:	fa00 f202 	lsl.w	r2, r0, r2
   8053a:	3320      	adds	r3, #32
   8053c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   80540:	bf00      	nop
   80542:	370c      	adds	r7, #12
   80544:	46bd      	mov	sp, r7
   80546:	bc80      	pop	{r7}
   80548:	4770      	bx	lr
   8054a:	bf00      	nop
   8054c:	e000e100 	.word	0xe000e100

00080550 <_ZN9UARTClasscvbEv>:
    void setInterruptPriority(uint32_t priority);
    uint32_t getInterruptPriority();

    void IrqHandler(void);

    operator bool() { return true; }; // UART always active
   80550:	b480      	push	{r7}
   80552:	b083      	sub	sp, #12
   80554:	af00      	add	r7, sp, #0
   80556:	6078      	str	r0, [r7, #4]
   80558:	2301      	movs	r3, #1
   8055a:	4618      	mov	r0, r3
   8055c:	370c      	adds	r7, #12
   8055e:	46bd      	mov	sp, r7
   80560:	bc80      	pop	{r7}
   80562:	4770      	bx	lr

00080564 <_ZN14HardwareSerialC1Ev>:

#include <inttypes.h>

#include "Stream.h"

class HardwareSerial : public Stream
   80564:	b580      	push	{r7, lr}
   80566:	b082      	sub	sp, #8
   80568:	af00      	add	r7, sp, #0
   8056a:	6078      	str	r0, [r7, #4]
   8056c:	687b      	ldr	r3, [r7, #4]
   8056e:	4618      	mov	r0, r3
   80570:	4b04      	ldr	r3, [pc, #16]	; (80584 <_ZN14HardwareSerialC1Ev+0x20>)
   80572:	4798      	blx	r3
   80574:	4a04      	ldr	r2, [pc, #16]	; (80588 <_ZN14HardwareSerialC1Ev+0x24>)
   80576:	687b      	ldr	r3, [r7, #4]
   80578:	601a      	str	r2, [r3, #0]
   8057a:	687b      	ldr	r3, [r7, #4]
   8057c:	4618      	mov	r0, r3
   8057e:	3708      	adds	r7, #8
   80580:	46bd      	mov	sp, r7
   80582:	bd80      	pop	{r7, pc}
   80584:	000804bd 	.word	0x000804bd
   80588:	000994c0 	.word	0x000994c0

0008058c <_ZN9UARTClassC1EP4Uart4IRQnmP10RingBufferS4_>:
#include <string.h>
#include "UARTClass.h"

// Constructors ////////////////////////////////////////////////////////////////

UARTClass::UARTClass( Uart *pUart, IRQn_Type dwIrq, uint32_t dwId, RingBuffer *pRx_buffer, RingBuffer *pTx_buffer )
   8058c:	b580      	push	{r7, lr}
   8058e:	b084      	sub	sp, #16
   80590:	af00      	add	r7, sp, #0
   80592:	60f8      	str	r0, [r7, #12]
   80594:	60b9      	str	r1, [r7, #8]
   80596:	603b      	str	r3, [r7, #0]
   80598:	4613      	mov	r3, r2
   8059a:	71fb      	strb	r3, [r7, #7]
   8059c:	68fb      	ldr	r3, [r7, #12]
   8059e:	4618      	mov	r0, r3
   805a0:	4b0c      	ldr	r3, [pc, #48]	; (805d4 <_ZN9UARTClassC1EP4Uart4IRQnmP10RingBufferS4_+0x48>)
   805a2:	4798      	blx	r3
   805a4:	4a0c      	ldr	r2, [pc, #48]	; (805d8 <_ZN9UARTClassC1EP4Uart4IRQnmP10RingBufferS4_+0x4c>)
   805a6:	68fb      	ldr	r3, [r7, #12]
   805a8:	601a      	str	r2, [r3, #0]
{
  _rx_buffer = pRx_buffer;
   805aa:	68fb      	ldr	r3, [r7, #12]
   805ac:	69ba      	ldr	r2, [r7, #24]
   805ae:	611a      	str	r2, [r3, #16]
  _tx_buffer = pTx_buffer;
   805b0:	68fb      	ldr	r3, [r7, #12]
   805b2:	69fa      	ldr	r2, [r7, #28]
   805b4:	615a      	str	r2, [r3, #20]

  _pUart=pUart;
   805b6:	68fb      	ldr	r3, [r7, #12]
   805b8:	68ba      	ldr	r2, [r7, #8]
   805ba:	619a      	str	r2, [r3, #24]
  _dwIrq=dwIrq;
   805bc:	68fb      	ldr	r3, [r7, #12]
   805be:	79fa      	ldrb	r2, [r7, #7]
   805c0:	771a      	strb	r2, [r3, #28]
  _dwId=dwId;
   805c2:	68fb      	ldr	r3, [r7, #12]
   805c4:	683a      	ldr	r2, [r7, #0]
   805c6:	621a      	str	r2, [r3, #32]
}
   805c8:	68fb      	ldr	r3, [r7, #12]
   805ca:	4618      	mov	r0, r3
   805cc:	3710      	adds	r7, #16
   805ce:	46bd      	mov	sp, r7
   805d0:	bd80      	pop	{r7, pc}
   805d2:	bf00      	nop
   805d4:	00080565 	.word	0x00080565
   805d8:	00099494 	.word	0x00099494

000805dc <_ZN9UARTClass5beginEm>:

// Public Methods //////////////////////////////////////////////////////////////

void UARTClass::begin(const uint32_t dwBaudRate)
{
   805dc:	b580      	push	{r7, lr}
   805de:	b082      	sub	sp, #8
   805e0:	af00      	add	r7, sp, #0
   805e2:	6078      	str	r0, [r7, #4]
   805e4:	6039      	str	r1, [r7, #0]
  begin(dwBaudRate, Mode_8N1);
   805e6:	f44f 620c 	mov.w	r2, #2240	; 0x8c0
   805ea:	6839      	ldr	r1, [r7, #0]
   805ec:	6878      	ldr	r0, [r7, #4]
   805ee:	4b03      	ldr	r3, [pc, #12]	; (805fc <_ZN9UARTClass5beginEm+0x20>)
   805f0:	4798      	blx	r3
}
   805f2:	bf00      	nop
   805f4:	3708      	adds	r7, #8
   805f6:	46bd      	mov	sp, r7
   805f8:	bd80      	pop	{r7, pc}
   805fa:	bf00      	nop
   805fc:	00080601 	.word	0x00080601

00080600 <_ZN9UARTClass5beginEmNS_9UARTModesE>:

void UARTClass::begin(const uint32_t dwBaudRate, const UARTModes config)
{
   80600:	b580      	push	{r7, lr}
   80602:	b086      	sub	sp, #24
   80604:	af00      	add	r7, sp, #0
   80606:	60f8      	str	r0, [r7, #12]
   80608:	60b9      	str	r1, [r7, #8]
   8060a:	4613      	mov	r3, r2
   8060c:	80fb      	strh	r3, [r7, #6]
  uint32_t modeReg = static_cast<uint32_t>(config) & 0x00000E00;
   8060e:	88fb      	ldrh	r3, [r7, #6]
   80610:	f403 6360 	and.w	r3, r3, #3584	; 0xe00
   80614:	617b      	str	r3, [r7, #20]
  init(dwBaudRate, modeReg | UART_MR_CHMODE_NORMAL);
   80616:	697a      	ldr	r2, [r7, #20]
   80618:	68b9      	ldr	r1, [r7, #8]
   8061a:	68f8      	ldr	r0, [r7, #12]
   8061c:	4b02      	ldr	r3, [pc, #8]	; (80628 <_ZN9UARTClass5beginEmNS_9UARTModesE+0x28>)
   8061e:	4798      	blx	r3
}
   80620:	bf00      	nop
   80622:	3718      	adds	r7, #24
   80624:	46bd      	mov	sp, r7
   80626:	bd80      	pop	{r7, pc}
   80628:	0008062d 	.word	0x0008062d

0008062c <_ZN9UARTClass4initEmm>:

void UARTClass::init(const uint32_t dwBaudRate, const uint32_t modeReg)
{
   8062c:	b580      	push	{r7, lr}
   8062e:	b084      	sub	sp, #16
   80630:	af00      	add	r7, sp, #0
   80632:	60f8      	str	r0, [r7, #12]
   80634:	60b9      	str	r1, [r7, #8]
   80636:	607a      	str	r2, [r7, #4]
  // Configure PMC
  pmc_enable_periph_clk( _dwId );
   80638:	68fb      	ldr	r3, [r7, #12]
   8063a:	6a1b      	ldr	r3, [r3, #32]
   8063c:	4618      	mov	r0, r3
   8063e:	4b21      	ldr	r3, [pc, #132]	; (806c4 <_ZN9UARTClass4initEmm+0x98>)
   80640:	4798      	blx	r3

  // Disable PDC channel
  _pUart->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
   80642:	68fb      	ldr	r3, [r7, #12]
   80644:	699b      	ldr	r3, [r3, #24]
   80646:	f240 2202 	movw	r2, #514	; 0x202
   8064a:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120

  // Reset and disable receiver and transmitter
  _pUart->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX | UART_CR_RXDIS | UART_CR_TXDIS;
   8064e:	68fb      	ldr	r3, [r7, #12]
   80650:	699b      	ldr	r3, [r3, #24]
   80652:	22ac      	movs	r2, #172	; 0xac
   80654:	601a      	str	r2, [r3, #0]

  // Configure mode
  _pUart->UART_MR = modeReg;
   80656:	68fb      	ldr	r3, [r7, #12]
   80658:	699b      	ldr	r3, [r3, #24]
   8065a:	687a      	ldr	r2, [r7, #4]
   8065c:	605a      	str	r2, [r3, #4]

  // Configure baudrate (asynchronous, no oversampling)
  _pUart->UART_BRGR = (SystemCoreClock / dwBaudRate) >> 4;
   8065e:	68fb      	ldr	r3, [r7, #12]
   80660:	699b      	ldr	r3, [r3, #24]
   80662:	4a19      	ldr	r2, [pc, #100]	; (806c8 <_ZN9UARTClass4initEmm+0x9c>)
   80664:	6811      	ldr	r1, [r2, #0]
   80666:	68ba      	ldr	r2, [r7, #8]
   80668:	fbb1 f2f2 	udiv	r2, r1, r2
   8066c:	0912      	lsrs	r2, r2, #4
   8066e:	621a      	str	r2, [r3, #32]

  // Configure interrupts
  _pUart->UART_IDR = 0xFFFFFFFF;
   80670:	68fb      	ldr	r3, [r7, #12]
   80672:	699b      	ldr	r3, [r3, #24]
   80674:	f04f 32ff 	mov.w	r2, #4294967295
   80678:	60da      	str	r2, [r3, #12]
  _pUart->UART_IER = UART_IER_RXRDY | UART_IER_OVRE | UART_IER_FRAME;
   8067a:	68fb      	ldr	r3, [r7, #12]
   8067c:	699b      	ldr	r3, [r3, #24]
   8067e:	2261      	movs	r2, #97	; 0x61
   80680:	609a      	str	r2, [r3, #8]

  // Enable UART interrupt in NVIC
  NVIC_EnableIRQ(_dwIrq);
   80682:	68fb      	ldr	r3, [r7, #12]
   80684:	f993 301c 	ldrsb.w	r3, [r3, #28]
   80688:	4618      	mov	r0, r3
   8068a:	4b10      	ldr	r3, [pc, #64]	; (806cc <_ZN9UARTClass4initEmm+0xa0>)
   8068c:	4798      	blx	r3

  // Make sure both ring buffers are initialized back to empty.
  _rx_buffer->_iHead = _rx_buffer->_iTail = 0;
   8068e:	68fb      	ldr	r3, [r7, #12]
   80690:	691a      	ldr	r2, [r3, #16]
   80692:	68fb      	ldr	r3, [r7, #12]
   80694:	6919      	ldr	r1, [r3, #16]
   80696:	2300      	movs	r3, #0
   80698:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
   8069c:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
  _tx_buffer->_iHead = _tx_buffer->_iTail = 0;
   806a0:	68fb      	ldr	r3, [r7, #12]
   806a2:	695a      	ldr	r2, [r3, #20]
   806a4:	68fb      	ldr	r3, [r7, #12]
   806a6:	6959      	ldr	r1, [r3, #20]
   806a8:	2300      	movs	r3, #0
   806aa:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
   806ae:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80

  // Enable receiver and transmitter
  _pUart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
   806b2:	68fb      	ldr	r3, [r7, #12]
   806b4:	699b      	ldr	r3, [r3, #24]
   806b6:	2250      	movs	r2, #80	; 0x50
   806b8:	601a      	str	r2, [r3, #0]
}
   806ba:	bf00      	nop
   806bc:	3710      	adds	r7, #16
   806be:	46bd      	mov	sp, r7
   806c0:	bd80      	pop	{r7, pc}
   806c2:	bf00      	nop
   806c4:	00088021 	.word	0x00088021
   806c8:	20070090 	.word	0x20070090
   806cc:	000804ed 	.word	0x000804ed

000806d0 <_ZN9UARTClass3endEv>:

void UARTClass::end( void )
{
   806d0:	b580      	push	{r7, lr}
   806d2:	b082      	sub	sp, #8
   806d4:	af00      	add	r7, sp, #0
   806d6:	6078      	str	r0, [r7, #4]
  // Clear any received data
  _rx_buffer->_iHead = _rx_buffer->_iTail;
   806d8:	687b      	ldr	r3, [r7, #4]
   806da:	691b      	ldr	r3, [r3, #16]
   806dc:	687a      	ldr	r2, [r7, #4]
   806de:	6912      	ldr	r2, [r2, #16]
   806e0:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
   806e4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  // Wait for any outstanding data to be sent
  flush();
   806e8:	687b      	ldr	r3, [r7, #4]
   806ea:	681b      	ldr	r3, [r3, #0]
   806ec:	3314      	adds	r3, #20
   806ee:	681b      	ldr	r3, [r3, #0]
   806f0:	6878      	ldr	r0, [r7, #4]
   806f2:	4798      	blx	r3

  // Disable UART interrupt in NVIC
  NVIC_DisableIRQ( _dwIrq );
   806f4:	687b      	ldr	r3, [r7, #4]
   806f6:	f993 301c 	ldrsb.w	r3, [r3, #28]
   806fa:	4618      	mov	r0, r3
   806fc:	4b05      	ldr	r3, [pc, #20]	; (80714 <_ZN9UARTClass3endEv+0x44>)
   806fe:	4798      	blx	r3

  pmc_disable_periph_clk( _dwId );
   80700:	687b      	ldr	r3, [r7, #4]
   80702:	6a1b      	ldr	r3, [r3, #32]
   80704:	4618      	mov	r0, r3
   80706:	4b04      	ldr	r3, [pc, #16]	; (80718 <_ZN9UARTClass3endEv+0x48>)
   80708:	4798      	blx	r3
}
   8070a:	bf00      	nop
   8070c:	3708      	adds	r7, #8
   8070e:	46bd      	mov	sp, r7
   80710:	bd80      	pop	{r7, pc}
   80712:	bf00      	nop
   80714:	0008051d 	.word	0x0008051d
   80718:	000880a1 	.word	0x000880a1

0008071c <_ZN9UARTClass9availableEv>:
{
  return NVIC_GetPriority(_dwIrq);
}

int UARTClass::available( void )
{
   8071c:	b480      	push	{r7}
   8071e:	b083      	sub	sp, #12
   80720:	af00      	add	r7, sp, #0
   80722:	6078      	str	r0, [r7, #4]
  return (uint32_t)(SERIAL_BUFFER_SIZE + _rx_buffer->_iHead - _rx_buffer->_iTail) % SERIAL_BUFFER_SIZE;
   80724:	687b      	ldr	r3, [r7, #4]
   80726:	691b      	ldr	r3, [r3, #16]
   80728:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   8072c:	f103 0280 	add.w	r2, r3, #128	; 0x80
   80730:	687b      	ldr	r3, [r7, #4]
   80732:	691b      	ldr	r3, [r3, #16]
   80734:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   80738:	1ad3      	subs	r3, r2, r3
   8073a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
}
   8073e:	4618      	mov	r0, r3
   80740:	370c      	adds	r7, #12
   80742:	46bd      	mov	sp, r7
   80744:	bc80      	pop	{r7}
   80746:	4770      	bx	lr

00080748 <_ZN9UARTClass4peekEv>:
  if (head >= tail) return SERIAL_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

int UARTClass::peek( void )
{
   80748:	b480      	push	{r7}
   8074a:	b083      	sub	sp, #12
   8074c:	af00      	add	r7, sp, #0
   8074e:	6078      	str	r0, [r7, #4]
  if ( _rx_buffer->_iHead == _rx_buffer->_iTail )
   80750:	687b      	ldr	r3, [r7, #4]
   80752:	691b      	ldr	r3, [r3, #16]
   80754:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   80758:	687b      	ldr	r3, [r7, #4]
   8075a:	691b      	ldr	r3, [r3, #16]
   8075c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   80760:	429a      	cmp	r2, r3
   80762:	bf0c      	ite	eq
   80764:	2301      	moveq	r3, #1
   80766:	2300      	movne	r3, #0
   80768:	b2db      	uxtb	r3, r3
   8076a:	2b00      	cmp	r3, #0
   8076c:	d002      	beq.n	80774 <_ZN9UARTClass4peekEv+0x2c>
    return -1;
   8076e:	f04f 33ff 	mov.w	r3, #4294967295
   80772:	e007      	b.n	80784 <_ZN9UARTClass4peekEv+0x3c>

  return _rx_buffer->_aucBuffer[_rx_buffer->_iTail];
   80774:	687b      	ldr	r3, [r7, #4]
   80776:	691a      	ldr	r2, [r3, #16]
   80778:	687b      	ldr	r3, [r7, #4]
   8077a:	691b      	ldr	r3, [r3, #16]
   8077c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   80780:	5cd3      	ldrb	r3, [r2, r3]
   80782:	b2db      	uxtb	r3, r3
}
   80784:	4618      	mov	r0, r3
   80786:	370c      	adds	r7, #12
   80788:	46bd      	mov	sp, r7
   8078a:	bc80      	pop	{r7}
   8078c:	4770      	bx	lr
   8078e:	bf00      	nop

00080790 <_ZN9UARTClass4readEv>:

int UARTClass::read( void )
{
   80790:	b480      	push	{r7}
   80792:	b085      	sub	sp, #20
   80794:	af00      	add	r7, sp, #0
   80796:	6078      	str	r0, [r7, #4]
  // if the head isn't ahead of the tail, we don't have any characters
  if ( _rx_buffer->_iHead == _rx_buffer->_iTail )
   80798:	687b      	ldr	r3, [r7, #4]
   8079a:	691b      	ldr	r3, [r3, #16]
   8079c:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   807a0:	687b      	ldr	r3, [r7, #4]
   807a2:	691b      	ldr	r3, [r3, #16]
   807a4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   807a8:	429a      	cmp	r2, r3
   807aa:	bf0c      	ite	eq
   807ac:	2301      	moveq	r3, #1
   807ae:	2300      	movne	r3, #0
   807b0:	b2db      	uxtb	r3, r3
   807b2:	2b00      	cmp	r3, #0
   807b4:	d002      	beq.n	807bc <_ZN9UARTClass4readEv+0x2c>
    return -1;
   807b6:	f04f 33ff 	mov.w	r3, #4294967295
   807ba:	e013      	b.n	807e4 <_ZN9UARTClass4readEv+0x54>

  uint8_t uc = _rx_buffer->_aucBuffer[_rx_buffer->_iTail];
   807bc:	687b      	ldr	r3, [r7, #4]
   807be:	691a      	ldr	r2, [r3, #16]
   807c0:	687b      	ldr	r3, [r7, #4]
   807c2:	691b      	ldr	r3, [r3, #16]
   807c4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   807c8:	5cd3      	ldrb	r3, [r2, r3]
   807ca:	73fb      	strb	r3, [r7, #15]
  _rx_buffer->_iTail = (unsigned int)(_rx_buffer->_iTail + 1) % SERIAL_BUFFER_SIZE;
   807cc:	687b      	ldr	r3, [r7, #4]
   807ce:	691b      	ldr	r3, [r3, #16]
   807d0:	687a      	ldr	r2, [r7, #4]
   807d2:	6912      	ldr	r2, [r2, #16]
   807d4:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
   807d8:	3201      	adds	r2, #1
   807da:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   807de:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  return uc;
   807e2:	7bfb      	ldrb	r3, [r7, #15]
}
   807e4:	4618      	mov	r0, r3
   807e6:	3714      	adds	r7, #20
   807e8:	46bd      	mov	sp, r7
   807ea:	bc80      	pop	{r7}
   807ec:	4770      	bx	lr
   807ee:	bf00      	nop

000807f0 <_ZN9UARTClass5flushEv>:

void UARTClass::flush( void )
{
   807f0:	b480      	push	{r7}
   807f2:	b083      	sub	sp, #12
   807f4:	af00      	add	r7, sp, #0
   807f6:	6078      	str	r0, [r7, #4]
  while (_tx_buffer->_iHead != _tx_buffer->_iTail); //wait for transmit data to be sent
   807f8:	687b      	ldr	r3, [r7, #4]
   807fa:	695b      	ldr	r3, [r3, #20]
   807fc:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   80800:	687b      	ldr	r3, [r7, #4]
   80802:	695b      	ldr	r3, [r3, #20]
   80804:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
   80808:	429a      	cmp	r2, r3
   8080a:	bf14      	ite	ne
   8080c:	2301      	movne	r3, #1
   8080e:	2300      	moveq	r3, #0
   80810:	b2db      	uxtb	r3, r3
   80812:	2b00      	cmp	r3, #0
   80814:	d000      	beq.n	80818 <_ZN9UARTClass5flushEv+0x28>
   80816:	e7ef      	b.n	807f8 <_ZN9UARTClass5flushEv+0x8>
  // Wait for transmission to complete
  while ((_pUart->UART_SR & UART_SR_TXEMPTY) != UART_SR_TXEMPTY)
   80818:	687b      	ldr	r3, [r7, #4]
   8081a:	699b      	ldr	r3, [r3, #24]
   8081c:	695b      	ldr	r3, [r3, #20]
   8081e:	f403 7300 	and.w	r3, r3, #512	; 0x200
   80822:	2b00      	cmp	r3, #0
   80824:	bf0c      	ite	eq
   80826:	2301      	moveq	r3, #1
   80828:	2300      	movne	r3, #0
   8082a:	b2db      	uxtb	r3, r3
   8082c:	2b00      	cmp	r3, #0
   8082e:	d000      	beq.n	80832 <_ZN9UARTClass5flushEv+0x42>
   80830:	e7f2      	b.n	80818 <_ZN9UARTClass5flushEv+0x28>
   ;
}
   80832:	bf00      	nop
   80834:	370c      	adds	r7, #12
   80836:	46bd      	mov	sp, r7
   80838:	bc80      	pop	{r7}
   8083a:	4770      	bx	lr

0008083c <_ZN9UARTClass5writeEh>:

size_t UARTClass::write( const uint8_t uc_data )
{
   8083c:	b480      	push	{r7}
   8083e:	b085      	sub	sp, #20
   80840:	af00      	add	r7, sp, #0
   80842:	6078      	str	r0, [r7, #4]
   80844:	460b      	mov	r3, r1
   80846:	70fb      	strb	r3, [r7, #3]
  // Is the hardware currently busy?
  if (((_pUart->UART_SR & UART_SR_TXRDY) != UART_SR_TXRDY) |
   80848:	687b      	ldr	r3, [r7, #4]
   8084a:	699b      	ldr	r3, [r3, #24]
   8084c:	695b      	ldr	r3, [r3, #20]
   8084e:	f003 0302 	and.w	r3, r3, #2
   80852:	2b00      	cmp	r3, #0
   80854:	bf0c      	ite	eq
   80856:	2301      	moveq	r3, #1
   80858:	2300      	movne	r3, #0
   8085a:	b2da      	uxtb	r2, r3
      (_tx_buffer->_iTail != _tx_buffer->_iHead))
   8085c:	687b      	ldr	r3, [r7, #4]
   8085e:	695b      	ldr	r3, [r3, #20]
   80860:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
   80864:	687b      	ldr	r3, [r7, #4]
   80866:	695b      	ldr	r3, [r3, #20]
   80868:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
}

size_t UARTClass::write( const uint8_t uc_data )
{
  // Is the hardware currently busy?
  if (((_pUart->UART_SR & UART_SR_TXRDY) != UART_SR_TXRDY) |
   8086c:	4299      	cmp	r1, r3
   8086e:	bf14      	ite	ne
   80870:	2301      	movne	r3, #1
   80872:	2300      	moveq	r3, #0
   80874:	b2db      	uxtb	r3, r3
   80876:	4313      	orrs	r3, r2
   80878:	b2db      	uxtb	r3, r3
   8087a:	2b00      	cmp	r3, #0
   8087c:	d02c      	beq.n	808d8 <_ZN9UARTClass5writeEh+0x9c>
      (_tx_buffer->_iTail != _tx_buffer->_iHead))
  {
    // If busy we buffer
    int nextWrite = (_tx_buffer->_iHead + 1) % SERIAL_BUFFER_SIZE;
   8087e:	687b      	ldr	r3, [r7, #4]
   80880:	695b      	ldr	r3, [r3, #20]
   80882:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   80886:	1c5a      	adds	r2, r3, #1
   80888:	4b18      	ldr	r3, [pc, #96]	; (808ec <_ZN9UARTClass5writeEh+0xb0>)
   8088a:	4013      	ands	r3, r2
   8088c:	2b00      	cmp	r3, #0
   8088e:	da03      	bge.n	80898 <_ZN9UARTClass5writeEh+0x5c>
   80890:	3b01      	subs	r3, #1
   80892:	f063 037f 	orn	r3, r3, #127	; 0x7f
   80896:	3301      	adds	r3, #1
   80898:	60fb      	str	r3, [r7, #12]
    while (_tx_buffer->_iTail == nextWrite)
   8089a:	687b      	ldr	r3, [r7, #4]
   8089c:	695b      	ldr	r3, [r3, #20]
   8089e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   808a2:	68fb      	ldr	r3, [r7, #12]
   808a4:	429a      	cmp	r2, r3
   808a6:	bf0c      	ite	eq
   808a8:	2301      	moveq	r3, #1
   808aa:	2300      	movne	r3, #0
   808ac:	b2db      	uxtb	r3, r3
   808ae:	2b00      	cmp	r3, #0
   808b0:	d000      	beq.n	808b4 <_ZN9UARTClass5writeEh+0x78>
   808b2:	e7f2      	b.n	8089a <_ZN9UARTClass5writeEh+0x5e>
      ; // Spin locks if we're about to overwrite the buffer. This continues once the data is sent

    _tx_buffer->_aucBuffer[_tx_buffer->_iHead] = uc_data;
   808b4:	687b      	ldr	r3, [r7, #4]
   808b6:	695a      	ldr	r2, [r3, #20]
   808b8:	687b      	ldr	r3, [r7, #4]
   808ba:	695b      	ldr	r3, [r3, #20]
   808bc:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   808c0:	78f9      	ldrb	r1, [r7, #3]
   808c2:	54d1      	strb	r1, [r2, r3]
    _tx_buffer->_iHead = nextWrite;
   808c4:	687b      	ldr	r3, [r7, #4]
   808c6:	695b      	ldr	r3, [r3, #20]
   808c8:	68fa      	ldr	r2, [r7, #12]
   808ca:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    // Make sure TX interrupt is enabled
    _pUart->UART_IER = UART_IER_TXRDY;
   808ce:	687b      	ldr	r3, [r7, #4]
   808d0:	699b      	ldr	r3, [r3, #24]
   808d2:	2202      	movs	r2, #2
   808d4:	609a      	str	r2, [r3, #8]
   808d6:	e003      	b.n	808e0 <_ZN9UARTClass5writeEh+0xa4>
  }
  else 
  {
     // Bypass buffering and send character directly
     _pUart->UART_THR = uc_data;
   808d8:	687b      	ldr	r3, [r7, #4]
   808da:	699b      	ldr	r3, [r3, #24]
   808dc:	78fa      	ldrb	r2, [r7, #3]
   808de:	61da      	str	r2, [r3, #28]
  }
  return 1;
   808e0:	2301      	movs	r3, #1
}
   808e2:	4618      	mov	r0, r3
   808e4:	3714      	adds	r7, #20
   808e6:	46bd      	mov	sp, r7
   808e8:	bc80      	pop	{r7}
   808ea:	4770      	bx	lr
   808ec:	8000007f 	.word	0x8000007f

000808f0 <_ZN9UARTClass10IrqHandlerEv>:

void UARTClass::IrqHandler( void )
{
   808f0:	b580      	push	{r7, lr}
   808f2:	b084      	sub	sp, #16
   808f4:	af00      	add	r7, sp, #0
   808f6:	6078      	str	r0, [r7, #4]
  uint32_t status = _pUart->UART_SR;
   808f8:	687b      	ldr	r3, [r7, #4]
   808fa:	699b      	ldr	r3, [r3, #24]
   808fc:	695b      	ldr	r3, [r3, #20]
   808fe:	60fb      	str	r3, [r7, #12]

  // Did we receive data?
  if ((status & UART_SR_RXRDY) == UART_SR_RXRDY)
   80900:	68fb      	ldr	r3, [r7, #12]
   80902:	f003 0301 	and.w	r3, r3, #1
   80906:	2b00      	cmp	r3, #0
   80908:	d009      	beq.n	8091e <_ZN9UARTClass10IrqHandlerEv+0x2e>
    _rx_buffer->store_char(_pUart->UART_RHR);
   8090a:	687b      	ldr	r3, [r7, #4]
   8090c:	691a      	ldr	r2, [r3, #16]
   8090e:	687b      	ldr	r3, [r7, #4]
   80910:	699b      	ldr	r3, [r3, #24]
   80912:	699b      	ldr	r3, [r3, #24]
   80914:	b2db      	uxtb	r3, r3
   80916:	4619      	mov	r1, r3
   80918:	4610      	mov	r0, r2
   8091a:	4b23      	ldr	r3, [pc, #140]	; (809a8 <_ZN9UARTClass10IrqHandlerEv+0xb8>)
   8091c:	4798      	blx	r3

  // Do we need to keep sending data?
  if ((status & UART_SR_TXRDY) == UART_SR_TXRDY) 
   8091e:	68fb      	ldr	r3, [r7, #12]
   80920:	f003 0302 	and.w	r3, r3, #2
   80924:	2b00      	cmp	r3, #0
   80926:	d029      	beq.n	8097c <_ZN9UARTClass10IrqHandlerEv+0x8c>
  {
    if (_tx_buffer->_iTail != _tx_buffer->_iHead) {
   80928:	687b      	ldr	r3, [r7, #4]
   8092a:	695b      	ldr	r3, [r3, #20]
   8092c:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   80930:	687b      	ldr	r3, [r7, #4]
   80932:	695b      	ldr	r3, [r3, #20]
   80934:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   80938:	429a      	cmp	r2, r3
   8093a:	bf14      	ite	ne
   8093c:	2301      	movne	r3, #1
   8093e:	2300      	moveq	r3, #0
   80940:	b2db      	uxtb	r3, r3
   80942:	2b00      	cmp	r3, #0
   80944:	d016      	beq.n	80974 <_ZN9UARTClass10IrqHandlerEv+0x84>
      _pUart->UART_THR = _tx_buffer->_aucBuffer[_tx_buffer->_iTail];
   80946:	687b      	ldr	r3, [r7, #4]
   80948:	699b      	ldr	r3, [r3, #24]
   8094a:	687a      	ldr	r2, [r7, #4]
   8094c:	6951      	ldr	r1, [r2, #20]
   8094e:	687a      	ldr	r2, [r7, #4]
   80950:	6952      	ldr	r2, [r2, #20]
   80952:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
   80956:	5c8a      	ldrb	r2, [r1, r2]
   80958:	b2d2      	uxtb	r2, r2
   8095a:	61da      	str	r2, [r3, #28]
      _tx_buffer->_iTail = (unsigned int)(_tx_buffer->_iTail + 1) % SERIAL_BUFFER_SIZE;
   8095c:	687b      	ldr	r3, [r7, #4]
   8095e:	695b      	ldr	r3, [r3, #20]
   80960:	687a      	ldr	r2, [r7, #4]
   80962:	6952      	ldr	r2, [r2, #20]
   80964:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
   80968:	3201      	adds	r2, #1
   8096a:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   8096e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
   80972:	e003      	b.n	8097c <_ZN9UARTClass10IrqHandlerEv+0x8c>
    }
    else
    {
      // Mask off transmit interrupt so we don't get it anymore
      _pUart->UART_IDR = UART_IDR_TXRDY;
   80974:	687b      	ldr	r3, [r7, #4]
   80976:	699b      	ldr	r3, [r3, #24]
   80978:	2202      	movs	r2, #2
   8097a:	60da      	str	r2, [r3, #12]
    }
  }

  // Acknowledge errors
  if ((status & UART_SR_OVRE) == UART_SR_OVRE || (status & UART_SR_FRAME) == UART_SR_FRAME)
   8097c:	68fb      	ldr	r3, [r7, #12]
   8097e:	f003 0320 	and.w	r3, r3, #32
   80982:	2b00      	cmp	r3, #0
   80984:	d104      	bne.n	80990 <_ZN9UARTClass10IrqHandlerEv+0xa0>
   80986:	68fb      	ldr	r3, [r7, #12]
   80988:	f003 0340 	and.w	r3, r3, #64	; 0x40
   8098c:	2b00      	cmp	r3, #0
   8098e:	d007      	beq.n	809a0 <_ZN9UARTClass10IrqHandlerEv+0xb0>
  {
    // TODO: error reporting outside ISR
    _pUart->UART_CR |= UART_CR_RSTSTA;
   80990:	687b      	ldr	r3, [r7, #4]
   80992:	699b      	ldr	r3, [r3, #24]
   80994:	687a      	ldr	r2, [r7, #4]
   80996:	6992      	ldr	r2, [r2, #24]
   80998:	6812      	ldr	r2, [r2, #0]
   8099a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   8099e:	601a      	str	r2, [r3, #0]
  }
}
   809a0:	bf00      	nop
   809a2:	3710      	adds	r7, #16
   809a4:	46bd      	mov	sp, r7
   809a6:	bd80      	pop	{r7, pc}
   809a8:	00087ac9 	.word	0x00087ac9

000809ac <cpu_irq_save>:

typedef uint32_t irqflags_t;
extern int g_interrupt_enabled;

static inline irqflags_t cpu_irq_save(void)
{
   809ac:	b480      	push	{r7}
   809ae:	b083      	sub	sp, #12
   809b0:	af00      	add	r7, sp, #0
	irqflags_t flags = g_interrupt_enabled;
   809b2:	4b07      	ldr	r3, [pc, #28]	; (809d0 <cpu_irq_save+0x24>)
   809b4:	681b      	ldr	r3, [r3, #0]
   809b6:	607b      	str	r3, [r7, #4]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
   809b8:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before 
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) static __INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
   809ba:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   809be:	4b04      	ldr	r3, [pc, #16]	; (809d0 <cpu_irq_save+0x24>)
   809c0:	2200      	movs	r2, #0
   809c2:	601a      	str	r2, [r3, #0]
	return flags;
   809c4:	687b      	ldr	r3, [r7, #4]
}
   809c6:	4618      	mov	r0, r3
   809c8:	370c      	adds	r7, #12
   809ca:	46bd      	mov	sp, r7
   809cc:	bc80      	pop	{r7}
   809ce:	4770      	bx	lr
   809d0:	20070104 	.word	0x20070104

000809d4 <cpu_irq_is_enabled_flags>:

static inline int cpu_irq_is_enabled_flags(irqflags_t flags)
{
   809d4:	b480      	push	{r7}
   809d6:	b083      	sub	sp, #12
   809d8:	af00      	add	r7, sp, #0
   809da:	6078      	str	r0, [r7, #4]
	return (flags);
   809dc:	687b      	ldr	r3, [r7, #4]
}
   809de:	4618      	mov	r0, r3
   809e0:	370c      	adds	r7, #12
   809e2:	46bd      	mov	sp, r7
   809e4:	bc80      	pop	{r7}
   809e6:	4770      	bx	lr

000809e8 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
   809e8:	b580      	push	{r7, lr}
   809ea:	b082      	sub	sp, #8
   809ec:	af00      	add	r7, sp, #0
   809ee:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
   809f0:	6878      	ldr	r0, [r7, #4]
   809f2:	4b0a      	ldr	r3, [pc, #40]	; (80a1c <cpu_irq_restore+0x34>)
   809f4:	4798      	blx	r3
   809f6:	4603      	mov	r3, r0
   809f8:	2b00      	cmp	r3, #0
   809fa:	bf14      	ite	ne
   809fc:	2301      	movne	r3, #1
   809fe:	2300      	moveq	r3, #0
   80a00:	b2db      	uxtb	r3, r3
   80a02:	2b00      	cmp	r3, #0
   80a04:	d005      	beq.n	80a12 <cpu_irq_restore+0x2a>
		cpu_irq_enable();
   80a06:	4b06      	ldr	r3, [pc, #24]	; (80a20 <cpu_irq_restore+0x38>)
   80a08:	2201      	movs	r2, #1
   80a0a:	601a      	str	r2, [r3, #0]
   80a0c:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
   80a10:	b662      	cpsie	i
}
   80a12:	bf00      	nop
   80a14:	3708      	adds	r7, #8
   80a16:	46bd      	mov	sp, r7
   80a18:	bd80      	pop	{r7, pc}
   80a1a:	bf00      	nop
   80a1c:	000809d5 	.word	0x000809d5
   80a20:	20070104 	.word	0x20070104

00080a24 <_ZN6LockEPC1Em>:
#define USB_RECV_TIMEOUT
class LockEP
{
	irqflags_t flags;
public:
	LockEP(uint32_t ep __attribute__ ((unused))) : flags(cpu_irq_save())
   80a24:	b580      	push	{r7, lr}
   80a26:	b082      	sub	sp, #8
   80a28:	af00      	add	r7, sp, #0
   80a2a:	6078      	str	r0, [r7, #4]
   80a2c:	6039      	str	r1, [r7, #0]
   80a2e:	4b05      	ldr	r3, [pc, #20]	; (80a44 <_ZN6LockEPC1Em+0x20>)
   80a30:	4798      	blx	r3
   80a32:	4602      	mov	r2, r0
   80a34:	687b      	ldr	r3, [r7, #4]
   80a36:	601a      	str	r2, [r3, #0]
	{
	}
   80a38:	687b      	ldr	r3, [r7, #4]
   80a3a:	4618      	mov	r0, r3
   80a3c:	3708      	adds	r7, #8
   80a3e:	46bd      	mov	sp, r7
   80a40:	bd80      	pop	{r7, pc}
   80a42:	bf00      	nop
   80a44:	000809ad 	.word	0x000809ad

00080a48 <_ZN6LockEPD1Ev>:
	~LockEP()
   80a48:	b580      	push	{r7, lr}
   80a4a:	b082      	sub	sp, #8
   80a4c:	af00      	add	r7, sp, #0
   80a4e:	6078      	str	r0, [r7, #4]
	{
		cpu_irq_restore(flags);
   80a50:	687b      	ldr	r3, [r7, #4]
   80a52:	681b      	ldr	r3, [r3, #0]
   80a54:	4618      	mov	r0, r3
   80a56:	4b03      	ldr	r3, [pc, #12]	; (80a64 <_ZN6LockEPD1Ev+0x1c>)
   80a58:	4798      	blx	r3
	}
   80a5a:	687b      	ldr	r3, [r7, #4]
   80a5c:	4618      	mov	r0, r3
   80a5e:	3708      	adds	r7, #8
   80a60:	46bd      	mov	sp, r7
   80a62:	bd80      	pop	{r7, pc}
   80a64:	000809e9 	.word	0x000809e9

00080a68 <_Z14USBD_Availablem>:
};

//	Number of bytes, assumes a rx endpoint
uint32_t USBD_Available(uint32_t ep)
{
   80a68:	b590      	push	{r4, r7, lr}
   80a6a:	b085      	sub	sp, #20
   80a6c:	af00      	add	r7, sp, #0
   80a6e:	6078      	str	r0, [r7, #4]
	LockEP lock(ep);
   80a70:	f107 030c 	add.w	r3, r7, #12
   80a74:	6879      	ldr	r1, [r7, #4]
   80a76:	4618      	mov	r0, r3
   80a78:	4b09      	ldr	r3, [pc, #36]	; (80aa0 <_Z14USBD_Availablem+0x38>)
   80a7a:	4798      	blx	r3
	return UDD_FifoByteCount(ep & 0xF);
   80a7c:	687b      	ldr	r3, [r7, #4]
   80a7e:	f003 030f 	and.w	r3, r3, #15
   80a82:	4618      	mov	r0, r3
   80a84:	4b07      	ldr	r3, [pc, #28]	; (80aa4 <_Z14USBD_Availablem+0x3c>)
   80a86:	4798      	blx	r3
   80a88:	4604      	mov	r4, r0
};

//	Number of bytes, assumes a rx endpoint
uint32_t USBD_Available(uint32_t ep)
{
	LockEP lock(ep);
   80a8a:	f107 030c 	add.w	r3, r7, #12
   80a8e:	4618      	mov	r0, r3
   80a90:	4b05      	ldr	r3, [pc, #20]	; (80aa8 <_Z14USBD_Availablem+0x40>)
   80a92:	4798      	blx	r3
	return UDD_FifoByteCount(ep & 0xF);
   80a94:	4623      	mov	r3, r4
}
   80a96:	4618      	mov	r0, r3
   80a98:	3714      	adds	r7, #20
   80a9a:	46bd      	mov	sp, r7
   80a9c:	bd90      	pop	{r4, r7, pc}
   80a9e:	bf00      	nop
   80aa0:	00080a25 	.word	0x00080a25
   80aa4:	000888bd 	.word	0x000888bd
   80aa8:	00080a49 	.word	0x00080a49

00080aac <_Z9USBD_RecvmPvm>:

//	Non Blocking receive
//	Return number of bytes read
uint32_t USBD_Recv(uint32_t ep, void* d, uint32_t len)
{
   80aac:	b590      	push	{r4, r7, lr}
   80aae:	b089      	sub	sp, #36	; 0x24
   80ab0:	af00      	add	r7, sp, #0
   80ab2:	60f8      	str	r0, [r7, #12]
   80ab4:	60b9      	str	r1, [r7, #8]
   80ab6:	607a      	str	r2, [r7, #4]
	if (!_usbConfiguration)
   80ab8:	4b2e      	ldr	r3, [pc, #184]	; (80b74 <_Z9USBD_RecvmPvm+0xc8>)
   80aba:	681b      	ldr	r3, [r3, #0]
   80abc:	2b00      	cmp	r3, #0
   80abe:	bf0c      	ite	eq
   80ac0:	2301      	moveq	r3, #1
   80ac2:	2300      	movne	r3, #0
   80ac4:	b2db      	uxtb	r3, r3
   80ac6:	2b00      	cmp	r3, #0
   80ac8:	d002      	beq.n	80ad0 <_Z9USBD_RecvmPvm+0x24>
		return -1;
   80aca:	f04f 34ff 	mov.w	r4, #4294967295
   80ace:	e04b      	b.n	80b68 <_Z9USBD_RecvmPvm+0xbc>

	LockEP lock(ep);
   80ad0:	f107 0314 	add.w	r3, r7, #20
   80ad4:	68f9      	ldr	r1, [r7, #12]
   80ad6:	4618      	mov	r0, r3
   80ad8:	4b27      	ldr	r3, [pc, #156]	; (80b78 <_Z9USBD_RecvmPvm+0xcc>)
   80ada:	4798      	blx	r3
	uint32_t n = UDD_FifoByteCount(ep & 0xF);
   80adc:	68fb      	ldr	r3, [r7, #12]
   80ade:	f003 030f 	and.w	r3, r3, #15
   80ae2:	4618      	mov	r0, r3
   80ae4:	4b25      	ldr	r3, [pc, #148]	; (80b7c <_Z9USBD_RecvmPvm+0xd0>)
   80ae6:	4798      	blx	r3
   80ae8:	61f8      	str	r0, [r7, #28]
	len = min(n,len);
   80aea:	69fa      	ldr	r2, [r7, #28]
   80aec:	687b      	ldr	r3, [r7, #4]
   80aee:	429a      	cmp	r2, r3
   80af0:	d201      	bcs.n	80af6 <_Z9USBD_RecvmPvm+0x4a>
   80af2:	69fb      	ldr	r3, [r7, #28]
   80af4:	e000      	b.n	80af8 <_Z9USBD_RecvmPvm+0x4c>
   80af6:	687b      	ldr	r3, [r7, #4]
   80af8:	607b      	str	r3, [r7, #4]
	n = len;
   80afa:	687b      	ldr	r3, [r7, #4]
   80afc:	61fb      	str	r3, [r7, #28]
	uint8_t* dst = (uint8_t*)d;
   80afe:	68bb      	ldr	r3, [r7, #8]
   80b00:	61bb      	str	r3, [r7, #24]
	while (n--)
   80b02:	69fb      	ldr	r3, [r7, #28]
   80b04:	1e5a      	subs	r2, r3, #1
   80b06:	61fa      	str	r2, [r7, #28]
   80b08:	2b00      	cmp	r3, #0
   80b0a:	bf14      	ite	ne
   80b0c:	2301      	movne	r3, #1
   80b0e:	2300      	moveq	r3, #0
   80b10:	b2db      	uxtb	r3, r3
   80b12:	2b00      	cmp	r3, #0
   80b14:	d00b      	beq.n	80b2e <_Z9USBD_RecvmPvm+0x82>
		*dst++ = UDD_Recv8(ep & 0xF);
   80b16:	69bc      	ldr	r4, [r7, #24]
   80b18:	1c63      	adds	r3, r4, #1
   80b1a:	61bb      	str	r3, [r7, #24]
   80b1c:	68fb      	ldr	r3, [r7, #12]
   80b1e:	f003 030f 	and.w	r3, r3, #15
   80b22:	4618      	mov	r0, r3
   80b24:	4b16      	ldr	r3, [pc, #88]	; (80b80 <_Z9USBD_RecvmPvm+0xd4>)
   80b26:	4798      	blx	r3
   80b28:	4603      	mov	r3, r0
   80b2a:	7023      	strb	r3, [r4, #0]
	LockEP lock(ep);
	uint32_t n = UDD_FifoByteCount(ep & 0xF);
	len = min(n,len);
	n = len;
	uint8_t* dst = (uint8_t*)d;
	while (n--)
   80b2c:	e7e9      	b.n	80b02 <_Z9USBD_RecvmPvm+0x56>
		*dst++ = UDD_Recv8(ep & 0xF);
	if (len && !UDD_FifoByteCount(ep & 0xF)) // release empty buffer
   80b2e:	687b      	ldr	r3, [r7, #4]
   80b30:	2b00      	cmp	r3, #0
   80b32:	d00a      	beq.n	80b4a <_Z9USBD_RecvmPvm+0x9e>
   80b34:	68fb      	ldr	r3, [r7, #12]
   80b36:	f003 030f 	and.w	r3, r3, #15
   80b3a:	4618      	mov	r0, r3
   80b3c:	4b0f      	ldr	r3, [pc, #60]	; (80b7c <_Z9USBD_RecvmPvm+0xd0>)
   80b3e:	4798      	blx	r3
   80b40:	4603      	mov	r3, r0
   80b42:	2b00      	cmp	r3, #0
   80b44:	d101      	bne.n	80b4a <_Z9USBD_RecvmPvm+0x9e>
   80b46:	2301      	movs	r3, #1
   80b48:	e000      	b.n	80b4c <_Z9USBD_RecvmPvm+0xa0>
   80b4a:	2300      	movs	r3, #0
   80b4c:	2b00      	cmp	r3, #0
   80b4e:	d005      	beq.n	80b5c <_Z9USBD_RecvmPvm+0xb0>
		UDD_ReleaseRX(ep & 0xF);
   80b50:	68fb      	ldr	r3, [r7, #12]
   80b52:	f003 030f 	and.w	r3, r3, #15
   80b56:	4618      	mov	r0, r3
   80b58:	4b0a      	ldr	r3, [pc, #40]	; (80b84 <_Z9USBD_RecvmPvm+0xd8>)
   80b5a:	4798      	blx	r3

	return len;
   80b5c:	687c      	ldr	r4, [r7, #4]
uint32_t USBD_Recv(uint32_t ep, void* d, uint32_t len)
{
	if (!_usbConfiguration)
		return -1;

	LockEP lock(ep);
   80b5e:	f107 0314 	add.w	r3, r7, #20
   80b62:	4618      	mov	r0, r3
   80b64:	4b08      	ldr	r3, [pc, #32]	; (80b88 <_Z9USBD_RecvmPvm+0xdc>)
   80b66:	4798      	blx	r3
   80b68:	4623      	mov	r3, r4
		*dst++ = UDD_Recv8(ep & 0xF);
	if (len && !UDD_FifoByteCount(ep & 0xF)) // release empty buffer
		UDD_ReleaseRX(ep & 0xF);

	return len;
}
   80b6a:	4618      	mov	r0, r3
   80b6c:	3724      	adds	r7, #36	; 0x24
   80b6e:	46bd      	mov	sp, r7
   80b70:	bd90      	pop	{r4, r7, pc}
   80b72:	bf00      	nop
   80b74:	20070c60 	.word	0x20070c60
   80b78:	00080a25 	.word	0x00080a25
   80b7c:	000888bd 	.word	0x000888bd
   80b80:	000887e1 	.word	0x000887e1
   80b84:	000888e9 	.word	0x000888e9
   80b88:	00080a49 	.word	0x00080a49

00080b8c <_Z9USBD_Recvm>:

//	Recv 1 byte if ready
uint32_t USBD_Recv(uint32_t ep)
{
   80b8c:	b580      	push	{r7, lr}
   80b8e:	b084      	sub	sp, #16
   80b90:	af00      	add	r7, sp, #0
   80b92:	6078      	str	r0, [r7, #4]
	uint8_t c;
	if (USBD_Recv(ep & 0xF, &c, 1) != 1)
   80b94:	687b      	ldr	r3, [r7, #4]
   80b96:	f003 030f 	and.w	r3, r3, #15
   80b9a:	f107 010f 	add.w	r1, r7, #15
   80b9e:	2201      	movs	r2, #1
   80ba0:	4618      	mov	r0, r3
   80ba2:	4b09      	ldr	r3, [pc, #36]	; (80bc8 <_Z9USBD_Recvm+0x3c>)
   80ba4:	4798      	blx	r3
   80ba6:	4603      	mov	r3, r0
   80ba8:	2b01      	cmp	r3, #1
   80baa:	bf14      	ite	ne
   80bac:	2301      	movne	r3, #1
   80bae:	2300      	moveq	r3, #0
   80bb0:	b2db      	uxtb	r3, r3
   80bb2:	2b00      	cmp	r3, #0
   80bb4:	d002      	beq.n	80bbc <_Z9USBD_Recvm+0x30>
		return -1;
   80bb6:	f04f 33ff 	mov.w	r3, #4294967295
   80bba:	e000      	b.n	80bbe <_Z9USBD_Recvm+0x32>
	else
		return c;
   80bbc:	7bfb      	ldrb	r3, [r7, #15]
}
   80bbe:	4618      	mov	r0, r3
   80bc0:	3710      	adds	r7, #16
   80bc2:	46bd      	mov	sp, r7
   80bc4:	bd80      	pop	{r7, pc}
   80bc6:	bf00      	nop
   80bc8:	00080aad 	.word	0x00080aad

00080bcc <_Z9USBD_SendmPKvm>:
    //else return 512 - UDD_FifoByteCount(ep & 0xF);  // EPX_SIZE  jcb
//}

//	Blocking Send of data to an endpoint
uint32_t USBD_Send(uint32_t ep, const void* d, uint32_t len)
{
   80bcc:	b580      	push	{r7, lr}
   80bce:	b088      	sub	sp, #32
   80bd0:	af00      	add	r7, sp, #0
   80bd2:	60f8      	str	r0, [r7, #12]
   80bd4:	60b9      	str	r1, [r7, #8]
   80bd6:	607a      	str	r2, [r7, #4]
    uint32_t n;
	int r = len;
   80bd8:	687b      	ldr	r3, [r7, #4]
   80bda:	617b      	str	r3, [r7, #20]
	const uint8_t* data = (const uint8_t*)d;
   80bdc:	68bb      	ldr	r3, [r7, #8]
   80bde:	61bb      	str	r3, [r7, #24]

    if (!_usbConfiguration)
   80be0:	4b19      	ldr	r3, [pc, #100]	; (80c48 <_Z9USBD_SendmPKvm+0x7c>)
   80be2:	681b      	ldr	r3, [r3, #0]
   80be4:	2b00      	cmp	r3, #0
   80be6:	bf0c      	ite	eq
   80be8:	2301      	moveq	r3, #1
   80bea:	2300      	movne	r3, #0
   80bec:	b2db      	uxtb	r3, r3
   80bee:	2b00      	cmp	r3, #0
   80bf0:	d002      	beq.n	80bf8 <_Z9USBD_SendmPKvm+0x2c>
    {
    	TRACE_CORE(printf("pb conf\n\r");)
		return -1;
   80bf2:	f04f 33ff 	mov.w	r3, #4294967295
   80bf6:	e023      	b.n	80c40 <_Z9USBD_SendmPKvm+0x74>
    }

	while (len)
   80bf8:	687b      	ldr	r3, [r7, #4]
   80bfa:	2b00      	cmp	r3, #0
   80bfc:	d01f      	beq.n	80c3e <_Z9USBD_SendmPKvm+0x72>
	{
        if(ep==0) n = EP0_SIZE;
   80bfe:	68fb      	ldr	r3, [r7, #12]
   80c00:	2b00      	cmp	r3, #0
   80c02:	d102      	bne.n	80c0a <_Z9USBD_SendmPKvm+0x3e>
   80c04:	2340      	movs	r3, #64	; 0x40
   80c06:	61fb      	str	r3, [r7, #28]
   80c08:	e002      	b.n	80c10 <_Z9USBD_SendmPKvm+0x44>
        else n =  EPX_SIZE;
   80c0a:	f44f 7300 	mov.w	r3, #512	; 0x200
   80c0e:	61fb      	str	r3, [r7, #28]
		if (n > len)
   80c10:	69fa      	ldr	r2, [r7, #28]
   80c12:	687b      	ldr	r3, [r7, #4]
   80c14:	429a      	cmp	r2, r3
   80c16:	d901      	bls.n	80c1c <_Z9USBD_SendmPKvm+0x50>
			n = len;
   80c18:	687b      	ldr	r3, [r7, #4]
   80c1a:	61fb      	str	r3, [r7, #28]
		len -= n;
   80c1c:	687a      	ldr	r2, [r7, #4]
   80c1e:	69fb      	ldr	r3, [r7, #28]
   80c20:	1ad3      	subs	r3, r2, r3
   80c22:	607b      	str	r3, [r7, #4]

		UDD_Send(ep & 0xF, data, n);
   80c24:	68fb      	ldr	r3, [r7, #12]
   80c26:	f003 030f 	and.w	r3, r3, #15
   80c2a:	69fa      	ldr	r2, [r7, #28]
   80c2c:	69b9      	ldr	r1, [r7, #24]
   80c2e:	4618      	mov	r0, r3
   80c30:	4b06      	ldr	r3, [pc, #24]	; (80c4c <_Z9USBD_SendmPKvm+0x80>)
   80c32:	4798      	blx	r3
		data += n;
   80c34:	69ba      	ldr	r2, [r7, #24]
   80c36:	69fb      	ldr	r3, [r7, #28]
   80c38:	4413      	add	r3, r2
   80c3a:	61bb      	str	r3, [r7, #24]
    {
    	TRACE_CORE(printf("pb conf\n\r");)
		return -1;
    }

	while (len)
   80c3c:	e7dc      	b.n	80bf8 <_Z9USBD_SendmPKvm+0x2c>
		UDD_Send(ep & 0xF, data, n);
		data += n;
    }
	//TXLED1;					// light the TX LED
	//TxLEDPulse = TX_RX_LED_PULSE_MS;
	return r;
   80c3e:	697b      	ldr	r3, [r7, #20]
}
   80c40:	4618      	mov	r0, r3
   80c42:	3720      	adds	r7, #32
   80c44:	46bd      	mov	sp, r7
   80c46:	bd80      	pop	{r7, pc}
   80c48:	20070c60 	.word	0x20070c60
   80c4c:	000886a5 	.word	0x000886a5

00080c50 <_Z16USBD_InitControli>:

uint16_t _cmark;
uint16_t _cend;

void USBD_InitControl(int end)
{
   80c50:	b480      	push	{r7}
   80c52:	b083      	sub	sp, #12
   80c54:	af00      	add	r7, sp, #0
   80c56:	6078      	str	r0, [r7, #4]
	_cmark = 0;
   80c58:	4b05      	ldr	r3, [pc, #20]	; (80c70 <_Z16USBD_InitControli+0x20>)
   80c5a:	2200      	movs	r2, #0
   80c5c:	801a      	strh	r2, [r3, #0]
	_cend = end;
   80c5e:	687b      	ldr	r3, [r7, #4]
   80c60:	b29a      	uxth	r2, r3
   80c62:	4b04      	ldr	r3, [pc, #16]	; (80c74 <_Z16USBD_InitControli+0x24>)
   80c64:	801a      	strh	r2, [r3, #0]
}
   80c66:	bf00      	nop
   80c68:	370c      	adds	r7, #12
   80c6a:	46bd      	mov	sp, r7
   80c6c:	bc80      	pop	{r7}
   80c6e:	4770      	bx	lr
   80c70:	20070c70 	.word	0x20070c70
   80c74:	20070c72 	.word	0x20070c72

00080c78 <_Z16USBD_SendControlhPKvm>:

//	Clipped by _cmark/_cend
int USBD_SendControl(uint8_t flags __attribute__ ((unused)), const void* d, uint32_t len)
{
   80c78:	b580      	push	{r7, lr}
   80c7a:	b088      	sub	sp, #32
   80c7c:	af00      	add	r7, sp, #0
   80c7e:	4603      	mov	r3, r0
   80c80:	60b9      	str	r1, [r7, #8]
   80c82:	607a      	str	r2, [r7, #4]
   80c84:	73fb      	strb	r3, [r7, #15]
	const uint8_t* data = (const uint8_t*)d;
   80c86:	68bb      	ldr	r3, [r7, #8]
   80c88:	61bb      	str	r3, [r7, #24]
	uint32_t length = len;
   80c8a:	687b      	ldr	r3, [r7, #4]
   80c8c:	617b      	str	r3, [r7, #20]
	uint32_t sent = 0;
   80c8e:	2300      	movs	r3, #0
   80c90:	613b      	str	r3, [r7, #16]
	uint32_t pos = 0;
   80c92:	2300      	movs	r3, #0
   80c94:	61fb      	str	r3, [r7, #28]

	TRACE_CORE(printf("=> USBD_SendControl TOTAL len=%lu\r\n", len);)

	if (_cmark < _cend)
   80c96:	4b14      	ldr	r3, [pc, #80]	; (80ce8 <_Z16USBD_SendControlhPKvm+0x70>)
   80c98:	881a      	ldrh	r2, [r3, #0]
   80c9a:	4b14      	ldr	r3, [pc, #80]	; (80cec <_Z16USBD_SendControlhPKvm+0x74>)
   80c9c:	881b      	ldrh	r3, [r3, #0]
   80c9e:	429a      	cmp	r2, r3
   80ca0:	d214      	bcs.n	80ccc <_Z16USBD_SendControlhPKvm+0x54>
	{
		while (len > 0)
   80ca2:	687b      	ldr	r3, [r7, #4]
   80ca4:	2b00      	cmp	r3, #0
   80ca6:	d011      	beq.n	80ccc <_Z16USBD_SendControlhPKvm+0x54>
		{
			sent = UDD_Send(EP0, data + pos, len);
   80ca8:	69ba      	ldr	r2, [r7, #24]
   80caa:	69fb      	ldr	r3, [r7, #28]
   80cac:	4413      	add	r3, r2
   80cae:	687a      	ldr	r2, [r7, #4]
   80cb0:	4619      	mov	r1, r3
   80cb2:	2000      	movs	r0, #0
   80cb4:	4b0e      	ldr	r3, [pc, #56]	; (80cf0 <_Z16USBD_SendControlhPKvm+0x78>)
   80cb6:	4798      	blx	r3
   80cb8:	6138      	str	r0, [r7, #16]
			TRACE_CORE(printf("=> USBD_SendControl sent=%lu\r\n", sent);)
			pos += sent;
   80cba:	69fa      	ldr	r2, [r7, #28]
   80cbc:	693b      	ldr	r3, [r7, #16]
   80cbe:	4413      	add	r3, r2
   80cc0:	61fb      	str	r3, [r7, #28]
			len -= sent;
   80cc2:	687a      	ldr	r2, [r7, #4]
   80cc4:	693b      	ldr	r3, [r7, #16]
   80cc6:	1ad3      	subs	r3, r2, r3
   80cc8:	607b      	str	r3, [r7, #4]

	TRACE_CORE(printf("=> USBD_SendControl TOTAL len=%lu\r\n", len);)

	if (_cmark < _cend)
	{
		while (len > 0)
   80cca:	e7ea      	b.n	80ca2 <_Z16USBD_SendControlhPKvm+0x2a>
			pos += sent;
			len -= sent;
		}
	}

	_cmark += length;
   80ccc:	697b      	ldr	r3, [r7, #20]
   80cce:	b29a      	uxth	r2, r3
   80cd0:	4b05      	ldr	r3, [pc, #20]	; (80ce8 <_Z16USBD_SendControlhPKvm+0x70>)
   80cd2:	881b      	ldrh	r3, [r3, #0]
   80cd4:	4413      	add	r3, r2
   80cd6:	b29a      	uxth	r2, r3
   80cd8:	4b03      	ldr	r3, [pc, #12]	; (80ce8 <_Z16USBD_SendControlhPKvm+0x70>)
   80cda:	801a      	strh	r2, [r3, #0]

	return length;
   80cdc:	697b      	ldr	r3, [r7, #20]
}
   80cde:	4618      	mov	r0, r3
   80ce0:	3720      	adds	r7, #32
   80ce2:	46bd      	mov	sp, r7
   80ce4:	bd80      	pop	{r7, pc}
   80ce6:	bf00      	nop
   80ce8:	20070c70 	.word	0x20070c70
   80cec:	20070c72 	.word	0x20070c72
   80cf0:	000886a5 	.word	0x000886a5

00080cf4 <_ZL24USB_SendStringDescriptorPKhi>:

// Send a USB descriptor string. The string is stored as a
// plain ASCII string but is sent out as UTF-16 with the
// correct 2-byte prefix
static bool USB_SendStringDescriptor(const uint8_t *string, int wLength) {
   80cf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   80cf8:	b086      	sub	sp, #24
   80cfa:	af00      	add	r7, sp, #0
   80cfc:	6078      	str	r0, [r7, #4]
   80cfe:	6039      	str	r1, [r7, #0]
		buffer[i++] = *string++;
		if (i == wLength) break;
		buffer[i] = 0;
	}

	return USBD_SendControl(0, (uint8_t*)buffer, i);
   80d00:	466a      	mov	r2, sp
   80d02:	4690      	mov	r8, r2

// Send a USB descriptor string. The string is stored as a
// plain ASCII string but is sent out as UTF-16 with the
// correct 2-byte prefix
static bool USB_SendStringDescriptor(const uint8_t *string, int wLength) {
	if (wLength < 2)
   80d04:	683a      	ldr	r2, [r7, #0]
   80d06:	2a01      	cmp	r2, #1
   80d08:	dc01      	bgt.n	80d0e <_ZL24USB_SendStringDescriptorPKhi+0x1a>
		return false;
   80d0a:	2300      	movs	r3, #0
   80d0c:	e058      	b.n	80dc0 <_ZL24USB_SendStringDescriptorPKhi+0xcc>

	uint8_t buffer[wLength];
   80d0e:	683a      	ldr	r2, [r7, #0]
   80d10:	1e50      	subs	r0, r2, #1
   80d12:	6138      	str	r0, [r7, #16]
   80d14:	4602      	mov	r2, r0
   80d16:	3201      	adds	r2, #1
   80d18:	4611      	mov	r1, r2
   80d1a:	f04f 0200 	mov.w	r2, #0
   80d1e:	00d6      	lsls	r6, r2, #3
   80d20:	ea46 7651 	orr.w	r6, r6, r1, lsr #29
   80d24:	00cd      	lsls	r5, r1, #3
   80d26:	4602      	mov	r2, r0
   80d28:	3201      	adds	r2, #1
   80d2a:	4611      	mov	r1, r2
   80d2c:	f04f 0200 	mov.w	r2, #0
   80d30:	00d4      	lsls	r4, r2, #3
   80d32:	ea44 7451 	orr.w	r4, r4, r1, lsr #29
   80d36:	00cb      	lsls	r3, r1, #3
   80d38:	4603      	mov	r3, r0
   80d3a:	3301      	adds	r3, #1
   80d3c:	3307      	adds	r3, #7
   80d3e:	08db      	lsrs	r3, r3, #3
   80d40:	00db      	lsls	r3, r3, #3
   80d42:	ebad 0d03 	sub.w	sp, sp, r3
   80d46:	466b      	mov	r3, sp
   80d48:	3300      	adds	r3, #0
   80d4a:	60fb      	str	r3, [r7, #12]
	buffer[0] = strlen((const char*)string) * 2 + 2;
   80d4c:	6878      	ldr	r0, [r7, #4]
   80d4e:	4b1f      	ldr	r3, [pc, #124]	; (80dcc <_ZL24USB_SendStringDescriptorPKhi+0xd8>)
   80d50:	4798      	blx	r3
   80d52:	4603      	mov	r3, r0
   80d54:	3301      	adds	r3, #1
   80d56:	b2db      	uxtb	r3, r3
   80d58:	005b      	lsls	r3, r3, #1
   80d5a:	b2da      	uxtb	r2, r3
   80d5c:	68fb      	ldr	r3, [r7, #12]
   80d5e:	701a      	strb	r2, [r3, #0]
	buffer[1] = 0x03;
   80d60:	68fb      	ldr	r3, [r7, #12]
   80d62:	2203      	movs	r2, #3
   80d64:	705a      	strb	r2, [r3, #1]

	uint8_t i;
	for (i = 2; i < wLength && *string; i++) {
   80d66:	2302      	movs	r3, #2
   80d68:	75fb      	strb	r3, [r7, #23]
   80d6a:	7dfa      	ldrb	r2, [r7, #23]
   80d6c:	683b      	ldr	r3, [r7, #0]
   80d6e:	429a      	cmp	r2, r3
   80d70:	da1a      	bge.n	80da8 <_ZL24USB_SendStringDescriptorPKhi+0xb4>
   80d72:	687b      	ldr	r3, [r7, #4]
   80d74:	781b      	ldrb	r3, [r3, #0]
   80d76:	2b00      	cmp	r3, #0
   80d78:	d016      	beq.n	80da8 <_ZL24USB_SendStringDescriptorPKhi+0xb4>
		buffer[i++] = *string++;
   80d7a:	7dfb      	ldrb	r3, [r7, #23]
   80d7c:	1c5a      	adds	r2, r3, #1
   80d7e:	75fa      	strb	r2, [r7, #23]
   80d80:	4619      	mov	r1, r3
   80d82:	687b      	ldr	r3, [r7, #4]
   80d84:	1c5a      	adds	r2, r3, #1
   80d86:	607a      	str	r2, [r7, #4]
   80d88:	781a      	ldrb	r2, [r3, #0]
   80d8a:	68fb      	ldr	r3, [r7, #12]
   80d8c:	545a      	strb	r2, [r3, r1]
		if (i == wLength) break;
   80d8e:	7dfa      	ldrb	r2, [r7, #23]
   80d90:	683b      	ldr	r3, [r7, #0]
   80d92:	429a      	cmp	r2, r3
   80d94:	d007      	beq.n	80da6 <_ZL24USB_SendStringDescriptorPKhi+0xb2>
		buffer[i] = 0;
   80d96:	7dfb      	ldrb	r3, [r7, #23]
   80d98:	68fa      	ldr	r2, [r7, #12]
   80d9a:	2100      	movs	r1, #0
   80d9c:	54d1      	strb	r1, [r2, r3]
	uint8_t buffer[wLength];
	buffer[0] = strlen((const char*)string) * 2 + 2;
	buffer[1] = 0x03;

	uint8_t i;
	for (i = 2; i < wLength && *string; i++) {
   80d9e:	7dfb      	ldrb	r3, [r7, #23]
   80da0:	3301      	adds	r3, #1
   80da2:	75fb      	strb	r3, [r7, #23]
   80da4:	e7e1      	b.n	80d6a <_ZL24USB_SendStringDescriptorPKhi+0x76>
		buffer[i++] = *string++;
		if (i == wLength) break;
   80da6:	bf00      	nop
		buffer[i] = 0;
	}

	return USBD_SendControl(0, (uint8_t*)buffer, i);
   80da8:	68fb      	ldr	r3, [r7, #12]
   80daa:	7dfa      	ldrb	r2, [r7, #23]
   80dac:	4619      	mov	r1, r3
   80dae:	2000      	movs	r0, #0
   80db0:	4b07      	ldr	r3, [pc, #28]	; (80dd0 <_ZL24USB_SendStringDescriptorPKhi+0xdc>)
   80db2:	4798      	blx	r3
   80db4:	4603      	mov	r3, r0
   80db6:	2b00      	cmp	r3, #0
   80db8:	bf14      	ite	ne
   80dba:	2301      	movne	r3, #1
   80dbc:	2300      	moveq	r3, #0
   80dbe:	b2db      	uxtb	r3, r3
   80dc0:	46c5      	mov	sp, r8
}
   80dc2:	4618      	mov	r0, r3
   80dc4:	3718      	adds	r7, #24
   80dc6:	46bd      	mov	sp, r7
   80dc8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   80dcc:	00094349 	.word	0x00094349
   80dd0:	00080c79 	.word	0x00080c79

00080dd4 <_Z16USBD_RecvControlPvm>:

//	Does not timeout or cross fifo boundaries
//	Will only work for transfers <= 64 bytes
//	TODO
int USBD_RecvControl(void* d, uint32_t len)
{
   80dd4:	b580      	push	{r7, lr}
   80dd6:	b082      	sub	sp, #8
   80dd8:	af00      	add	r7, sp, #0
   80dda:	6078      	str	r0, [r7, #4]
   80ddc:	6039      	str	r1, [r7, #0]
	UDD_WaitOUT();
   80dde:	4b07      	ldr	r3, [pc, #28]	; (80dfc <_Z16USBD_RecvControlPvm+0x28>)
   80de0:	4798      	blx	r3
	UDD_Recv(EP0, (uint8_t*)d, len);
   80de2:	683a      	ldr	r2, [r7, #0]
   80de4:	6879      	ldr	r1, [r7, #4]
   80de6:	2000      	movs	r0, #0
   80de8:	4b05      	ldr	r3, [pc, #20]	; (80e00 <_Z16USBD_RecvControlPvm+0x2c>)
   80dea:	4798      	blx	r3
	UDD_ClearOUT();
   80dec:	4b05      	ldr	r3, [pc, #20]	; (80e04 <_Z16USBD_RecvControlPvm+0x30>)
   80dee:	4798      	blx	r3

	return len;
   80df0:	683b      	ldr	r3, [r7, #0]
}
   80df2:	4618      	mov	r0, r3
   80df4:	3708      	adds	r7, #8
   80df6:	46bd      	mov	sp, r7
   80df8:	bd80      	pop	{r7, pc}
   80dfa:	bf00      	nop
   80dfc:	00088609 	.word	0x00088609
   80e00:	00088829 	.word	0x00088829
   80e04:	0008864d 	.word	0x0008864d

00080e08 <_Z26USBD_ClassInterfaceRequestR8USBSetup>:

//	Handle CLASS_INTERFACE requests
bool USBD_ClassInterfaceRequest(USBSetup& setup)
{
   80e08:	b580      	push	{r7, lr}
   80e0a:	b084      	sub	sp, #16
   80e0c:	af00      	add	r7, sp, #0
   80e0e:	6078      	str	r0, [r7, #4]
	uint8_t i = setup.wIndex;
   80e10:	687b      	ldr	r3, [r7, #4]
   80e12:	889b      	ldrh	r3, [r3, #4]
   80e14:	73fb      	strb	r3, [r7, #15]

	TRACE_CORE(printf("=> USBD_ClassInterfaceRequest\r\n");)

#ifdef CDC_ENABLED
	if (CDC_ACM_INTERFACE == i)
   80e16:	7bfb      	ldrb	r3, [r7, #15]
   80e18:	2b00      	cmp	r3, #0
   80e1a:	d104      	bne.n	80e26 <_Z26USBD_ClassInterfaceRequestR8USBSetup+0x1e>
	{
		return CDC_Setup(setup);
   80e1c:	6878      	ldr	r0, [r7, #4]
   80e1e:	4b08      	ldr	r3, [pc, #32]	; (80e40 <_Z26USBD_ClassInterfaceRequestR8USBSetup+0x38>)
   80e20:	4798      	blx	r3
   80e22:	4603      	mov	r3, r0
   80e24:	e007      	b.n	80e36 <_Z26USBD_ClassInterfaceRequestR8USBSetup+0x2e>
	}
#endif

#ifdef PLUGGABLE_USB_ENABLED
	return PluggableUSB().setup(setup);
   80e26:	4b07      	ldr	r3, [pc, #28]	; (80e44 <_Z26USBD_ClassInterfaceRequestR8USBSetup+0x3c>)
   80e28:	4798      	blx	r3
   80e2a:	4603      	mov	r3, r0
   80e2c:	6879      	ldr	r1, [r7, #4]
   80e2e:	4618      	mov	r0, r3
   80e30:	4b05      	ldr	r3, [pc, #20]	; (80e48 <_Z26USBD_ClassInterfaceRequestR8USBSetup+0x40>)
   80e32:	4798      	blx	r3
   80e34:	4603      	mov	r3, r0
#endif

	return false;
}
   80e36:	4618      	mov	r0, r3
   80e38:	3710      	adds	r7, #16
   80e3a:	46bd      	mov	sp, r7
   80e3c:	bd80      	pop	{r7, pc}
   80e3e:	bf00      	nop
   80e40:	00088acd 	.word	0x00088acd
   80e44:	00088fb1 	.word	0x00088fb1
   80e48:	00088f71 	.word	0x00088f71

00080e4c <_Z19USBD_SendInterfacesv>:

uint8_t USBD_SendInterfaces(void)
{
   80e4c:	b580      	push	{r7, lr}
   80e4e:	b082      	sub	sp, #8
   80e50:	af00      	add	r7, sp, #0
	uint8_t interfaces = 0;
   80e52:	2300      	movs	r3, #0
   80e54:	71fb      	strb	r3, [r7, #7]

#ifdef CDC_ENABLED
	CDC_GetInterface(&interfaces);
   80e56:	1dfb      	adds	r3, r7, #7
   80e58:	4618      	mov	r0, r3
   80e5a:	4b07      	ldr	r3, [pc, #28]	; (80e78 <_Z19USBD_SendInterfacesv+0x2c>)
   80e5c:	4798      	blx	r3
#endif

#ifdef PLUGGABLE_USB_ENABLED
	PluggableUSB().getInterface(&interfaces);
   80e5e:	4b07      	ldr	r3, [pc, #28]	; (80e7c <_Z19USBD_SendInterfacesv+0x30>)
   80e60:	4798      	blx	r3
   80e62:	4602      	mov	r2, r0
   80e64:	1dfb      	adds	r3, r7, #7
   80e66:	4619      	mov	r1, r3
   80e68:	4610      	mov	r0, r2
   80e6a:	4b05      	ldr	r3, [pc, #20]	; (80e80 <_Z19USBD_SendInterfacesv+0x34>)
   80e6c:	4798      	blx	r3
#endif

	TRACE_CORE(printf("=> USBD_SendInterfaces, interfaces=%d\r\n", interfaces);)
	return interfaces;
   80e6e:	79fb      	ldrb	r3, [r7, #7]
}
   80e70:	4618      	mov	r0, r3
   80e72:	3708      	adds	r7, #8
   80e74:	46bd      	mov	sp, r7
   80e76:	bd80      	pop	{r7, pc}
   80e78:	00088a6d 	.word	0x00088a6d
   80e7c:	00088fb1 	.word	0x00088fb1
   80e80:	00088e99 	.word	0x00088e99

00080e84 <_Z24USBD_SendOtherInterfacesv>:

uint8_t USBD_SendOtherInterfaces(void)
{
   80e84:	b580      	push	{r7, lr}
   80e86:	b082      	sub	sp, #8
   80e88:	af00      	add	r7, sp, #0
	uint8_t interfaces = 0;
   80e8a:	2300      	movs	r3, #0
   80e8c:	71fb      	strb	r3, [r7, #7]

#ifdef CDC_ENABLED
	CDC_GetOtherInterface(&interfaces);
   80e8e:	1dfb      	adds	r3, r7, #7
   80e90:	4618      	mov	r0, r3
   80e92:	4b07      	ldr	r3, [pc, #28]	; (80eb0 <_Z24USBD_SendOtherInterfacesv+0x2c>)
   80e94:	4798      	blx	r3
#endif

#ifdef PLUGGABLE_USB_ENABLED
	PluggableUSB().getInterface(&interfaces);
   80e96:	4b07      	ldr	r3, [pc, #28]	; (80eb4 <_Z24USBD_SendOtherInterfacesv+0x30>)
   80e98:	4798      	blx	r3
   80e9a:	4602      	mov	r2, r0
   80e9c:	1dfb      	adds	r3, r7, #7
   80e9e:	4619      	mov	r1, r3
   80ea0:	4610      	mov	r0, r2
   80ea2:	4b05      	ldr	r3, [pc, #20]	; (80eb8 <_Z24USBD_SendOtherInterfacesv+0x34>)
   80ea4:	4798      	blx	r3
#endif

	TRACE_CORE(printf("=> USBD_SendInterfaces, interfaces=%d\r\n", interfaces);)
	return interfaces;
   80ea6:	79fb      	ldrb	r3, [r7, #7]
}
   80ea8:	4618      	mov	r0, r3
   80eaa:	3708      	adds	r7, #8
   80eac:	46bd      	mov	sp, r7
   80eae:	bd80      	pop	{r7, pc}
   80eb0:	00088a9d 	.word	0x00088a9d
   80eb4:	00088fb1 	.word	0x00088fb1
   80eb8:	00088e99 	.word	0x00088e99

00080ebc <_ZL22USBD_SendConfigurationi>:

//	Construct a dynamic configuration descriptor
//	This really needs dynamic endpoint allocation etc
//	TODO
static bool USBD_SendConfiguration(int maxlen)
{
   80ebc:	b580      	push	{r7, lr}
   80ebe:	b086      	sub	sp, #24
   80ec0:	af00      	add	r7, sp, #0
   80ec2:	6078      	str	r0, [r7, #4]
	//	Count and measure interfaces
	USBD_InitControl(0);
   80ec4:	2000      	movs	r0, #0
   80ec6:	4b17      	ldr	r3, [pc, #92]	; (80f24 <_ZL22USBD_SendConfigurationi+0x68>)
   80ec8:	4798      	blx	r3
	//TRACE_CORE(printf("=> USBD_SendConfiguration _cmark1=%d\r\n", _cmark);)
	uint8_t interfaces = USBD_SendInterfaces();
   80eca:	4b17      	ldr	r3, [pc, #92]	; (80f28 <_ZL22USBD_SendConfigurationi+0x6c>)
   80ecc:	4798      	blx	r3
   80ece:	4603      	mov	r3, r0
   80ed0:	75fb      	strb	r3, [r7, #23]
	//TRACE_CORE(printf("=> USBD_SendConfiguration _cmark2=%d\r\n", _cmark);)
	//TRACE_CORE(printf("=> USBD_SendConfiguration sizeof=%d\r\n", sizeof(ConfigDescriptor));)

_Pragma("pack(1)")
	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
   80ed2:	f107 030c 	add.w	r3, r7, #12
   80ed6:	2200      	movs	r2, #0
   80ed8:	601a      	str	r2, [r3, #0]
   80eda:	605a      	str	r2, [r3, #4]
   80edc:	721a      	strb	r2, [r3, #8]
   80ede:	2309      	movs	r3, #9
   80ee0:	733b      	strb	r3, [r7, #12]
   80ee2:	2302      	movs	r3, #2
   80ee4:	737b      	strb	r3, [r7, #13]
   80ee6:	2301      	movs	r3, #1
   80ee8:	747b      	strb	r3, [r7, #17]
   80eea:	23c0      	movs	r3, #192	; 0xc0
   80eec:	74fb      	strb	r3, [r7, #19]
   80eee:	23fa      	movs	r3, #250	; 0xfa
   80ef0:	753b      	strb	r3, [r7, #20]
   80ef2:	2209      	movs	r2, #9
   80ef4:	4b0d      	ldr	r3, [pc, #52]	; (80f2c <_ZL22USBD_SendConfigurationi+0x70>)
   80ef6:	881b      	ldrh	r3, [r3, #0]
   80ef8:	4413      	add	r3, r2
   80efa:	b29b      	uxth	r3, r3
   80efc:	81fb      	strh	r3, [r7, #14]
   80efe:	7dfb      	ldrb	r3, [r7, #23]
   80f00:	743b      	strb	r3, [r7, #16]
	//TRACE_CORE(printf("=> USBD_SendConfiguration clen=%d\r\n", config.clen);)

	//TRACE_CORE(printf("=> USBD_SendConfiguration maxlen=%d\r\n", maxlen);)

	//	Now send them
	USBD_InitControl(maxlen);
   80f02:	6878      	ldr	r0, [r7, #4]
   80f04:	4b07      	ldr	r3, [pc, #28]	; (80f24 <_ZL22USBD_SendConfigurationi+0x68>)
   80f06:	4798      	blx	r3
	USBD_SendControl(0,&config,sizeof(ConfigDescriptor));
   80f08:	f107 030c 	add.w	r3, r7, #12
   80f0c:	2209      	movs	r2, #9
   80f0e:	4619      	mov	r1, r3
   80f10:	2000      	movs	r0, #0
   80f12:	4b07      	ldr	r3, [pc, #28]	; (80f30 <_ZL22USBD_SendConfigurationi+0x74>)
   80f14:	4798      	blx	r3
	USBD_SendInterfaces();
   80f16:	4b04      	ldr	r3, [pc, #16]	; (80f28 <_ZL22USBD_SendConfigurationi+0x6c>)
   80f18:	4798      	blx	r3
	return true;
   80f1a:	2301      	movs	r3, #1
}
   80f1c:	4618      	mov	r0, r3
   80f1e:	3718      	adds	r7, #24
   80f20:	46bd      	mov	sp, r7
   80f22:	bd80      	pop	{r7, pc}
   80f24:	00080c51 	.word	0x00080c51
   80f28:	00080e4d 	.word	0x00080e4d
   80f2c:	20070c70 	.word	0x20070c70
   80f30:	00080c79 	.word	0x00080c79

00080f34 <_ZL27USBD_SendOtherConfigurationi>:

static bool USBD_SendOtherConfiguration(int maxlen)
{
   80f34:	b580      	push	{r7, lr}
   80f36:	b086      	sub	sp, #24
   80f38:	af00      	add	r7, sp, #0
   80f3a:	6078      	str	r0, [r7, #4]
	//	Count and measure interfaces
	USBD_InitControl(0);
   80f3c:	2000      	movs	r0, #0
   80f3e:	4b17      	ldr	r3, [pc, #92]	; (80f9c <_ZL27USBD_SendOtherConfigurationi+0x68>)
   80f40:	4798      	blx	r3
	//TRACE_CORE(printf("=> USBD_SendConfiguration _cmark1=%d\r\n", _cmark);)
	uint8_t interfaces = USBD_SendOtherInterfaces();
   80f42:	4b17      	ldr	r3, [pc, #92]	; (80fa0 <_ZL27USBD_SendOtherConfigurationi+0x6c>)
   80f44:	4798      	blx	r3
   80f46:	4603      	mov	r3, r0
   80f48:	75fb      	strb	r3, [r7, #23]
	//TRACE_CORE(printf("=> USBD_SendConfiguration _cmark2=%d\r\n", _cmark);)
	//TRACE_CORE(printf("=> USBD_SendConfiguration sizeof=%d\r\n", sizeof(ConfigDescriptor));)

_Pragma("pack(1)")
	ConfigDescriptor config = D_OTHERCONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
   80f4a:	f107 030c 	add.w	r3, r7, #12
   80f4e:	2200      	movs	r2, #0
   80f50:	601a      	str	r2, [r3, #0]
   80f52:	605a      	str	r2, [r3, #4]
   80f54:	721a      	strb	r2, [r3, #8]
   80f56:	2309      	movs	r3, #9
   80f58:	733b      	strb	r3, [r7, #12]
   80f5a:	2307      	movs	r3, #7
   80f5c:	737b      	strb	r3, [r7, #13]
   80f5e:	2301      	movs	r3, #1
   80f60:	747b      	strb	r3, [r7, #17]
   80f62:	23c0      	movs	r3, #192	; 0xc0
   80f64:	74fb      	strb	r3, [r7, #19]
   80f66:	23fa      	movs	r3, #250	; 0xfa
   80f68:	753b      	strb	r3, [r7, #20]
   80f6a:	2209      	movs	r2, #9
   80f6c:	4b0d      	ldr	r3, [pc, #52]	; (80fa4 <_ZL27USBD_SendOtherConfigurationi+0x70>)
   80f6e:	881b      	ldrh	r3, [r3, #0]
   80f70:	4413      	add	r3, r2
   80f72:	b29b      	uxth	r3, r3
   80f74:	81fb      	strh	r3, [r7, #14]
   80f76:	7dfb      	ldrb	r3, [r7, #23]
   80f78:	743b      	strb	r3, [r7, #16]
	//TRACE_CORE(printf("=> USBD_SendConfiguration clen=%d\r\n", config.clen);)

	//TRACE_CORE(printf("=> USBD_SendConfiguration maxlen=%d\r\n", maxlen);)

	//	Now send them
	USBD_InitControl(maxlen);
   80f7a:	6878      	ldr	r0, [r7, #4]
   80f7c:	4b07      	ldr	r3, [pc, #28]	; (80f9c <_ZL27USBD_SendOtherConfigurationi+0x68>)
   80f7e:	4798      	blx	r3
	USBD_SendControl(0,&config,sizeof(ConfigDescriptor));
   80f80:	f107 030c 	add.w	r3, r7, #12
   80f84:	2209      	movs	r2, #9
   80f86:	4619      	mov	r1, r3
   80f88:	2000      	movs	r0, #0
   80f8a:	4b07      	ldr	r3, [pc, #28]	; (80fa8 <_ZL27USBD_SendOtherConfigurationi+0x74>)
   80f8c:	4798      	blx	r3
	USBD_SendOtherInterfaces();
   80f8e:	4b04      	ldr	r3, [pc, #16]	; (80fa0 <_ZL27USBD_SendOtherConfigurationi+0x6c>)
   80f90:	4798      	blx	r3
	return true;
   80f92:	2301      	movs	r3, #1
}
   80f94:	4618      	mov	r0, r3
   80f96:	3718      	adds	r7, #24
   80f98:	46bd      	mov	sp, r7
   80f9a:	bd80      	pop	{r7, pc}
   80f9c:	00080c51 	.word	0x00080c51
   80fa0:	00080e85 	.word	0x00080e85
   80fa4:	20070c70 	.word	0x20070c70
   80fa8:	00080c79 	.word	0x00080c79

00080fac <_ZL19USBD_SendDescriptorR8USBSetup>:

static bool USBD_SendDescriptor(USBSetup& setup)
{
   80fac:	b580      	push	{r7, lr}
   80fae:	b08c      	sub	sp, #48	; 0x30
   80fb0:	af00      	add	r7, sp, #0
   80fb2:	6078      	str	r0, [r7, #4]
	uint8_t t = setup.wValueH;
   80fb4:	687b      	ldr	r3, [r7, #4]
   80fb6:	78db      	ldrb	r3, [r3, #3]
   80fb8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	uint8_t desc_length = 0;
   80fbc:	2300      	movs	r3, #0
   80fbe:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	int ret = 0;
   80fc2:	2300      	movs	r3, #0
   80fc4:	623b      	str	r3, [r7, #32]
	const uint8_t* desc_addr = 0;
   80fc6:	2300      	movs	r3, #0
   80fc8:	62bb      	str	r3, [r7, #40]	; 0x28

	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
   80fca:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   80fce:	2b02      	cmp	r3, #2
   80fd0:	d106      	bne.n	80fe0 <_ZL19USBD_SendDescriptorR8USBSetup+0x34>
	{
		TRACE_CORE(printf("=> USBD_SendDescriptor : USB_CONFIGURATION_DESCRIPTOR_TYPE length=%d\r\n", setup.wLength);)
		return USBD_SendConfiguration(setup.wLength);
   80fd2:	687b      	ldr	r3, [r7, #4]
   80fd4:	88db      	ldrh	r3, [r3, #6]
   80fd6:	4618      	mov	r0, r3
   80fd8:	4b5c      	ldr	r3, [pc, #368]	; (8114c <_ZL19USBD_SendDescriptorR8USBSetup+0x1a0>)
   80fda:	4798      	blx	r3
   80fdc:	4603      	mov	r3, r0
   80fde:	e0b0      	b.n	81142 <_ZL19USBD_SendDescriptorR8USBSetup+0x196>
	}

	USBD_InitControl(setup.wLength);
   80fe0:	687b      	ldr	r3, [r7, #4]
   80fe2:	88db      	ldrh	r3, [r3, #6]
   80fe4:	4618      	mov	r0, r3
   80fe6:	4b5a      	ldr	r3, [pc, #360]	; (81150 <_ZL19USBD_SendDescriptorR8USBSetup+0x1a4>)
   80fe8:	4798      	blx	r3

#ifdef PLUGGABLE_USB_ENABLED
	ret = PluggableUSB().getDescriptor(setup);
   80fea:	4b5a      	ldr	r3, [pc, #360]	; (81154 <_ZL19USBD_SendDescriptorR8USBSetup+0x1a8>)
   80fec:	4798      	blx	r3
   80fee:	4603      	mov	r3, r0
   80ff0:	6879      	ldr	r1, [r7, #4]
   80ff2:	4618      	mov	r0, r3
   80ff4:	4b58      	ldr	r3, [pc, #352]	; (81158 <_ZL19USBD_SendDescriptorR8USBSetup+0x1ac>)
   80ff6:	4798      	blx	r3
   80ff8:	6238      	str	r0, [r7, #32]
	if (ret != 0) {
   80ffa:	6a3b      	ldr	r3, [r7, #32]
   80ffc:	2b00      	cmp	r3, #0
   80ffe:	d006      	beq.n	8100e <_ZL19USBD_SendDescriptorR8USBSetup+0x62>
		return (ret > 0 ? true : false);
   81000:	6a3b      	ldr	r3, [r7, #32]
   81002:	2b00      	cmp	r3, #0
   81004:	bfcc      	ite	gt
   81006:	2301      	movgt	r3, #1
   81008:	2300      	movle	r3, #0
   8100a:	b2db      	uxtb	r3, r3
   8100c:	e099      	b.n	81142 <_ZL19USBD_SendDescriptorR8USBSetup+0x196>
	}
#endif

	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
   8100e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   81012:	2b01      	cmp	r3, #1
   81014:	d11a      	bne.n	8104c <_ZL19USBD_SendDescriptorR8USBSetup+0xa0>
	{
		TRACE_CORE(puts("=> USBD_SendDescriptor : USB_DEVICE_DESCRIPTOR_TYPE\r\n");)
		if (setup.wLength == 8)
   81016:	687b      	ldr	r3, [r7, #4]
   81018:	88db      	ldrh	r3, [r3, #6]
   8101a:	2b08      	cmp	r3, #8
   8101c:	d102      	bne.n	81024 <_ZL19USBD_SendDescriptorR8USBSetup+0x78>
		{
			_cdcComposite = 1;
   8101e:	4b4f      	ldr	r3, [pc, #316]	; (8115c <_ZL19USBD_SendDescriptorR8USBSetup+0x1b0>)
   81020:	2201      	movs	r2, #1
   81022:	601a      	str	r2, [r3, #0]
		}
		desc_addr = _cdcComposite ?  (const uint8_t*)&USB_DeviceDescriptorA : (const uint8_t*)&USB_DeviceDescriptor;
   81024:	4b4d      	ldr	r3, [pc, #308]	; (8115c <_ZL19USBD_SendDescriptorR8USBSetup+0x1b0>)
   81026:	681b      	ldr	r3, [r3, #0]
   81028:	2b00      	cmp	r3, #0
   8102a:	d001      	beq.n	81030 <_ZL19USBD_SendDescriptorR8USBSetup+0x84>
   8102c:	4b4c      	ldr	r3, [pc, #304]	; (81160 <_ZL19USBD_SendDescriptorR8USBSetup+0x1b4>)
   8102e:	e000      	b.n	81032 <_ZL19USBD_SendDescriptorR8USBSetup+0x86>
   81030:	4b4c      	ldr	r3, [pc, #304]	; (81164 <_ZL19USBD_SendDescriptorR8USBSetup+0x1b8>)
   81032:	62bb      	str	r3, [r7, #40]	; 0x28
        if( *desc_addr > setup.wLength ) {
   81034:	6abb      	ldr	r3, [r7, #40]	; 0x28
   81036:	781b      	ldrb	r3, [r3, #0]
   81038:	b29a      	uxth	r2, r3
   8103a:	687b      	ldr	r3, [r7, #4]
   8103c:	88db      	ldrh	r3, [r3, #6]
   8103e:	429a      	cmp	r2, r3
   81040:	d96a      	bls.n	81118 <_ZL19USBD_SendDescriptorR8USBSetup+0x16c>
            desc_length = setup.wLength;
   81042:	687b      	ldr	r3, [r7, #4]
   81044:	88db      	ldrh	r3, [r3, #6]
   81046:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   8104a:	e065      	b.n	81118 <_ZL19USBD_SendDescriptorR8USBSetup+0x16c>
        }
	}
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
   8104c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   81050:	2b03      	cmp	r3, #3
   81052:	d144      	bne.n	810de <_ZL19USBD_SendDescriptorR8USBSetup+0x132>
	{
		TRACE_CORE(puts("=> USBD_SendDescriptor : USB_STRING_DESCRIPTOR_TYPE\r\n");)
		if (setup.wValueL == 0) {
   81054:	687b      	ldr	r3, [r7, #4]
   81056:	789b      	ldrb	r3, [r3, #2]
   81058:	2b00      	cmp	r3, #0
   8105a:	d109      	bne.n	81070 <_ZL19USBD_SendDescriptorR8USBSetup+0xc4>
			desc_addr = (const uint8_t*)&STRING_LANGUAGE;
   8105c:	4b42      	ldr	r3, [pc, #264]	; (81168 <_ZL19USBD_SendDescriptorR8USBSetup+0x1bc>)
   8105e:	62bb      	str	r3, [r7, #40]	; 0x28
#endif
		}
		else {
			return false;
		}
		if( *desc_addr > setup.wLength ) {
   81060:	6abb      	ldr	r3, [r7, #40]	; 0x28
   81062:	781b      	ldrb	r3, [r3, #0]
   81064:	b29a      	uxth	r2, r3
   81066:	687b      	ldr	r3, [r7, #4]
   81068:	88db      	ldrh	r3, [r3, #6]
   8106a:	429a      	cmp	r2, r3
   8106c:	d954      	bls.n	81118 <_ZL19USBD_SendDescriptorR8USBSetup+0x16c>
   8106e:	e031      	b.n	810d4 <_ZL19USBD_SendDescriptorR8USBSetup+0x128>
	{
		TRACE_CORE(puts("=> USBD_SendDescriptor : USB_STRING_DESCRIPTOR_TYPE\r\n");)
		if (setup.wValueL == 0) {
			desc_addr = (const uint8_t*)&STRING_LANGUAGE;
		}
		else if (setup.wValueL == IPRODUCT) {
   81070:	687b      	ldr	r3, [r7, #4]
   81072:	789b      	ldrb	r3, [r3, #2]
   81074:	2b02      	cmp	r3, #2
   81076:	d107      	bne.n	81088 <_ZL19USBD_SendDescriptorR8USBSetup+0xdc>
			return USB_SendStringDescriptor(STRING_PRODUCT, setup.wLength);
   81078:	687b      	ldr	r3, [r7, #4]
   8107a:	88db      	ldrh	r3, [r3, #6]
   8107c:	4619      	mov	r1, r3
   8107e:	483b      	ldr	r0, [pc, #236]	; (8116c <_ZL19USBD_SendDescriptorR8USBSetup+0x1c0>)
   81080:	4b3b      	ldr	r3, [pc, #236]	; (81170 <_ZL19USBD_SendDescriptorR8USBSetup+0x1c4>)
   81082:	4798      	blx	r3
   81084:	4603      	mov	r3, r0
   81086:	e05c      	b.n	81142 <_ZL19USBD_SendDescriptorR8USBSetup+0x196>
		}
		else if (setup.wValueL == IMANUFACTURER) {
   81088:	687b      	ldr	r3, [r7, #4]
   8108a:	789b      	ldrb	r3, [r3, #2]
   8108c:	2b01      	cmp	r3, #1
   8108e:	d107      	bne.n	810a0 <_ZL19USBD_SendDescriptorR8USBSetup+0xf4>
			return USB_SendStringDescriptor(STRING_MANUFACTURER, setup.wLength);
   81090:	687b      	ldr	r3, [r7, #4]
   81092:	88db      	ldrh	r3, [r3, #6]
   81094:	4619      	mov	r1, r3
   81096:	4837      	ldr	r0, [pc, #220]	; (81174 <_ZL19USBD_SendDescriptorR8USBSetup+0x1c8>)
   81098:	4b35      	ldr	r3, [pc, #212]	; (81170 <_ZL19USBD_SendDescriptorR8USBSetup+0x1c4>)
   8109a:	4798      	blx	r3
   8109c:	4603      	mov	r3, r0
   8109e:	e050      	b.n	81142 <_ZL19USBD_SendDescriptorR8USBSetup+0x196>
		}
		else if (setup.wValueL == ISERIAL) {
   810a0:	687b      	ldr	r3, [r7, #4]
   810a2:	789b      	ldrb	r3, [r3, #2]
   810a4:	2b03      	cmp	r3, #3
   810a6:	d113      	bne.n	810d0 <_ZL19USBD_SendDescriptorR8USBSetup+0x124>
#ifdef PLUGGABLE_USB_ENABLED
			char name[ISERIAL_MAX_LEN];
			PluggableUSB().getShortName(name);
   810a8:	4b2a      	ldr	r3, [pc, #168]	; (81154 <_ZL19USBD_SendDescriptorR8USBSetup+0x1a8>)
   810aa:	4798      	blx	r3
   810ac:	4602      	mov	r2, r0
   810ae:	f107 030c 	add.w	r3, r7, #12
   810b2:	4619      	mov	r1, r3
   810b4:	4610      	mov	r0, r2
   810b6:	4b30      	ldr	r3, [pc, #192]	; (81178 <_ZL19USBD_SendDescriptorR8USBSetup+0x1cc>)
   810b8:	4798      	blx	r3
			return USB_SendStringDescriptor((uint8_t*)name, setup.wLength);
   810ba:	687b      	ldr	r3, [r7, #4]
   810bc:	88db      	ldrh	r3, [r3, #6]
   810be:	461a      	mov	r2, r3
   810c0:	f107 030c 	add.w	r3, r7, #12
   810c4:	4611      	mov	r1, r2
   810c6:	4618      	mov	r0, r3
   810c8:	4b29      	ldr	r3, [pc, #164]	; (81170 <_ZL19USBD_SendDescriptorR8USBSetup+0x1c4>)
   810ca:	4798      	blx	r3
   810cc:	4603      	mov	r3, r0
   810ce:	e038      	b.n	81142 <_ZL19USBD_SendDescriptorR8USBSetup+0x196>
#endif
		}
		else {
			return false;
   810d0:	2300      	movs	r3, #0
   810d2:	e036      	b.n	81142 <_ZL19USBD_SendDescriptorR8USBSetup+0x196>
		}
		if( *desc_addr > setup.wLength ) {
			desc_length = setup.wLength;
   810d4:	687b      	ldr	r3, [r7, #4]
   810d6:	88db      	ldrh	r3, [r3, #6]
   810d8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   810dc:	e01c      	b.n	81118 <_ZL19USBD_SendDescriptorR8USBSetup+0x16c>
		}
	}
	else if (USB_DEVICE_QUALIFIER == t)
   810de:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   810e2:	2b06      	cmp	r3, #6
   810e4:	d10d      	bne.n	81102 <_ZL19USBD_SendDescriptorR8USBSetup+0x156>
	{
		// Device qualifier descriptor requested
		desc_addr = (const uint8_t*)&USB_DeviceQualifier;
   810e6:	4b25      	ldr	r3, [pc, #148]	; (8117c <_ZL19USBD_SendDescriptorR8USBSetup+0x1d0>)
   810e8:	62bb      	str	r3, [r7, #40]	; 0x28
        if( *desc_addr > setup.wLength ) {
   810ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
   810ec:	781b      	ldrb	r3, [r3, #0]
   810ee:	b29a      	uxth	r2, r3
   810f0:	687b      	ldr	r3, [r7, #4]
   810f2:	88db      	ldrh	r3, [r3, #6]
   810f4:	429a      	cmp	r2, r3
   810f6:	d90f      	bls.n	81118 <_ZL19USBD_SendDescriptorR8USBSetup+0x16c>
            desc_length = setup.wLength;
   810f8:	687b      	ldr	r3, [r7, #4]
   810fa:	88db      	ldrh	r3, [r3, #6]
   810fc:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   81100:	e00a      	b.n	81118 <_ZL19USBD_SendDescriptorR8USBSetup+0x16c>
        }
    }
    else if (USB_OTHER_SPEED_CONFIGURATION == t)
   81102:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   81106:	2b07      	cmp	r3, #7
   81108:	d106      	bne.n	81118 <_ZL19USBD_SendDescriptorR8USBSetup+0x16c>
    {
		// Other configuration descriptor requested
		return USBD_SendOtherConfiguration(setup.wLength);
   8110a:	687b      	ldr	r3, [r7, #4]
   8110c:	88db      	ldrh	r3, [r3, #6]
   8110e:	4618      	mov	r0, r3
   81110:	4b1b      	ldr	r3, [pc, #108]	; (81180 <_ZL19USBD_SendDescriptorR8USBSetup+0x1d4>)
   81112:	4798      	blx	r3
   81114:	4603      	mov	r3, r0
   81116:	e014      	b.n	81142 <_ZL19USBD_SendDescriptorR8USBSetup+0x196>
    else
    {
        //printf("Device ERROR");
    }

	if (desc_addr == 0)
   81118:	6abb      	ldr	r3, [r7, #40]	; 0x28
   8111a:	2b00      	cmp	r3, #0
   8111c:	d101      	bne.n	81122 <_ZL19USBD_SendDescriptorR8USBSetup+0x176>
	{
		return false;
   8111e:	2300      	movs	r3, #0
   81120:	e00f      	b.n	81142 <_ZL19USBD_SendDescriptorR8USBSetup+0x196>
	}

	if (desc_length == 0)
   81122:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   81126:	2b00      	cmp	r3, #0
   81128:	d103      	bne.n	81132 <_ZL19USBD_SendDescriptorR8USBSetup+0x186>
	{
		desc_length = *desc_addr;
   8112a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   8112c:	781b      	ldrb	r3, [r3, #0]
   8112e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	}

	TRACE_CORE(printf("=> USBD_SendDescriptor : desc_addr=%p desc_length=%d\r\n", desc_addr, desc_length);)
	USBD_SendControl(0, desc_addr, desc_length);
   81132:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   81136:	461a      	mov	r2, r3
   81138:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   8113a:	2000      	movs	r0, #0
   8113c:	4b11      	ldr	r3, [pc, #68]	; (81184 <_ZL19USBD_SendDescriptorR8USBSetup+0x1d8>)
   8113e:	4798      	blx	r3

	return true;
   81140:	2301      	movs	r3, #1
}
   81142:	4618      	mov	r0, r3
   81144:	3730      	adds	r7, #48	; 0x30
   81146:	46bd      	mov	sp, r7
   81148:	bd80      	pop	{r7, pc}
   8114a:	bf00      	nop
   8114c:	00080ebd 	.word	0x00080ebd
   81150:	00080c51 	.word	0x00080c51
   81154:	00088fb1 	.word	0x00088fb1
   81158:	00088ee9 	.word	0x00088ee9
   8115c:	20070c6c 	.word	0x20070c6c
   81160:	00099534 	.word	0x00099534
   81164:	00099520 	.word	0x00099520
   81168:	00099504 	.word	0x00099504
   8116c:	00099508 	.word	0x00099508
   81170:	00080cf5 	.word	0x00080cf5
   81174:	00099514 	.word	0x00099514
   81178:	00088f2d 	.word	0x00088f2d
   8117c:	00099548 	.word	0x00099548
   81180:	00080f35 	.word	0x00080f35
   81184:	00080c79 	.word	0x00080c79

00081188 <_ZL11USB_SendZlpv>:


static void USB_SendZlp( void )
{
   81188:	b480      	push	{r7}
   8118a:	af00      	add	r7, sp, #0
    while( UOTGHS_DEVEPTISR_TXINI != (UOTGHS->UOTGHS_DEVEPTISR[0] & UOTGHS_DEVEPTISR_TXINI ) )
   8118c:	4b10      	ldr	r3, [pc, #64]	; (811d0 <_ZL11USB_SendZlpv+0x48>)
   8118e:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   81192:	f003 0301 	and.w	r3, r3, #1
   81196:	2b00      	cmp	r3, #0
   81198:	bf0c      	ite	eq
   8119a:	2301      	moveq	r3, #1
   8119c:	2300      	movne	r3, #0
   8119e:	b2db      	uxtb	r3, r3
   811a0:	2b00      	cmp	r3, #0
   811a2:	d00b      	beq.n	811bc <_ZL11USB_SendZlpv+0x34>
    {
        if((UOTGHS->UOTGHS_DEVISR & UOTGHS_DEVISR_SUSP) == UOTGHS_DEVISR_SUSP)
   811a4:	4b0a      	ldr	r3, [pc, #40]	; (811d0 <_ZL11USB_SendZlpv+0x48>)
   811a6:	685b      	ldr	r3, [r3, #4]
   811a8:	f003 0301 	and.w	r3, r3, #1
   811ac:	2b00      	cmp	r3, #0
   811ae:	bf14      	ite	ne
   811b0:	2301      	movne	r3, #1
   811b2:	2300      	moveq	r3, #0
   811b4:	b2db      	uxtb	r3, r3
   811b6:	2b00      	cmp	r3, #0
   811b8:	d105      	bne.n	811c6 <_ZL11USB_SendZlpv+0x3e>
}


static void USB_SendZlp( void )
{
    while( UOTGHS_DEVEPTISR_TXINI != (UOTGHS->UOTGHS_DEVEPTISR[0] & UOTGHS_DEVEPTISR_TXINI ) )
   811ba:	e7e7      	b.n	8118c <_ZL11USB_SendZlpv+0x4>
        if((UOTGHS->UOTGHS_DEVISR & UOTGHS_DEVISR_SUSP) == UOTGHS_DEVISR_SUSP)
        {
            return;
        }
    }
    UOTGHS->UOTGHS_DEVEPTICR[0] = UOTGHS_DEVEPTICR_TXINIC;
   811bc:	4b04      	ldr	r3, [pc, #16]	; (811d0 <_ZL11USB_SendZlpv+0x48>)
   811be:	2201      	movs	r2, #1
   811c0:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
   811c4:	e000      	b.n	811c8 <_ZL11USB_SendZlpv+0x40>
{
    while( UOTGHS_DEVEPTISR_TXINI != (UOTGHS->UOTGHS_DEVEPTISR[0] & UOTGHS_DEVEPTISR_TXINI ) )
    {
        if((UOTGHS->UOTGHS_DEVISR & UOTGHS_DEVISR_SUSP) == UOTGHS_DEVISR_SUSP)
        {
            return;
   811c6:	bf00      	nop
        }
    }
    UOTGHS->UOTGHS_DEVEPTICR[0] = UOTGHS_DEVEPTICR_TXINIC;
}
   811c8:	46bd      	mov	sp, r7
   811ca:	bc80      	pop	{r7}
   811cc:	4770      	bx	lr
   811ce:	bf00      	nop
   811d0:	400ac000 	.word	0x400ac000

000811d4 <_ZL17Test_Mode_Supporth>:


static void Test_Mode_Support( uint8_t wIndex )
{
   811d4:	b580      	push	{r7, lr}
   811d6:	b084      	sub	sp, #16
   811d8:	af00      	add	r7, sp, #0
   811da:	4603      	mov	r3, r0
   811dc:	71fb      	strb	r3, [r7, #7]
    uint8_t i;
	uint8_t *ptr_dest = (uint8_t *) &udd_get_endpoint_fifo_access8(2);
   811de:	4b3b      	ldr	r3, [pc, #236]	; (812cc <_ZL17Test_Mode_Supporth+0xf8>)
   811e0:	60bb      	str	r3, [r7, #8]

	switch( wIndex )
   811e2:	79fb      	ldrb	r3, [r7, #7]
   811e4:	3b01      	subs	r3, #1
   811e6:	2b03      	cmp	r3, #3
   811e8:	d86c      	bhi.n	812c4 <_ZL17Test_Mode_Supporth+0xf0>
   811ea:	a201      	add	r2, pc, #4	; (adr r2, 811f0 <_ZL17Test_Mode_Supporth+0x1c>)
   811ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   811f0:	00081295 	.word	0x00081295
   811f4:	000812a7 	.word	0x000812a7
   811f8:	000812b9 	.word	0x000812b9
   811fc:	00081201 	.word	0x00081201
			//A port in Test_Packet mode must send this packet repetitively. The inter-packet timing
			//must be no less than the minimum allowable inter-packet gap as defined in Section 7.1.18 and
			//no greater than 125 us.

			// Send ZLP
			USB_SendZlp();
   81200:	4b33      	ldr	r3, [pc, #204]	; (812d0 <_ZL17Test_Mode_Supporth+0xfc>)
   81202:	4798      	blx	r3

			UOTGHS->UOTGHS_DEVDMA[0].UOTGHS_DEVDMACONTROL = 0; // raz
   81204:	4b33      	ldr	r3, [pc, #204]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   81206:	2200      	movs	r2, #0
   81208:	f8c3 2318 	str.w	r2, [r3, #792]	; 0x318
			UOTGHS->UOTGHS_DEVDMA[1].UOTGHS_DEVDMACONTROL = 0; // raz
   8120c:	4b31      	ldr	r3, [pc, #196]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   8120e:	2200      	movs	r2, #0
   81210:	f8c3 2328 	str.w	r2, [r3, #808]	; 0x328

			// Configure endpoint 2, 64 bytes, direction IN, type BULK, 1 bank
			UOTGHS->UOTGHS_DEVEPTCFG[2] = UOTGHS_DEVEPTCFG_EPSIZE_64_BYTE
   81214:	4b2f      	ldr	r3, [pc, #188]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
												 | UOTGHS_DEVEPTCFG_EPDIR_IN
												 | UOTGHS_DEVEPTCFG_EPTYPE_BLK
												 | UOTGHS_DEVEPTCFG_EPBK_1_BANK;
   81216:	f241 1230 	movw	r2, #4400	; 0x1130
   8121a:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
			// Check if the configuration is ok
			UOTGHS->UOTGHS_DEVEPTCFG[2] |= UOTGHS_DEVEPTCFG_ALLOC;
   8121e:	4a2d      	ldr	r2, [pc, #180]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   81220:	4b2c      	ldr	r3, [pc, #176]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   81222:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
   81226:	f043 0302 	orr.w	r3, r3, #2
   8122a:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
			while((UOTGHS->UOTGHS_DEVEPTISR[2]&UOTGHS_DEVEPTISR_CFGOK)==0) {}
   8122e:	4b29      	ldr	r3, [pc, #164]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   81230:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
   81234:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
   81238:	2b00      	cmp	r3, #0
   8123a:	bf0c      	ite	eq
   8123c:	2301      	moveq	r3, #1
   8123e:	2300      	movne	r3, #0
   81240:	b2db      	uxtb	r3, r3
   81242:	2b00      	cmp	r3, #0
   81244:	d000      	beq.n	81248 <_ZL17Test_Mode_Supporth+0x74>
   81246:	e7f2      	b.n	8122e <_ZL17Test_Mode_Supporth+0x5a>
			UOTGHS->UOTGHS_DEVEPT |= UOTGHS_DEVEPT_EPEN2;
   81248:	4a22      	ldr	r2, [pc, #136]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   8124a:	4b22      	ldr	r3, [pc, #136]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   8124c:	69db      	ldr	r3, [r3, #28]
   8124e:	f043 0304 	orr.w	r3, r3, #4
   81252:	61d3      	str	r3, [r2, #28]
			// Write FIFO
			for( i=0; i<sizeof(test_packet_buffer); i++)
   81254:	2300      	movs	r3, #0
   81256:	73fb      	strb	r3, [r7, #15]
   81258:	7bfb      	ldrb	r3, [r7, #15]
   8125a:	2b35      	cmp	r3, #53	; 0x35
   8125c:	d20a      	bcs.n	81274 <_ZL17Test_Mode_Supporth+0xa0>
			{
				ptr_dest[i] = test_packet_buffer[i];;
   8125e:	7bfb      	ldrb	r3, [r7, #15]
   81260:	68ba      	ldr	r2, [r7, #8]
   81262:	4413      	add	r3, r2
   81264:	7bfa      	ldrb	r2, [r7, #15]
   81266:	491c      	ldr	r1, [pc, #112]	; (812d8 <_ZL17Test_Mode_Supporth+0x104>)
   81268:	5c8a      	ldrb	r2, [r1, r2]
   8126a:	701a      	strb	r2, [r3, #0]
			// Check if the configuration is ok
			UOTGHS->UOTGHS_DEVEPTCFG[2] |= UOTGHS_DEVEPTCFG_ALLOC;
			while((UOTGHS->UOTGHS_DEVEPTISR[2]&UOTGHS_DEVEPTISR_CFGOK)==0) {}
			UOTGHS->UOTGHS_DEVEPT |= UOTGHS_DEVEPT_EPEN2;
			// Write FIFO
			for( i=0; i<sizeof(test_packet_buffer); i++)
   8126c:	7bfb      	ldrb	r3, [r7, #15]
   8126e:	3301      	adds	r3, #1
   81270:	73fb      	strb	r3, [r7, #15]
   81272:	e7f1      	b.n	81258 <_ZL17Test_Mode_Supporth+0x84>
			{
				ptr_dest[i] = test_packet_buffer[i];;
			}
			// Tst PACKET
			UOTGHS->UOTGHS_DEVCTRL |= UOTGHS_DEVCTRL_TSTPCKT;
   81274:	4a17      	ldr	r2, [pc, #92]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   81276:	4b17      	ldr	r3, [pc, #92]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   81278:	681b      	ldr	r3, [r3, #0]
   8127a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   8127e:	6013      	str	r3, [r2, #0]
			// Send packet
			UOTGHS->UOTGHS_DEVEPTICR[2] = UOTGHS_DEVEPTICR_TXINIC;
   81280:	4b14      	ldr	r3, [pc, #80]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   81282:	2201      	movs	r2, #1
   81284:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
			UOTGHS->UOTGHS_DEVEPTIDR[2] = UOTGHS_DEVEPTIDR_FIFOCONC;
   81288:	4b12      	ldr	r3, [pc, #72]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   8128a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   8128e:	f8c3 2228 	str.w	r2, [r3, #552]	; 0x228
			for(;;);
   81292:	e7fe      	b.n	81292 <_ZL17Test_Mode_Supporth+0xbe>
			//Test mode Test_J:
			//Upon command, a port's transceiver must enter the high-speed J state and remain in that
			//state until the exit action is taken. This enables the testing of the high output drive
			//level on the D+ line.
			// Send a ZLP
			USB_SendZlp();
   81294:	4b0e      	ldr	r3, [pc, #56]	; (812d0 <_ZL17Test_Mode_Supporth+0xfc>)
   81296:	4798      	blx	r3
			UOTGHS->UOTGHS_DEVCTRL |= UOTGHS_DEVCTRL_TSTJ;
   81298:	4a0e      	ldr	r2, [pc, #56]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   8129a:	4b0e      	ldr	r3, [pc, #56]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   8129c:	681b      	ldr	r3, [r3, #0]
   8129e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   812a2:	6013      	str	r3, [r2, #0]
			for(;;);
   812a4:	e7fe      	b.n	812a4 <_ZL17Test_Mode_Supporth+0xd0>
			//Test mode Test_K:
			//Upon command, a port's transceiver must enter the high-speed K state and remain in
			//that state until the exit action is taken. This enables the testing of the high output drive
			//level on the D- line.
			// Send a ZLP
			USB_SendZlp();
   812a6:	4b0a      	ldr	r3, [pc, #40]	; (812d0 <_ZL17Test_Mode_Supporth+0xfc>)
   812a8:	4798      	blx	r3
			UOTGHS->UOTGHS_DEVCTRL |= UOTGHS_DEVCTRL_TSTK;
   812aa:	4a0a      	ldr	r2, [pc, #40]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   812ac:	4b09      	ldr	r3, [pc, #36]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
   812ae:	681b      	ldr	r3, [r3, #0]
   812b0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   812b4:	6013      	str	r3, [r2, #0]
			for(;;);
   812b6:	e7fe      	b.n	812b6 <_ZL17Test_Mode_Supporth+0xe2>
			//determined to be correct) within the normal allowed device response time. This enables testing of
			//the device squelch level circuitry and, additionally, provides a general purpose stimulus/response
			//test for basic functional testing.

			// Send a ZLP
			USB_SendZlp();
   812b8:	4b05      	ldr	r3, [pc, #20]	; (812d0 <_ZL17Test_Mode_Supporth+0xfc>)
   812ba:	4798      	blx	r3
			UOTGHS->UOTGHS_DEVIDR = UOTGHS_DEVIDR_SUSPEC
   812bc:	4b05      	ldr	r3, [pc, #20]	; (812d4 <_ZL17Test_Mode_Supporth+0x100>)
							   | UOTGHS_DEVIDR_DMA_1
							   | UOTGHS_DEVIDR_DMA_2
							   | UOTGHS_DEVIDR_DMA_3
							   | UOTGHS_DEVIDR_DMA_4
							   | UOTGHS_DEVIDR_DMA_5
							   | UOTGHS_DEVIDR_DMA_6;
   812be:	4a07      	ldr	r2, [pc, #28]	; (812dc <_ZL17Test_Mode_Supporth+0x108>)
   812c0:	615a      	str	r2, [r3, #20]
			for(;;);
   812c2:	e7fe      	b.n	812c2 <_ZL17Test_Mode_Supporth+0xee>
//		break;
	}
}
   812c4:	bf00      	nop
   812c6:	3710      	adds	r7, #16
   812c8:	46bd      	mov	sp, r7
   812ca:	bd80      	pop	{r7, pc}
   812cc:	20190000 	.word	0x20190000
   812d0:	00081189 	.word	0x00081189
   812d4:	400ac000 	.word	0x400ac000
   812d8:	00099554 	.word	0x00099554
   812dc:	7e07f07f 	.word	0x7e07f07f

000812e0 <_ZL7USB_ISRv>:


//unsigned int iii=0;
//	Endpoint 0 interrupt
static void USB_ISR(void)
{
   812e0:	b580      	push	{r7, lr}
   812e2:	b086      	sub	sp, #24
   812e4:	af00      	add	r7, sp, #0
//    printf("ISR=0x%X\n\r", UOTGHS->UOTGHS_DEVISR); // jcb
//    if( iii++ > 1500 ) while(1); // jcb
    // End of bus reset
    if (Is_udd_reset())
   812e6:	4b9f      	ldr	r3, [pc, #636]	; (81564 <_ZL7USB_ISRv+0x284>)
   812e8:	685b      	ldr	r3, [r3, #4]
   812ea:	f003 0308 	and.w	r3, r3, #8
   812ee:	2b00      	cmp	r3, #0
   812f0:	bf14      	ite	ne
   812f2:	2301      	movne	r3, #1
   812f4:	2300      	moveq	r3, #0
   812f6:	b2db      	uxtb	r3, r3
   812f8:	2b00      	cmp	r3, #0
   812fa:	d01d      	beq.n	81338 <_ZL7USB_ISRv+0x58>
    {
		TRACE_CORE(printf(">>> End of Reset\r\n");)

		// Reset USB address to 0
		udd_configure_address(0);
   812fc:	4a99      	ldr	r2, [pc, #612]	; (81564 <_ZL7USB_ISRv+0x284>)
   812fe:	4b99      	ldr	r3, [pc, #612]	; (81564 <_ZL7USB_ISRv+0x284>)
   81300:	681b      	ldr	r3, [r3, #0]
   81302:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   81306:	6013      	str	r3, [r2, #0]
		udd_enable_address();
   81308:	4a96      	ldr	r2, [pc, #600]	; (81564 <_ZL7USB_ISRv+0x284>)
   8130a:	4b96      	ldr	r3, [pc, #600]	; (81564 <_ZL7USB_ISRv+0x284>)
   8130c:	681b      	ldr	r3, [r3, #0]
   8130e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   81312:	6013      	str	r3, [r2, #0]

		// Configure EP 0
        UDD_InitEP(0, EP_TYPE_CONTROL);
   81314:	f242 0132 	movw	r1, #8242	; 0x2032
   81318:	2000      	movs	r0, #0
   8131a:	4b93      	ldr	r3, [pc, #588]	; (81568 <_ZL7USB_ISRv+0x288>)
   8131c:	4798      	blx	r3
		udd_enable_setup_received_interrupt(0);
   8131e:	4b93      	ldr	r3, [pc, #588]	; (8156c <_ZL7USB_ISRv+0x28c>)
   81320:	2204      	movs	r2, #4
   81322:	601a      	str	r2, [r3, #0]
		udd_enable_endpoint_interrupt(0);
   81324:	4b8f      	ldr	r3, [pc, #572]	; (81564 <_ZL7USB_ISRv+0x284>)
   81326:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   8132a:	619a      	str	r2, [r3, #24]

        _usbConfiguration = 0;
   8132c:	4b90      	ldr	r3, [pc, #576]	; (81570 <_ZL7USB_ISRv+0x290>)
   8132e:	2200      	movs	r2, #0
   81330:	601a      	str	r2, [r3, #0]
		udd_ack_reset();
   81332:	4b8c      	ldr	r3, [pc, #560]	; (81564 <_ZL7USB_ISRv+0x284>)
   81334:	2208      	movs	r2, #8
   81336:	609a      	str	r2, [r3, #8]
    }

#ifdef CDC_ENABLED
  	if (Is_udd_endpoint_interrupt(CDC_RX))
   81338:	4b8a      	ldr	r3, [pc, #552]	; (81564 <_ZL7USB_ISRv+0x284>)
   8133a:	685b      	ldr	r3, [r3, #4]
   8133c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   81340:	2b00      	cmp	r3, #0
   81342:	bf14      	ite	ne
   81344:	2301      	movne	r3, #1
   81346:	2300      	moveq	r3, #0
   81348:	b2db      	uxtb	r3, r3
   8134a:	2b00      	cmp	r3, #0
   8134c:	d010      	beq.n	81370 <_ZL7USB_ISRv+0x90>
	{
		udd_ack_out_received(CDC_RX);
   8134e:	4b89      	ldr	r3, [pc, #548]	; (81574 <_ZL7USB_ISRv+0x294>)
   81350:	2202      	movs	r2, #2
   81352:	601a      	str	r2, [r3, #0]

		// Handle received bytes
		if (USBD_Available(CDC_RX))
   81354:	2002      	movs	r0, #2
   81356:	4b88      	ldr	r3, [pc, #544]	; (81578 <_ZL7USB_ISRv+0x298>)
   81358:	4798      	blx	r3
   8135a:	4603      	mov	r3, r0
   8135c:	2b00      	cmp	r3, #0
   8135e:	bf14      	ite	ne
   81360:	2301      	movne	r3, #1
   81362:	2300      	moveq	r3, #0
   81364:	b2db      	uxtb	r3, r3
   81366:	2b00      	cmp	r3, #0
   81368:	d002      	beq.n	81370 <_ZL7USB_ISRv+0x90>
			SerialUSB.accept();
   8136a:	4884      	ldr	r0, [pc, #528]	; (8157c <_ZL7USB_ISRv+0x29c>)
   8136c:	4b84      	ldr	r3, [pc, #528]	; (81580 <_ZL7USB_ISRv+0x2a0>)
   8136e:	4798      	blx	r3
	}

	if (Is_udd_sof())
   81370:	4b7c      	ldr	r3, [pc, #496]	; (81564 <_ZL7USB_ISRv+0x284>)
   81372:	685b      	ldr	r3, [r3, #4]
   81374:	f003 0304 	and.w	r3, r3, #4
   81378:	2b00      	cmp	r3, #0
   8137a:	bf14      	ite	ne
   8137c:	2301      	movne	r3, #1
   8137e:	2300      	moveq	r3, #0
   81380:	b2db      	uxtb	r3, r3
   81382:	2b00      	cmp	r3, #0
   81384:	d002      	beq.n	8138c <_ZL7USB_ISRv+0xac>
	{
		udd_ack_sof();
   81386:	4b77      	ldr	r3, [pc, #476]	; (81564 <_ZL7USB_ISRv+0x284>)
   81388:	2204      	movs	r2, #4
   8138a:	609a      	str	r2, [r3, #8]
	//	USBD_Flush(CDC_TX); // jcb
	}
#endif

	// EP 0 Interrupt
	if (Is_udd_endpoint_interrupt(0) )
   8138c:	4b75      	ldr	r3, [pc, #468]	; (81564 <_ZL7USB_ISRv+0x284>)
   8138e:	685b      	ldr	r3, [r3, #4]
   81390:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
   81394:	2b00      	cmp	r3, #0
   81396:	bf14      	ite	ne
   81398:	2301      	movne	r3, #1
   8139a:	2300      	moveq	r3, #0
   8139c:	b2db      	uxtb	r3, r3
   8139e:	2b00      	cmp	r3, #0
   813a0:	f000 8144 	beq.w	8162c <_ZL7USB_ISRv+0x34c>
	{
		if (!UDD_ReceivedSetupInt())
   813a4:	4b77      	ldr	r3, [pc, #476]	; (81584 <_ZL7USB_ISRv+0x2a4>)
   813a6:	4798      	blx	r3
   813a8:	4603      	mov	r3, r0
   813aa:	2b00      	cmp	r3, #0
   813ac:	bf0c      	ite	eq
   813ae:	2301      	moveq	r3, #1
   813b0:	2300      	movne	r3, #0
   813b2:	b2db      	uxtb	r3, r3
   813b4:	2b00      	cmp	r3, #0
   813b6:	f040 8138 	bne.w	8162a <_ZL7USB_ISRv+0x34a>
		{
			return;
		}

		USBSetup setup;
		UDD_Recv(EP0, (uint8_t*)&setup, 8);
   813ba:	1d3b      	adds	r3, r7, #4
   813bc:	2208      	movs	r2, #8
   813be:	4619      	mov	r1, r3
   813c0:	2000      	movs	r0, #0
   813c2:	4b71      	ldr	r3, [pc, #452]	; (81588 <_ZL7USB_ISRv+0x2a8>)
   813c4:	4798      	blx	r3
		UDD_ClearSetupInt();
   813c6:	4b71      	ldr	r3, [pc, #452]	; (8158c <_ZL7USB_ISRv+0x2ac>)
   813c8:	4798      	blx	r3

		uint8_t requestType = setup.bmRequestType;
   813ca:	793b      	ldrb	r3, [r7, #4]
   813cc:	73fb      	strb	r3, [r7, #15]
		if (requestType & REQUEST_DEVICETOHOST)
   813ce:	f997 300f 	ldrsb.w	r3, [r7, #15]
   813d2:	2b00      	cmp	r3, #0
   813d4:	da02      	bge.n	813dc <_ZL7USB_ISRv+0xfc>
		{
			TRACE_CORE(puts(">>> EP0 Int: IN Request\r\n");)
			UDD_WaitIN();
   813d6:	4b6e      	ldr	r3, [pc, #440]	; (81590 <_ZL7USB_ISRv+0x2b0>)
   813d8:	4798      	blx	r3
   813da:	e001      	b.n	813e0 <_ZL7USB_ISRv+0x100>
		}
		else
		{
			TRACE_CORE(puts(">>> EP0 Int: OUT Request\r\n");)
			UDD_ClearIN();
   813dc:	4b6d      	ldr	r3, [pc, #436]	; (81594 <_ZL7USB_ISRv+0x2b4>)
   813de:	4798      	blx	r3
		}

		bool ok = true;
   813e0:	2301      	movs	r3, #1
   813e2:	75fb      	strb	r3, [r7, #23]
		if (REQUEST_STANDARD == (requestType & REQUEST_TYPE))
   813e4:	7bfb      	ldrb	r3, [r7, #15]
   813e6:	f003 0360 	and.w	r3, r3, #96	; 0x60
   813ea:	2b00      	cmp	r3, #0
   813ec:	f040 8108 	bne.w	81600 <_ZL7USB_ISRv+0x320>
		{
			// Standard Requests
			uint8_t r = setup.bRequest;
   813f0:	797b      	ldrb	r3, [r7, #5]
   813f2:	73bb      	strb	r3, [r7, #14]
			if (GET_STATUS == r)
   813f4:	7bbb      	ldrb	r3, [r7, #14]
   813f6:	2b00      	cmp	r3, #0
   813f8:	d11d      	bne.n	81436 <_ZL7USB_ISRv+0x156>
			{
                if( setup.bmRequestType == 0 )  // device
   813fa:	793b      	ldrb	r3, [r7, #4]
   813fc:	2b00      	cmp	r3, #0
   813fe:	d108      	bne.n	81412 <_ZL7USB_ISRv+0x132>
     				TRACE_CORE(puts(">>> EP0 Int: GET_STATUS\r\n");)
                    // Check current configuration for power mode (if device is configured)
                    // TODO
                    // Check if remote wake-up is enabled
                    // TODO
                    UDD_Send8(EP0, 0); // TODO
   81400:	2100      	movs	r1, #0
   81402:	2000      	movs	r0, #0
   81404:	4b64      	ldr	r3, [pc, #400]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   81406:	4798      	blx	r3
	    			UDD_Send8(EP0, 0);
   81408:	2100      	movs	r1, #0
   8140a:	2000      	movs	r0, #0
   8140c:	4b62      	ldr	r3, [pc, #392]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   8140e:	4798      	blx	r3
   81410:	e102      	b.n	81618 <_ZL7USB_ISRv+0x338>
                // if( setup.bmRequestType == 2 ) // Endpoint:
                else
                {
                    // Send the endpoint status
                    // Check if the endpoint if currently halted
                    if( isEndpointHalt == 1 )
   81412:	4b62      	ldr	r3, [pc, #392]	; (8159c <_ZL7USB_ISRv+0x2bc>)
   81414:	781b      	ldrb	r3, [r3, #0]
   81416:	2b01      	cmp	r3, #1
   81418:	d104      	bne.n	81424 <_ZL7USB_ISRv+0x144>
    				UDD_Send8(EP0, 1); // TODO
   8141a:	2101      	movs	r1, #1
   8141c:	2000      	movs	r0, #0
   8141e:	4b5e      	ldr	r3, [pc, #376]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   81420:	4798      	blx	r3
   81422:	e003      	b.n	8142c <_ZL7USB_ISRv+0x14c>
                    else
    				UDD_Send8(EP0, 0); // TODO
   81424:	2100      	movs	r1, #0
   81426:	2000      	movs	r0, #0
   81428:	4b5b      	ldr	r3, [pc, #364]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   8142a:	4798      	blx	r3
	    			UDD_Send8(EP0, 0);
   8142c:	2100      	movs	r1, #0
   8142e:	2000      	movs	r0, #0
   81430:	4b59      	ldr	r3, [pc, #356]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   81432:	4798      	blx	r3
   81434:	e0f0      	b.n	81618 <_ZL7USB_ISRv+0x338>
                }
			}
			else if (CLEAR_FEATURE == r)
   81436:	7bbb      	ldrb	r3, [r7, #14]
   81438:	2b01      	cmp	r3, #1
   8143a:	d120      	bne.n	8147e <_ZL7USB_ISRv+0x19e>
			{
               // Check which is the selected feature
                if( setup.wValueL == 1) // DEVICEREMOTEWAKEUP
   8143c:	79bb      	ldrb	r3, [r7, #6]
   8143e:	2b01      	cmp	r3, #1
   81440:	d111      	bne.n	81466 <_ZL7USB_ISRv+0x186>
                {
                    // Enable remote wake-up and send a ZLP
                    if( isRemoteWakeUpEnabled == 1 )
   81442:	4b57      	ldr	r3, [pc, #348]	; (815a0 <_ZL7USB_ISRv+0x2c0>)
   81444:	781b      	ldrb	r3, [r3, #0]
   81446:	2b01      	cmp	r3, #1
   81448:	d104      	bne.n	81454 <_ZL7USB_ISRv+0x174>
	    			UDD_Send8(EP0, 1);
   8144a:	2101      	movs	r1, #1
   8144c:	2000      	movs	r0, #0
   8144e:	4b52      	ldr	r3, [pc, #328]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   81450:	4798      	blx	r3
   81452:	e003      	b.n	8145c <_ZL7USB_ISRv+0x17c>
                    else
	    			UDD_Send8(EP0, 0);
   81454:	2100      	movs	r1, #0
   81456:	2000      	movs	r0, #0
   81458:	4b4f      	ldr	r3, [pc, #316]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   8145a:	4798      	blx	r3
                    UDD_Send8(EP0, 0);
   8145c:	2100      	movs	r1, #0
   8145e:	2000      	movs	r0, #0
   81460:	4b4d      	ldr	r3, [pc, #308]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   81462:	4798      	blx	r3
   81464:	e0d8      	b.n	81618 <_ZL7USB_ISRv+0x338>
                }
                else // if( setup.wValueL == 0) // ENDPOINTHALT
                {
                    isEndpointHalt = 0;  // TODO
   81466:	4b4d      	ldr	r3, [pc, #308]	; (8159c <_ZL7USB_ISRv+0x2bc>)
   81468:	2200      	movs	r2, #0
   8146a:	701a      	strb	r2, [r3, #0]
    				UDD_Send8(EP0, 0);
   8146c:	2100      	movs	r1, #0
   8146e:	2000      	movs	r0, #0
   81470:	4b49      	ldr	r3, [pc, #292]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   81472:	4798      	blx	r3
	    			UDD_Send8(EP0, 0);
   81474:	2100      	movs	r1, #0
   81476:	2000      	movs	r0, #0
   81478:	4b47      	ldr	r3, [pc, #284]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   8147a:	4798      	blx	r3
   8147c:	e0cc      	b.n	81618 <_ZL7USB_ISRv+0x338>
                }

 			}
			else if (SET_FEATURE == r)
   8147e:	7bbb      	ldrb	r3, [r7, #14]
   81480:	2b03      	cmp	r3, #3
   81482:	d135      	bne.n	814f0 <_ZL7USB_ISRv+0x210>
			{
                // Check which is the selected feature
                if( setup.wValueL == 1) // DEVICEREMOTEWAKEUP
   81484:	79bb      	ldrb	r3, [r7, #6]
   81486:	2b01      	cmp	r3, #1
   81488:	d106      	bne.n	81498 <_ZL7USB_ISRv+0x1b8>
                {
                    // Enable remote wake-up and send a ZLP
                    isRemoteWakeUpEnabled = 1;
   8148a:	4b45      	ldr	r3, [pc, #276]	; (815a0 <_ZL7USB_ISRv+0x2c0>)
   8148c:	2201      	movs	r2, #1
   8148e:	701a      	strb	r2, [r3, #0]
	    			UDD_Send8(EP0, 0);
   81490:	2100      	movs	r1, #0
   81492:	2000      	movs	r0, #0
   81494:	4b40      	ldr	r3, [pc, #256]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   81496:	4798      	blx	r3
                }
                if( setup.wValueL == 0) // ENDPOINTHALT
   81498:	79bb      	ldrb	r3, [r7, #6]
   8149a:	2b00      	cmp	r3, #0
   8149c:	d106      	bne.n	814ac <_ZL7USB_ISRv+0x1cc>
                {
                    // Halt endpoint
                    isEndpointHalt = 1;
   8149e:	4b3f      	ldr	r3, [pc, #252]	; (8159c <_ZL7USB_ISRv+0x2bc>)
   814a0:	2201      	movs	r2, #1
   814a2:	701a      	strb	r2, [r3, #0]
                    //USBD_Halt(USBGenericRequest_GetEndpointNumber(pRequest));
	    			UDD_Send8(EP0, 0);
   814a4:	2100      	movs	r1, #0
   814a6:	2000      	movs	r0, #0
   814a8:	4b3b      	ldr	r3, [pc, #236]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   814aa:	4798      	blx	r3
                }
                if( setup.wValueL == 2) // TEST_MODE
   814ac:	79bb      	ldrb	r3, [r7, #6]
   814ae:	2b02      	cmp	r3, #2
   814b0:	f040 80b2 	bne.w	81618 <_ZL7USB_ISRv+0x338>
                {
                    // 7.1.20 Test Mode Support, 9.4.9 SetFeature
                    if( (setup.bmRequestType == 0 /*USBGenericRequest_DEVICE*/) &&
   814b4:	793b      	ldrb	r3, [r7, #4]
   814b6:	2b00      	cmp	r3, #0
   814b8:	f040 80ae 	bne.w	81618 <_ZL7USB_ISRv+0x338>
                        ((setup.wIndex & 0x000F) == 0) )
   814bc:	893b      	ldrh	r3, [r7, #8]
   814be:	f003 030f 	and.w	r3, r3, #15
	    			UDD_Send8(EP0, 0);
                }
                if( setup.wValueL == 2) // TEST_MODE
                {
                    // 7.1.20 Test Mode Support, 9.4.9 SetFeature
                    if( (setup.bmRequestType == 0 /*USBGenericRequest_DEVICE*/) &&
   814c2:	2b00      	cmp	r3, #0
   814c4:	f040 80a8 	bne.w	81618 <_ZL7USB_ISRv+0x338>
                        ((setup.wIndex & 0x000F) == 0) )
                    {
                        // the lower byte of wIndex must be zero
                        // the most significant byte of wIndex is used to specify the specific test mode

                        UOTGHS->UOTGHS_DEVIDR &= ~UOTGHS_DEVIDR_SUSPEC;
   814c8:	4a26      	ldr	r2, [pc, #152]	; (81564 <_ZL7USB_ISRv+0x284>)
   814ca:	4b26      	ldr	r3, [pc, #152]	; (81564 <_ZL7USB_ISRv+0x284>)
   814cc:	695b      	ldr	r3, [r3, #20]
   814ce:	f023 0301 	bic.w	r3, r3, #1
   814d2:	6153      	str	r3, [r2, #20]
                        UOTGHS->UOTGHS_DEVCTRL |= UOTGHS_DEVCTRL_SPDCONF_HIGH_SPEED; // remove suspend ?
   814d4:	4a23      	ldr	r2, [pc, #140]	; (81564 <_ZL7USB_ISRv+0x284>)
   814d6:	4b23      	ldr	r3, [pc, #140]	; (81564 <_ZL7USB_ISRv+0x284>)
   814d8:	681b      	ldr	r3, [r3, #0]
   814da:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   814de:	6013      	str	r3, [r2, #0]

                        Test_Mode_Support( (setup.wIndex & 0xFF00)>>8 );
   814e0:	893b      	ldrh	r3, [r7, #8]
   814e2:	0a1b      	lsrs	r3, r3, #8
   814e4:	b29b      	uxth	r3, r3
   814e6:	b2db      	uxtb	r3, r3
   814e8:	4618      	mov	r0, r3
   814ea:	4b2e      	ldr	r3, [pc, #184]	; (815a4 <_ZL7USB_ISRv+0x2c4>)
   814ec:	4798      	blx	r3
   814ee:	e093      	b.n	81618 <_ZL7USB_ISRv+0x338>
                    }
                }
			}
			else if (SET_ADDRESS == r)
   814f0:	7bbb      	ldrb	r3, [r7, #14]
   814f2:	2b05      	cmp	r3, #5
   814f4:	d106      	bne.n	81504 <_ZL7USB_ISRv+0x224>
			{
				TRACE_CORE(puts(">>> EP0 Int: SET_ADDRESS\r\n");)
				UDD_WaitIN();
   814f6:	4b26      	ldr	r3, [pc, #152]	; (81590 <_ZL7USB_ISRv+0x2b0>)
   814f8:	4798      	blx	r3
				UDD_SetAddress(setup.wValueL);
   814fa:	79bb      	ldrb	r3, [r7, #6]
   814fc:	4618      	mov	r0, r3
   814fe:	4b2a      	ldr	r3, [pc, #168]	; (815a8 <_ZL7USB_ISRv+0x2c8>)
   81500:	4798      	blx	r3
   81502:	e089      	b.n	81618 <_ZL7USB_ISRv+0x338>
			}
			else if (GET_DESCRIPTOR == r)
   81504:	7bbb      	ldrb	r3, [r7, #14]
   81506:	2b06      	cmp	r3, #6
   81508:	d106      	bne.n	81518 <_ZL7USB_ISRv+0x238>
			{
				TRACE_CORE(puts(">>> EP0 Int: GET_DESCRIPTOR\r\n");)
				ok = USBD_SendDescriptor(setup);
   8150a:	1d3b      	adds	r3, r7, #4
   8150c:	4618      	mov	r0, r3
   8150e:	4b27      	ldr	r3, [pc, #156]	; (815ac <_ZL7USB_ISRv+0x2cc>)
   81510:	4798      	blx	r3
   81512:	4603      	mov	r3, r0
   81514:	75fb      	strb	r3, [r7, #23]
   81516:	e07f      	b.n	81618 <_ZL7USB_ISRv+0x338>
			}
			else if (SET_DESCRIPTOR == r)
   81518:	7bbb      	ldrb	r3, [r7, #14]
   8151a:	2b07      	cmp	r3, #7
   8151c:	d102      	bne.n	81524 <_ZL7USB_ISRv+0x244>
			{
				TRACE_CORE(puts(">>> EP0 Int: SET_DESCRIPTOR\r\n");)
				ok = false;
   8151e:	2300      	movs	r3, #0
   81520:	75fb      	strb	r3, [r7, #23]
   81522:	e079      	b.n	81618 <_ZL7USB_ISRv+0x338>
			}
			else if (GET_CONFIGURATION == r)
   81524:	7bbb      	ldrb	r3, [r7, #14]
   81526:	2b08      	cmp	r3, #8
   81528:	d107      	bne.n	8153a <_ZL7USB_ISRv+0x25a>
			{
				TRACE_CORE(puts(">>> EP0 Int: GET_CONFIGURATION\r\n");)
				UDD_Send8(EP0, _usbConfiguration);
   8152a:	4b11      	ldr	r3, [pc, #68]	; (81570 <_ZL7USB_ISRv+0x290>)
   8152c:	681b      	ldr	r3, [r3, #0]
   8152e:	b2db      	uxtb	r3, r3
   81530:	4619      	mov	r1, r3
   81532:	2000      	movs	r0, #0
   81534:	4b18      	ldr	r3, [pc, #96]	; (81598 <_ZL7USB_ISRv+0x2b8>)
   81536:	4798      	blx	r3
   81538:	e06e      	b.n	81618 <_ZL7USB_ISRv+0x338>
			}
			else if (SET_CONFIGURATION == r)
   8153a:	7bbb      	ldrb	r3, [r7, #14]
   8153c:	2b09      	cmp	r3, #9
   8153e:	d14c      	bne.n	815da <_ZL7USB_ISRv+0x2fa>
			{
				if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
   81540:	7bfb      	ldrb	r3, [r7, #15]
   81542:	f003 031f 	and.w	r3, r3, #31
   81546:	2b00      	cmp	r3, #0
   81548:	d144      	bne.n	815d4 <_ZL7USB_ISRv+0x2f4>
				{
					TRACE_CORE(printf(">>> EP0 Int: SET_CONFIGURATION REQUEST_DEVICE %d\r\n", setup.wValueL);)

					uint32_t num_endpoints = 0;
   8154a:	2300      	movs	r3, #0
   8154c:	613b      	str	r3, [r7, #16]
					while (EndPoints[num_endpoints] != 0) {
   8154e:	4a18      	ldr	r2, [pc, #96]	; (815b0 <_ZL7USB_ISRv+0x2d0>)
   81550:	693b      	ldr	r3, [r7, #16]
   81552:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   81556:	2b00      	cmp	r3, #0
   81558:	d02c      	beq.n	815b4 <_ZL7USB_ISRv+0x2d4>
						num_endpoints++;
   8155a:	693b      	ldr	r3, [r7, #16]
   8155c:	3301      	adds	r3, #1
   8155e:	613b      	str	r3, [r7, #16]
				if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
				{
					TRACE_CORE(printf(">>> EP0 Int: SET_CONFIGURATION REQUEST_DEVICE %d\r\n", setup.wValueL);)

					uint32_t num_endpoints = 0;
					while (EndPoints[num_endpoints] != 0) {
   81560:	e7f5      	b.n	8154e <_ZL7USB_ISRv+0x26e>
   81562:	bf00      	nop
   81564:	400ac000 	.word	0x400ac000
   81568:	00088525 	.word	0x00088525
   8156c:	400ac1f0 	.word	0x400ac1f0
   81570:	20070c60 	.word	0x20070c60
   81574:	400ac168 	.word	0x400ac168
   81578:	00080a69 	.word	0x00080a69
   8157c:	20071884 	.word	0x20071884
   81580:	00088b99 	.word	0x00088b99
   81584:	00088671 	.word	0x00088671
   81588:	00088829 	.word	0x00088829
   8158c:	0008868d 	.word	0x0008868d
   81590:	000885e9 	.word	0x000885e9
   81594:	00088629 	.word	0x00088629
   81598:	00088795 	.word	0x00088795
   8159c:	20070c5d 	.word	0x20070c5d
   815a0:	20070c5c 	.word	0x20070c5c
   815a4:	000811d5 	.word	0x000811d5
   815a8:	00088969 	.word	0x00088969
   815ac:	00080fad 	.word	0x00080fad
   815b0:	20070068 	.word	0x20070068
						num_endpoints++;
					}
					UDD_InitEndpoints(EndPoints, num_endpoints);
   815b4:	6939      	ldr	r1, [r7, #16]
   815b6:	481f      	ldr	r0, [pc, #124]	; (81634 <_ZL7USB_ISRv+0x354>)
   815b8:	4b1f      	ldr	r3, [pc, #124]	; (81638 <_ZL7USB_ISRv+0x358>)
   815ba:	4798      	blx	r3
					_usbConfiguration = setup.wValueL;
   815bc:	79bb      	ldrb	r3, [r7, #6]
   815be:	461a      	mov	r2, r3
   815c0:	4b1e      	ldr	r3, [pc, #120]	; (8163c <_ZL7USB_ISRv+0x35c>)
   815c2:	601a      	str	r2, [r3, #0]

#ifdef CDC_ENABLED
					// Enable interrupt for CDC reception from host (OUT packet)
					udd_enable_out_received_interrupt(CDC_RX);
   815c4:	4b1e      	ldr	r3, [pc, #120]	; (81640 <_ZL7USB_ISRv+0x360>)
   815c6:	2202      	movs	r2, #2
   815c8:	601a      	str	r2, [r3, #0]
					udd_enable_endpoint_interrupt(CDC_RX);
   815ca:	4b1e      	ldr	r3, [pc, #120]	; (81644 <_ZL7USB_ISRv+0x364>)
   815cc:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   815d0:	619a      	str	r2, [r3, #24]
   815d2:	e021      	b.n	81618 <_ZL7USB_ISRv+0x338>
#endif
				}
				else
				{
					TRACE_CORE(puts(">>> EP0 Int: SET_CONFIGURATION failed!\r\n");)
					ok = false;
   815d4:	2300      	movs	r3, #0
   815d6:	75fb      	strb	r3, [r7, #23]
   815d8:	e01e      	b.n	81618 <_ZL7USB_ISRv+0x338>
				}
			}
			else if (GET_INTERFACE == r)
   815da:	7bbb      	ldrb	r3, [r7, #14]
   815dc:	2b0a      	cmp	r3, #10
   815de:	d107      	bne.n	815f0 <_ZL7USB_ISRv+0x310>
			{
				TRACE_CORE(puts(">>> EP0 Int: GET_INTERFACE\r\n");)
				UDD_Send8(EP0, _usbSetInterface);
   815e0:	4b19      	ldr	r3, [pc, #100]	; (81648 <_ZL7USB_ISRv+0x368>)
   815e2:	681b      	ldr	r3, [r3, #0]
   815e4:	b2db      	uxtb	r3, r3
   815e6:	4619      	mov	r1, r3
   815e8:	2000      	movs	r0, #0
   815ea:	4b18      	ldr	r3, [pc, #96]	; (8164c <_ZL7USB_ISRv+0x36c>)
   815ec:	4798      	blx	r3
   815ee:	e013      	b.n	81618 <_ZL7USB_ISRv+0x338>
			}
			else if (SET_INTERFACE == r)
   815f0:	7bbb      	ldrb	r3, [r7, #14]
   815f2:	2b0b      	cmp	r3, #11
   815f4:	d110      	bne.n	81618 <_ZL7USB_ISRv+0x338>
			{
                _usbSetInterface = setup.wValueL;
   815f6:	79bb      	ldrb	r3, [r7, #6]
   815f8:	461a      	mov	r2, r3
   815fa:	4b13      	ldr	r3, [pc, #76]	; (81648 <_ZL7USB_ISRv+0x368>)
   815fc:	601a      	str	r2, [r3, #0]
   815fe:	e00b      	b.n	81618 <_ZL7USB_ISRv+0x338>
		}
		else
		{
			TRACE_CORE(puts(">>> EP0 Int: ClassInterfaceRequest\r\n");)

			UDD_WaitIN(); // Workaround: need tempo here, else CDC serial won't open correctly
   81600:	4b13      	ldr	r3, [pc, #76]	; (81650 <_ZL7USB_ISRv+0x370>)
   81602:	4798      	blx	r3

			USBD_InitControl(setup.wLength); // Max length of transfer
   81604:	897b      	ldrh	r3, [r7, #10]
   81606:	4618      	mov	r0, r3
   81608:	4b12      	ldr	r3, [pc, #72]	; (81654 <_ZL7USB_ISRv+0x374>)
   8160a:	4798      	blx	r3
			ok = USBD_ClassInterfaceRequest(setup);
   8160c:	1d3b      	adds	r3, r7, #4
   8160e:	4618      	mov	r0, r3
   81610:	4b11      	ldr	r3, [pc, #68]	; (81658 <_ZL7USB_ISRv+0x378>)
   81612:	4798      	blx	r3
   81614:	4603      	mov	r3, r0
   81616:	75fb      	strb	r3, [r7, #23]
		}

		if (ok)
   81618:	7dfb      	ldrb	r3, [r7, #23]
   8161a:	2b00      	cmp	r3, #0
   8161c:	d002      	beq.n	81624 <_ZL7USB_ISRv+0x344>
		{
			TRACE_CORE(puts(">>> EP0 Int: Send packet\r\n");)
			UDD_ClearIN();
   8161e:	4b0f      	ldr	r3, [pc, #60]	; (8165c <_ZL7USB_ISRv+0x37c>)
   81620:	4798      	blx	r3
   81622:	e003      	b.n	8162c <_ZL7USB_ISRv+0x34c>
		}
		else
		{
			TRACE_CORE(puts(">>> EP0 Int: Stall\r\n");)
			UDD_Stall();
   81624:	4b0e      	ldr	r3, [pc, #56]	; (81660 <_ZL7USB_ISRv+0x380>)
   81626:	4798      	blx	r3
   81628:	e000      	b.n	8162c <_ZL7USB_ISRv+0x34c>
	// EP 0 Interrupt
	if (Is_udd_endpoint_interrupt(0) )
	{
		if (!UDD_ReceivedSetupInt())
		{
			return;
   8162a:	bf00      	nop
		{
			TRACE_CORE(puts(">>> EP0 Int: Stall\r\n");)
			UDD_Stall();
		}
	}
}
   8162c:	3718      	adds	r7, #24
   8162e:	46bd      	mov	sp, r7
   81630:	bd80      	pop	{r7, pc}
   81632:	bf00      	nop
   81634:	20070068 	.word	0x20070068
   81638:	0008857d 	.word	0x0008857d
   8163c:	20070c60 	.word	0x20070c60
   81640:	400ac1f8 	.word	0x400ac1f8
   81644:	400ac000 	.word	0x400ac000
   81648:	20070c68 	.word	0x20070c68
   8164c:	00088795 	.word	0x00088795
   81650:	000885e9 	.word	0x000885e9
   81654:	00080c51 	.word	0x00080c51
   81658:	00080e09 	.word	0x00080e09
   8165c:	00088629 	.word	0x00088629
   81660:	0008889d 	.word	0x0008889d

00081664 <_Z10USBD_Flushm>:

void USBD_Flush(uint32_t ep)
{
   81664:	b580      	push	{r7, lr}
   81666:	b082      	sub	sp, #8
   81668:	af00      	add	r7, sp, #0
   8166a:	6078      	str	r0, [r7, #4]
	if (UDD_FifoByteCount(ep))
   8166c:	6878      	ldr	r0, [r7, #4]
   8166e:	4b08      	ldr	r3, [pc, #32]	; (81690 <_Z10USBD_Flushm+0x2c>)
   81670:	4798      	blx	r3
   81672:	4603      	mov	r3, r0
   81674:	2b00      	cmp	r3, #0
   81676:	bf14      	ite	ne
   81678:	2301      	movne	r3, #1
   8167a:	2300      	moveq	r3, #0
   8167c:	b2db      	uxtb	r3, r3
   8167e:	2b00      	cmp	r3, #0
   81680:	d002      	beq.n	81688 <_Z10USBD_Flushm+0x24>
		UDD_ReleaseTX(ep);
   81682:	6878      	ldr	r0, [r7, #4]
   81684:	4b03      	ldr	r3, [pc, #12]	; (81694 <_Z10USBD_Flushm+0x30>)
   81686:	4798      	blx	r3
}
   81688:	bf00      	nop
   8168a:	3708      	adds	r7, #8
   8168c:	46bd      	mov	sp, r7
   8168e:	bd80      	pop	{r7, pc}
   81690:	000888bd 	.word	0x000888bd
   81694:	00088929 	.word	0x00088929

00081698 <_ZN10USBDevice_C1Ev>:
//=======================================================================
//=======================================================================

USBDevice_ USBDevice;

USBDevice_::USBDevice_()
   81698:	b580      	push	{r7, lr}
   8169a:	b082      	sub	sp, #8
   8169c:	af00      	add	r7, sp, #0
   8169e:	6078      	str	r0, [r7, #4]
{
	UDD_SetStack(&USB_ISR);
   816a0:	480a      	ldr	r0, [pc, #40]	; (816cc <_ZN10USBDevice_C1Ev+0x34>)
   816a2:	4b0b      	ldr	r3, [pc, #44]	; (816d0 <_ZN10USBDevice_C1Ev+0x38>)
   816a4:	4798      	blx	r3

	if (UDD_Init() == 0UL)
   816a6:	4b0b      	ldr	r3, [pc, #44]	; (816d4 <_ZN10USBDevice_C1Ev+0x3c>)
   816a8:	4798      	blx	r3
   816aa:	4603      	mov	r3, r0
   816ac:	2b00      	cmp	r3, #0
   816ae:	bf0c      	ite	eq
   816b0:	2301      	moveq	r3, #1
   816b2:	2300      	movne	r3, #0
   816b4:	b2db      	uxtb	r3, r3
   816b6:	2b00      	cmp	r3, #0
   816b8:	d002      	beq.n	816c0 <_ZN10USBDevice_C1Ev+0x28>
	{
		_usbInitialized=1UL;
   816ba:	4b07      	ldr	r3, [pc, #28]	; (816d8 <_ZN10USBDevice_C1Ev+0x40>)
   816bc:	2201      	movs	r2, #1
   816be:	601a      	str	r2, [r3, #0]
	}
}
   816c0:	687b      	ldr	r3, [r7, #4]
   816c2:	4618      	mov	r0, r3
   816c4:	3708      	adds	r7, #8
   816c6:	46bd      	mov	sp, r7
   816c8:	bd80      	pop	{r7, pc}
   816ca:	bf00      	nop
   816cc:	000812e1 	.word	0x000812e1
   816d0:	0008839d 	.word	0x0008839d
   816d4:	000883b9 	.word	0x000883b9
   816d8:	20070c64 	.word	0x20070c64

000816dc <_ZN10USBDevice_6attachEv>:

bool USBDevice_::attach(void)
{
   816dc:	b580      	push	{r7, lr}
   816de:	b082      	sub	sp, #8
   816e0:	af00      	add	r7, sp, #0
   816e2:	6078      	str	r0, [r7, #4]
  if (_usbInitialized != 0UL)
   816e4:	4b0a      	ldr	r3, [pc, #40]	; (81710 <_ZN10USBDevice_6attachEv+0x34>)
   816e6:	681b      	ldr	r3, [r3, #0]
   816e8:	2b00      	cmp	r3, #0
   816ea:	bf14      	ite	ne
   816ec:	2301      	movne	r3, #1
   816ee:	2300      	moveq	r3, #0
   816f0:	b2db      	uxtb	r3, r3
   816f2:	2b00      	cmp	r3, #0
   816f4:	d006      	beq.n	81704 <_ZN10USBDevice_6attachEv+0x28>
  {
    UDD_Attach();
   816f6:	4b07      	ldr	r3, [pc, #28]	; (81714 <_ZN10USBDevice_6attachEv+0x38>)
   816f8:	4798      	blx	r3
	_usbConfiguration = 0;
   816fa:	4b07      	ldr	r3, [pc, #28]	; (81718 <_ZN10USBDevice_6attachEv+0x3c>)
   816fc:	2200      	movs	r2, #0
   816fe:	601a      	str	r2, [r3, #0]
	return true;
   81700:	2301      	movs	r3, #1
   81702:	e000      	b.n	81706 <_ZN10USBDevice_6attachEv+0x2a>
  }
  else
  {
    return false;
   81704:	2300      	movs	r3, #0
  }
}
   81706:	4618      	mov	r0, r3
   81708:	3708      	adds	r7, #8
   8170a:	46bd      	mov	sp, r7
   8170c:	bd80      	pop	{r7, pc}
   8170e:	bf00      	nop
   81710:	20070c64 	.word	0x20070c64
   81714:	000884cd 	.word	0x000884cd
   81718:	20070c60 	.word	0x20070c60

0008171c <_Z41__static_initialization_and_destruction_0ii>:
	return _usbConfiguration;
}

void USBDevice_::poll()
{
}
   8171c:	b580      	push	{r7, lr}
   8171e:	b082      	sub	sp, #8
   81720:	af00      	add	r7, sp, #0
   81722:	6078      	str	r0, [r7, #4]
   81724:	6039      	str	r1, [r7, #0]
   81726:	687b      	ldr	r3, [r7, #4]
   81728:	2b01      	cmp	r3, #1
   8172a:	d107      	bne.n	8173c <_Z41__static_initialization_and_destruction_0ii+0x20>
   8172c:	683b      	ldr	r3, [r7, #0]
   8172e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   81732:	4293      	cmp	r3, r2
   81734:	d102      	bne.n	8173c <_Z41__static_initialization_and_destruction_0ii+0x20>


//=======================================================================
//=======================================================================

USBDevice_ USBDevice;
   81736:	4803      	ldr	r0, [pc, #12]	; (81744 <_Z41__static_initialization_and_destruction_0ii+0x28>)
   81738:	4b03      	ldr	r3, [pc, #12]	; (81748 <_Z41__static_initialization_and_destruction_0ii+0x2c>)
   8173a:	4798      	blx	r3
	return _usbConfiguration;
}

void USBDevice_::poll()
{
}
   8173c:	bf00      	nop
   8173e:	3708      	adds	r7, #8
   81740:	46bd      	mov	sp, r7
   81742:	bd80      	pop	{r7, pc}
   81744:	20070c74 	.word	0x20070c74
   81748:	00081699 	.word	0x00081699

0008174c <_GLOBAL__sub_I_EndPoints>:
   8174c:	b580      	push	{r7, lr}
   8174e:	af00      	add	r7, sp, #0
   81750:	f64f 71ff 	movw	r1, #65535	; 0xffff
   81754:	2001      	movs	r0, #1
   81756:	4b01      	ldr	r3, [pc, #4]	; (8175c <_GLOBAL__sub_I_EndPoints+0x10>)
   81758:	4798      	blx	r3
   8175a:	bd80      	pop	{r7, pc}
   8175c:	0008171d 	.word	0x0008171d

00081760 <NVIC_SetPriority>:

    \param [in]      IRQn  Number of the interrupt for set priority
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   81760:	b480      	push	{r7}
   81762:	b083      	sub	sp, #12
   81764:	af00      	add	r7, sp, #0
   81766:	4603      	mov	r3, r0
   81768:	6039      	str	r1, [r7, #0]
   8176a:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
   8176c:	f997 3007 	ldrsb.w	r3, [r7, #7]
   81770:	2b00      	cmp	r3, #0
   81772:	da0b      	bge.n	8178c <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
   81774:	490d      	ldr	r1, [pc, #52]	; (817ac <NVIC_SetPriority+0x4c>)
   81776:	79fb      	ldrb	r3, [r7, #7]
   81778:	f003 030f 	and.w	r3, r3, #15
   8177c:	3b04      	subs	r3, #4
   8177e:	683a      	ldr	r2, [r7, #0]
   81780:	b2d2      	uxtb	r2, r2
   81782:	0112      	lsls	r2, r2, #4
   81784:	b2d2      	uxtb	r2, r2
   81786:	440b      	add	r3, r1
   81788:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
}
   8178a:	e009      	b.n	817a0 <NVIC_SetPriority+0x40>
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   8178c:	4908      	ldr	r1, [pc, #32]	; (817b0 <NVIC_SetPriority+0x50>)
   8178e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   81792:	683a      	ldr	r2, [r7, #0]
   81794:	b2d2      	uxtb	r2, r2
   81796:	0112      	lsls	r2, r2, #4
   81798:	b2d2      	uxtb	r2, r2
   8179a:	440b      	add	r3, r1
   8179c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   817a0:	bf00      	nop
   817a2:	370c      	adds	r7, #12
   817a4:	46bd      	mov	sp, r7
   817a6:	bc80      	pop	{r7}
   817a8:	4770      	bx	lr
   817aa:	bf00      	nop
   817ac:	e000ed00 	.word	0xe000ed00
   817b0:	e000e100 	.word	0xe000e100

000817b4 <SysTick_Config>:
    \param [in]  ticks  Number of ticks between two interrupts
    \return          0  Function succeeded
    \return          1  Function failed
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{
   817b4:	b580      	push	{r7, lr}
   817b6:	b082      	sub	sp, #8
   817b8:	af00      	add	r7, sp, #0
   817ba:	6078      	str	r0, [r7, #4]
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
   817bc:	687b      	ldr	r3, [r7, #4]
   817be:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
   817c2:	d301      	bcc.n	817c8 <SysTick_Config+0x14>
   817c4:	2301      	movs	r3, #1
   817c6:	e011      	b.n	817ec <SysTick_Config+0x38>

  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
   817c8:	4a0a      	ldr	r2, [pc, #40]	; (817f4 <SysTick_Config+0x40>)
   817ca:	687b      	ldr	r3, [r7, #4]
   817cc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   817d0:	3b01      	subs	r3, #1
   817d2:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
   817d4:	210f      	movs	r1, #15
   817d6:	f04f 30ff 	mov.w	r0, #4294967295
   817da:	4b07      	ldr	r3, [pc, #28]	; (817f8 <SysTick_Config+0x44>)
   817dc:	4798      	blx	r3
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
   817de:	4b05      	ldr	r3, [pc, #20]	; (817f4 <SysTick_Config+0x40>)
   817e0:	2200      	movs	r2, #0
   817e2:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
   817e4:	4b03      	ldr	r3, [pc, #12]	; (817f4 <SysTick_Config+0x40>)
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
   817e6:	2207      	movs	r2, #7
   817e8:	601a      	str	r2, [r3, #0]
  return (0);                                                  /* Function successful */
   817ea:	2300      	movs	r3, #0
}
   817ec:	4618      	mov	r0, r3
   817ee:	3708      	adds	r7, #8
   817f0:	46bd      	mov	sp, r7
   817f2:	bd80      	pop	{r7, pc}
   817f4:	e000e010 	.word	0xe000e010
   817f8:	00081761 	.word	0x00081761

000817fc <_Z11serialEventv>:
RingBuffer rx_buffer1;
RingBuffer tx_buffer1;

UARTClass Serial(UART, UART_IRQn, ID_UART, &rx_buffer1, &tx_buffer1);
void serialEvent() __attribute__((weak));
void serialEvent() { }
   817fc:	b480      	push	{r7}
   817fe:	af00      	add	r7, sp, #0
   81800:	bf00      	nop
   81802:	46bd      	mov	sp, r7
   81804:	bc80      	pop	{r7}
   81806:	4770      	bx	lr

00081808 <UART_Handler>:

// IT handlers
void UART_Handler(void)
{
   81808:	b580      	push	{r7, lr}
   8180a:	af00      	add	r7, sp, #0
  Serial.IrqHandler();
   8180c:	4802      	ldr	r0, [pc, #8]	; (81818 <UART_Handler+0x10>)
   8180e:	4b03      	ldr	r3, [pc, #12]	; (8181c <UART_Handler+0x14>)
   81810:	4798      	blx	r3
}
   81812:	bf00      	nop
   81814:	bd80      	pop	{r7, pc}
   81816:	bf00      	nop
   81818:	20070dd8 	.word	0x20070dd8
   8181c:	000808f1 	.word	0x000808f1

00081820 <_Z12serialEvent1v>:
RingBuffer tx_buffer3;
RingBuffer tx_buffer4;

USARTClass Serial1(USART0, USART0_IRQn, ID_USART0, &rx_buffer2, &tx_buffer2);
void serialEvent1() __attribute__((weak));
void serialEvent1() { }
   81820:	b480      	push	{r7}
   81822:	af00      	add	r7, sp, #0
   81824:	bf00      	nop
   81826:	46bd      	mov	sp, r7
   81828:	bc80      	pop	{r7}
   8182a:	4770      	bx	lr

0008182c <_Z12serialEvent2v>:
USARTClass Serial2(USART1, USART1_IRQn, ID_USART1, &rx_buffer3, &tx_buffer3);
void serialEvent2() __attribute__((weak));
void serialEvent2() { }
   8182c:	b480      	push	{r7}
   8182e:	af00      	add	r7, sp, #0
   81830:	bf00      	nop
   81832:	46bd      	mov	sp, r7
   81834:	bc80      	pop	{r7}
   81836:	4770      	bx	lr

00081838 <_Z12serialEvent3v>:
USARTClass Serial3(USART3, USART3_IRQn, ID_USART3, &rx_buffer4, &tx_buffer4);
void serialEvent3() __attribute__((weak));
void serialEvent3() { }
   81838:	b480      	push	{r7}
   8183a:	af00      	add	r7, sp, #0
   8183c:	bf00      	nop
   8183e:	46bd      	mov	sp, r7
   81840:	bc80      	pop	{r7}
   81842:	4770      	bx	lr

00081844 <USART0_Handler>:

// IT handlers
void USART0_Handler(void)
{
   81844:	b580      	push	{r7, lr}
   81846:	af00      	add	r7, sp, #0
  Serial1.IrqHandler();
   81848:	4802      	ldr	r0, [pc, #8]	; (81854 <USART0_Handler+0x10>)
   8184a:	4b03      	ldr	r3, [pc, #12]	; (81858 <USART0_Handler+0x14>)
   8184c:	4798      	blx	r3
}
   8184e:	bf00      	nop
   81850:	bd80      	pop	{r7, pc}
   81852:	bf00      	nop
   81854:	2007112c 	.word	0x2007112c
   81858:	000808f1 	.word	0x000808f1

0008185c <USART1_Handler>:

void USART1_Handler(void)
{
   8185c:	b580      	push	{r7, lr}
   8185e:	af00      	add	r7, sp, #0
  Serial2.IrqHandler();
   81860:	4802      	ldr	r0, [pc, #8]	; (8186c <USART1_Handler+0x10>)
   81862:	4b03      	ldr	r3, [pc, #12]	; (81870 <USART1_Handler+0x14>)
   81864:	4798      	blx	r3
}
   81866:	bf00      	nop
   81868:	bd80      	pop	{r7, pc}
   8186a:	bf00      	nop
   8186c:	20071154 	.word	0x20071154
   81870:	000808f1 	.word	0x000808f1

00081874 <USART3_Handler>:

void USART3_Handler(void)
{
   81874:	b580      	push	{r7, lr}
   81876:	af00      	add	r7, sp, #0
  Serial3.IrqHandler();
   81878:	4802      	ldr	r0, [pc, #8]	; (81884 <USART3_Handler+0x10>)
   8187a:	4b03      	ldr	r3, [pc, #12]	; (81888 <USART3_Handler+0x14>)
   8187c:	4798      	blx	r3
}
   8187e:	bf00      	nop
   81880:	bd80      	pop	{r7, pc}
   81882:	bf00      	nop
   81884:	2007117c 	.word	0x2007117c
   81888:	000808f1 	.word	0x000808f1

0008188c <_Z14serialEventRunv>:

// ----------------------------------------------------------------------------

void serialEventRun(void)
{
   8188c:	b580      	push	{r7, lr}
   8188e:	af00      	add	r7, sp, #0
  if (Serial.available()) serialEvent();
   81890:	481a      	ldr	r0, [pc, #104]	; (818fc <_Z14serialEventRunv+0x70>)
   81892:	4b1b      	ldr	r3, [pc, #108]	; (81900 <_Z14serialEventRunv+0x74>)
   81894:	4798      	blx	r3
   81896:	4603      	mov	r3, r0
   81898:	2b00      	cmp	r3, #0
   8189a:	bf14      	ite	ne
   8189c:	2301      	movne	r3, #1
   8189e:	2300      	moveq	r3, #0
   818a0:	b2db      	uxtb	r3, r3
   818a2:	2b00      	cmp	r3, #0
   818a4:	d001      	beq.n	818aa <_Z14serialEventRunv+0x1e>
   818a6:	4b17      	ldr	r3, [pc, #92]	; (81904 <_Z14serialEventRunv+0x78>)
   818a8:	4798      	blx	r3
  if (Serial1.available()) serialEvent1();
   818aa:	4817      	ldr	r0, [pc, #92]	; (81908 <_Z14serialEventRunv+0x7c>)
   818ac:	4b14      	ldr	r3, [pc, #80]	; (81900 <_Z14serialEventRunv+0x74>)
   818ae:	4798      	blx	r3
   818b0:	4603      	mov	r3, r0
   818b2:	2b00      	cmp	r3, #0
   818b4:	bf14      	ite	ne
   818b6:	2301      	movne	r3, #1
   818b8:	2300      	moveq	r3, #0
   818ba:	b2db      	uxtb	r3, r3
   818bc:	2b00      	cmp	r3, #0
   818be:	d001      	beq.n	818c4 <_Z14serialEventRunv+0x38>
   818c0:	4b12      	ldr	r3, [pc, #72]	; (8190c <_Z14serialEventRunv+0x80>)
   818c2:	4798      	blx	r3
  if (Serial2.available()) serialEvent2();
   818c4:	4812      	ldr	r0, [pc, #72]	; (81910 <_Z14serialEventRunv+0x84>)
   818c6:	4b0e      	ldr	r3, [pc, #56]	; (81900 <_Z14serialEventRunv+0x74>)
   818c8:	4798      	blx	r3
   818ca:	4603      	mov	r3, r0
   818cc:	2b00      	cmp	r3, #0
   818ce:	bf14      	ite	ne
   818d0:	2301      	movne	r3, #1
   818d2:	2300      	moveq	r3, #0
   818d4:	b2db      	uxtb	r3, r3
   818d6:	2b00      	cmp	r3, #0
   818d8:	d001      	beq.n	818de <_Z14serialEventRunv+0x52>
   818da:	4b0e      	ldr	r3, [pc, #56]	; (81914 <_Z14serialEventRunv+0x88>)
   818dc:	4798      	blx	r3
  if (Serial3.available()) serialEvent3();
   818de:	480e      	ldr	r0, [pc, #56]	; (81918 <_Z14serialEventRunv+0x8c>)
   818e0:	4b07      	ldr	r3, [pc, #28]	; (81900 <_Z14serialEventRunv+0x74>)
   818e2:	4798      	blx	r3
   818e4:	4603      	mov	r3, r0
   818e6:	2b00      	cmp	r3, #0
   818e8:	bf14      	ite	ne
   818ea:	2301      	movne	r3, #1
   818ec:	2300      	moveq	r3, #0
   818ee:	b2db      	uxtb	r3, r3
   818f0:	2b00      	cmp	r3, #0
   818f2:	d001      	beq.n	818f8 <_Z14serialEventRunv+0x6c>
   818f4:	4b09      	ldr	r3, [pc, #36]	; (8191c <_Z14serialEventRunv+0x90>)
   818f6:	4798      	blx	r3
}
   818f8:	bf00      	nop
   818fa:	bd80      	pop	{r7, pc}
   818fc:	20070dd8 	.word	0x20070dd8
   81900:	0008071d 	.word	0x0008071d
   81904:	000817fd 	.word	0x000817fd
   81908:	2007112c 	.word	0x2007112c
   8190c:	00081821 	.word	0x00081821
   81910:	20071154 	.word	0x20071154
   81914:	0008182d 	.word	0x0008182d
   81918:	2007117c 	.word	0x2007117c
   8191c:	00081839 	.word	0x00081839

00081920 <init>:
#endif

void __libc_init_array(void);

void init( void )
{
   81920:	b590      	push	{r4, r7, lr}
   81922:	b083      	sub	sp, #12
   81924:	af00      	add	r7, sp, #0
  SystemInit();
   81926:	4b47      	ldr	r3, [pc, #284]	; (81a44 <init+0x124>)
   81928:	4798      	blx	r3

  // Set Systick to 1ms interval, common to all SAM3 variants
  if (SysTick_Config(SystemCoreClock / 1000))
   8192a:	4b47      	ldr	r3, [pc, #284]	; (81a48 <init+0x128>)
   8192c:	681b      	ldr	r3, [r3, #0]
   8192e:	4a47      	ldr	r2, [pc, #284]	; (81a4c <init+0x12c>)
   81930:	fba2 2303 	umull	r2, r3, r2, r3
   81934:	099b      	lsrs	r3, r3, #6
   81936:	4618      	mov	r0, r3
   81938:	4b45      	ldr	r3, [pc, #276]	; (81a50 <init+0x130>)
   8193a:	4798      	blx	r3
   8193c:	4603      	mov	r3, r0
   8193e:	2b00      	cmp	r3, #0
   81940:	bf14      	ite	ne
   81942:	2301      	movne	r3, #1
   81944:	2300      	moveq	r3, #0
   81946:	b2db      	uxtb	r3, r3
   81948:	2b00      	cmp	r3, #0
   8194a:	d000      	beq.n	8194e <init+0x2e>
  {
    // Capture error
    while (true);
   8194c:	e7fe      	b.n	8194c <init+0x2c>
  }

  // Initialize C library
  __libc_init_array();
   8194e:	4b41      	ldr	r3, [pc, #260]	; (81a54 <init+0x134>)
   81950:	4798      	blx	r3

  // Disable pull-up on every pin
  for (unsigned i = 0; i < PINS_COUNT; i++)
   81952:	2300      	movs	r3, #0
   81954:	607b      	str	r3, [r7, #4]
   81956:	687b      	ldr	r3, [r7, #4]
   81958:	2b4e      	cmp	r3, #78	; 0x4e
   8195a:	d807      	bhi.n	8196c <init+0x4c>
	  digitalWrite(i, LOW);
   8195c:	2100      	movs	r1, #0
   8195e:	6878      	ldr	r0, [r7, #4]
   81960:	4b3d      	ldr	r3, [pc, #244]	; (81a58 <init+0x138>)
   81962:	4798      	blx	r3

  // Initialize C library
  __libc_init_array();

  // Disable pull-up on every pin
  for (unsigned i = 0; i < PINS_COUNT; i++)
   81964:	687b      	ldr	r3, [r7, #4]
   81966:	3301      	adds	r3, #1
   81968:	607b      	str	r3, [r7, #4]
   8196a:	e7f4      	b.n	81956 <init+0x36>
	  digitalWrite(i, LOW);

  // Enable parallel access on PIO output data registers
  PIOA->PIO_OWER = 0xFFFFFFFF;
   8196c:	4b3b      	ldr	r3, [pc, #236]	; (81a5c <init+0x13c>)
   8196e:	f04f 32ff 	mov.w	r2, #4294967295
   81972:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  PIOB->PIO_OWER = 0xFFFFFFFF;
   81976:	4b3a      	ldr	r3, [pc, #232]	; (81a60 <init+0x140>)
   81978:	f04f 32ff 	mov.w	r2, #4294967295
   8197c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  PIOC->PIO_OWER = 0xFFFFFFFF;
   81980:	4b38      	ldr	r3, [pc, #224]	; (81a64 <init+0x144>)
   81982:	f04f 32ff 	mov.w	r2, #4294967295
   81986:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  PIOD->PIO_OWER = 0xFFFFFFFF;
   8198a:	4b37      	ldr	r3, [pc, #220]	; (81a68 <init+0x148>)
   8198c:	f04f 32ff 	mov.w	r2, #4294967295
   81990:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0

  // Initialize Serial port U(S)ART pins
  PIO_Configure(
    g_APinDescription[PINS_UART].pPort,
   81994:	4831      	ldr	r0, [pc, #196]	; (81a5c <init+0x13c>)
    g_APinDescription[PINS_UART].ulPinType,
   81996:	2101      	movs	r1, #1
    g_APinDescription[PINS_UART].ulPin,
   81998:	f44f 7240 	mov.w	r2, #768	; 0x300
    g_APinDescription[PINS_UART].ulPinConfiguration);
   8199c:	2300      	movs	r3, #0
   8199e:	4c33      	ldr	r4, [pc, #204]	; (81a6c <init+0x14c>)
   819a0:	47a0      	blx	r4
  digitalWrite(0, HIGH); // Enable pullup for RX0
   819a2:	2101      	movs	r1, #1
   819a4:	2000      	movs	r0, #0
   819a6:	4b2c      	ldr	r3, [pc, #176]	; (81a58 <init+0x138>)
   819a8:	4798      	blx	r3
  PIO_Configure(
    g_APinDescription[PINS_USART0].pPort,
   819aa:	482c      	ldr	r0, [pc, #176]	; (81a5c <init+0x13c>)
    g_APinDescription[PINS_USART0].ulPinType,
   819ac:	2101      	movs	r1, #1
    g_APinDescription[PINS_USART0].ulPin,
   819ae:	f44f 6240 	mov.w	r2, #3072	; 0xc00
    g_APinDescription[PINS_USART0].ulPinConfiguration);
   819b2:	2300      	movs	r3, #0
   819b4:	4c2d      	ldr	r4, [pc, #180]	; (81a6c <init+0x14c>)
   819b6:	47a0      	blx	r4
  PIO_Configure(
    g_APinDescription[PINS_USART1].pPort,
   819b8:	4828      	ldr	r0, [pc, #160]	; (81a5c <init+0x13c>)
    g_APinDescription[PINS_USART1].ulPinType,
   819ba:	2101      	movs	r1, #1
    g_APinDescription[PINS_USART1].ulPin,
   819bc:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    g_APinDescription[PINS_USART1].ulPinConfiguration);
   819c0:	2300      	movs	r3, #0
   819c2:	4c2a      	ldr	r4, [pc, #168]	; (81a6c <init+0x14c>)
   819c4:	47a0      	blx	r4
  PIO_Configure(
    g_APinDescription[PINS_USART3].pPort,
   819c6:	4828      	ldr	r0, [pc, #160]	; (81a68 <init+0x148>)
    g_APinDescription[PINS_USART3].ulPinType,
   819c8:	2102      	movs	r1, #2
    g_APinDescription[PINS_USART3].ulPin,
   819ca:	2230      	movs	r2, #48	; 0x30
    g_APinDescription[PINS_USART3].ulPinConfiguration);
   819cc:	2300      	movs	r3, #0
   819ce:	4c27      	ldr	r4, [pc, #156]	; (81a6c <init+0x14c>)
   819d0:	47a0      	blx	r4

  // Initialize USB pins
  PIO_Configure(
    g_APinDescription[PINS_USB].pPort,
   819d2:	4823      	ldr	r0, [pc, #140]	; (81a60 <init+0x140>)
    g_APinDescription[PINS_USB].ulPinType,
   819d4:	2101      	movs	r1, #1
    g_APinDescription[PINS_USB].ulPin,
   819d6:	f44f 6240 	mov.w	r2, #3072	; 0xc00
    g_APinDescription[PINS_USB].ulPinConfiguration);
   819da:	2300      	movs	r3, #0
   819dc:	4c23      	ldr	r4, [pc, #140]	; (81a6c <init+0x14c>)
   819de:	47a0      	blx	r4

  // Initialize CAN pins
  PIO_Configure(
    g_APinDescription[PINS_CAN0].pPort,
   819e0:	481e      	ldr	r0, [pc, #120]	; (81a5c <init+0x13c>)
    g_APinDescription[PINS_CAN0].ulPinType,
   819e2:	2101      	movs	r1, #1
    g_APinDescription[PINS_CAN0].ulPin,
   819e4:	2203      	movs	r2, #3
    g_APinDescription[PINS_CAN0].ulPinConfiguration);
   819e6:	2300      	movs	r3, #0
   819e8:	4c20      	ldr	r4, [pc, #128]	; (81a6c <init+0x14c>)
   819ea:	47a0      	blx	r4
  PIO_Configure(
    g_APinDescription[PINS_CAN1].pPort,
   819ec:	481c      	ldr	r0, [pc, #112]	; (81a60 <init+0x140>)
    g_APinDescription[PINS_CAN1].ulPinType,
   819ee:	2101      	movs	r1, #1
    g_APinDescription[PINS_CAN1].ulPin,
   819f0:	f44f 4240 	mov.w	r2, #49152	; 0xc000
    g_APinDescription[PINS_CAN1].ulPinConfiguration);
   819f4:	2300      	movs	r3, #0
   819f6:	4c1d      	ldr	r4, [pc, #116]	; (81a6c <init+0x14c>)
   819f8:	47a0      	blx	r4

  // Initialize Analog Controller
  pmc_enable_periph_clk(ID_ADC);
   819fa:	2025      	movs	r0, #37	; 0x25
   819fc:	4b1c      	ldr	r3, [pc, #112]	; (81a70 <init+0x150>)
   819fe:	4798      	blx	r3
  adc_init(ADC, SystemCoreClock, ADC_FREQ_MAX, ADC_STARTUP_FAST);
   81a00:	4b11      	ldr	r3, [pc, #68]	; (81a48 <init+0x128>)
   81a02:	6819      	ldr	r1, [r3, #0]
   81a04:	230c      	movs	r3, #12
   81a06:	4a1b      	ldr	r2, [pc, #108]	; (81a74 <init+0x154>)
   81a08:	481b      	ldr	r0, [pc, #108]	; (81a78 <init+0x158>)
   81a0a:	4c1c      	ldr	r4, [pc, #112]	; (81a7c <init+0x15c>)
   81a0c:	47a0      	blx	r4
  adc_configure_timing(ADC, 0, ADC_SETTLING_TIME_3, 1);
   81a0e:	2301      	movs	r3, #1
   81a10:	f44f 1240 	mov.w	r2, #3145728	; 0x300000
   81a14:	2100      	movs	r1, #0
   81a16:	4818      	ldr	r0, [pc, #96]	; (81a78 <init+0x158>)
   81a18:	4c19      	ldr	r4, [pc, #100]	; (81a80 <init+0x160>)
   81a1a:	47a0      	blx	r4
  adc_configure_trigger(ADC, ADC_TRIG_SW, 0); // Disable hardware trigger.
   81a1c:	2200      	movs	r2, #0
   81a1e:	2100      	movs	r1, #0
   81a20:	4815      	ldr	r0, [pc, #84]	; (81a78 <init+0x158>)
   81a22:	4b18      	ldr	r3, [pc, #96]	; (81a84 <init+0x164>)
   81a24:	4798      	blx	r3
  adc_disable_interrupt(ADC, 0xFFFFFFFF); // Disable all ADC interrupts.
   81a26:	f04f 31ff 	mov.w	r1, #4294967295
   81a2a:	4813      	ldr	r0, [pc, #76]	; (81a78 <init+0x158>)
   81a2c:	4b16      	ldr	r3, [pc, #88]	; (81a88 <init+0x168>)
   81a2e:	4798      	blx	r3
  adc_disable_all_channel(ADC);
   81a30:	4811      	ldr	r0, [pc, #68]	; (81a78 <init+0x158>)
   81a32:	4b16      	ldr	r3, [pc, #88]	; (81a8c <init+0x16c>)
   81a34:	4798      	blx	r3

  // Initialize analogOutput module
  analogOutputInit();
   81a36:	4b16      	ldr	r3, [pc, #88]	; (81a90 <init+0x170>)
   81a38:	4798      	blx	r3
}
   81a3a:	bf00      	nop
   81a3c:	370c      	adds	r7, #12
   81a3e:	46bd      	mov	sp, r7
   81a40:	bd90      	pop	{r4, r7, pc}
   81a42:	bf00      	nop
   81a44:	000822ad 	.word	0x000822ad
   81a48:	20070090 	.word	0x20070090
   81a4c:	10624dd3 	.word	0x10624dd3
   81a50:	000817b5 	.word	0x000817b5
   81a54:	000934bd 	.word	0x000934bd
   81a58:	00081f29 	.word	0x00081f29
   81a5c:	400e0e00 	.word	0x400e0e00
   81a60:	400e1000 	.word	0x400e1000
   81a64:	400e1200 	.word	0x400e1200
   81a68:	400e1400 	.word	0x400e1400
   81a6c:	00087efd 	.word	0x00087efd
   81a70:	00088021 	.word	0x00088021
   81a74:	01312d00 	.word	0x01312d00
   81a78:	400c0000 	.word	0x400c0000
   81a7c:	00087b19 	.word	0x00087b19
   81a80:	00087c79 	.word	0x00087c79
   81a84:	00087c1d 	.word	0x00087c1d
   81a88:	00087cf9 	.word	0x00087cf9
   81a8c:	00087cdd 	.word	0x00087cdd
   81a90:	00081cb9 	.word	0x00081cb9

00081a94 <_Z41__static_initialization_and_destruction_0ii>:

#ifdef __cplusplus
}
   81a94:	b590      	push	{r4, r7, lr}
   81a96:	b085      	sub	sp, #20
   81a98:	af02      	add	r7, sp, #8
   81a9a:	6078      	str	r0, [r7, #4]
   81a9c:	6039      	str	r1, [r7, #0]
   81a9e:	687b      	ldr	r3, [r7, #4]
   81aa0:	2b01      	cmp	r3, #1
   81aa2:	d144      	bne.n	81b2e <_Z41__static_initialization_and_destruction_0ii+0x9a>
   81aa4:	683b      	ldr	r3, [r7, #0]
   81aa6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   81aaa:	4293      	cmp	r3, r2
   81aac:	d13f      	bne.n	81b2e <_Z41__static_initialization_and_destruction_0ii+0x9a>
#endif

/*
 * UART objects
 */
RingBuffer rx_buffer1;
   81aae:	4822      	ldr	r0, [pc, #136]	; (81b38 <_Z41__static_initialization_and_destruction_0ii+0xa4>)
   81ab0:	4b22      	ldr	r3, [pc, #136]	; (81b3c <_Z41__static_initialization_and_destruction_0ii+0xa8>)
   81ab2:	4798      	blx	r3
RingBuffer tx_buffer1;
   81ab4:	4822      	ldr	r0, [pc, #136]	; (81b40 <_Z41__static_initialization_and_destruction_0ii+0xac>)
   81ab6:	4b21      	ldr	r3, [pc, #132]	; (81b3c <_Z41__static_initialization_and_destruction_0ii+0xa8>)
   81ab8:	4798      	blx	r3

UARTClass Serial(UART, UART_IRQn, ID_UART, &rx_buffer1, &tx_buffer1);
   81aba:	4b21      	ldr	r3, [pc, #132]	; (81b40 <_Z41__static_initialization_and_destruction_0ii+0xac>)
   81abc:	9301      	str	r3, [sp, #4]
   81abe:	4b1e      	ldr	r3, [pc, #120]	; (81b38 <_Z41__static_initialization_and_destruction_0ii+0xa4>)
   81ac0:	9300      	str	r3, [sp, #0]
   81ac2:	2308      	movs	r3, #8
   81ac4:	2208      	movs	r2, #8
   81ac6:	491f      	ldr	r1, [pc, #124]	; (81b44 <_Z41__static_initialization_and_destruction_0ii+0xb0>)
   81ac8:	481f      	ldr	r0, [pc, #124]	; (81b48 <_Z41__static_initialization_and_destruction_0ii+0xb4>)
   81aca:	4c20      	ldr	r4, [pc, #128]	; (81b4c <_Z41__static_initialization_and_destruction_0ii+0xb8>)
   81acc:	47a0      	blx	r4

// ----------------------------------------------------------------------------
/*
 * USART objects
 */
RingBuffer rx_buffer2;
   81ace:	4820      	ldr	r0, [pc, #128]	; (81b50 <_Z41__static_initialization_and_destruction_0ii+0xbc>)
   81ad0:	4b1a      	ldr	r3, [pc, #104]	; (81b3c <_Z41__static_initialization_and_destruction_0ii+0xa8>)
   81ad2:	4798      	blx	r3
RingBuffer rx_buffer3;
   81ad4:	481f      	ldr	r0, [pc, #124]	; (81b54 <_Z41__static_initialization_and_destruction_0ii+0xc0>)
   81ad6:	4b19      	ldr	r3, [pc, #100]	; (81b3c <_Z41__static_initialization_and_destruction_0ii+0xa8>)
   81ad8:	4798      	blx	r3
RingBuffer rx_buffer4;
   81ada:	481f      	ldr	r0, [pc, #124]	; (81b58 <_Z41__static_initialization_and_destruction_0ii+0xc4>)
   81adc:	4b17      	ldr	r3, [pc, #92]	; (81b3c <_Z41__static_initialization_and_destruction_0ii+0xa8>)
   81ade:	4798      	blx	r3
RingBuffer tx_buffer2;
   81ae0:	481e      	ldr	r0, [pc, #120]	; (81b5c <_Z41__static_initialization_and_destruction_0ii+0xc8>)
   81ae2:	4b16      	ldr	r3, [pc, #88]	; (81b3c <_Z41__static_initialization_and_destruction_0ii+0xa8>)
   81ae4:	4798      	blx	r3
RingBuffer tx_buffer3;
   81ae6:	481e      	ldr	r0, [pc, #120]	; (81b60 <_Z41__static_initialization_and_destruction_0ii+0xcc>)
   81ae8:	4b14      	ldr	r3, [pc, #80]	; (81b3c <_Z41__static_initialization_and_destruction_0ii+0xa8>)
   81aea:	4798      	blx	r3
RingBuffer tx_buffer4;
   81aec:	481d      	ldr	r0, [pc, #116]	; (81b64 <_Z41__static_initialization_and_destruction_0ii+0xd0>)
   81aee:	4b13      	ldr	r3, [pc, #76]	; (81b3c <_Z41__static_initialization_and_destruction_0ii+0xa8>)
   81af0:	4798      	blx	r3

USARTClass Serial1(USART0, USART0_IRQn, ID_USART0, &rx_buffer2, &tx_buffer2);
   81af2:	4b1a      	ldr	r3, [pc, #104]	; (81b5c <_Z41__static_initialization_and_destruction_0ii+0xc8>)
   81af4:	9301      	str	r3, [sp, #4]
   81af6:	4b16      	ldr	r3, [pc, #88]	; (81b50 <_Z41__static_initialization_and_destruction_0ii+0xbc>)
   81af8:	9300      	str	r3, [sp, #0]
   81afa:	2311      	movs	r3, #17
   81afc:	2211      	movs	r2, #17
   81afe:	491a      	ldr	r1, [pc, #104]	; (81b68 <_Z41__static_initialization_and_destruction_0ii+0xd4>)
   81b00:	481a      	ldr	r0, [pc, #104]	; (81b6c <_Z41__static_initialization_and_destruction_0ii+0xd8>)
   81b02:	4c1b      	ldr	r4, [pc, #108]	; (81b70 <_Z41__static_initialization_and_destruction_0ii+0xdc>)
   81b04:	47a0      	blx	r4
void serialEvent1() __attribute__((weak));
void serialEvent1() { }
USARTClass Serial2(USART1, USART1_IRQn, ID_USART1, &rx_buffer3, &tx_buffer3);
   81b06:	4b16      	ldr	r3, [pc, #88]	; (81b60 <_Z41__static_initialization_and_destruction_0ii+0xcc>)
   81b08:	9301      	str	r3, [sp, #4]
   81b0a:	4b12      	ldr	r3, [pc, #72]	; (81b54 <_Z41__static_initialization_and_destruction_0ii+0xc0>)
   81b0c:	9300      	str	r3, [sp, #0]
   81b0e:	2312      	movs	r3, #18
   81b10:	2212      	movs	r2, #18
   81b12:	4918      	ldr	r1, [pc, #96]	; (81b74 <_Z41__static_initialization_and_destruction_0ii+0xe0>)
   81b14:	4818      	ldr	r0, [pc, #96]	; (81b78 <_Z41__static_initialization_and_destruction_0ii+0xe4>)
   81b16:	4c16      	ldr	r4, [pc, #88]	; (81b70 <_Z41__static_initialization_and_destruction_0ii+0xdc>)
   81b18:	47a0      	blx	r4
void serialEvent2() __attribute__((weak));
void serialEvent2() { }
USARTClass Serial3(USART3, USART3_IRQn, ID_USART3, &rx_buffer4, &tx_buffer4);
   81b1a:	4b12      	ldr	r3, [pc, #72]	; (81b64 <_Z41__static_initialization_and_destruction_0ii+0xd0>)
   81b1c:	9301      	str	r3, [sp, #4]
   81b1e:	4b0e      	ldr	r3, [pc, #56]	; (81b58 <_Z41__static_initialization_and_destruction_0ii+0xc4>)
   81b20:	9300      	str	r3, [sp, #0]
   81b22:	2314      	movs	r3, #20
   81b24:	2214      	movs	r2, #20
   81b26:	4915      	ldr	r1, [pc, #84]	; (81b7c <_Z41__static_initialization_and_destruction_0ii+0xe8>)
   81b28:	4815      	ldr	r0, [pc, #84]	; (81b80 <_Z41__static_initialization_and_destruction_0ii+0xec>)
   81b2a:	4c11      	ldr	r4, [pc, #68]	; (81b70 <_Z41__static_initialization_and_destruction_0ii+0xdc>)
   81b2c:	47a0      	blx	r4
  // Initialize analogOutput module
  analogOutputInit();
}

#ifdef __cplusplus
}
   81b2e:	bf00      	nop
   81b30:	370c      	adds	r7, #12
   81b32:	46bd      	mov	sp, r7
   81b34:	bd90      	pop	{r4, r7, pc}
   81b36:	bf00      	nop
   81b38:	20070cc8 	.word	0x20070cc8
   81b3c:	00087a95 	.word	0x00087a95
   81b40:	20070d50 	.word	0x20070d50
   81b44:	400e0800 	.word	0x400e0800
   81b48:	20070dd8 	.word	0x20070dd8
   81b4c:	0008058d 	.word	0x0008058d
   81b50:	20070dfc 	.word	0x20070dfc
   81b54:	20070e84 	.word	0x20070e84
   81b58:	20070f0c 	.word	0x20070f0c
   81b5c:	20070f94 	.word	0x20070f94
   81b60:	2007101c 	.word	0x2007101c
   81b64:	200710a4 	.word	0x200710a4
   81b68:	40098000 	.word	0x40098000
   81b6c:	2007112c 	.word	0x2007112c
   81b70:	000889bd 	.word	0x000889bd
   81b74:	4009c000 	.word	0x4009c000
   81b78:	20071154 	.word	0x20071154
   81b7c:	400a4000 	.word	0x400a4000
   81b80:	2007117c 	.word	0x2007117c

00081b84 <_GLOBAL__sub_I_g_APinDescription>:
   81b84:	b580      	push	{r7, lr}
   81b86:	af00      	add	r7, sp, #0
   81b88:	f64f 71ff 	movw	r1, #65535	; 0xffff
   81b8c:	2001      	movs	r0, #1
   81b8e:	4b01      	ldr	r3, [pc, #4]	; (81b94 <_GLOBAL__sub_I_g_APinDescription+0x10>)
   81b90:	4798      	blx	r3
   81b92:	bd80      	pop	{r7, pc}
   81b94:	00081a95 	.word	0x00081a95

00081b98 <_watchdogDefaultSetup>:
}


extern "C"
void _watchdogDefaultSetup (void)
{
   81b98:	b580      	push	{r7, lr}
   81b9a:	af00      	add	r7, sp, #0
	WDT_Disable (WDT);
   81b9c:	4802      	ldr	r0, [pc, #8]	; (81ba8 <_watchdogDefaultSetup+0x10>)
   81b9e:	4b03      	ldr	r3, [pc, #12]	; (81bac <_watchdogDefaultSetup+0x14>)
   81ba0:	4798      	blx	r3
}
   81ba2:	bf00      	nop
   81ba4:	bd80      	pop	{r7, pc}
   81ba6:	bf00      	nop
   81ba8:	400e1a50 	.word	0x400e1a50
   81bac:	000889a1 	.word	0x000889a1

00081bb0 <millis>:
#ifdef __cplusplus
extern "C" {
#endif

uint32_t millis( void )
{
   81bb0:	b580      	push	{r7, lr}
   81bb2:	af00      	add	r7, sp, #0
// todo: ensure no interrupts
    return GetTickCount() ;
   81bb4:	4b02      	ldr	r3, [pc, #8]	; (81bc0 <millis+0x10>)
   81bb6:	4798      	blx	r3
   81bb8:	4603      	mov	r3, r0
}
   81bba:	4618      	mov	r0, r3
   81bbc:	bd80      	pop	{r7, pc}
   81bbe:	bf00      	nop
   81bc0:	00088299 	.word	0x00088299

00081bc4 <micros>:
// Interrupt-compatible version of micros
// Theory: repeatedly take readings of SysTick counter, millis counter and SysTick interrupt pending flag.
// When it appears that millis counter and pending is stable and SysTick hasn't rolled over, use these 
// values to calculate micros. If there is a pending SysTick, add one to the millis counter in the calculation.
uint32_t micros( void )
{
   81bc4:	b580      	push	{r7, lr}
   81bc6:	b086      	sub	sp, #24
   81bc8:	af00      	add	r7, sp, #0
    uint32_t ticks, ticks2;
    uint32_t pend, pend2;
    uint32_t count, count2;

    ticks2  = SysTick->VAL;
   81bca:	4b29      	ldr	r3, [pc, #164]	; (81c70 <micros+0xac>)
   81bcc:	689b      	ldr	r3, [r3, #8]
   81bce:	617b      	str	r3, [r7, #20]
    pend2   = !!((SCB->ICSR & SCB_ICSR_PENDSTSET_Msk)||((SCB->SHCSR & SCB_SHCSR_SYSTICKACT_Msk)))  ;
   81bd0:	4b28      	ldr	r3, [pc, #160]	; (81c74 <micros+0xb0>)
   81bd2:	685b      	ldr	r3, [r3, #4]
   81bd4:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
   81bd8:	2b00      	cmp	r3, #0
   81bda:	d105      	bne.n	81be8 <micros+0x24>
   81bdc:	4b25      	ldr	r3, [pc, #148]	; (81c74 <micros+0xb0>)
   81bde:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   81be0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
   81be4:	2b00      	cmp	r3, #0
   81be6:	d001      	beq.n	81bec <micros+0x28>
   81be8:	2301      	movs	r3, #1
   81bea:	e000      	b.n	81bee <micros+0x2a>
   81bec:	2300      	movs	r3, #0
   81bee:	613b      	str	r3, [r7, #16]
    count2  = GetTickCount();
   81bf0:	4b21      	ldr	r3, [pc, #132]	; (81c78 <micros+0xb4>)
   81bf2:	4798      	blx	r3
   81bf4:	60f8      	str	r0, [r7, #12]

    do {
        ticks=ticks2;
   81bf6:	697b      	ldr	r3, [r7, #20]
   81bf8:	60bb      	str	r3, [r7, #8]
        pend=pend2;
   81bfa:	693b      	ldr	r3, [r7, #16]
   81bfc:	607b      	str	r3, [r7, #4]
        count=count2;
   81bfe:	68fb      	ldr	r3, [r7, #12]
   81c00:	603b      	str	r3, [r7, #0]
        ticks2  = SysTick->VAL;
   81c02:	4b1b      	ldr	r3, [pc, #108]	; (81c70 <micros+0xac>)
   81c04:	689b      	ldr	r3, [r3, #8]
   81c06:	617b      	str	r3, [r7, #20]
        pend2   = !!((SCB->ICSR & SCB_ICSR_PENDSTSET_Msk)||((SCB->SHCSR & SCB_SHCSR_SYSTICKACT_Msk)))  ;
   81c08:	4b1a      	ldr	r3, [pc, #104]	; (81c74 <micros+0xb0>)
   81c0a:	685b      	ldr	r3, [r3, #4]
   81c0c:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
   81c10:	2b00      	cmp	r3, #0
   81c12:	d105      	bne.n	81c20 <micros+0x5c>
   81c14:	4b17      	ldr	r3, [pc, #92]	; (81c74 <micros+0xb0>)
   81c16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   81c18:	f403 6300 	and.w	r3, r3, #2048	; 0x800
   81c1c:	2b00      	cmp	r3, #0
   81c1e:	d001      	beq.n	81c24 <micros+0x60>
   81c20:	2301      	movs	r3, #1
   81c22:	e000      	b.n	81c26 <micros+0x62>
   81c24:	2300      	movs	r3, #0
   81c26:	613b      	str	r3, [r7, #16]
        count2  = GetTickCount();
   81c28:	4b13      	ldr	r3, [pc, #76]	; (81c78 <micros+0xb4>)
   81c2a:	4798      	blx	r3
   81c2c:	60f8      	str	r0, [r7, #12]
    } while ((pend != pend2) || (count != count2) || (ticks < ticks2));
   81c2e:	687a      	ldr	r2, [r7, #4]
   81c30:	693b      	ldr	r3, [r7, #16]
   81c32:	429a      	cmp	r2, r3
   81c34:	d1df      	bne.n	81bf6 <micros+0x32>
   81c36:	683a      	ldr	r2, [r7, #0]
   81c38:	68fb      	ldr	r3, [r7, #12]
   81c3a:	429a      	cmp	r2, r3
   81c3c:	d1db      	bne.n	81bf6 <micros+0x32>
   81c3e:	68ba      	ldr	r2, [r7, #8]
   81c40:	697b      	ldr	r3, [r7, #20]
   81c42:	429a      	cmp	r2, r3
   81c44:	d3d7      	bcc.n	81bf6 <micros+0x32>

    return ((count+pend) * 1000) + (((SysTick->LOAD  - ticks)*(1048576/(F_CPU/1000000)))>>20) ; 
   81c46:	683a      	ldr	r2, [r7, #0]
   81c48:	687b      	ldr	r3, [r7, #4]
   81c4a:	4413      	add	r3, r2
   81c4c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   81c50:	fb02 f203 	mul.w	r2, r2, r3
   81c54:	4b06      	ldr	r3, [pc, #24]	; (81c70 <micros+0xac>)
   81c56:	6859      	ldr	r1, [r3, #4]
   81c58:	68bb      	ldr	r3, [r7, #8]
   81c5a:	1acb      	subs	r3, r1, r3
   81c5c:	f243 01c3 	movw	r1, #12483	; 0x30c3
   81c60:	fb01 f303 	mul.w	r3, r1, r3
   81c64:	0d1b      	lsrs	r3, r3, #20
   81c66:	4413      	add	r3, r2
    // this is an optimization to turn a runtime division into two compile-time divisions and 
    // a runtime multiplication and shift, saving a few cycles
}
   81c68:	4618      	mov	r0, r3
   81c6a:	3718      	adds	r7, #24
   81c6c:	46bd      	mov	sp, r7
   81c6e:	bd80      	pop	{r7, pc}
   81c70:	e000e010 	.word	0xe000e010
   81c74:	e000ed00 	.word	0xe000ed00
   81c78:	00088299 	.word	0x00088299

00081c7c <delay>:
//     return count * 1000 + (SysTick->LOAD + 1 - ticks) / (SystemCoreClock/1000000) ;
// }


void delay( uint32_t ms )
{
   81c7c:	b580      	push	{r7, lr}
   81c7e:	b084      	sub	sp, #16
   81c80:	af00      	add	r7, sp, #0
   81c82:	6078      	str	r0, [r7, #4]
    if (ms == 0)
   81c84:	687b      	ldr	r3, [r7, #4]
   81c86:	2b00      	cmp	r3, #0
   81c88:	d00d      	beq.n	81ca6 <delay+0x2a>
        return;
    uint32_t start = GetTickCount();
   81c8a:	4b09      	ldr	r3, [pc, #36]	; (81cb0 <delay+0x34>)
   81c8c:	4798      	blx	r3
   81c8e:	60f8      	str	r0, [r7, #12]
    do {
        yield();
   81c90:	4b08      	ldr	r3, [pc, #32]	; (81cb4 <delay+0x38>)
   81c92:	4798      	blx	r3
    } while (GetTickCount() - start < ms);
   81c94:	4b06      	ldr	r3, [pc, #24]	; (81cb0 <delay+0x34>)
   81c96:	4798      	blx	r3
   81c98:	4602      	mov	r2, r0
   81c9a:	68fb      	ldr	r3, [r7, #12]
   81c9c:	1ad2      	subs	r2, r2, r3
   81c9e:	687b      	ldr	r3, [r7, #4]
   81ca0:	429a      	cmp	r2, r3
   81ca2:	d3f5      	bcc.n	81c90 <delay+0x14>
   81ca4:	e000      	b.n	81ca8 <delay+0x2c>


void delay( uint32_t ms )
{
    if (ms == 0)
        return;
   81ca6:	bf00      	nop
    uint32_t start = GetTickCount();
    do {
        yield();
    } while (GetTickCount() - start < ms);
}
   81ca8:	3710      	adds	r7, #16
   81caa:	46bd      	mov	sp, r7
   81cac:	bd80      	pop	{r7, pc}
   81cae:	bf00      	nop
   81cb0:	00088299 	.word	0x00088299
   81cb4:	00087881 	.word	0x00087881

00081cb8 <analogOutputInit>:
}

static uint8_t PWMEnabled = 0;
static uint8_t TCChanEnabled[] = {0, 0, 0, 0, 0, 0, 0, 0, 0};

void analogOutputInit(void) {
   81cb8:	b480      	push	{r7}
   81cba:	af00      	add	r7, sp, #0
}
   81cbc:	bf00      	nop
   81cbe:	46bd      	mov	sp, r7
   81cc0:	bc80      	pop	{r7}
   81cc2:	4770      	bx	lr

00081cc4 <pinMode>:
#ifdef __cplusplus
 extern "C" {
#endif

extern void pinMode( uint32_t ulPin, uint32_t ulMode )
{
   81cc4:	b5b0      	push	{r4, r5, r7, lr}
   81cc6:	b082      	sub	sp, #8
   81cc8:	af00      	add	r7, sp, #0
   81cca:	6078      	str	r0, [r7, #4]
   81ccc:	6039      	str	r1, [r7, #0]
	if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
   81cce:	498f      	ldr	r1, [pc, #572]	; (81f0c <pinMode+0x248>)
   81cd0:	687a      	ldr	r2, [r7, #4]
   81cd2:	4613      	mov	r3, r2
   81cd4:	00db      	lsls	r3, r3, #3
   81cd6:	1a9b      	subs	r3, r3, r2
   81cd8:	009b      	lsls	r3, r3, #2
   81cda:	440b      	add	r3, r1
   81cdc:	330c      	adds	r3, #12
   81cde:	781b      	ldrb	r3, [r3, #0]
   81ce0:	2b00      	cmp	r3, #0
   81ce2:	f000 810a 	beq.w	81efa <pinMode+0x236>
    {
        return ;
    }

  if ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_ANALOG)
   81ce6:	4a8a      	ldr	r2, [pc, #552]	; (81f10 <pinMode+0x24c>)
   81ce8:	687b      	ldr	r3, [r7, #4]
   81cea:	4413      	add	r3, r2
   81cec:	781b      	ldrb	r3, [r3, #0]
   81cee:	f003 030f 	and.w	r3, r3, #15
   81cf2:	2b04      	cmp	r3, #4
   81cf4:	d10e      	bne.n	81d14 <pinMode+0x50>
    {
      adc_disable_channel( ADC, g_APinDescription[ulPin].ulADCChannelNumber);
   81cf6:	4985      	ldr	r1, [pc, #532]	; (81f0c <pinMode+0x248>)
   81cf8:	687a      	ldr	r2, [r7, #4]
   81cfa:	4613      	mov	r3, r2
   81cfc:	00db      	lsls	r3, r3, #3
   81cfe:	1a9b      	subs	r3, r3, r2
   81d00:	009b      	lsls	r3, r3, #2
   81d02:	440b      	add	r3, r1
   81d04:	3319      	adds	r3, #25
   81d06:	f993 3000 	ldrsb.w	r3, [r3]
   81d0a:	b2db      	uxtb	r3, r3
   81d0c:	4619      	mov	r1, r3
   81d0e:	4881      	ldr	r0, [pc, #516]	; (81f14 <pinMode+0x250>)
   81d10:	4b81      	ldr	r3, [pc, #516]	; (81f18 <pinMode+0x254>)
   81d12:	4798      	blx	r3
    }

  if ((g_pinStatus[ulPin] & 0xF) < PIN_STATUS_DIGITAL_OUTPUT && g_pinStatus[ulPin] != 0)
   81d14:	4a7e      	ldr	r2, [pc, #504]	; (81f10 <pinMode+0x24c>)
   81d16:	687b      	ldr	r3, [r7, #4]
   81d18:	4413      	add	r3, r2
   81d1a:	781b      	ldrb	r3, [r3, #0]
   81d1c:	f003 030f 	and.w	r3, r3, #15
   81d20:	2b02      	cmp	r3, #2
   81d22:	dc29      	bgt.n	81d78 <pinMode+0xb4>
   81d24:	4a7a      	ldr	r2, [pc, #488]	; (81f10 <pinMode+0x24c>)
   81d26:	687b      	ldr	r3, [r7, #4]
   81d28:	4413      	add	r3, r2
   81d2a:	781b      	ldrb	r3, [r3, #0]
   81d2c:	2b00      	cmp	r3, #0
   81d2e:	d023      	beq.n	81d78 <pinMode+0xb4>
    {
      // return if already configured in the right way
      if (((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_INPUT && ulMode == INPUT) ||
   81d30:	4a77      	ldr	r2, [pc, #476]	; (81f10 <pinMode+0x24c>)
   81d32:	687b      	ldr	r3, [r7, #4]
   81d34:	4413      	add	r3, r2
   81d36:	781b      	ldrb	r3, [r3, #0]
   81d38:	f003 030f 	and.w	r3, r3, #15
   81d3c:	2b02      	cmp	r3, #2
   81d3e:	d103      	bne.n	81d48 <pinMode+0x84>
   81d40:	683b      	ldr	r3, [r7, #0]
   81d42:	2b00      	cmp	r3, #0
   81d44:	f000 80db 	beq.w	81efe <pinMode+0x23a>
          ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_INPUT_PULLUP && ulMode == INPUT_PULLUP) ||
   81d48:	4a71      	ldr	r2, [pc, #452]	; (81f10 <pinMode+0x24c>)
   81d4a:	687b      	ldr	r3, [r7, #4]
   81d4c:	4413      	add	r3, r2
   81d4e:	781b      	ldrb	r3, [r3, #0]
   81d50:	f003 030f 	and.w	r3, r3, #15
    }

  if ((g_pinStatus[ulPin] & 0xF) < PIN_STATUS_DIGITAL_OUTPUT && g_pinStatus[ulPin] != 0)
    {
      // return if already configured in the right way
      if (((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_INPUT && ulMode == INPUT) ||
   81d54:	2b01      	cmp	r3, #1
   81d56:	d103      	bne.n	81d60 <pinMode+0x9c>
          ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_INPUT_PULLUP && ulMode == INPUT_PULLUP) ||
   81d58:	683b      	ldr	r3, [r7, #0]
   81d5a:	2b02      	cmp	r3, #2
   81d5c:	f000 80cf 	beq.w	81efe <pinMode+0x23a>
          ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_OUTPUT && ulMode == OUTPUT))
   81d60:	4a6b      	ldr	r2, [pc, #428]	; (81f10 <pinMode+0x24c>)
   81d62:	687b      	ldr	r3, [r7, #4]
   81d64:	4413      	add	r3, r2
   81d66:	781b      	ldrb	r3, [r3, #0]
   81d68:	f003 030f 	and.w	r3, r3, #15

  if ((g_pinStatus[ulPin] & 0xF) < PIN_STATUS_DIGITAL_OUTPUT && g_pinStatus[ulPin] != 0)
    {
      // return if already configured in the right way
      if (((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_INPUT && ulMode == INPUT) ||
          ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_INPUT_PULLUP && ulMode == INPUT_PULLUP) ||
   81d6c:	2b03      	cmp	r3, #3
   81d6e:	d103      	bne.n	81d78 <pinMode+0xb4>
          ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_OUTPUT && ulMode == OUTPUT))
   81d70:	683b      	ldr	r3, [r7, #0]
   81d72:	2b01      	cmp	r3, #1
   81d74:	f000 80c3 	beq.w	81efe <pinMode+0x23a>
      return;
    }

	switch ( ulMode )
   81d78:	683b      	ldr	r3, [r7, #0]
   81d7a:	2b01      	cmp	r3, #1
   81d7c:	d06a      	beq.n	81e54 <pinMode+0x190>
   81d7e:	2b01      	cmp	r3, #1
   81d80:	d302      	bcc.n	81d88 <pinMode+0xc4>
   81d82:	2b02      	cmp	r3, #2
   81d84:	d033      	beq.n	81dee <pinMode+0x12a>
                pmc_disable_periph_clk( g_APinDescription[ulPin].ulPeripheralId ) ;
            }
        break ;

        default:
        break ;
   81d86:	e0bd      	b.n	81f04 <pinMode+0x240>

	switch ( ulMode )
    {
        case INPUT:
            /* Enable peripheral for clocking input */
            pmc_enable_periph_clk( g_APinDescription[ulPin].ulPeripheralId ) ;
   81d88:	4960      	ldr	r1, [pc, #384]	; (81f0c <pinMode+0x248>)
   81d8a:	687a      	ldr	r2, [r7, #4]
   81d8c:	4613      	mov	r3, r2
   81d8e:	00db      	lsls	r3, r3, #3
   81d90:	1a9b      	subs	r3, r3, r2
   81d92:	009b      	lsls	r3, r3, #2
   81d94:	440b      	add	r3, r1
   81d96:	3308      	adds	r3, #8
   81d98:	681b      	ldr	r3, [r3, #0]
   81d9a:	4618      	mov	r0, r3
   81d9c:	4b5f      	ldr	r3, [pc, #380]	; (81f1c <pinMode+0x258>)
   81d9e:	4798      	blx	r3
            PIO_Configure(
   81da0:	495a      	ldr	r1, [pc, #360]	; (81f0c <pinMode+0x248>)
   81da2:	687a      	ldr	r2, [r7, #4]
   81da4:	4613      	mov	r3, r2
   81da6:	00db      	lsls	r3, r3, #3
   81da8:	1a9b      	subs	r3, r3, r2
   81daa:	009b      	lsls	r3, r3, #2
   81dac:	440b      	add	r3, r1
   81dae:	6818      	ldr	r0, [r3, #0]
   81db0:	4956      	ldr	r1, [pc, #344]	; (81f0c <pinMode+0x248>)
   81db2:	687a      	ldr	r2, [r7, #4]
   81db4:	4613      	mov	r3, r2
   81db6:	00db      	lsls	r3, r3, #3
   81db8:	1a9b      	subs	r3, r3, r2
   81dba:	009b      	lsls	r3, r3, #2
   81dbc:	440b      	add	r3, r1
   81dbe:	3304      	adds	r3, #4
   81dc0:	681a      	ldr	r2, [r3, #0]
   81dc2:	2300      	movs	r3, #0
   81dc4:	2103      	movs	r1, #3
   81dc6:	4c56      	ldr	r4, [pc, #344]	; (81f20 <pinMode+0x25c>)
   81dc8:	47a0      	blx	r4
            	g_APinDescription[ulPin].pPort,
            	PIO_INPUT,
            	g_APinDescription[ulPin].ulPin,
            	0 ) ;
            g_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_DIGITAL_INPUT;
   81dca:	4a51      	ldr	r2, [pc, #324]	; (81f10 <pinMode+0x24c>)
   81dcc:	687b      	ldr	r3, [r7, #4]
   81dce:	4413      	add	r3, r2
   81dd0:	781b      	ldrb	r3, [r3, #0]
   81dd2:	b25b      	sxtb	r3, r3
   81dd4:	f023 030f 	bic.w	r3, r3, #15
   81dd8:	b25b      	sxtb	r3, r3
   81dda:	f043 0302 	orr.w	r3, r3, #2
   81dde:	b25b      	sxtb	r3, r3
   81de0:	b2d9      	uxtb	r1, r3
   81de2:	4a4b      	ldr	r2, [pc, #300]	; (81f10 <pinMode+0x24c>)
   81de4:	687b      	ldr	r3, [r7, #4]
   81de6:	4413      	add	r3, r2
   81de8:	460a      	mov	r2, r1
   81dea:	701a      	strb	r2, [r3, #0]
        break ;
   81dec:	e08a      	b.n	81f04 <pinMode+0x240>

        case INPUT_PULLUP:
            /* Enable peripheral for clocking input */
            pmc_enable_periph_clk( g_APinDescription[ulPin].ulPeripheralId ) ;
   81dee:	4947      	ldr	r1, [pc, #284]	; (81f0c <pinMode+0x248>)
   81df0:	687a      	ldr	r2, [r7, #4]
   81df2:	4613      	mov	r3, r2
   81df4:	00db      	lsls	r3, r3, #3
   81df6:	1a9b      	subs	r3, r3, r2
   81df8:	009b      	lsls	r3, r3, #2
   81dfa:	440b      	add	r3, r1
   81dfc:	3308      	adds	r3, #8
   81dfe:	681b      	ldr	r3, [r3, #0]
   81e00:	4618      	mov	r0, r3
   81e02:	4b46      	ldr	r3, [pc, #280]	; (81f1c <pinMode+0x258>)
   81e04:	4798      	blx	r3
            PIO_Configure(
   81e06:	4941      	ldr	r1, [pc, #260]	; (81f0c <pinMode+0x248>)
   81e08:	687a      	ldr	r2, [r7, #4]
   81e0a:	4613      	mov	r3, r2
   81e0c:	00db      	lsls	r3, r3, #3
   81e0e:	1a9b      	subs	r3, r3, r2
   81e10:	009b      	lsls	r3, r3, #2
   81e12:	440b      	add	r3, r1
   81e14:	6818      	ldr	r0, [r3, #0]
   81e16:	493d      	ldr	r1, [pc, #244]	; (81f0c <pinMode+0x248>)
   81e18:	687a      	ldr	r2, [r7, #4]
   81e1a:	4613      	mov	r3, r2
   81e1c:	00db      	lsls	r3, r3, #3
   81e1e:	1a9b      	subs	r3, r3, r2
   81e20:	009b      	lsls	r3, r3, #2
   81e22:	440b      	add	r3, r1
   81e24:	3304      	adds	r3, #4
   81e26:	681a      	ldr	r2, [r3, #0]
   81e28:	2301      	movs	r3, #1
   81e2a:	2103      	movs	r1, #3
   81e2c:	4c3c      	ldr	r4, [pc, #240]	; (81f20 <pinMode+0x25c>)
   81e2e:	47a0      	blx	r4
            	g_APinDescription[ulPin].pPort,
            	PIO_INPUT,
            	g_APinDescription[ulPin].ulPin,
            	PIO_PULLUP ) ;
            g_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_DIGITAL_INPUT_PULLUP;
   81e30:	4a37      	ldr	r2, [pc, #220]	; (81f10 <pinMode+0x24c>)
   81e32:	687b      	ldr	r3, [r7, #4]
   81e34:	4413      	add	r3, r2
   81e36:	781b      	ldrb	r3, [r3, #0]
   81e38:	b25b      	sxtb	r3, r3
   81e3a:	f023 030f 	bic.w	r3, r3, #15
   81e3e:	b25b      	sxtb	r3, r3
   81e40:	f043 0301 	orr.w	r3, r3, #1
   81e44:	b25b      	sxtb	r3, r3
   81e46:	b2d9      	uxtb	r1, r3
   81e48:	4a31      	ldr	r2, [pc, #196]	; (81f10 <pinMode+0x24c>)
   81e4a:	687b      	ldr	r3, [r7, #4]
   81e4c:	4413      	add	r3, r2
   81e4e:	460a      	mov	r2, r1
   81e50:	701a      	strb	r2, [r3, #0]
        break ;
   81e52:	e057      	b.n	81f04 <pinMode+0x240>

        case OUTPUT:
            PIO_Configure(
   81e54:	492d      	ldr	r1, [pc, #180]	; (81f0c <pinMode+0x248>)
   81e56:	687a      	ldr	r2, [r7, #4]
   81e58:	4613      	mov	r3, r2
   81e5a:	00db      	lsls	r3, r3, #3
   81e5c:	1a9b      	subs	r3, r3, r2
   81e5e:	009b      	lsls	r3, r3, #2
   81e60:	440b      	add	r3, r1
   81e62:	6818      	ldr	r0, [r3, #0]
            	g_APinDescription[ulPin].pPort,
              (g_pinStatus[ulPin] & 0xF0) >> 4 ? PIO_OUTPUT_1 : PIO_OUTPUT_0,
   81e64:	4a2a      	ldr	r2, [pc, #168]	; (81f10 <pinMode+0x24c>)
   81e66:	687b      	ldr	r3, [r7, #4]
   81e68:	4413      	add	r3, r2
   81e6a:	781b      	ldrb	r3, [r3, #0]
   81e6c:	091b      	lsrs	r3, r3, #4
   81e6e:	b2db      	uxtb	r3, r3
            	PIO_PULLUP ) ;
            g_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_DIGITAL_INPUT_PULLUP;
        break ;

        case OUTPUT:
            PIO_Configure(
   81e70:	2b00      	cmp	r3, #0
   81e72:	d001      	beq.n	81e78 <pinMode+0x1b4>
   81e74:	2405      	movs	r4, #5
   81e76:	e000      	b.n	81e7a <pinMode+0x1b6>
   81e78:	2404      	movs	r4, #4
   81e7a:	4924      	ldr	r1, [pc, #144]	; (81f0c <pinMode+0x248>)
   81e7c:	687a      	ldr	r2, [r7, #4]
   81e7e:	4613      	mov	r3, r2
   81e80:	00db      	lsls	r3, r3, #3
   81e82:	1a9b      	subs	r3, r3, r2
   81e84:	009b      	lsls	r3, r3, #2
   81e86:	440b      	add	r3, r1
   81e88:	3304      	adds	r3, #4
   81e8a:	681d      	ldr	r5, [r3, #0]
   81e8c:	491f      	ldr	r1, [pc, #124]	; (81f0c <pinMode+0x248>)
   81e8e:	687a      	ldr	r2, [r7, #4]
   81e90:	4613      	mov	r3, r2
   81e92:	00db      	lsls	r3, r3, #3
   81e94:	1a9b      	subs	r3, r3, r2
   81e96:	009b      	lsls	r3, r3, #2
   81e98:	440b      	add	r3, r1
   81e9a:	3310      	adds	r3, #16
   81e9c:	681b      	ldr	r3, [r3, #0]
   81e9e:	462a      	mov	r2, r5
   81ea0:	4621      	mov	r1, r4
   81ea2:	4c1f      	ldr	r4, [pc, #124]	; (81f20 <pinMode+0x25c>)
   81ea4:	47a0      	blx	r4
            	g_APinDescription[ulPin].pPort,
              (g_pinStatus[ulPin] & 0xF0) >> 4 ? PIO_OUTPUT_1 : PIO_OUTPUT_0,
            	g_APinDescription[ulPin].ulPin,
            	g_APinDescription[ulPin].ulPinConfiguration ) ;

            g_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0xF0) | PIN_STATUS_DIGITAL_OUTPUT;
   81ea6:	4a1a      	ldr	r2, [pc, #104]	; (81f10 <pinMode+0x24c>)
   81ea8:	687b      	ldr	r3, [r7, #4]
   81eaa:	4413      	add	r3, r2
   81eac:	781b      	ldrb	r3, [r3, #0]
   81eae:	b25b      	sxtb	r3, r3
   81eb0:	f023 030f 	bic.w	r3, r3, #15
   81eb4:	b25b      	sxtb	r3, r3
   81eb6:	f043 0303 	orr.w	r3, r3, #3
   81eba:	b25b      	sxtb	r3, r3
   81ebc:	b2d9      	uxtb	r1, r3
   81ebe:	4a14      	ldr	r2, [pc, #80]	; (81f10 <pinMode+0x24c>)
   81ec0:	687b      	ldr	r3, [r7, #4]
   81ec2:	4413      	add	r3, r2
   81ec4:	460a      	mov	r2, r1
   81ec6:	701a      	strb	r2, [r3, #0]

            /* if all pins are output, disable PIO Controller clocking, reduce power consumption */
            if ( g_APinDescription[ulPin].pPort->PIO_OSR == 0xffffffff )
   81ec8:	4910      	ldr	r1, [pc, #64]	; (81f0c <pinMode+0x248>)
   81eca:	687a      	ldr	r2, [r7, #4]
   81ecc:	4613      	mov	r3, r2
   81ece:	00db      	lsls	r3, r3, #3
   81ed0:	1a9b      	subs	r3, r3, r2
   81ed2:	009b      	lsls	r3, r3, #2
   81ed4:	440b      	add	r3, r1
   81ed6:	681b      	ldr	r3, [r3, #0]
   81ed8:	699b      	ldr	r3, [r3, #24]
   81eda:	f1b3 3fff 	cmp.w	r3, #4294967295
   81ede:	d110      	bne.n	81f02 <pinMode+0x23e>
            {
                pmc_disable_periph_clk( g_APinDescription[ulPin].ulPeripheralId ) ;
   81ee0:	490a      	ldr	r1, [pc, #40]	; (81f0c <pinMode+0x248>)
   81ee2:	687a      	ldr	r2, [r7, #4]
   81ee4:	4613      	mov	r3, r2
   81ee6:	00db      	lsls	r3, r3, #3
   81ee8:	1a9b      	subs	r3, r3, r2
   81eea:	009b      	lsls	r3, r3, #2
   81eec:	440b      	add	r3, r1
   81eee:	3308      	adds	r3, #8
   81ef0:	681b      	ldr	r3, [r3, #0]
   81ef2:	4618      	mov	r0, r3
   81ef4:	4b0b      	ldr	r3, [pc, #44]	; (81f24 <pinMode+0x260>)
   81ef6:	4798      	blx	r3
            }
        break ;
   81ef8:	e003      	b.n	81f02 <pinMode+0x23e>

extern void pinMode( uint32_t ulPin, uint32_t ulMode )
{
	if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
    {
        return ;
   81efa:	bf00      	nop
   81efc:	e002      	b.n	81f04 <pinMode+0x240>
    {
      // return if already configured in the right way
      if (((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_INPUT && ulMode == INPUT) ||
          ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_INPUT_PULLUP && ulMode == INPUT_PULLUP) ||
          ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_OUTPUT && ulMode == OUTPUT))
      return;
   81efe:	bf00      	nop
   81f00:	e000      	b.n	81f04 <pinMode+0x240>
            /* if all pins are output, disable PIO Controller clocking, reduce power consumption */
            if ( g_APinDescription[ulPin].pPort->PIO_OSR == 0xffffffff )
            {
                pmc_disable_periph_clk( g_APinDescription[ulPin].ulPeripheralId ) ;
            }
        break ;
   81f02:	bf00      	nop

        default:
        break ;
    }
}
   81f04:	3708      	adds	r7, #8
   81f06:	46bd      	mov	sp, r7
   81f08:	bdb0      	pop	{r4, r5, r7, pc}
   81f0a:	bf00      	nop
   81f0c:	0009958c 	.word	0x0009958c
   81f10:	20070c78 	.word	0x20070c78
   81f14:	400c0000 	.word	0x400c0000
   81f18:	00087cb9 	.word	0x00087cb9
   81f1c:	00088021 	.word	0x00088021
   81f20:	00087efd 	.word	0x00087efd
   81f24:	000880a1 	.word	0x000880a1

00081f28 <digitalWrite>:

extern void digitalWrite( uint32_t ulPin, uint32_t ulVal )
{
   81f28:	b590      	push	{r4, r7, lr}
   81f2a:	b085      	sub	sp, #20
   81f2c:	af02      	add	r7, sp, #8
   81f2e:	6078      	str	r0, [r7, #4]
   81f30:	6039      	str	r1, [r7, #0]
  /* Handle */
	if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
   81f32:	4939      	ldr	r1, [pc, #228]	; (82018 <digitalWrite+0xf0>)
   81f34:	687a      	ldr	r2, [r7, #4]
   81f36:	4613      	mov	r3, r2
   81f38:	00db      	lsls	r3, r3, #3
   81f3a:	1a9b      	subs	r3, r3, r2
   81f3c:	009b      	lsls	r3, r3, #2
   81f3e:	440b      	add	r3, r1
   81f40:	330c      	adds	r3, #12
   81f42:	781b      	ldrb	r3, [r3, #0]
   81f44:	2b00      	cmp	r3, #0
   81f46:	d062      	beq.n	8200e <digitalWrite+0xe6>
  {
    return ;
  }

  if ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_PWM) {
   81f48:	4a34      	ldr	r2, [pc, #208]	; (8201c <digitalWrite+0xf4>)
   81f4a:	687b      	ldr	r3, [r7, #4]
   81f4c:	4413      	add	r3, r2
   81f4e:	781b      	ldrb	r3, [r3, #0]
   81f50:	f003 030f 	and.w	r3, r3, #15
   81f54:	2b05      	cmp	r3, #5
   81f56:	d103      	bne.n	81f60 <digitalWrite+0x38>
    pinMode(ulPin, OUTPUT);
   81f58:	2101      	movs	r1, #1
   81f5a:	6878      	ldr	r0, [r7, #4]
   81f5c:	4b30      	ldr	r3, [pc, #192]	; (82020 <digitalWrite+0xf8>)
   81f5e:	4798      	blx	r3
  }

  g_pinStatus[ulPin] = (g_pinStatus[ulPin] & 0x0F) | (ulVal << 4) ;
   81f60:	4a2e      	ldr	r2, [pc, #184]	; (8201c <digitalWrite+0xf4>)
   81f62:	687b      	ldr	r3, [r7, #4]
   81f64:	4413      	add	r3, r2
   81f66:	781b      	ldrb	r3, [r3, #0]
   81f68:	f003 030f 	and.w	r3, r3, #15
   81f6c:	b2da      	uxtb	r2, r3
   81f6e:	683b      	ldr	r3, [r7, #0]
   81f70:	b2db      	uxtb	r3, r3
   81f72:	011b      	lsls	r3, r3, #4
   81f74:	b2db      	uxtb	r3, r3
   81f76:	4313      	orrs	r3, r2
   81f78:	b2d9      	uxtb	r1, r3
   81f7a:	4a28      	ldr	r2, [pc, #160]	; (8201c <digitalWrite+0xf4>)
   81f7c:	687b      	ldr	r3, [r7, #4]
   81f7e:	4413      	add	r3, r2
   81f80:	460a      	mov	r2, r1
   81f82:	701a      	strb	r2, [r3, #0]

  if ( PIO_GetOutputDataStatus( g_APinDescription[ulPin].pPort, g_APinDescription[ulPin].ulPin ) == 0 )
   81f84:	4924      	ldr	r1, [pc, #144]	; (82018 <digitalWrite+0xf0>)
   81f86:	687a      	ldr	r2, [r7, #4]
   81f88:	4613      	mov	r3, r2
   81f8a:	00db      	lsls	r3, r3, #3
   81f8c:	1a9b      	subs	r3, r3, r2
   81f8e:	009b      	lsls	r3, r3, #2
   81f90:	440b      	add	r3, r1
   81f92:	6818      	ldr	r0, [r3, #0]
   81f94:	4920      	ldr	r1, [pc, #128]	; (82018 <digitalWrite+0xf0>)
   81f96:	687a      	ldr	r2, [r7, #4]
   81f98:	4613      	mov	r3, r2
   81f9a:	00db      	lsls	r3, r3, #3
   81f9c:	1a9b      	subs	r3, r3, r2
   81f9e:	009b      	lsls	r3, r3, #2
   81fa0:	440b      	add	r3, r1
   81fa2:	3304      	adds	r3, #4
   81fa4:	681b      	ldr	r3, [r3, #0]
   81fa6:	4619      	mov	r1, r3
   81fa8:	4b1e      	ldr	r3, [pc, #120]	; (82024 <digitalWrite+0xfc>)
   81faa:	4798      	blx	r3
   81fac:	4603      	mov	r3, r0
   81fae:	2b00      	cmp	r3, #0
   81fb0:	d115      	bne.n	81fde <digitalWrite+0xb6>
  {
    PIO_PullUp( g_APinDescription[ulPin].pPort, g_APinDescription[ulPin].ulPin, ulVal ) ;
   81fb2:	4919      	ldr	r1, [pc, #100]	; (82018 <digitalWrite+0xf0>)
   81fb4:	687a      	ldr	r2, [r7, #4]
   81fb6:	4613      	mov	r3, r2
   81fb8:	00db      	lsls	r3, r3, #3
   81fba:	1a9b      	subs	r3, r3, r2
   81fbc:	009b      	lsls	r3, r3, #2
   81fbe:	440b      	add	r3, r1
   81fc0:	6818      	ldr	r0, [r3, #0]
   81fc2:	4915      	ldr	r1, [pc, #84]	; (82018 <digitalWrite+0xf0>)
   81fc4:	687a      	ldr	r2, [r7, #4]
   81fc6:	4613      	mov	r3, r2
   81fc8:	00db      	lsls	r3, r3, #3
   81fca:	1a9b      	subs	r3, r3, r2
   81fcc:	009b      	lsls	r3, r3, #2
   81fce:	440b      	add	r3, r1
   81fd0:	3304      	adds	r3, #4
   81fd2:	681b      	ldr	r3, [r3, #0]
   81fd4:	683a      	ldr	r2, [r7, #0]
   81fd6:	4619      	mov	r1, r3
   81fd8:	4b13      	ldr	r3, [pc, #76]	; (82028 <digitalWrite+0x100>)
   81fda:	4798      	blx	r3
   81fdc:	e018      	b.n	82010 <digitalWrite+0xe8>
  }
  else
  {
    PIO_SetOutput( g_APinDescription[ulPin].pPort, g_APinDescription[ulPin].ulPin, ulVal, 0, PIO_PULLUP ) ;
   81fde:	490e      	ldr	r1, [pc, #56]	; (82018 <digitalWrite+0xf0>)
   81fe0:	687a      	ldr	r2, [r7, #4]
   81fe2:	4613      	mov	r3, r2
   81fe4:	00db      	lsls	r3, r3, #3
   81fe6:	1a9b      	subs	r3, r3, r2
   81fe8:	009b      	lsls	r3, r3, #2
   81fea:	440b      	add	r3, r1
   81fec:	6818      	ldr	r0, [r3, #0]
   81fee:	490a      	ldr	r1, [pc, #40]	; (82018 <digitalWrite+0xf0>)
   81ff0:	687a      	ldr	r2, [r7, #4]
   81ff2:	4613      	mov	r3, r2
   81ff4:	00db      	lsls	r3, r3, #3
   81ff6:	1a9b      	subs	r3, r3, r2
   81ff8:	009b      	lsls	r3, r3, #2
   81ffa:	440b      	add	r3, r1
   81ffc:	3304      	adds	r3, #4
   81ffe:	6819      	ldr	r1, [r3, #0]
   82000:	2301      	movs	r3, #1
   82002:	9300      	str	r3, [sp, #0]
   82004:	2300      	movs	r3, #0
   82006:	683a      	ldr	r2, [r7, #0]
   82008:	4c08      	ldr	r4, [pc, #32]	; (8202c <digitalWrite+0x104>)
   8200a:	47a0      	blx	r4
   8200c:	e000      	b.n	82010 <digitalWrite+0xe8>
extern void digitalWrite( uint32_t ulPin, uint32_t ulVal )
{
  /* Handle */
	if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
  {
    return ;
   8200e:	bf00      	nop
  }
  else
  {
    PIO_SetOutput( g_APinDescription[ulPin].pPort, g_APinDescription[ulPin].ulPin, ulVal, 0, PIO_PULLUP ) ;
  }
}
   82010:	370c      	adds	r7, #12
   82012:	46bd      	mov	sp, r7
   82014:	bd90      	pop	{r4, r7, pc}
   82016:	bf00      	nop
   82018:	0009958c 	.word	0x0009958c
   8201c:	20070c78 	.word	0x20070c78
   82020:	00081cc5 	.word	0x00081cc5
   82024:	00087fc5 	.word	0x00087fc5
   82028:	00087d31 	.word	0x00087d31
   8202c:	00087e99 	.word	0x00087e99

00082030 <digitalRead>:

extern int digitalRead( uint32_t ulPin )
{
   82030:	b580      	push	{r7, lr}
   82032:	b082      	sub	sp, #8
   82034:	af00      	add	r7, sp, #0
   82036:	6078      	str	r0, [r7, #4]
  if ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_DIGITAL_OUTPUT) {
   82038:	4a23      	ldr	r2, [pc, #140]	; (820c8 <digitalRead+0x98>)
   8203a:	687b      	ldr	r3, [r7, #4]
   8203c:	4413      	add	r3, r2
   8203e:	781b      	ldrb	r3, [r3, #0]
   82040:	f003 030f 	and.w	r3, r3, #15
   82044:	2b03      	cmp	r3, #3
   82046:	d106      	bne.n	82056 <digitalRead+0x26>
    return (g_pinStatus[ulPin] & 0xF0) >> 4;
   82048:	4a1f      	ldr	r2, [pc, #124]	; (820c8 <digitalRead+0x98>)
   8204a:	687b      	ldr	r3, [r7, #4]
   8204c:	4413      	add	r3, r2
   8204e:	781b      	ldrb	r3, [r3, #0]
   82050:	091b      	lsrs	r3, r3, #4
   82052:	b2db      	uxtb	r3, r3
   82054:	e033      	b.n	820be <digitalRead+0x8e>
  }

  if ((g_pinStatus[ulPin] & 0xF) == PIN_STATUS_ANALOG) {
   82056:	4a1c      	ldr	r2, [pc, #112]	; (820c8 <digitalRead+0x98>)
   82058:	687b      	ldr	r3, [r7, #4]
   8205a:	4413      	add	r3, r2
   8205c:	781b      	ldrb	r3, [r3, #0]
   8205e:	f003 030f 	and.w	r3, r3, #15
   82062:	2b04      	cmp	r3, #4
   82064:	d103      	bne.n	8206e <digitalRead+0x3e>
    pinMode(ulPin, INPUT);
   82066:	2100      	movs	r1, #0
   82068:	6878      	ldr	r0, [r7, #4]
   8206a:	4b18      	ldr	r3, [pc, #96]	; (820cc <digitalRead+0x9c>)
   8206c:	4798      	blx	r3
  }

	if ( g_APinDescription[ulPin].ulPinType == PIO_NOT_A_PIN )
   8206e:	4918      	ldr	r1, [pc, #96]	; (820d0 <digitalRead+0xa0>)
   82070:	687a      	ldr	r2, [r7, #4]
   82072:	4613      	mov	r3, r2
   82074:	00db      	lsls	r3, r3, #3
   82076:	1a9b      	subs	r3, r3, r2
   82078:	009b      	lsls	r3, r3, #2
   8207a:	440b      	add	r3, r1
   8207c:	330c      	adds	r3, #12
   8207e:	781b      	ldrb	r3, [r3, #0]
   82080:	2b00      	cmp	r3, #0
   82082:	d101      	bne.n	82088 <digitalRead+0x58>
    {
        return LOW ;
   82084:	2300      	movs	r3, #0
   82086:	e01a      	b.n	820be <digitalRead+0x8e>
    }

	if ( PIO_Get( g_APinDescription[ulPin].pPort, PIO_INPUT, g_APinDescription[ulPin].ulPin ) == 1 )
   82088:	4911      	ldr	r1, [pc, #68]	; (820d0 <digitalRead+0xa0>)
   8208a:	687a      	ldr	r2, [r7, #4]
   8208c:	4613      	mov	r3, r2
   8208e:	00db      	lsls	r3, r3, #3
   82090:	1a9b      	subs	r3, r3, r2
   82092:	009b      	lsls	r3, r3, #2
   82094:	440b      	add	r3, r1
   82096:	6818      	ldr	r0, [r3, #0]
   82098:	490d      	ldr	r1, [pc, #52]	; (820d0 <digitalRead+0xa0>)
   8209a:	687a      	ldr	r2, [r7, #4]
   8209c:	4613      	mov	r3, r2
   8209e:	00db      	lsls	r3, r3, #3
   820a0:	1a9b      	subs	r3, r3, r2
   820a2:	009b      	lsls	r3, r3, #2
   820a4:	440b      	add	r3, r1
   820a6:	3304      	adds	r3, #4
   820a8:	681b      	ldr	r3, [r3, #0]
   820aa:	461a      	mov	r2, r3
   820ac:	2103      	movs	r1, #3
   820ae:	4b09      	ldr	r3, [pc, #36]	; (820d4 <digitalRead+0xa4>)
   820b0:	4798      	blx	r3
   820b2:	4603      	mov	r3, r0
   820b4:	2b01      	cmp	r3, #1
   820b6:	d101      	bne.n	820bc <digitalRead+0x8c>
    {
        return HIGH ;
   820b8:	2301      	movs	r3, #1
   820ba:	e000      	b.n	820be <digitalRead+0x8e>
    }

	return LOW ;
   820bc:	2300      	movs	r3, #0
}
   820be:	4618      	mov	r0, r3
   820c0:	3708      	adds	r7, #8
   820c2:	46bd      	mov	sp, r7
   820c4:	bd80      	pop	{r7, pc}
   820c6:	bf00      	nop
   820c8:	20070c78 	.word	0x20070c78
   820cc:	00081cc5 	.word	0x00081cc5
   820d0:	0009958c 	.word	0x0009958c
   820d4:	00087d5d 	.word	0x00087d5d

000820d8 <_Z8init_bspv>:
#include "BSP.h"

void
init_bsp ()
{
   820d8:	b580      	push	{r7, lr}
   820da:	af00      	add	r7, sp, #0
  //pinMode(MOSFET1, OUTPUT);
  //pinMode(MOSFET2, OUTPUT);
  pinMode (SERVO1, 		OUTPUT);
   820dc:	2101      	movs	r1, #1
   820de:	2004      	movs	r0, #4
   820e0:	4b49      	ldr	r3, [pc, #292]	; (82208 <_Z8init_bspv+0x130>)
   820e2:	4798      	blx	r3
  pinMode (SERVO2, 		OUTPUT);
   820e4:	2101      	movs	r1, #1
   820e6:	2005      	movs	r0, #5
   820e8:	4b47      	ldr	r3, [pc, #284]	; (82208 <_Z8init_bspv+0x130>)
   820ea:	4798      	blx	r3
  pinMode (SERVO3,		OUTPUT);
   820ec:	2101      	movs	r1, #1
   820ee:	2006      	movs	r0, #6
   820f0:	4b45      	ldr	r3, [pc, #276]	; (82208 <_Z8init_bspv+0x130>)
   820f2:	4798      	blx	r3
  pinMode (SERVO4, 		OUTPUT);
   820f4:	2101      	movs	r1, #1
   820f6:	2007      	movs	r0, #7
   820f8:	4b43      	ldr	r3, [pc, #268]	; (82208 <_Z8init_bspv+0x130>)
   820fa:	4798      	blx	r3
  pinMode (SERVO5, 		OUTPUT);
   820fc:	2101      	movs	r1, #1
   820fe:	2008      	movs	r0, #8
   82100:	4b41      	ldr	r3, [pc, #260]	; (82208 <_Z8init_bspv+0x130>)
   82102:	4798      	blx	r3
  pinMode (SERVO6, 		OUTPUT);
   82104:	2101      	movs	r1, #1
   82106:	2009      	movs	r0, #9
   82108:	4b3f      	ldr	r3, [pc, #252]	; (82208 <_Z8init_bspv+0x130>)
   8210a:	4798      	blx	r3
  pinMode (SERVO7, 		OUTPUT);
   8210c:	2101      	movs	r1, #1
   8210e:	200a      	movs	r0, #10
   82110:	4b3d      	ldr	r3, [pc, #244]	; (82208 <_Z8init_bspv+0x130>)
   82112:	4798      	blx	r3
  pinMode (SERVO8, 		OUTPUT);
   82114:	2101      	movs	r1, #1
   82116:	200b      	movs	r0, #11
   82118:	4b3b      	ldr	r3, [pc, #236]	; (82208 <_Z8init_bspv+0x130>)
   8211a:	4798      	blx	r3
  pinMode (BUZZER, 		OUTPUT);
   8211c:	2101      	movs	r1, #1
   8211e:	200c      	movs	r0, #12
   82120:	4b39      	ldr	r3, [pc, #228]	; (82208 <_Z8init_bspv+0x130>)
   82122:	4798      	blx	r3
  pinMode (LED_DUE_L, 		OUTPUT); //used by ArdOs to signal OS errors
   82124:	2101      	movs	r1, #1
   82126:	200d      	movs	r0, #13
   82128:	4b37      	ldr	r3, [pc, #220]	; (82208 <_Z8init_bspv+0x130>)
   8212a:	4798      	blx	r3
  pinMode (BUTTON_START, 	INPUT);
   8212c:	2100      	movs	r1, #0
   8212e:	2016      	movs	r0, #22
   82130:	4b35      	ldr	r3, [pc, #212]	; (82208 <_Z8init_bspv+0x130>)
   82132:	4798      	blx	r3
  pinMode (BUTTON_COLOR, 	INPUT);
   82134:	2100      	movs	r1, #0
   82136:	2017      	movs	r0, #23
   82138:	4b33      	ldr	r3, [pc, #204]	; (82208 <_Z8init_bspv+0x130>)
   8213a:	4798      	blx	r3
  pinMode (BUTTON_USER1, 	INPUT);
   8213c:	2100      	movs	r1, #0
   8213e:	2018      	movs	r0, #24
   82140:	4b31      	ldr	r3, [pc, #196]	; (82208 <_Z8init_bspv+0x130>)
   82142:	4798      	blx	r3
  pinMode (BUTTON_USER2, 	INPUT);
   82144:	2100      	movs	r1, #0
   82146:	2019      	movs	r0, #25
   82148:	4b2f      	ldr	r3, [pc, #188]	; (82208 <_Z8init_bspv+0x130>)
   8214a:	4798      	blx	r3
  pinMode (OMRON1, 		INPUT_PULLUP);
   8214c:	2102      	movs	r1, #2
   8214e:	201f      	movs	r0, #31
   82150:	4b2d      	ldr	r3, [pc, #180]	; (82208 <_Z8init_bspv+0x130>)
   82152:	4798      	blx	r3
  pinMode (OMRON2, 		INPUT_PULLUP);
   82154:	2102      	movs	r1, #2
   82156:	201a      	movs	r0, #26
   82158:	4b2b      	ldr	r3, [pc, #172]	; (82208 <_Z8init_bspv+0x130>)
   8215a:	4798      	blx	r3
  pinMode (OMRON3, 		INPUT_PULLUP);
   8215c:	2102      	movs	r1, #2
   8215e:	201b      	movs	r0, #27
   82160:	4b29      	ldr	r3, [pc, #164]	; (82208 <_Z8init_bspv+0x130>)
   82162:	4798      	blx	r3
  pinMode (OMRON4, 		INPUT_PULLUP);
   82164:	2102      	movs	r1, #2
   82166:	201c      	movs	r0, #28
   82168:	4b27      	ldr	r3, [pc, #156]	; (82208 <_Z8init_bspv+0x130>)
   8216a:	4798      	blx	r3
  pinMode (BORDURE_G, 		INPUT);
   8216c:	2100      	movs	r1, #0
   8216e:	201d      	movs	r0, #29
   82170:	4b25      	ldr	r3, [pc, #148]	; (82208 <_Z8init_bspv+0x130>)
   82172:	4798      	blx	r3
  pinMode (BORDURE_D, 		INPUT);
   82174:	2100      	movs	r1, #0
   82176:	201e      	movs	r0, #30
   82178:	4b23      	ldr	r3, [pc, #140]	; (82208 <_Z8init_bspv+0x130>)
   8217a:	4798      	blx	r3
  pinMode (CS_SDCARD, 		OUTPUT);
   8217c:	2101      	movs	r1, #1
   8217e:	2020      	movs	r0, #32
   82180:	4b21      	ldr	r3, [pc, #132]	; (82208 <_Z8init_bspv+0x130>)
   82182:	4798      	blx	r3
  pinMode (PAPG_DIR, 		OUTPUT);
   82184:	2101      	movs	r1, #1
   82186:	2022      	movs	r0, #34	; 0x22
   82188:	4b1f      	ldr	r3, [pc, #124]	; (82208 <_Z8init_bspv+0x130>)
   8218a:	4798      	blx	r3
  pinMode (PAPG_STEP, 		OUTPUT);
   8218c:	2101      	movs	r1, #1
   8218e:	2023      	movs	r0, #35	; 0x23
   82190:	4b1d      	ldr	r3, [pc, #116]	; (82208 <_Z8init_bspv+0x130>)
   82192:	4798      	blx	r3
  pinMode (PAPD_DIR, 		OUTPUT);
   82194:	2101      	movs	r1, #1
   82196:	2024      	movs	r0, #36	; 0x24
   82198:	4b1b      	ldr	r3, [pc, #108]	; (82208 <_Z8init_bspv+0x130>)
   8219a:	4798      	blx	r3
  pinMode (PAPD_STEP, 		OUTPUT);
   8219c:	2101      	movs	r1, #1
   8219e:	2025      	movs	r0, #37	; 0x25
   821a0:	4b19      	ldr	r3, [pc, #100]	; (82208 <_Z8init_bspv+0x130>)
   821a2:	4798      	blx	r3
  pinMode (DEBUG_1,     	OUTPUT);
   821a4:	2101      	movs	r1, #1
   821a6:	2026      	movs	r0, #38	; 0x26
   821a8:	4b17      	ldr	r3, [pc, #92]	; (82208 <_Z8init_bspv+0x130>)
   821aa:	4798      	blx	r3
  pinMode (DEBUG_2,     	OUTPUT);
   821ac:	2101      	movs	r1, #1
   821ae:	2027      	movs	r0, #39	; 0x27
   821b0:	4b15      	ldr	r3, [pc, #84]	; (82208 <_Z8init_bspv+0x130>)
   821b2:	4798      	blx	r3
  //pinMode (US_TRIG_1, 	OUTPUT);
  //pinMode (US_ECHO_1, 	INPUT);
  //pinMode (US_TRIG_2, 	OUTPUT);
  //pinMode (US_ECHO_2, 	INPUT);
  pinMode (PAP_ENABLE,		OUTPUT);
   821b4:	2101      	movs	r1, #1
   821b6:	202c      	movs	r0, #44	; 0x2c
   821b8:	4b13      	ldr	r3, [pc, #76]	; (82208 <_Z8init_bspv+0x130>)
   821ba:	4798      	blx	r3
  pinMode (LED1, 		OUTPUT);
   821bc:	2101      	movs	r1, #1
   821be:	202f      	movs	r0, #47	; 0x2f
   821c0:	4b11      	ldr	r3, [pc, #68]	; (82208 <_Z8init_bspv+0x130>)
   821c2:	4798      	blx	r3
  pinMode (LED2, 		OUTPUT);
   821c4:	2101      	movs	r1, #1
   821c6:	2030      	movs	r0, #48	; 0x30
   821c8:	4b0f      	ldr	r3, [pc, #60]	; (82208 <_Z8init_bspv+0x130>)
   821ca:	4798      	blx	r3
  pinMode (LED3, 		OUTPUT);
   821cc:	2101      	movs	r1, #1
   821ce:	2031      	movs	r0, #49	; 0x31
   821d0:	4b0d      	ldr	r3, [pc, #52]	; (82208 <_Z8init_bspv+0x130>)
   821d2:	4798      	blx	r3
  pinMode (LED4, 		OUTPUT);
   821d4:	2101      	movs	r1, #1
   821d6:	2032      	movs	r0, #50	; 0x32
   821d8:	4b0b      	ldr	r3, [pc, #44]	; (82208 <_Z8init_bspv+0x130>)
   821da:	4798      	blx	r3
  pinMode (LED_RGB_R, 		OUTPUT);
   821dc:	2101      	movs	r1, #1
   821de:	2033      	movs	r0, #51	; 0x33
   821e0:	4b09      	ldr	r3, [pc, #36]	; (82208 <_Z8init_bspv+0x130>)
   821e2:	4798      	blx	r3
  pinMode (LED_RGB_G, 		OUTPUT);
   821e4:	2101      	movs	r1, #1
   821e6:	2034      	movs	r0, #52	; 0x34
   821e8:	4b07      	ldr	r3, [pc, #28]	; (82208 <_Z8init_bspv+0x130>)
   821ea:	4798      	blx	r3
  pinMode (LED_RGB_B, 		OUTPUT);
   821ec:	2101      	movs	r1, #1
   821ee:	2035      	movs	r0, #53	; 0x35
   821f0:	4b05      	ldr	r3, [pc, #20]	; (82208 <_Z8init_bspv+0x130>)
   821f2:	4798      	blx	r3
  pinMode (LED_DUE_RX, 		OUTPUT);
   821f4:	2101      	movs	r1, #1
   821f6:	2048      	movs	r0, #72	; 0x48
   821f8:	4b03      	ldr	r3, [pc, #12]	; (82208 <_Z8init_bspv+0x130>)
   821fa:	4798      	blx	r3
  pinMode (LED_DUE_TX, 		OUTPUT);
   821fc:	2101      	movs	r1, #1
   821fe:	2049      	movs	r0, #73	; 0x49
   82200:	4b01      	ldr	r3, [pc, #4]	; (82208 <_Z8init_bspv+0x130>)
   82202:	4798      	blx	r3

}
   82204:	bf00      	nop
   82206:	bd80      	pop	{r7, pc}
   82208:	00081cc5 	.word	0x00081cc5

0008220c <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
   8220c:	b580      	push	{r7, lr}
   8220e:	b082      	sub	sp, #8
   82210:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc = &_etext;
   82212:	4b1d      	ldr	r3, [pc, #116]	; (82288 <Reset_Handler+0x7c>)
   82214:	607b      	str	r3, [r7, #4]
	pDest = &_srelocate;
   82216:	4b1d      	ldr	r3, [pc, #116]	; (8228c <Reset_Handler+0x80>)
   82218:	603b      	str	r3, [r7, #0]

	if (pSrc != pDest) {
   8221a:	687a      	ldr	r2, [r7, #4]
   8221c:	683b      	ldr	r3, [r7, #0]
   8221e:	429a      	cmp	r2, r3
   82220:	d00c      	beq.n	8223c <Reset_Handler+0x30>
		for (; pDest < &_erelocate;) {
   82222:	e007      	b.n	82234 <Reset_Handler+0x28>
			*pDest++ = *pSrc++;
   82224:	683b      	ldr	r3, [r7, #0]
   82226:	1d1a      	adds	r2, r3, #4
   82228:	603a      	str	r2, [r7, #0]
   8222a:	687a      	ldr	r2, [r7, #4]
   8222c:	1d11      	adds	r1, r2, #4
   8222e:	6079      	str	r1, [r7, #4]
   82230:	6812      	ldr	r2, [r2, #0]
   82232:	601a      	str	r2, [r3, #0]
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
   82234:	683b      	ldr	r3, [r7, #0]
   82236:	4a16      	ldr	r2, [pc, #88]	; (82290 <Reset_Handler+0x84>)
   82238:	4293      	cmp	r3, r2
   8223a:	d3f3      	bcc.n	82224 <Reset_Handler+0x18>
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   8223c:	4b15      	ldr	r3, [pc, #84]	; (82294 <Reset_Handler+0x88>)
   8223e:	603b      	str	r3, [r7, #0]
   82240:	e004      	b.n	8224c <Reset_Handler+0x40>
		*pDest++ = 0;
   82242:	683b      	ldr	r3, [r7, #0]
   82244:	1d1a      	adds	r2, r3, #4
   82246:	603a      	str	r2, [r7, #0]
   82248:	2200      	movs	r2, #0
   8224a:	601a      	str	r2, [r3, #0]
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   8224c:	683b      	ldr	r3, [r7, #0]
   8224e:	4a12      	ldr	r2, [pc, #72]	; (82298 <Reset_Handler+0x8c>)
   82250:	4293      	cmp	r3, r2
   82252:	d3f6      	bcc.n	82242 <Reset_Handler+0x36>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
   82254:	4b11      	ldr	r3, [pc, #68]	; (8229c <Reset_Handler+0x90>)
   82256:	607b      	str	r3, [r7, #4]
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   82258:	4a11      	ldr	r2, [pc, #68]	; (822a0 <Reset_Handler+0x94>)
   8225a:	687b      	ldr	r3, [r7, #4]
   8225c:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   82260:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   82264:	6093      	str	r3, [r2, #8]

	if (((uint32_t) pSrc >= IRAM0_ADDR) && ((uint32_t) pSrc < NFC_RAM_ADDR)) {
   82266:	687b      	ldr	r3, [r7, #4]
   82268:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   8226c:	d309      	bcc.n	82282 <Reset_Handler+0x76>
   8226e:	687b      	ldr	r3, [r7, #4]
   82270:	4a0c      	ldr	r2, [pc, #48]	; (822a4 <Reset_Handler+0x98>)
   82272:	4293      	cmp	r3, r2
   82274:	d805      	bhi.n	82282 <Reset_Handler+0x76>
		SCB->VTOR |= (1UL) << SCB_VTOR_TBLBASE_Pos;
   82276:	4a0a      	ldr	r2, [pc, #40]	; (822a0 <Reset_Handler+0x94>)
   82278:	4b09      	ldr	r3, [pc, #36]	; (822a0 <Reset_Handler+0x94>)
   8227a:	689b      	ldr	r3, [r3, #8]
   8227c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   82280:	6093      	str	r3, [r2, #8]

	// Arduino: we must setup hardware before doing this
	//__libc_init_array();

	/* Branch to main function */
	main();
   82282:	4b09      	ldr	r3, [pc, #36]	; (822a8 <Reset_Handler+0x9c>)
   82284:	4798      	blx	r3

	/* Infinite loop */
	while (1);
   82286:	e7fe      	b.n	82286 <Reset_Handler+0x7a>
   82288:	0009b368 	.word	0x0009b368
   8228c:	20070000 	.word	0x20070000
   82290:	200709bc 	.word	0x200709bc
   82294:	200709bc 	.word	0x200709bc
   82298:	20071d04 	.word	0x20071d04
   8229c:	00080000 	.word	0x00080000
   822a0:	e000ed00 	.word	0xe000ed00
   822a4:	200fffff 	.word	0x200fffff
   822a8:	000802e9 	.word	0x000802e9

000822ac <SystemInit>:
/**
 * \brief Setup the microcontroller system.
 * Initialize the System and update the SystemFrequency variable.
 */
void SystemInit(void)
{
   822ac:	b480      	push	{r7}
   822ae:	af00      	add	r7, sp, #0
	/* Set FWS according to SYS_BOARD_MCKR configuration */
	EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
   822b0:	4b2a      	ldr	r3, [pc, #168]	; (8235c <SystemInit+0xb0>)
   822b2:	f44f 6280 	mov.w	r2, #1024	; 0x400
   822b6:	601a      	str	r2, [r3, #0]
	EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
   822b8:	4b29      	ldr	r3, [pc, #164]	; (82360 <SystemInit+0xb4>)
   822ba:	f44f 6280 	mov.w	r2, #1024	; 0x400
   822be:	601a      	str	r2, [r3, #0]

	/* Initialize main oscillator */
	if (!(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)) {
   822c0:	4b28      	ldr	r3, [pc, #160]	; (82364 <SystemInit+0xb8>)
   822c2:	6a1b      	ldr	r3, [r3, #32]
   822c4:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
   822c8:	2b00      	cmp	r3, #0
   822ca:	d109      	bne.n	822e0 <SystemInit+0x34>
		PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT | 
   822cc:	4b25      	ldr	r3, [pc, #148]	; (82364 <SystemInit+0xb8>)
   822ce:	4a26      	ldr	r2, [pc, #152]	; (82368 <SystemInit+0xbc>)
   822d0:	621a      	str	r2, [r3, #32]
			                     CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN;
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS)) {
   822d2:	bf00      	nop
   822d4:	4b23      	ldr	r3, [pc, #140]	; (82364 <SystemInit+0xb8>)
   822d6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   822d8:	f003 0301 	and.w	r3, r3, #1
   822dc:	2b00      	cmp	r3, #0
   822de:	d0f9      	beq.n	822d4 <SystemInit+0x28>
		}
	}

	/* Switch to 3-20MHz Xtal oscillator */
	PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT | 
   822e0:	4b20      	ldr	r3, [pc, #128]	; (82364 <SystemInit+0xb8>)
   822e2:	4a22      	ldr	r2, [pc, #136]	; (8236c <SystemInit+0xc0>)
   822e4:	621a      	str	r2, [r3, #32]
	                           CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCSEL;

	while (!(PMC->PMC_SR & PMC_SR_MOSCSELS)) {
   822e6:	bf00      	nop
   822e8:	4b1e      	ldr	r3, [pc, #120]	; (82364 <SystemInit+0xb8>)
   822ea:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   822ec:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
   822f0:	2b00      	cmp	r3, #0
   822f2:	d0f9      	beq.n	822e8 <SystemInit+0x3c>
	}
 	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk) | 
   822f4:	4a1b      	ldr	r2, [pc, #108]	; (82364 <SystemInit+0xb8>)
   822f6:	4b1b      	ldr	r3, [pc, #108]	; (82364 <SystemInit+0xb8>)
   822f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   822fa:	f023 0303 	bic.w	r3, r3, #3
   822fe:	f043 0301 	orr.w	r3, r3, #1
   82302:	6313      	str	r3, [r2, #48]	; 0x30
		                     PMC_MCKR_CSS_MAIN_CLK;
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
   82304:	bf00      	nop
   82306:	4b17      	ldr	r3, [pc, #92]	; (82364 <SystemInit+0xb8>)
   82308:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8230a:	f003 0308 	and.w	r3, r3, #8
   8230e:	2b00      	cmp	r3, #0
   82310:	d0f9      	beq.n	82306 <SystemInit+0x5a>
	}

	/* Initialize PLLA */
	PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
   82312:	4b14      	ldr	r3, [pc, #80]	; (82364 <SystemInit+0xb8>)
   82314:	4a16      	ldr	r2, [pc, #88]	; (82370 <SystemInit+0xc4>)
   82316:	629a      	str	r2, [r3, #40]	; 0x28
	while (!(PMC->PMC_SR & PMC_SR_LOCKA)) {
   82318:	bf00      	nop
   8231a:	4b12      	ldr	r3, [pc, #72]	; (82364 <SystemInit+0xb8>)
   8231c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8231e:	f003 0302 	and.w	r3, r3, #2
   82322:	2b00      	cmp	r3, #0
   82324:	d0f9      	beq.n	8231a <SystemInit+0x6e>
	}

	/* Switch to main clock */
	PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
   82326:	4b0f      	ldr	r3, [pc, #60]	; (82364 <SystemInit+0xb8>)
   82328:	2211      	movs	r2, #17
   8232a:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
   8232c:	bf00      	nop
   8232e:	4b0d      	ldr	r3, [pc, #52]	; (82364 <SystemInit+0xb8>)
   82330:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   82332:	f003 0308 	and.w	r3, r3, #8
   82336:	2b00      	cmp	r3, #0
   82338:	d0f9      	beq.n	8232e <SystemInit+0x82>
	}

	/* Switch to PLLA */
	PMC->PMC_MCKR = SYS_BOARD_MCKR;
   8233a:	4b0a      	ldr	r3, [pc, #40]	; (82364 <SystemInit+0xb8>)
   8233c:	2212      	movs	r2, #18
   8233e:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
   82340:	bf00      	nop
   82342:	4b08      	ldr	r3, [pc, #32]	; (82364 <SystemInit+0xb8>)
   82344:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   82346:	f003 0308 	and.w	r3, r3, #8
   8234a:	2b00      	cmp	r3, #0
   8234c:	d0f9      	beq.n	82342 <SystemInit+0x96>
	}

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
   8234e:	4b09      	ldr	r3, [pc, #36]	; (82374 <SystemInit+0xc8>)
   82350:	4a09      	ldr	r2, [pc, #36]	; (82378 <SystemInit+0xcc>)
   82352:	601a      	str	r2, [r3, #0]
}
   82354:	bf00      	nop
   82356:	46bd      	mov	sp, r7
   82358:	bc80      	pop	{r7}
   8235a:	4770      	bx	lr
   8235c:	400e0a00 	.word	0x400e0a00
   82360:	400e0c00 	.word	0x400e0c00
   82364:	400e0600 	.word	0x400e0600
   82368:	00370809 	.word	0x00370809
   8236c:	01370809 	.word	0x01370809
   82370:	200d3f01 	.word	0x200d3f01
   82374:	20070090 	.word	0x20070090
   82378:	0501bd00 	.word	0x0501bd00

0008237c <NVIC_EnableIRQ>:
    The interrupt number cannot be a negative value.

    \param [in]      IRQn  Number of the external interrupt to enable
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   8237c:	b480      	push	{r7}
   8237e:	b083      	sub	sp, #12
   82380:	af00      	add	r7, sp, #0
   82382:	4603      	mov	r3, r0
   82384:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   82386:	4908      	ldr	r1, [pc, #32]	; (823a8 <NVIC_EnableIRQ+0x2c>)
   82388:	f997 3007 	ldrsb.w	r3, [r7, #7]
   8238c:	095b      	lsrs	r3, r3, #5
   8238e:	79fa      	ldrb	r2, [r7, #7]
   82390:	f002 021f 	and.w	r2, r2, #31
   82394:	2001      	movs	r0, #1
   82396:	fa00 f202 	lsl.w	r2, r0, r2
   8239a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   8239e:	bf00      	nop
   823a0:	370c      	adds	r7, #12
   823a2:	46bd      	mov	sp, r7
   823a4:	bc80      	pop	{r7}
   823a6:	4770      	bx	lr
   823a8:	e000e100 	.word	0xe000e100

000823ac <NVIC_ClearPendingIRQ>:
    The interrupt number cannot be a negative value.

    \param [in]      IRQn  Number of the interrupt for clear pending
 */
static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
   823ac:	b480      	push	{r7}
   823ae:	b083      	sub	sp, #12
   823b0:	af00      	add	r7, sp, #0
   823b2:	4603      	mov	r3, r0
   823b4:	71fb      	strb	r3, [r7, #7]
  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
   823b6:	4909      	ldr	r1, [pc, #36]	; (823dc <NVIC_ClearPendingIRQ+0x30>)
   823b8:	f997 3007 	ldrsb.w	r3, [r7, #7]
   823bc:	095b      	lsrs	r3, r3, #5
   823be:	79fa      	ldrb	r2, [r7, #7]
   823c0:	f002 021f 	and.w	r2, r2, #31
   823c4:	2001      	movs	r0, #1
   823c6:	fa00 f202 	lsl.w	r2, r0, r2
   823ca:	3360      	adds	r3, #96	; 0x60
   823cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   823d0:	bf00      	nop
   823d2:	370c      	adds	r7, #12
   823d4:	46bd      	mov	sp, r7
   823d6:	bc80      	pop	{r7}
   823d8:	4770      	bx	lr
   823da:	bf00      	nop
   823dc:	e000e100 	.word	0xe000e100

000823e0 <_ZN8DueTimerC1Et>:
#endif
DueTimer Timer6(6);
DueTimer Timer7(7);
DueTimer Timer8(8);

DueTimer::DueTimer(unsigned short _timer) : timer(_timer){
   823e0:	b480      	push	{r7}
   823e2:	b083      	sub	sp, #12
   823e4:	af00      	add	r7, sp, #0
   823e6:	6078      	str	r0, [r7, #4]
   823e8:	460b      	mov	r3, r1
   823ea:	807b      	strh	r3, [r7, #2]
   823ec:	687b      	ldr	r3, [r7, #4]
   823ee:	887a      	ldrh	r2, [r7, #2]
   823f0:	801a      	strh	r2, [r3, #0]
	/*
		The constructor of the class DueTimer 
	*/
}
   823f2:	687b      	ldr	r3, [r7, #4]
   823f4:	4618      	mov	r0, r3
   823f6:	370c      	adds	r7, #12
   823f8:	46bd      	mov	sp, r7
   823fa:	bc80      	pop	{r7}
   823fc:	4770      	bx	lr
   823fe:	bf00      	nop

00082400 <_ZN8DueTimer15attachInterruptEPFvvE>:
	}
	// Default, return Timer0;
	return DueTimer(0);
}

DueTimer& DueTimer::attachInterrupt(void (*isr)()){
   82400:	b480      	push	{r7}
   82402:	b083      	sub	sp, #12
   82404:	af00      	add	r7, sp, #0
   82406:	6078      	str	r0, [r7, #4]
   82408:	6039      	str	r1, [r7, #0]
	/*
		Links the function passed as argument to the timer of the object
	*/

	callbacks[timer] = isr;
   8240a:	687b      	ldr	r3, [r7, #4]
   8240c:	881b      	ldrh	r3, [r3, #0]
   8240e:	4619      	mov	r1, r3
   82410:	4a04      	ldr	r2, [pc, #16]	; (82424 <_ZN8DueTimer15attachInterruptEPFvvE+0x24>)
   82412:	683b      	ldr	r3, [r7, #0]
   82414:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

	return *this;
   82418:	687b      	ldr	r3, [r7, #4]
}
   8241a:	4618      	mov	r0, r3
   8241c:	370c      	adds	r7, #12
   8241e:	46bd      	mov	sp, r7
   82420:	bc80      	pop	{r7}
   82422:	4770      	bx	lr
   82424:	20070094 	.word	0x20070094

00082428 <_ZN8DueTimer5startEl>:
	callbacks[timer] = NULL;

	return *this;
}

DueTimer& DueTimer::start(long microseconds){
   82428:	b590      	push	{r4, r7, lr}
   8242a:	b083      	sub	sp, #12
   8242c:	af00      	add	r7, sp, #0
   8242e:	6078      	str	r0, [r7, #4]
   82430:	6039      	str	r1, [r7, #0]
	/*
		Start the timer
		If a period is set, then sets the period and start the timer
	*/

	if(microseconds > 0)
   82432:	683b      	ldr	r3, [r7, #0]
   82434:	2b00      	cmp	r3, #0
   82436:	dd04      	ble.n	82442 <_ZN8DueTimer5startEl+0x1a>
		setPeriod(microseconds);
   82438:	683b      	ldr	r3, [r7, #0]
   8243a:	4619      	mov	r1, r3
   8243c:	6878      	ldr	r0, [r7, #4]
   8243e:	4b29      	ldr	r3, [pc, #164]	; (824e4 <_ZN8DueTimer5startEl+0xbc>)
   82440:	4798      	blx	r3
	
	if(_frequency[timer] <= 0)
   82442:	687b      	ldr	r3, [r7, #4]
   82444:	881b      	ldrh	r3, [r3, #0]
   82446:	4a28      	ldr	r2, [pc, #160]	; (824e8 <_ZN8DueTimer5startEl+0xc0>)
   82448:	00db      	lsls	r3, r3, #3
   8244a:	4413      	add	r3, r2
   8244c:	e9d3 0100 	ldrd	r0, r1, [r3]
   82450:	4c26      	ldr	r4, [pc, #152]	; (824ec <_ZN8DueTimer5startEl+0xc4>)
   82452:	f04f 0200 	mov.w	r2, #0
   82456:	f04f 0300 	mov.w	r3, #0
   8245a:	47a0      	blx	r4
   8245c:	4603      	mov	r3, r0
   8245e:	2b00      	cmp	r3, #0
   82460:	d005      	beq.n	8246e <_ZN8DueTimer5startEl+0x46>
		setFrequency(1);
   82462:	f04f 0200 	mov.w	r2, #0
   82466:	4b22      	ldr	r3, [pc, #136]	; (824f0 <_ZN8DueTimer5startEl+0xc8>)
   82468:	6878      	ldr	r0, [r7, #4]
   8246a:	4922      	ldr	r1, [pc, #136]	; (824f4 <_ZN8DueTimer5startEl+0xcc>)
   8246c:	4788      	blx	r1

	NVIC_ClearPendingIRQ(Timers[timer].irq);
   8246e:	687b      	ldr	r3, [r7, #4]
   82470:	881b      	ldrh	r3, [r3, #0]
   82472:	4619      	mov	r1, r3
   82474:	4a20      	ldr	r2, [pc, #128]	; (824f8 <_ZN8DueTimer5startEl+0xd0>)
   82476:	460b      	mov	r3, r1
   82478:	005b      	lsls	r3, r3, #1
   8247a:	440b      	add	r3, r1
   8247c:	009b      	lsls	r3, r3, #2
   8247e:	4413      	add	r3, r2
   82480:	3308      	adds	r3, #8
   82482:	f993 3000 	ldrsb.w	r3, [r3]
   82486:	4618      	mov	r0, r3
   82488:	4b1c      	ldr	r3, [pc, #112]	; (824fc <_ZN8DueTimer5startEl+0xd4>)
   8248a:	4798      	blx	r3
	NVIC_EnableIRQ(Timers[timer].irq);
   8248c:	687b      	ldr	r3, [r7, #4]
   8248e:	881b      	ldrh	r3, [r3, #0]
   82490:	4619      	mov	r1, r3
   82492:	4a19      	ldr	r2, [pc, #100]	; (824f8 <_ZN8DueTimer5startEl+0xd0>)
   82494:	460b      	mov	r3, r1
   82496:	005b      	lsls	r3, r3, #1
   82498:	440b      	add	r3, r1
   8249a:	009b      	lsls	r3, r3, #2
   8249c:	4413      	add	r3, r2
   8249e:	3308      	adds	r3, #8
   824a0:	f993 3000 	ldrsb.w	r3, [r3]
   824a4:	4618      	mov	r0, r3
   824a6:	4b16      	ldr	r3, [pc, #88]	; (82500 <_ZN8DueTimer5startEl+0xd8>)
   824a8:	4798      	blx	r3
	
	TC_Start(Timers[timer].tc, Timers[timer].channel);
   824aa:	687b      	ldr	r3, [r7, #4]
   824ac:	881b      	ldrh	r3, [r3, #0]
   824ae:	4619      	mov	r1, r3
   824b0:	4a11      	ldr	r2, [pc, #68]	; (824f8 <_ZN8DueTimer5startEl+0xd0>)
   824b2:	460b      	mov	r3, r1
   824b4:	005b      	lsls	r3, r3, #1
   824b6:	440b      	add	r3, r1
   824b8:	009b      	lsls	r3, r3, #2
   824ba:	4413      	add	r3, r2
   824bc:	6818      	ldr	r0, [r3, #0]
   824be:	687b      	ldr	r3, [r7, #4]
   824c0:	881b      	ldrh	r3, [r3, #0]
   824c2:	4619      	mov	r1, r3
   824c4:	4a0c      	ldr	r2, [pc, #48]	; (824f8 <_ZN8DueTimer5startEl+0xd0>)
   824c6:	460b      	mov	r3, r1
   824c8:	005b      	lsls	r3, r3, #1
   824ca:	440b      	add	r3, r1
   824cc:	009b      	lsls	r3, r3, #2
   824ce:	4413      	add	r3, r2
   824d0:	3304      	adds	r3, #4
   824d2:	681b      	ldr	r3, [r3, #0]
   824d4:	4619      	mov	r1, r3
   824d6:	4b0b      	ldr	r3, [pc, #44]	; (82504 <_ZN8DueTimer5startEl+0xdc>)
   824d8:	4798      	blx	r3

	return *this;
   824da:	687b      	ldr	r3, [r7, #4]
}
   824dc:	4618      	mov	r0, r3
   824de:	370c      	adds	r7, #12
   824e0:	46bd      	mov	sp, r7
   824e2:	bd90      	pop	{r4, r7, pc}
   824e4:	00082a49 	.word	0x00082a49
   824e8:	200700b8 	.word	0x200700b8
   824ec:	00092c75 	.word	0x00092c75
   824f0:	3ff00000 	.word	0x3ff00000
   824f4:	00082881 	.word	0x00082881
   824f8:	00099fb8 	.word	0x00099fb8
   824fc:	000823ad 	.word	0x000823ad
   82500:	0008237d 	.word	0x0008237d
   82504:	000881f1 	.word	0x000881f1

00082508 <_ZN8DueTimer9bestClockEdRm>:
	TC_Stop(Timers[timer].tc, Timers[timer].channel);

	return *this;
}

uint8_t DueTimer::bestClock(double frequency, uint32_t& retRC){
   82508:	b5f0      	push	{r4, r5, r6, r7, lr}
   8250a:	b08d      	sub	sp, #52	; 0x34
   8250c:	af00      	add	r7, sp, #0
   8250e:	e9c7 0102 	strd	r0, r1, [r7, #8]
   82512:	607a      	str	r2, [r7, #4]
	} clockConfig[] = {
		{ TC_CMR_TCCLKS_TIMER_CLOCK1,   2 },
		{ TC_CMR_TCCLKS_TIMER_CLOCK2,   8 },
		{ TC_CMR_TCCLKS_TIMER_CLOCK3,  32 },
		{ TC_CMR_TCCLKS_TIMER_CLOCK4, 128 }
	};
   82514:	4a8c      	ldr	r2, [pc, #560]	; (82748 <_ZN8DueTimer9bestClockEdRm+0x240>)
   82516:	f107 0314 	add.w	r3, r7, #20
   8251a:	6810      	ldr	r0, [r2, #0]
   8251c:	6851      	ldr	r1, [r2, #4]
   8251e:	c303      	stmia	r3!, {r0, r1}
	float ticks;
	float error;
	int clkId = 3;
   82520:	2303      	movs	r3, #3
   82522:	62fb      	str	r3, [r7, #44]	; 0x2c
	int bestClock = 3;
   82524:	2303      	movs	r3, #3
   82526:	62bb      	str	r3, [r7, #40]	; 0x28
	float bestError = 9.999e99;
   82528:	f04f 43ff 	mov.w	r3, #2139095040	; 0x7f800000
   8252c:	627b      	str	r3, [r7, #36]	; 0x24
	do
	{
		ticks = (float) VARIANT_MCK / frequency / (float) clockConfig[clkId].divisor;
   8252e:	4c87      	ldr	r4, [pc, #540]	; (8274c <_ZN8DueTimer9bestClockEdRm+0x244>)
   82530:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
   82534:	a182      	add	r1, pc, #520	; (adr r1, 82740 <_ZN8DueTimer9bestClockEdRm+0x238>)
   82536:	e9d1 0100 	ldrd	r0, r1, [r1]
   8253a:	47a0      	blx	r4
   8253c:	4603      	mov	r3, r0
   8253e:	460c      	mov	r4, r1
   82540:	461d      	mov	r5, r3
   82542:	4626      	mov	r6, r4
   82544:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   82546:	005b      	lsls	r3, r3, #1
   82548:	f107 0230 	add.w	r2, r7, #48	; 0x30
   8254c:	4413      	add	r3, r2
   8254e:	f813 2c1b 	ldrb.w	r2, [r3, #-27]
   82552:	4b7f      	ldr	r3, [pc, #508]	; (82750 <_ZN8DueTimer9bestClockEdRm+0x248>)
   82554:	4610      	mov	r0, r2
   82556:	4798      	blx	r3
   82558:	4602      	mov	r2, r0
   8255a:	4b7e      	ldr	r3, [pc, #504]	; (82754 <_ZN8DueTimer9bestClockEdRm+0x24c>)
   8255c:	4610      	mov	r0, r2
   8255e:	4798      	blx	r3
   82560:	4602      	mov	r2, r0
   82562:	460b      	mov	r3, r1
   82564:	4c79      	ldr	r4, [pc, #484]	; (8274c <_ZN8DueTimer9bestClockEdRm+0x244>)
   82566:	4628      	mov	r0, r5
   82568:	4631      	mov	r1, r6
   8256a:	47a0      	blx	r4
   8256c:	4603      	mov	r3, r0
   8256e:	460c      	mov	r4, r1
   82570:	4619      	mov	r1, r3
   82572:	4622      	mov	r2, r4
   82574:	4b78      	ldr	r3, [pc, #480]	; (82758 <_ZN8DueTimer9bestClockEdRm+0x250>)
   82576:	4608      	mov	r0, r1
   82578:	4611      	mov	r1, r2
   8257a:	4798      	blx	r3
   8257c:	4603      	mov	r3, r0
   8257e:	623b      	str	r3, [r7, #32]
		// error = abs(ticks - round(ticks));
		error = clockConfig[clkId].divisor * abs(ticks - round(ticks));	// Error comparison needs scaling
   82580:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   82582:	005b      	lsls	r3, r3, #1
   82584:	f107 0230 	add.w	r2, r7, #48	; 0x30
   82588:	4413      	add	r3, r2
   8258a:	f813 3c1b 	ldrb.w	r3, [r3, #-27]
   8258e:	461a      	mov	r2, r3
   82590:	4b72      	ldr	r3, [pc, #456]	; (8275c <_ZN8DueTimer9bestClockEdRm+0x254>)
   82592:	4610      	mov	r0, r2
   82594:	4798      	blx	r3
   82596:	4605      	mov	r5, r0
   82598:	4b71      	ldr	r3, [pc, #452]	; (82760 <_ZN8DueTimer9bestClockEdRm+0x258>)
   8259a:	f04f 0100 	mov.w	r1, #0
   8259e:	6a38      	ldr	r0, [r7, #32]
   825a0:	4798      	blx	r3
   825a2:	4603      	mov	r3, r0
   825a4:	2b00      	cmp	r3, #0
   825a6:	d015      	beq.n	825d4 <_ZN8DueTimer9bestClockEdRm+0xcc>
   825a8:	4b6a      	ldr	r3, [pc, #424]	; (82754 <_ZN8DueTimer9bestClockEdRm+0x24c>)
   825aa:	6a38      	ldr	r0, [r7, #32]
   825ac:	4798      	blx	r3
   825ae:	4c6d      	ldr	r4, [pc, #436]	; (82764 <_ZN8DueTimer9bestClockEdRm+0x25c>)
   825b0:	f04f 0200 	mov.w	r2, #0
   825b4:	4b6c      	ldr	r3, [pc, #432]	; (82768 <_ZN8DueTimer9bestClockEdRm+0x260>)
   825b6:	47a0      	blx	r4
   825b8:	4603      	mov	r3, r0
   825ba:	460c      	mov	r4, r1
   825bc:	4619      	mov	r1, r3
   825be:	4622      	mov	r2, r4
   825c0:	4b6a      	ldr	r3, [pc, #424]	; (8276c <_ZN8DueTimer9bestClockEdRm+0x264>)
   825c2:	4608      	mov	r0, r1
   825c4:	4611      	mov	r1, r2
   825c6:	4798      	blx	r3
   825c8:	4602      	mov	r2, r0
   825ca:	4b64      	ldr	r3, [pc, #400]	; (8275c <_ZN8DueTimer9bestClockEdRm+0x254>)
   825cc:	4610      	mov	r0, r2
   825ce:	4798      	blx	r3
   825d0:	4602      	mov	r2, r0
   825d2:	e014      	b.n	825fe <_ZN8DueTimer9bestClockEdRm+0xf6>
   825d4:	4b5f      	ldr	r3, [pc, #380]	; (82754 <_ZN8DueTimer9bestClockEdRm+0x24c>)
   825d6:	6a38      	ldr	r0, [r7, #32]
   825d8:	4798      	blx	r3
   825da:	4c65      	ldr	r4, [pc, #404]	; (82770 <_ZN8DueTimer9bestClockEdRm+0x268>)
   825dc:	f04f 0200 	mov.w	r2, #0
   825e0:	4b61      	ldr	r3, [pc, #388]	; (82768 <_ZN8DueTimer9bestClockEdRm+0x260>)
   825e2:	47a0      	blx	r4
   825e4:	4603      	mov	r3, r0
   825e6:	460c      	mov	r4, r1
   825e8:	4619      	mov	r1, r3
   825ea:	4622      	mov	r2, r4
   825ec:	4b5f      	ldr	r3, [pc, #380]	; (8276c <_ZN8DueTimer9bestClockEdRm+0x264>)
   825ee:	4608      	mov	r0, r1
   825f0:	4611      	mov	r1, r2
   825f2:	4798      	blx	r3
   825f4:	4602      	mov	r2, r0
   825f6:	4b59      	ldr	r3, [pc, #356]	; (8275c <_ZN8DueTimer9bestClockEdRm+0x254>)
   825f8:	4610      	mov	r0, r2
   825fa:	4798      	blx	r3
   825fc:	4602      	mov	r2, r0
   825fe:	4b5d      	ldr	r3, [pc, #372]	; (82774 <_ZN8DueTimer9bestClockEdRm+0x26c>)
   82600:	4611      	mov	r1, r2
   82602:	6a38      	ldr	r0, [r7, #32]
   82604:	4798      	blx	r3
   82606:	4603      	mov	r3, r0
   82608:	461a      	mov	r2, r3
   8260a:	4b5b      	ldr	r3, [pc, #364]	; (82778 <_ZN8DueTimer9bestClockEdRm+0x270>)
   8260c:	f04f 0100 	mov.w	r1, #0
   82610:	4610      	mov	r0, r2
   82612:	4798      	blx	r3
   82614:	4603      	mov	r3, r0
   82616:	2b00      	cmp	r3, #0
   82618:	d039      	beq.n	8268e <_ZN8DueTimer9bestClockEdRm+0x186>
   8261a:	4b51      	ldr	r3, [pc, #324]	; (82760 <_ZN8DueTimer9bestClockEdRm+0x258>)
   8261c:	f04f 0100 	mov.w	r1, #0
   82620:	6a38      	ldr	r0, [r7, #32]
   82622:	4798      	blx	r3
   82624:	4603      	mov	r3, r0
   82626:	2b00      	cmp	r3, #0
   82628:	d015      	beq.n	82656 <_ZN8DueTimer9bestClockEdRm+0x14e>
   8262a:	4b4a      	ldr	r3, [pc, #296]	; (82754 <_ZN8DueTimer9bestClockEdRm+0x24c>)
   8262c:	6a38      	ldr	r0, [r7, #32]
   8262e:	4798      	blx	r3
   82630:	4c4c      	ldr	r4, [pc, #304]	; (82764 <_ZN8DueTimer9bestClockEdRm+0x25c>)
   82632:	f04f 0200 	mov.w	r2, #0
   82636:	4b4c      	ldr	r3, [pc, #304]	; (82768 <_ZN8DueTimer9bestClockEdRm+0x260>)
   82638:	47a0      	blx	r4
   8263a:	4603      	mov	r3, r0
   8263c:	460c      	mov	r4, r1
   8263e:	4619      	mov	r1, r3
   82640:	4622      	mov	r2, r4
   82642:	4b4a      	ldr	r3, [pc, #296]	; (8276c <_ZN8DueTimer9bestClockEdRm+0x264>)
   82644:	4608      	mov	r0, r1
   82646:	4611      	mov	r1, r2
   82648:	4798      	blx	r3
   8264a:	4602      	mov	r2, r0
   8264c:	4b43      	ldr	r3, [pc, #268]	; (8275c <_ZN8DueTimer9bestClockEdRm+0x254>)
   8264e:	4610      	mov	r0, r2
   82650:	4798      	blx	r3
   82652:	4602      	mov	r2, r0
   82654:	e014      	b.n	82680 <_ZN8DueTimer9bestClockEdRm+0x178>
   82656:	4b3f      	ldr	r3, [pc, #252]	; (82754 <_ZN8DueTimer9bestClockEdRm+0x24c>)
   82658:	6a38      	ldr	r0, [r7, #32]
   8265a:	4798      	blx	r3
   8265c:	4c44      	ldr	r4, [pc, #272]	; (82770 <_ZN8DueTimer9bestClockEdRm+0x268>)
   8265e:	f04f 0200 	mov.w	r2, #0
   82662:	4b41      	ldr	r3, [pc, #260]	; (82768 <_ZN8DueTimer9bestClockEdRm+0x260>)
   82664:	47a0      	blx	r4
   82666:	4603      	mov	r3, r0
   82668:	460c      	mov	r4, r1
   8266a:	4619      	mov	r1, r3
   8266c:	4622      	mov	r2, r4
   8266e:	4b3f      	ldr	r3, [pc, #252]	; (8276c <_ZN8DueTimer9bestClockEdRm+0x264>)
   82670:	4608      	mov	r0, r1
   82672:	4611      	mov	r1, r2
   82674:	4798      	blx	r3
   82676:	4602      	mov	r2, r0
   82678:	4b38      	ldr	r3, [pc, #224]	; (8275c <_ZN8DueTimer9bestClockEdRm+0x254>)
   8267a:	4610      	mov	r0, r2
   8267c:	4798      	blx	r3
   8267e:	4602      	mov	r2, r0
   82680:	4b3c      	ldr	r3, [pc, #240]	; (82774 <_ZN8DueTimer9bestClockEdRm+0x26c>)
   82682:	4611      	mov	r1, r2
   82684:	6a38      	ldr	r0, [r7, #32]
   82686:	4798      	blx	r3
   82688:	4603      	mov	r3, r0
   8268a:	461a      	mov	r2, r3
   8268c:	e039      	b.n	82702 <_ZN8DueTimer9bestClockEdRm+0x1fa>
   8268e:	4b34      	ldr	r3, [pc, #208]	; (82760 <_ZN8DueTimer9bestClockEdRm+0x258>)
   82690:	f04f 0100 	mov.w	r1, #0
   82694:	6a38      	ldr	r0, [r7, #32]
   82696:	4798      	blx	r3
   82698:	4603      	mov	r3, r0
   8269a:	2b00      	cmp	r3, #0
   8269c:	d015      	beq.n	826ca <_ZN8DueTimer9bestClockEdRm+0x1c2>
   8269e:	4b2d      	ldr	r3, [pc, #180]	; (82754 <_ZN8DueTimer9bestClockEdRm+0x24c>)
   826a0:	6a38      	ldr	r0, [r7, #32]
   826a2:	4798      	blx	r3
   826a4:	4c2f      	ldr	r4, [pc, #188]	; (82764 <_ZN8DueTimer9bestClockEdRm+0x25c>)
   826a6:	f04f 0200 	mov.w	r2, #0
   826aa:	4b2f      	ldr	r3, [pc, #188]	; (82768 <_ZN8DueTimer9bestClockEdRm+0x260>)
   826ac:	47a0      	blx	r4
   826ae:	4603      	mov	r3, r0
   826b0:	460c      	mov	r4, r1
   826b2:	4619      	mov	r1, r3
   826b4:	4622      	mov	r2, r4
   826b6:	4b2d      	ldr	r3, [pc, #180]	; (8276c <_ZN8DueTimer9bestClockEdRm+0x264>)
   826b8:	4608      	mov	r0, r1
   826ba:	4611      	mov	r1, r2
   826bc:	4798      	blx	r3
   826be:	4602      	mov	r2, r0
   826c0:	4b26      	ldr	r3, [pc, #152]	; (8275c <_ZN8DueTimer9bestClockEdRm+0x254>)
   826c2:	4610      	mov	r0, r2
   826c4:	4798      	blx	r3
   826c6:	4602      	mov	r2, r0
   826c8:	e014      	b.n	826f4 <_ZN8DueTimer9bestClockEdRm+0x1ec>
   826ca:	4b22      	ldr	r3, [pc, #136]	; (82754 <_ZN8DueTimer9bestClockEdRm+0x24c>)
   826cc:	6a38      	ldr	r0, [r7, #32]
   826ce:	4798      	blx	r3
   826d0:	4c27      	ldr	r4, [pc, #156]	; (82770 <_ZN8DueTimer9bestClockEdRm+0x268>)
   826d2:	f04f 0200 	mov.w	r2, #0
   826d6:	4b24      	ldr	r3, [pc, #144]	; (82768 <_ZN8DueTimer9bestClockEdRm+0x260>)
   826d8:	47a0      	blx	r4
   826da:	4603      	mov	r3, r0
   826dc:	460c      	mov	r4, r1
   826de:	4619      	mov	r1, r3
   826e0:	4622      	mov	r2, r4
   826e2:	4b22      	ldr	r3, [pc, #136]	; (8276c <_ZN8DueTimer9bestClockEdRm+0x264>)
   826e4:	4608      	mov	r0, r1
   826e6:	4611      	mov	r1, r2
   826e8:	4798      	blx	r3
   826ea:	4602      	mov	r2, r0
   826ec:	4b1b      	ldr	r3, [pc, #108]	; (8275c <_ZN8DueTimer9bestClockEdRm+0x254>)
   826ee:	4610      	mov	r0, r2
   826f0:	4798      	blx	r3
   826f2:	4602      	mov	r2, r0
   826f4:	4b1f      	ldr	r3, [pc, #124]	; (82774 <_ZN8DueTimer9bestClockEdRm+0x26c>)
   826f6:	4611      	mov	r1, r2
   826f8:	6a38      	ldr	r0, [r7, #32]
   826fa:	4798      	blx	r3
   826fc:	4603      	mov	r3, r0
   826fe:	f083 4200 	eor.w	r2, r3, #2147483648	; 0x80000000
   82702:	4b1e      	ldr	r3, [pc, #120]	; (8277c <_ZN8DueTimer9bestClockEdRm+0x274>)
   82704:	4611      	mov	r1, r2
   82706:	4628      	mov	r0, r5
   82708:	4798      	blx	r3
   8270a:	4603      	mov	r3, r0
   8270c:	61fb      	str	r3, [r7, #28]
		if (error < bestError)
   8270e:	4b1c      	ldr	r3, [pc, #112]	; (82780 <_ZN8DueTimer9bestClockEdRm+0x278>)
   82710:	6a79      	ldr	r1, [r7, #36]	; 0x24
   82712:	69f8      	ldr	r0, [r7, #28]
   82714:	4798      	blx	r3
   82716:	4603      	mov	r3, r0
   82718:	2b00      	cmp	r3, #0
   8271a:	d003      	beq.n	82724 <_ZN8DueTimer9bestClockEdRm+0x21c>
		{
			bestClock = clkId;
   8271c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   8271e:	62bb      	str	r3, [r7, #40]	; 0x28
			bestError = error;
   82720:	69fb      	ldr	r3, [r7, #28]
   82722:	627b      	str	r3, [r7, #36]	; 0x24
		}
	} while (clkId-- > 0);
   82724:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   82726:	1e5a      	subs	r2, r3, #1
   82728:	62fa      	str	r2, [r7, #44]	; 0x2c
	float ticks;
	float error;
	int clkId = 3;
	int bestClock = 3;
	float bestError = 9.999e99;
	do
   8272a:	2b00      	cmp	r3, #0
   8272c:	bfcc      	ite	gt
   8272e:	2301      	movgt	r3, #1
   82730:	2300      	movle	r3, #0
   82732:	b2db      	uxtb	r3, r3
   82734:	2b00      	cmp	r3, #0
   82736:	d025      	beq.n	82784 <_ZN8DueTimer9bestClockEdRm+0x27c>
   82738:	e6f9      	b.n	8252e <_ZN8DueTimer9bestClockEdRm+0x26>
   8273a:	bf00      	nop
   8273c:	f3af 8000 	nop.w
   82740:	00000000 	.word	0x00000000
   82744:	419406f4 	.word	0x419406f4
   82748:	0009a024 	.word	0x0009a024
   8274c:	000929d1 	.word	0x000929d1
   82750:	00092f79 	.word	0x00092f79
   82754:	000926d5 	.word	0x000926d5
   82758:	00092d6d 	.word	0x00092d6d
   8275c:	00092f81 	.word	0x00092f81
   82760:	0009338d 	.word	0x0009338d
   82764:	00092419 	.word	0x00092419
   82768:	3fe00000 	.word	0x3fe00000
   8276c:	00092cdd 	.word	0x00092cdd
   82770:	00092415 	.word	0x00092415
   82774:	00092e15 	.word	0x00092e15
   82778:	000933a1 	.word	0x000933a1
   8277c:	00093029 	.word	0x00093029
   82780:	00093365 	.word	0x00093365
		{
			bestClock = clkId;
			bestError = error;
		}
	} while (clkId-- > 0);
	ticks = (float) VARIANT_MCK / frequency / (float) clockConfig[bestClock].divisor;
   82784:	4c34      	ldr	r4, [pc, #208]	; (82858 <_ZN8DueTimer9bestClockEdRm+0x350>)
   82786:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
   8278a:	a131      	add	r1, pc, #196	; (adr r1, 82850 <_ZN8DueTimer9bestClockEdRm+0x348>)
   8278c:	e9d1 0100 	ldrd	r0, r1, [r1]
   82790:	47a0      	blx	r4
   82792:	4603      	mov	r3, r0
   82794:	460c      	mov	r4, r1
   82796:	461d      	mov	r5, r3
   82798:	4626      	mov	r6, r4
   8279a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   8279c:	005b      	lsls	r3, r3, #1
   8279e:	f107 0230 	add.w	r2, r7, #48	; 0x30
   827a2:	4413      	add	r3, r2
   827a4:	f813 2c1b 	ldrb.w	r2, [r3, #-27]
   827a8:	4b2c      	ldr	r3, [pc, #176]	; (8285c <_ZN8DueTimer9bestClockEdRm+0x354>)
   827aa:	4610      	mov	r0, r2
   827ac:	4798      	blx	r3
   827ae:	4602      	mov	r2, r0
   827b0:	4b2b      	ldr	r3, [pc, #172]	; (82860 <_ZN8DueTimer9bestClockEdRm+0x358>)
   827b2:	4610      	mov	r0, r2
   827b4:	4798      	blx	r3
   827b6:	4602      	mov	r2, r0
   827b8:	460b      	mov	r3, r1
   827ba:	4c27      	ldr	r4, [pc, #156]	; (82858 <_ZN8DueTimer9bestClockEdRm+0x350>)
   827bc:	4628      	mov	r0, r5
   827be:	4631      	mov	r1, r6
   827c0:	47a0      	blx	r4
   827c2:	4603      	mov	r3, r0
   827c4:	460c      	mov	r4, r1
   827c6:	4619      	mov	r1, r3
   827c8:	4622      	mov	r2, r4
   827ca:	4b26      	ldr	r3, [pc, #152]	; (82864 <_ZN8DueTimer9bestClockEdRm+0x35c>)
   827cc:	4608      	mov	r0, r1
   827ce:	4611      	mov	r1, r2
   827d0:	4798      	blx	r3
   827d2:	4603      	mov	r3, r0
   827d4:	623b      	str	r3, [r7, #32]
	retRC = (uint32_t) round(ticks);
   827d6:	4b24      	ldr	r3, [pc, #144]	; (82868 <_ZN8DueTimer9bestClockEdRm+0x360>)
   827d8:	f04f 0100 	mov.w	r1, #0
   827dc:	6a38      	ldr	r0, [r7, #32]
   827de:	4798      	blx	r3
   827e0:	4603      	mov	r3, r0
   827e2:	2b00      	cmp	r3, #0
   827e4:	d012      	beq.n	8280c <_ZN8DueTimer9bestClockEdRm+0x304>
   827e6:	4b1e      	ldr	r3, [pc, #120]	; (82860 <_ZN8DueTimer9bestClockEdRm+0x358>)
   827e8:	6a38      	ldr	r0, [r7, #32]
   827ea:	4798      	blx	r3
   827ec:	4c1f      	ldr	r4, [pc, #124]	; (8286c <_ZN8DueTimer9bestClockEdRm+0x364>)
   827ee:	f04f 0200 	mov.w	r2, #0
   827f2:	4b1f      	ldr	r3, [pc, #124]	; (82870 <_ZN8DueTimer9bestClockEdRm+0x368>)
   827f4:	47a0      	blx	r4
   827f6:	4603      	mov	r3, r0
   827f8:	460c      	mov	r4, r1
   827fa:	4619      	mov	r1, r3
   827fc:	4622      	mov	r2, r4
   827fe:	4b1d      	ldr	r3, [pc, #116]	; (82874 <_ZN8DueTimer9bestClockEdRm+0x36c>)
   82800:	4608      	mov	r0, r1
   82802:	4611      	mov	r1, r2
   82804:	4798      	blx	r3
   82806:	4603      	mov	r3, r0
   82808:	461a      	mov	r2, r3
   8280a:	e011      	b.n	82830 <_ZN8DueTimer9bestClockEdRm+0x328>
   8280c:	4b14      	ldr	r3, [pc, #80]	; (82860 <_ZN8DueTimer9bestClockEdRm+0x358>)
   8280e:	6a38      	ldr	r0, [r7, #32]
   82810:	4798      	blx	r3
   82812:	4c19      	ldr	r4, [pc, #100]	; (82878 <_ZN8DueTimer9bestClockEdRm+0x370>)
   82814:	f04f 0200 	mov.w	r2, #0
   82818:	4b15      	ldr	r3, [pc, #84]	; (82870 <_ZN8DueTimer9bestClockEdRm+0x368>)
   8281a:	47a0      	blx	r4
   8281c:	4603      	mov	r3, r0
   8281e:	460c      	mov	r4, r1
   82820:	4619      	mov	r1, r3
   82822:	4622      	mov	r2, r4
   82824:	4b13      	ldr	r3, [pc, #76]	; (82874 <_ZN8DueTimer9bestClockEdRm+0x36c>)
   82826:	4608      	mov	r0, r1
   82828:	4611      	mov	r1, r2
   8282a:	4798      	blx	r3
   8282c:	4603      	mov	r3, r0
   8282e:	461a      	mov	r2, r3
   82830:	687b      	ldr	r3, [r7, #4]
   82832:	601a      	str	r2, [r3, #0]
	return clockConfig[bestClock].flag;
   82834:	6abb      	ldr	r3, [r7, #40]	; 0x28
   82836:	005b      	lsls	r3, r3, #1
   82838:	f107 0230 	add.w	r2, r7, #48	; 0x30
   8283c:	4413      	add	r3, r2
   8283e:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
}
   82842:	4618      	mov	r0, r3
   82844:	3734      	adds	r7, #52	; 0x34
   82846:	46bd      	mov	sp, r7
   82848:	bdf0      	pop	{r4, r5, r6, r7, pc}
   8284a:	bf00      	nop
   8284c:	f3af 8000 	nop.w
   82850:	00000000 	.word	0x00000000
   82854:	419406f4 	.word	0x419406f4
   82858:	000929d1 	.word	0x000929d1
   8285c:	00092f79 	.word	0x00092f79
   82860:	000926d5 	.word	0x000926d5
   82864:	00092d6d 	.word	0x00092d6d
   82868:	0009338d 	.word	0x0009338d
   8286c:	00092419 	.word	0x00092419
   82870:	3fe00000 	.word	0x3fe00000
   82874:	00092cdd 	.word	0x00092cdd
   82878:	00092415 	.word	0x00092415
   8287c:	00000000 	.word	0x00000000

00082880 <_ZN8DueTimer12setFrequencyEd>:


DueTimer& DueTimer::setFrequency(double frequency){
   82880:	b5b0      	push	{r4, r5, r7, lr}
   82882:	b08a      	sub	sp, #40	; 0x28
   82884:	af00      	add	r7, sp, #0
   82886:	60f8      	str	r0, [r7, #12]
   82888:	e9c7 2300 	strd	r2, r3, [r7]
	/*
		Set the timer frequency (in Hz)
	*/

	// Prevent negative frequencies
	if(frequency <= 0) { frequency = 1; }
   8288c:	4c62      	ldr	r4, [pc, #392]	; (82a18 <_ZN8DueTimer12setFrequencyEd+0x198>)
   8288e:	f04f 0200 	mov.w	r2, #0
   82892:	f04f 0300 	mov.w	r3, #0
   82896:	e9d7 0100 	ldrd	r0, r1, [r7]
   8289a:	47a0      	blx	r4
   8289c:	4603      	mov	r3, r0
   8289e:	2b00      	cmp	r3, #0
   828a0:	d004      	beq.n	828ac <_ZN8DueTimer12setFrequencyEd+0x2c>
   828a2:	f04f 0300 	mov.w	r3, #0
   828a6:	4c5d      	ldr	r4, [pc, #372]	; (82a1c <_ZN8DueTimer12setFrequencyEd+0x19c>)
   828a8:	e9c7 3400 	strd	r3, r4, [r7]

	// Remember the frequency — see below how the exact frequency is reported instead
	//_frequency[timer] = frequency;

	// Get current timer configuration
	Timer t = Timers[timer];
   828ac:	68fb      	ldr	r3, [r7, #12]
   828ae:	881b      	ldrh	r3, [r3, #0]
   828b0:	4619      	mov	r1, r3
   828b2:	4a5b      	ldr	r2, [pc, #364]	; (82a20 <_ZN8DueTimer12setFrequencyEd+0x1a0>)
   828b4:	460b      	mov	r3, r1
   828b6:	005b      	lsls	r3, r3, #1
   828b8:	440b      	add	r3, r1
   828ba:	009b      	lsls	r3, r3, #2
   828bc:	441a      	add	r2, r3
   828be:	f107 0318 	add.w	r3, r7, #24
   828c2:	ca07      	ldmia	r2, {r0, r1, r2}
   828c4:	e883 0007 	stmia.w	r3, {r0, r1, r2}

	uint32_t rc = 0;
   828c8:	2300      	movs	r3, #0
   828ca:	617b      	str	r3, [r7, #20]
	uint8_t clock;

	// Tell the Power Management Controller to disable 
	// the write protection of the (Timer/Counter) registers:
	pmc_set_writeprotect(false);
   828cc:	2000      	movs	r0, #0
   828ce:	4b55      	ldr	r3, [pc, #340]	; (82a24 <_ZN8DueTimer12setFrequencyEd+0x1a4>)
   828d0:	4798      	blx	r3

	// Enable clock for the timer
	pmc_enable_periph_clk((uint32_t)t.irq);
   828d2:	f997 3020 	ldrsb.w	r3, [r7, #32]
   828d6:	4618      	mov	r0, r3
   828d8:	4b53      	ldr	r3, [pc, #332]	; (82a28 <_ZN8DueTimer12setFrequencyEd+0x1a8>)
   828da:	4798      	blx	r3

	// Find the best clock for the wanted frequency
	clock = bestClock(frequency, rc);
   828dc:	f107 0314 	add.w	r3, r7, #20
   828e0:	461a      	mov	r2, r3
   828e2:	e9d7 0100 	ldrd	r0, r1, [r7]
   828e6:	4b51      	ldr	r3, [pc, #324]	; (82a2c <_ZN8DueTimer12setFrequencyEd+0x1ac>)
   828e8:	4798      	blx	r3
   828ea:	4603      	mov	r3, r0
   828ec:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	switch (clock) {
   828f0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   828f4:	2b01      	cmp	r3, #1
   828f6:	d019      	beq.n	8292c <_ZN8DueTimer12setFrequencyEd+0xac>
   828f8:	2b02      	cmp	r3, #2
   828fa:	d02d      	beq.n	82958 <_ZN8DueTimer12setFrequencyEd+0xd8>
   828fc:	2b00      	cmp	r3, #0
   828fe:	d141      	bne.n	82984 <_ZN8DueTimer12setFrequencyEd+0x104>
	  case TC_CMR_TCCLKS_TIMER_CLOCK1:
	    _frequency[timer] = (double)VARIANT_MCK / 2.0 / (double)rc;
   82900:	68fb      	ldr	r3, [r7, #12]
   82902:	881b      	ldrh	r3, [r3, #0]
   82904:	461d      	mov	r5, r3
   82906:	697a      	ldr	r2, [r7, #20]
   82908:	4b49      	ldr	r3, [pc, #292]	; (82a30 <_ZN8DueTimer12setFrequencyEd+0x1b0>)
   8290a:	4610      	mov	r0, r2
   8290c:	4798      	blx	r3
   8290e:	4602      	mov	r2, r0
   82910:	460b      	mov	r3, r1
   82912:	4c48      	ldr	r4, [pc, #288]	; (82a34 <_ZN8DueTimer12setFrequencyEd+0x1b4>)
   82914:	a138      	add	r1, pc, #224	; (adr r1, 829f8 <_ZN8DueTimer12setFrequencyEd+0x178>)
   82916:	e9d1 0100 	ldrd	r0, r1, [r1]
   8291a:	47a0      	blx	r4
   8291c:	4603      	mov	r3, r0
   8291e:	460c      	mov	r4, r1
   82920:	4945      	ldr	r1, [pc, #276]	; (82a38 <_ZN8DueTimer12setFrequencyEd+0x1b8>)
   82922:	00ea      	lsls	r2, r5, #3
   82924:	440a      	add	r2, r1
   82926:	e9c2 3400 	strd	r3, r4, [r2]
	    break;
   8292a:	e041      	b.n	829b0 <_ZN8DueTimer12setFrequencyEd+0x130>
	  case TC_CMR_TCCLKS_TIMER_CLOCK2:
	    _frequency[timer] = (double)VARIANT_MCK / 8.0 / (double)rc;
   8292c:	68fb      	ldr	r3, [r7, #12]
   8292e:	881b      	ldrh	r3, [r3, #0]
   82930:	461d      	mov	r5, r3
   82932:	697a      	ldr	r2, [r7, #20]
   82934:	4b3e      	ldr	r3, [pc, #248]	; (82a30 <_ZN8DueTimer12setFrequencyEd+0x1b0>)
   82936:	4610      	mov	r0, r2
   82938:	4798      	blx	r3
   8293a:	4602      	mov	r2, r0
   8293c:	460b      	mov	r3, r1
   8293e:	4c3d      	ldr	r4, [pc, #244]	; (82a34 <_ZN8DueTimer12setFrequencyEd+0x1b4>)
   82940:	a12f      	add	r1, pc, #188	; (adr r1, 82a00 <_ZN8DueTimer12setFrequencyEd+0x180>)
   82942:	e9d1 0100 	ldrd	r0, r1, [r1]
   82946:	47a0      	blx	r4
   82948:	4603      	mov	r3, r0
   8294a:	460c      	mov	r4, r1
   8294c:	493a      	ldr	r1, [pc, #232]	; (82a38 <_ZN8DueTimer12setFrequencyEd+0x1b8>)
   8294e:	00ea      	lsls	r2, r5, #3
   82950:	440a      	add	r2, r1
   82952:	e9c2 3400 	strd	r3, r4, [r2]
	    break;
   82956:	e02b      	b.n	829b0 <_ZN8DueTimer12setFrequencyEd+0x130>
	  case TC_CMR_TCCLKS_TIMER_CLOCK3:
	    _frequency[timer] = (double)VARIANT_MCK / 32.0 / (double)rc;
   82958:	68fb      	ldr	r3, [r7, #12]
   8295a:	881b      	ldrh	r3, [r3, #0]
   8295c:	461d      	mov	r5, r3
   8295e:	697a      	ldr	r2, [r7, #20]
   82960:	4b33      	ldr	r3, [pc, #204]	; (82a30 <_ZN8DueTimer12setFrequencyEd+0x1b0>)
   82962:	4610      	mov	r0, r2
   82964:	4798      	blx	r3
   82966:	4602      	mov	r2, r0
   82968:	460b      	mov	r3, r1
   8296a:	4c32      	ldr	r4, [pc, #200]	; (82a34 <_ZN8DueTimer12setFrequencyEd+0x1b4>)
   8296c:	a126      	add	r1, pc, #152	; (adr r1, 82a08 <_ZN8DueTimer12setFrequencyEd+0x188>)
   8296e:	e9d1 0100 	ldrd	r0, r1, [r1]
   82972:	47a0      	blx	r4
   82974:	4603      	mov	r3, r0
   82976:	460c      	mov	r4, r1
   82978:	492f      	ldr	r1, [pc, #188]	; (82a38 <_ZN8DueTimer12setFrequencyEd+0x1b8>)
   8297a:	00ea      	lsls	r2, r5, #3
   8297c:	440a      	add	r2, r1
   8297e:	e9c2 3400 	strd	r3, r4, [r2]
	    break;
   82982:	e015      	b.n	829b0 <_ZN8DueTimer12setFrequencyEd+0x130>
	  default: // TC_CMR_TCCLKS_TIMER_CLOCK4
	    _frequency[timer] = (double)VARIANT_MCK / 128.0 / (double)rc;
   82984:	68fb      	ldr	r3, [r7, #12]
   82986:	881b      	ldrh	r3, [r3, #0]
   82988:	461d      	mov	r5, r3
   8298a:	697a      	ldr	r2, [r7, #20]
   8298c:	4b28      	ldr	r3, [pc, #160]	; (82a30 <_ZN8DueTimer12setFrequencyEd+0x1b0>)
   8298e:	4610      	mov	r0, r2
   82990:	4798      	blx	r3
   82992:	4602      	mov	r2, r0
   82994:	460b      	mov	r3, r1
   82996:	4c27      	ldr	r4, [pc, #156]	; (82a34 <_ZN8DueTimer12setFrequencyEd+0x1b4>)
   82998:	a11d      	add	r1, pc, #116	; (adr r1, 82a10 <_ZN8DueTimer12setFrequencyEd+0x190>)
   8299a:	e9d1 0100 	ldrd	r0, r1, [r1]
   8299e:	47a0      	blx	r4
   829a0:	4603      	mov	r3, r0
   829a2:	460c      	mov	r4, r1
   829a4:	4924      	ldr	r1, [pc, #144]	; (82a38 <_ZN8DueTimer12setFrequencyEd+0x1b8>)
   829a6:	00ea      	lsls	r2, r5, #3
   829a8:	440a      	add	r2, r1
   829aa:	e9c2 3400 	strd	r3, r4, [r2]
	    break;
   829ae:	bf00      	nop
	}

	// Set up the Timer in waveform mode which creates a PWM
	// in UP mode with automatic trigger on RC Compare
	// and sets it up with the determined internal clock as clock input.
	TC_Configure(t.tc, t.channel, TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC | clock);
   829b0:	69b8      	ldr	r0, [r7, #24]
   829b2:	69f9      	ldr	r1, [r7, #28]
   829b4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   829b8:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
   829bc:	461a      	mov	r2, r3
   829be:	4b1f      	ldr	r3, [pc, #124]	; (82a3c <_ZN8DueTimer12setFrequencyEd+0x1bc>)
   829c0:	4798      	blx	r3
	// Reset counter and fire interrupt when RC value is matched:
	TC_SetRC(t.tc, t.channel, rc);
   829c2:	69bb      	ldr	r3, [r7, #24]
   829c4:	69f9      	ldr	r1, [r7, #28]
   829c6:	697a      	ldr	r2, [r7, #20]
   829c8:	4618      	mov	r0, r3
   829ca:	4b1d      	ldr	r3, [pc, #116]	; (82a40 <_ZN8DueTimer12setFrequencyEd+0x1c0>)
   829cc:	4798      	blx	r3
	// Enable the RC Compare Interrupt...
	t.tc->TC_CHANNEL[t.channel].TC_IER=TC_IER_CPCS;
   829ce:	69ba      	ldr	r2, [r7, #24]
   829d0:	69fb      	ldr	r3, [r7, #28]
   829d2:	019b      	lsls	r3, r3, #6
   829d4:	4413      	add	r3, r2
   829d6:	3324      	adds	r3, #36	; 0x24
   829d8:	2210      	movs	r2, #16
   829da:	601a      	str	r2, [r3, #0]
	// ... and disable all others.
	t.tc->TC_CHANNEL[t.channel].TC_IDR=~TC_IER_CPCS;
   829dc:	69ba      	ldr	r2, [r7, #24]
   829de:	69fb      	ldr	r3, [r7, #28]
   829e0:	019b      	lsls	r3, r3, #6
   829e2:	4413      	add	r3, r2
   829e4:	3328      	adds	r3, #40	; 0x28
   829e6:	f06f 0210 	mvn.w	r2, #16
   829ea:	601a      	str	r2, [r3, #0]

	return *this;
   829ec:	68fb      	ldr	r3, [r7, #12]
}
   829ee:	4618      	mov	r0, r3
   829f0:	3728      	adds	r7, #40	; 0x28
   829f2:	46bd      	mov	sp, r7
   829f4:	bdb0      	pop	{r4, r5, r7, pc}
   829f6:	bf00      	nop
   829f8:	00000000 	.word	0x00000000
   829fc:	418406f4 	.word	0x418406f4
   82a00:	00000000 	.word	0x00000000
   82a04:	416406f4 	.word	0x416406f4
   82a08:	00000000 	.word	0x00000000
   82a0c:	414406f4 	.word	0x414406f4
   82a10:	00000000 	.word	0x00000000
   82a14:	412406f4 	.word	0x412406f4
   82a18:	00092c75 	.word	0x00092c75
   82a1c:	3ff00000 	.word	0x3ff00000
   82a20:	00099fb8 	.word	0x00099fb8
   82a24:	00088161 	.word	0x00088161
   82a28:	00088021 	.word	0x00088021
   82a2c:	00082509 	.word	0x00082509
   82a30:	00092691 	.word	0x00092691
   82a34:	000929d1 	.word	0x000929d1
   82a38:	200700b8 	.word	0x200700b8
   82a3c:	00088199 	.word	0x00088199
   82a40:	00088259 	.word	0x00088259
   82a44:	00000000 	.word	0x00000000

00082a48 <_ZN8DueTimer9setPeriodEm>:

DueTimer& DueTimer::setPeriod(unsigned long microseconds){
   82a48:	b590      	push	{r4, r7, lr}
   82a4a:	b085      	sub	sp, #20
   82a4c:	af00      	add	r7, sp, #0
   82a4e:	6078      	str	r0, [r7, #4]
   82a50:	6039      	str	r1, [r7, #0]
	/*
		Set the period of the timer (in microseconds)
	*/

	// Convert period in microseconds to frequency in Hz
	double frequency = 1000000.0 / microseconds;	
   82a52:	4b0f      	ldr	r3, [pc, #60]	; (82a90 <_ZN8DueTimer9setPeriodEm+0x48>)
   82a54:	6838      	ldr	r0, [r7, #0]
   82a56:	4798      	blx	r3
   82a58:	4602      	mov	r2, r0
   82a5a:	460b      	mov	r3, r1
   82a5c:	4c0d      	ldr	r4, [pc, #52]	; (82a94 <_ZN8DueTimer9setPeriodEm+0x4c>)
   82a5e:	a10a      	add	r1, pc, #40	; (adr r1, 82a88 <_ZN8DueTimer9setPeriodEm+0x40>)
   82a60:	e9d1 0100 	ldrd	r0, r1, [r1]
   82a64:	47a0      	blx	r4
   82a66:	4603      	mov	r3, r0
   82a68:	460c      	mov	r4, r1
   82a6a:	e9c7 3402 	strd	r3, r4, [r7, #8]
	setFrequency(frequency);
   82a6e:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
   82a72:	6878      	ldr	r0, [r7, #4]
   82a74:	4908      	ldr	r1, [pc, #32]	; (82a98 <_ZN8DueTimer9setPeriodEm+0x50>)
   82a76:	4788      	blx	r1
	return *this;
   82a78:	687b      	ldr	r3, [r7, #4]
}
   82a7a:	4618      	mov	r0, r3
   82a7c:	3714      	adds	r7, #20
   82a7e:	46bd      	mov	sp, r7
   82a80:	bd90      	pop	{r4, r7, pc}
   82a82:	bf00      	nop
   82a84:	f3af 8000 	nop.w
   82a88:	00000000 	.word	0x00000000
   82a8c:	412e8480 	.word	0x412e8480
   82a90:	00092691 	.word	0x00092691
   82a94:	000929d1 	.word	0x000929d1
   82a98:	00082881 	.word	0x00082881

00082a9c <TC1_Handler>:
void TC0_Handler(void){
	TC_GetStatus(TC0, 0);
	DueTimer::callbacks[0]();
}
#endif
void TC1_Handler(void){
   82a9c:	b580      	push	{r7, lr}
   82a9e:	af00      	add	r7, sp, #0
	TC_GetStatus(TC0, 1);
   82aa0:	2101      	movs	r1, #1
   82aa2:	4804      	ldr	r0, [pc, #16]	; (82ab4 <TC1_Handler+0x18>)
   82aa4:	4b04      	ldr	r3, [pc, #16]	; (82ab8 <TC1_Handler+0x1c>)
   82aa6:	4798      	blx	r3
	DueTimer::callbacks[1]();
   82aa8:	4b04      	ldr	r3, [pc, #16]	; (82abc <TC1_Handler+0x20>)
   82aaa:	685b      	ldr	r3, [r3, #4]
   82aac:	4798      	blx	r3
}
   82aae:	bf00      	nop
   82ab0:	bd80      	pop	{r7, pc}
   82ab2:	bf00      	nop
   82ab4:	40080000 	.word	0x40080000
   82ab8:	00088235 	.word	0x00088235
   82abc:	20070094 	.word	0x20070094

00082ac0 <TC6_Handler>:
void TC5_Handler(void){
	TC_GetStatus(TC1, 2);
	DueTimer::callbacks[5]();
}
#endif
void TC6_Handler(void){
   82ac0:	b580      	push	{r7, lr}
   82ac2:	af00      	add	r7, sp, #0
	TC_GetStatus(TC2, 0);
   82ac4:	2100      	movs	r1, #0
   82ac6:	4804      	ldr	r0, [pc, #16]	; (82ad8 <TC6_Handler+0x18>)
   82ac8:	4b04      	ldr	r3, [pc, #16]	; (82adc <TC6_Handler+0x1c>)
   82aca:	4798      	blx	r3
	DueTimer::callbacks[6]();
   82acc:	4b04      	ldr	r3, [pc, #16]	; (82ae0 <TC6_Handler+0x20>)
   82ace:	699b      	ldr	r3, [r3, #24]
   82ad0:	4798      	blx	r3
}
   82ad2:	bf00      	nop
   82ad4:	bd80      	pop	{r7, pc}
   82ad6:	bf00      	nop
   82ad8:	40088000 	.word	0x40088000
   82adc:	00088235 	.word	0x00088235
   82ae0:	20070094 	.word	0x20070094

00082ae4 <TC7_Handler>:
void TC7_Handler(void){
   82ae4:	b580      	push	{r7, lr}
   82ae6:	af00      	add	r7, sp, #0
	TC_GetStatus(TC2, 1);
   82ae8:	2101      	movs	r1, #1
   82aea:	4804      	ldr	r0, [pc, #16]	; (82afc <TC7_Handler+0x18>)
   82aec:	4b04      	ldr	r3, [pc, #16]	; (82b00 <TC7_Handler+0x1c>)
   82aee:	4798      	blx	r3
	DueTimer::callbacks[7]();
   82af0:	4b04      	ldr	r3, [pc, #16]	; (82b04 <TC7_Handler+0x20>)
   82af2:	69db      	ldr	r3, [r3, #28]
   82af4:	4798      	blx	r3
}
   82af6:	bf00      	nop
   82af8:	bd80      	pop	{r7, pc}
   82afa:	bf00      	nop
   82afc:	40088000 	.word	0x40088000
   82b00:	00088235 	.word	0x00088235
   82b04:	20070094 	.word	0x20070094

00082b08 <TC8_Handler>:
void TC8_Handler(void){
   82b08:	b580      	push	{r7, lr}
   82b0a:	af00      	add	r7, sp, #0
	TC_GetStatus(TC2, 2);
   82b0c:	2102      	movs	r1, #2
   82b0e:	4804      	ldr	r0, [pc, #16]	; (82b20 <TC8_Handler+0x18>)
   82b10:	4b04      	ldr	r3, [pc, #16]	; (82b24 <TC8_Handler+0x1c>)
   82b12:	4798      	blx	r3
	DueTimer::callbacks[8]();
   82b14:	4b04      	ldr	r3, [pc, #16]	; (82b28 <TC8_Handler+0x20>)
   82b16:	6a1b      	ldr	r3, [r3, #32]
   82b18:	4798      	blx	r3
}
   82b1a:	bf00      	nop
   82b1c:	bd80      	pop	{r7, pc}
   82b1e:	bf00      	nop
   82b20:	40088000 	.word	0x40088000
   82b24:	00088235 	.word	0x00088235
   82b28:	20070094 	.word	0x20070094

00082b2c <_Z41__static_initialization_and_destruction_0ii>:
   82b2c:	b580      	push	{r7, lr}
   82b2e:	b082      	sub	sp, #8
   82b30:	af00      	add	r7, sp, #0
   82b32:	6078      	str	r0, [r7, #4]
   82b34:	6039      	str	r1, [r7, #0]
   82b36:	687b      	ldr	r3, [r7, #4]
   82b38:	2b01      	cmp	r3, #1
   82b3a:	d118      	bne.n	82b6e <_Z41__static_initialization_and_destruction_0ii+0x42>
   82b3c:	683b      	ldr	r3, [r7, #0]
   82b3e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   82b42:	4293      	cmp	r3, r2
   82b44:	d113      	bne.n	82b6e <_Z41__static_initialization_and_destruction_0ii+0x42>
double DueTimer::_frequency[NUM_TIMERS] = {-1,-1,-1,-1,-1,-1,-1,-1,-1};

/*
	Initializing all timers, so you can use them like this: Timer0.start();
*/
DueTimer Timer(0);
   82b46:	2100      	movs	r1, #0
   82b48:	480b      	ldr	r0, [pc, #44]	; (82b78 <_Z41__static_initialization_and_destruction_0ii+0x4c>)
   82b4a:	4b0c      	ldr	r3, [pc, #48]	; (82b7c <_Z41__static_initialization_and_destruction_0ii+0x50>)
   82b4c:	4798      	blx	r3

DueTimer Timer1(1);
   82b4e:	2101      	movs	r1, #1
   82b50:	480b      	ldr	r0, [pc, #44]	; (82b80 <_Z41__static_initialization_and_destruction_0ii+0x54>)
   82b52:	4b0a      	ldr	r3, [pc, #40]	; (82b7c <_Z41__static_initialization_and_destruction_0ii+0x50>)
   82b54:	4798      	blx	r3
	DueTimer Timer2(2);
	DueTimer Timer3(3);
	DueTimer Timer4(4);
	DueTimer Timer5(5);
#endif
DueTimer Timer6(6);
   82b56:	2106      	movs	r1, #6
   82b58:	480a      	ldr	r0, [pc, #40]	; (82b84 <_Z41__static_initialization_and_destruction_0ii+0x58>)
   82b5a:	4b08      	ldr	r3, [pc, #32]	; (82b7c <_Z41__static_initialization_and_destruction_0ii+0x50>)
   82b5c:	4798      	blx	r3
DueTimer Timer7(7);
   82b5e:	2107      	movs	r1, #7
   82b60:	4809      	ldr	r0, [pc, #36]	; (82b88 <_Z41__static_initialization_and_destruction_0ii+0x5c>)
   82b62:	4b06      	ldr	r3, [pc, #24]	; (82b7c <_Z41__static_initialization_and_destruction_0ii+0x50>)
   82b64:	4798      	blx	r3
DueTimer Timer8(8);
   82b66:	2108      	movs	r1, #8
   82b68:	4808      	ldr	r0, [pc, #32]	; (82b8c <_Z41__static_initialization_and_destruction_0ii+0x60>)
   82b6a:	4b04      	ldr	r3, [pc, #16]	; (82b7c <_Z41__static_initialization_and_destruction_0ii+0x50>)
   82b6c:	4798      	blx	r3
	DueTimer::callbacks[7]();
}
void TC8_Handler(void){
	TC_GetStatus(TC2, 2);
	DueTimer::callbacks[8]();
}
   82b6e:	bf00      	nop
   82b70:	3708      	adds	r7, #8
   82b72:	46bd      	mov	sp, r7
   82b74:	bd80      	pop	{r7, pc}
   82b76:	bf00      	nop
   82b78:	200711a4 	.word	0x200711a4
   82b7c:	000823e1 	.word	0x000823e1
   82b80:	200711a8 	.word	0x200711a8
   82b84:	200711ac 	.word	0x200711ac
   82b88:	200711b0 	.word	0x200711b0
   82b8c:	200711b4 	.word	0x200711b4

00082b90 <_GLOBAL__sub_I__ZN8DueTimer6TimersE>:
   82b90:	b580      	push	{r7, lr}
   82b92:	af00      	add	r7, sp, #0
   82b94:	f64f 71ff 	movw	r1, #65535	; 0xffff
   82b98:	2001      	movs	r0, #1
   82b9a:	4b01      	ldr	r3, [pc, #4]	; (82ba0 <_GLOBAL__sub_I__ZN8DueTimer6TimersE+0x10>)
   82b9c:	4798      	blx	r3
   82b9e:	bd80      	pop	{r7, pc}
   82ba0:	00082b2d 	.word	0x00082b2d

00082ba4 <TC3_Handler>:
//------------------------------------------------------------------------------
/// Interrupt handler for the TC0 channel 1.
//------------------------------------------------------------------------------
void Servo_Handler(timer16_Sequence_t timer, Tc *pTc, uint8_t channel);
#if defined (_useTimer1)
void HANDLER_FOR_TIMER1(void) {
   82ba4:	b580      	push	{r7, lr}
   82ba6:	af00      	add	r7, sp, #0
    Servo_Handler(_timer1, TC_FOR_TIMER1, CHANNEL_FOR_TIMER1);
   82ba8:	2200      	movs	r2, #0
   82baa:	4903      	ldr	r1, [pc, #12]	; (82bb8 <TC3_Handler+0x14>)
   82bac:	2000      	movs	r0, #0
   82bae:	4b03      	ldr	r3, [pc, #12]	; (82bbc <TC3_Handler+0x18>)
   82bb0:	4798      	blx	r3
}
   82bb2:	bf00      	nop
   82bb4:	bd80      	pop	{r7, pc}
   82bb6:	bf00      	nop
   82bb8:	40084000 	.word	0x40084000
   82bbc:	00082c31 	.word	0x00082c31

00082bc0 <TC4_Handler>:
#endif
#if defined (_useTimer2)
void HANDLER_FOR_TIMER2(void) {
   82bc0:	b580      	push	{r7, lr}
   82bc2:	af00      	add	r7, sp, #0
    Servo_Handler(_timer2, TC_FOR_TIMER2, CHANNEL_FOR_TIMER2);
   82bc4:	2201      	movs	r2, #1
   82bc6:	4903      	ldr	r1, [pc, #12]	; (82bd4 <TC4_Handler+0x14>)
   82bc8:	2001      	movs	r0, #1
   82bca:	4b03      	ldr	r3, [pc, #12]	; (82bd8 <TC4_Handler+0x18>)
   82bcc:	4798      	blx	r3
}
   82bce:	bf00      	nop
   82bd0:	bd80      	pop	{r7, pc}
   82bd2:	bf00      	nop
   82bd4:	40084000 	.word	0x40084000
   82bd8:	00082c31 	.word	0x00082c31

00082bdc <TC5_Handler>:
#endif
#if defined (_useTimer3)
void HANDLER_FOR_TIMER3(void) {
   82bdc:	b580      	push	{r7, lr}
   82bde:	af00      	add	r7, sp, #0
    Servo_Handler(_timer3, TC_FOR_TIMER3, CHANNEL_FOR_TIMER3);
   82be0:	2202      	movs	r2, #2
   82be2:	4903      	ldr	r1, [pc, #12]	; (82bf0 <TC5_Handler+0x14>)
   82be4:	2002      	movs	r0, #2
   82be6:	4b03      	ldr	r3, [pc, #12]	; (82bf4 <TC5_Handler+0x18>)
   82be8:	4798      	blx	r3
}
   82bea:	bf00      	nop
   82bec:	bd80      	pop	{r7, pc}
   82bee:	bf00      	nop
   82bf0:	40084000 	.word	0x40084000
   82bf4:	00082c31 	.word	0x00082c31

00082bf8 <TC2_Handler>:
#endif
#if defined (_useTimer4)
void HANDLER_FOR_TIMER4(void) {
   82bf8:	b580      	push	{r7, lr}
   82bfa:	af00      	add	r7, sp, #0
    Servo_Handler(_timer4, TC_FOR_TIMER4, CHANNEL_FOR_TIMER4);
   82bfc:	2202      	movs	r2, #2
   82bfe:	4903      	ldr	r1, [pc, #12]	; (82c0c <TC2_Handler+0x14>)
   82c00:	2003      	movs	r0, #3
   82c02:	4b03      	ldr	r3, [pc, #12]	; (82c10 <TC2_Handler+0x18>)
   82c04:	4798      	blx	r3
}
   82c06:	bf00      	nop
   82c08:	bd80      	pop	{r7, pc}
   82c0a:	bf00      	nop
   82c0c:	40080000 	.word	0x40080000
   82c10:	00082c31 	.word	0x00082c31

00082c14 <TC0_Handler>:
#endif
#if defined (_useTimer5)
void HANDLER_FOR_TIMER5(void) {
   82c14:	b580      	push	{r7, lr}
   82c16:	af00      	add	r7, sp, #0
    Servo_Handler(_timer5, TC_FOR_TIMER5, CHANNEL_FOR_TIMER5);
   82c18:	2200      	movs	r2, #0
   82c1a:	4903      	ldr	r1, [pc, #12]	; (82c28 <TC0_Handler+0x14>)
   82c1c:	2004      	movs	r0, #4
   82c1e:	4b03      	ldr	r3, [pc, #12]	; (82c2c <TC0_Handler+0x18>)
   82c20:	4798      	blx	r3
}
   82c22:	bf00      	nop
   82c24:	bd80      	pop	{r7, pc}
   82c26:	bf00      	nop
   82c28:	40080000 	.word	0x40080000
   82c2c:	00082c31 	.word	0x00082c31

00082c30 <_Z13Servo_Handler18timer16_Sequence_tP2Tch>:
#endif

void Servo_Handler(timer16_Sequence_t timer, Tc *tc, uint8_t channel)
{
   82c30:	b590      	push	{r4, r7, lr}
   82c32:	b083      	sub	sp, #12
   82c34:	af00      	add	r7, sp, #0
   82c36:	4603      	mov	r3, r0
   82c38:	6039      	str	r1, [r7, #0]
   82c3a:	71fb      	strb	r3, [r7, #7]
   82c3c:	4613      	mov	r3, r2
   82c3e:	71bb      	strb	r3, [r7, #6]
    // clear interrupt
    tc->TC_CHANNEL[channel].TC_SR;
   82c40:	79bb      	ldrb	r3, [r7, #6]
   82c42:	683a      	ldr	r2, [r7, #0]
   82c44:	019b      	lsls	r3, r3, #6
   82c46:	4413      	add	r3, r2
   82c48:	3320      	adds	r3, #32
   82c4a:	681b      	ldr	r3, [r3, #0]
    if (Channel[timer] < 0) {
   82c4c:	79fb      	ldrb	r3, [r7, #7]
   82c4e:	4a7d      	ldr	r2, [pc, #500]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82c50:	5cd3      	ldrb	r3, [r2, r3]
   82c52:	b25b      	sxtb	r3, r3
   82c54:	b2db      	uxtb	r3, r3
   82c56:	09db      	lsrs	r3, r3, #7
   82c58:	b2db      	uxtb	r3, r3
   82c5a:	2b00      	cmp	r3, #0
   82c5c:	d00c      	beq.n	82c78 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x48>
        tc->TC_CHANNEL[channel].TC_CCR |= TC_CCR_SWTRG; // channel set to -1 indicated that refresh interval completed so reset the timer
   82c5e:	79bb      	ldrb	r3, [r7, #6]
   82c60:	79ba      	ldrb	r2, [r7, #6]
   82c62:	6839      	ldr	r1, [r7, #0]
   82c64:	0192      	lsls	r2, r2, #6
   82c66:	440a      	add	r2, r1
   82c68:	6812      	ldr	r2, [r2, #0]
   82c6a:	f042 0204 	orr.w	r2, r2, #4
   82c6e:	6839      	ldr	r1, [r7, #0]
   82c70:	019b      	lsls	r3, r3, #6
   82c72:	440b      	add	r3, r1
   82c74:	601a      	str	r2, [r3, #0]
   82c76:	e03b      	b.n	82cf0 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0xc0>
    } else {
        if (SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true) {
   82c78:	79fa      	ldrb	r2, [r7, #7]
   82c7a:	4613      	mov	r3, r2
   82c7c:	005b      	lsls	r3, r3, #1
   82c7e:	4413      	add	r3, r2
   82c80:	009b      	lsls	r3, r3, #2
   82c82:	4619      	mov	r1, r3
   82c84:	79fb      	ldrb	r3, [r7, #7]
   82c86:	4a6f      	ldr	r2, [pc, #444]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82c88:	5cd3      	ldrb	r3, [r2, r3]
   82c8a:	b25b      	sxtb	r3, r3
   82c8c:	440b      	add	r3, r1
   82c8e:	4a6e      	ldr	r2, [pc, #440]	; (82e48 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x218>)
   82c90:	7812      	ldrb	r2, [r2, #0]
   82c92:	4293      	cmp	r3, r2
   82c94:	da14      	bge.n	82cc0 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x90>
   82c96:	79fa      	ldrb	r2, [r7, #7]
   82c98:	4613      	mov	r3, r2
   82c9a:	005b      	lsls	r3, r3, #1
   82c9c:	4413      	add	r3, r2
   82c9e:	009b      	lsls	r3, r3, #2
   82ca0:	4619      	mov	r1, r3
   82ca2:	79fb      	ldrb	r3, [r7, #7]
   82ca4:	4a67      	ldr	r2, [pc, #412]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82ca6:	5cd3      	ldrb	r3, [r2, r3]
   82ca8:	b25b      	sxtb	r3, r3
   82caa:	440b      	add	r3, r1
   82cac:	4a67      	ldr	r2, [pc, #412]	; (82e4c <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x21c>)
   82cae:	f812 3033 	ldrb.w	r3, [r2, r3, lsl #3]
   82cb2:	f3c3 1380 	ubfx	r3, r3, #6, #1
   82cb6:	b2db      	uxtb	r3, r3
   82cb8:	2b01      	cmp	r3, #1
   82cba:	d101      	bne.n	82cc0 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x90>
   82cbc:	2301      	movs	r3, #1
   82cbe:	e000      	b.n	82cc2 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x92>
   82cc0:	2300      	movs	r3, #0
   82cc2:	2b00      	cmp	r3, #0
   82cc4:	d014      	beq.n	82cf0 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0xc0>
            digitalWrite(SERVO(timer,Channel[timer]).Pin.nbr, LOW); // pulse this channel low if activated
   82cc6:	79fa      	ldrb	r2, [r7, #7]
   82cc8:	4613      	mov	r3, r2
   82cca:	005b      	lsls	r3, r3, #1
   82ccc:	4413      	add	r3, r2
   82cce:	009b      	lsls	r3, r3, #2
   82cd0:	4619      	mov	r1, r3
   82cd2:	79fb      	ldrb	r3, [r7, #7]
   82cd4:	4a5b      	ldr	r2, [pc, #364]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82cd6:	5cd3      	ldrb	r3, [r2, r3]
   82cd8:	b25b      	sxtb	r3, r3
   82cda:	440b      	add	r3, r1
   82cdc:	4a5b      	ldr	r2, [pc, #364]	; (82e4c <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x21c>)
   82cde:	f812 3033 	ldrb.w	r3, [r2, r3, lsl #3]
   82ce2:	f3c3 0305 	ubfx	r3, r3, #0, #6
   82ce6:	b2db      	uxtb	r3, r3
   82ce8:	2100      	movs	r1, #0
   82cea:	4618      	mov	r0, r3
   82cec:	4b58      	ldr	r3, [pc, #352]	; (82e50 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x220>)
   82cee:	4798      	blx	r3
        }
    }

    Channel[timer]++;    // increment to the next channel
   82cf0:	79fb      	ldrb	r3, [r7, #7]
   82cf2:	4a54      	ldr	r2, [pc, #336]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82cf4:	5cd2      	ldrb	r2, [r2, r3]
   82cf6:	b252      	sxtb	r2, r2
   82cf8:	b2d2      	uxtb	r2, r2
   82cfa:	3201      	adds	r2, #1
   82cfc:	b2d2      	uxtb	r2, r2
   82cfe:	b251      	sxtb	r1, r2
   82d00:	4a50      	ldr	r2, [pc, #320]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82d02:	54d1      	strb	r1, [r2, r3]
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
   82d04:	79fa      	ldrb	r2, [r7, #7]
   82d06:	4613      	mov	r3, r2
   82d08:	005b      	lsls	r3, r3, #1
   82d0a:	4413      	add	r3, r2
   82d0c:	009b      	lsls	r3, r3, #2
   82d0e:	4619      	mov	r1, r3
   82d10:	79fb      	ldrb	r3, [r7, #7]
   82d12:	4a4c      	ldr	r2, [pc, #304]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82d14:	5cd3      	ldrb	r3, [r2, r3]
   82d16:	b25b      	sxtb	r3, r3
   82d18:	440b      	add	r3, r1
   82d1a:	4a4b      	ldr	r2, [pc, #300]	; (82e48 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x218>)
   82d1c:	7812      	ldrb	r2, [r2, #0]
   82d1e:	4293      	cmp	r3, r2
   82d20:	da07      	bge.n	82d32 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x102>
   82d22:	79fb      	ldrb	r3, [r7, #7]
   82d24:	4a47      	ldr	r2, [pc, #284]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82d26:	5cd3      	ldrb	r3, [r2, r3]
   82d28:	b25b      	sxtb	r3, r3
   82d2a:	2b0b      	cmp	r3, #11
   82d2c:	dc01      	bgt.n	82d32 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x102>
   82d2e:	2301      	movs	r3, #1
   82d30:	e000      	b.n	82d34 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x104>
   82d32:	2300      	movs	r3, #0
   82d34:	2b00      	cmp	r3, #0
   82d36:	d044      	beq.n	82dc2 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x192>
        tc->TC_CHANNEL[channel].TC_RA = tc->TC_CHANNEL[channel].TC_CV + SERVO(timer,Channel[timer]).ticks;
   82d38:	79b8      	ldrb	r0, [r7, #6]
   82d3a:	79bb      	ldrb	r3, [r7, #6]
   82d3c:	683a      	ldr	r2, [r7, #0]
   82d3e:	019b      	lsls	r3, r3, #6
   82d40:	4413      	add	r3, r2
   82d42:	3310      	adds	r3, #16
   82d44:	6819      	ldr	r1, [r3, #0]
   82d46:	79fa      	ldrb	r2, [r7, #7]
   82d48:	4613      	mov	r3, r2
   82d4a:	005b      	lsls	r3, r3, #1
   82d4c:	4413      	add	r3, r2
   82d4e:	009b      	lsls	r3, r3, #2
   82d50:	461c      	mov	r4, r3
   82d52:	79fb      	ldrb	r3, [r7, #7]
   82d54:	4a3b      	ldr	r2, [pc, #236]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82d56:	5cd3      	ldrb	r3, [r2, r3]
   82d58:	b25b      	sxtb	r3, r3
   82d5a:	4423      	add	r3, r4
   82d5c:	4a3b      	ldr	r2, [pc, #236]	; (82e4c <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x21c>)
   82d5e:	00db      	lsls	r3, r3, #3
   82d60:	4413      	add	r3, r2
   82d62:	685b      	ldr	r3, [r3, #4]
   82d64:	18ca      	adds	r2, r1, r3
   82d66:	6839      	ldr	r1, [r7, #0]
   82d68:	0183      	lsls	r3, r0, #6
   82d6a:	440b      	add	r3, r1
   82d6c:	3314      	adds	r3, #20
   82d6e:	601a      	str	r2, [r3, #0]
        if(SERVO(timer,Channel[timer]).Pin.isActive == true) {    // check if activated
   82d70:	79fa      	ldrb	r2, [r7, #7]
   82d72:	4613      	mov	r3, r2
   82d74:	005b      	lsls	r3, r3, #1
   82d76:	4413      	add	r3, r2
   82d78:	009b      	lsls	r3, r3, #2
   82d7a:	4619      	mov	r1, r3
   82d7c:	79fb      	ldrb	r3, [r7, #7]
   82d7e:	4a31      	ldr	r2, [pc, #196]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82d80:	5cd3      	ldrb	r3, [r2, r3]
   82d82:	b25b      	sxtb	r3, r3
   82d84:	440b      	add	r3, r1
   82d86:	4a31      	ldr	r2, [pc, #196]	; (82e4c <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x21c>)
   82d88:	f812 3033 	ldrb.w	r3, [r2, r3, lsl #3]
   82d8c:	f3c3 1380 	ubfx	r3, r3, #6, #1
   82d90:	b2db      	uxtb	r3, r3
   82d92:	2b00      	cmp	r3, #0
   82d94:	d051      	beq.n	82e3a <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x20a>
            digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high
   82d96:	79fa      	ldrb	r2, [r7, #7]
   82d98:	4613      	mov	r3, r2
   82d9a:	005b      	lsls	r3, r3, #1
   82d9c:	4413      	add	r3, r2
   82d9e:	009b      	lsls	r3, r3, #2
   82da0:	4619      	mov	r1, r3
   82da2:	79fb      	ldrb	r3, [r7, #7]
   82da4:	4a27      	ldr	r2, [pc, #156]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82da6:	5cd3      	ldrb	r3, [r2, r3]
   82da8:	b25b      	sxtb	r3, r3
   82daa:	440b      	add	r3, r1
   82dac:	4a27      	ldr	r2, [pc, #156]	; (82e4c <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x21c>)
   82dae:	f812 3033 	ldrb.w	r3, [r2, r3, lsl #3]
   82db2:	f3c3 0305 	ubfx	r3, r3, #0, #6
   82db6:	b2db      	uxtb	r3, r3
   82db8:	2101      	movs	r1, #1
   82dba:	4618      	mov	r0, r3
   82dbc:	4b24      	ldr	r3, [pc, #144]	; (82e50 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x220>)
   82dbe:	4798      	blx	r3
        else {
            tc->TC_CHANNEL[channel].TC_RA = tc->TC_CHANNEL[channel].TC_CV + 4;  // at least REFRESH_INTERVAL has elapsed
        }
        Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
    }
}
   82dc0:	e03b      	b.n	82e3a <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x20a>
            digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high
        }
    }
    else {
        // finished all channels so wait for the refresh period to expire before starting over
        if( (tc->TC_CHANNEL[channel].TC_CV) + 4 < usToTicks(REFRESH_INTERVAL) ) { // allow a few ticks to ensure the next OCR1A not missed
   82dc2:	79bb      	ldrb	r3, [r7, #6]
   82dc4:	683a      	ldr	r2, [r7, #0]
   82dc6:	019b      	lsls	r3, r3, #6
   82dc8:	4413      	add	r3, r2
   82dca:	3310      	adds	r3, #16
   82dcc:	681b      	ldr	r3, [r3, #0]
   82dce:	1d1a      	adds	r2, r3, #4
   82dd0:	4b20      	ldr	r3, [pc, #128]	; (82e54 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x224>)
   82dd2:	681b      	ldr	r3, [r3, #0]
   82dd4:	4920      	ldr	r1, [pc, #128]	; (82e58 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x228>)
   82dd6:	fba1 1303 	umull	r1, r3, r1, r3
   82dda:	0c9b      	lsrs	r3, r3, #18
   82ddc:	f644 6120 	movw	r1, #20000	; 0x4e20
   82de0:	fb01 f303 	mul.w	r3, r1, r3
   82de4:	095b      	lsrs	r3, r3, #5
   82de6:	429a      	cmp	r2, r3
   82de8:	bf34      	ite	cc
   82dea:	2301      	movcc	r3, #1
   82dec:	2300      	movcs	r3, #0
   82dee:	b2db      	uxtb	r3, r3
   82df0:	2b00      	cmp	r3, #0
   82df2:	d011      	beq.n	82e18 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x1e8>
            tc->TC_CHANNEL[channel].TC_RA = (unsigned int)usToTicks(REFRESH_INTERVAL);
   82df4:	79bb      	ldrb	r3, [r7, #6]
   82df6:	4a17      	ldr	r2, [pc, #92]	; (82e54 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x224>)
   82df8:	6812      	ldr	r2, [r2, #0]
   82dfa:	4917      	ldr	r1, [pc, #92]	; (82e58 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x228>)
   82dfc:	fba1 1202 	umull	r1, r2, r1, r2
   82e00:	0c92      	lsrs	r2, r2, #18
   82e02:	f644 6120 	movw	r1, #20000	; 0x4e20
   82e06:	fb01 f202 	mul.w	r2, r1, r2
   82e0a:	0952      	lsrs	r2, r2, #5
   82e0c:	6839      	ldr	r1, [r7, #0]
   82e0e:	019b      	lsls	r3, r3, #6
   82e10:	440b      	add	r3, r1
   82e12:	3314      	adds	r3, #20
   82e14:	601a      	str	r2, [r3, #0]
   82e16:	e00c      	b.n	82e32 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x202>
        }
        else {
            tc->TC_CHANNEL[channel].TC_RA = tc->TC_CHANNEL[channel].TC_CV + 4;  // at least REFRESH_INTERVAL has elapsed
   82e18:	79bb      	ldrb	r3, [r7, #6]
   82e1a:	79ba      	ldrb	r2, [r7, #6]
   82e1c:	6839      	ldr	r1, [r7, #0]
   82e1e:	0192      	lsls	r2, r2, #6
   82e20:	440a      	add	r2, r1
   82e22:	3210      	adds	r2, #16
   82e24:	6812      	ldr	r2, [r2, #0]
   82e26:	3204      	adds	r2, #4
   82e28:	6839      	ldr	r1, [r7, #0]
   82e2a:	019b      	lsls	r3, r3, #6
   82e2c:	440b      	add	r3, r1
   82e2e:	3314      	adds	r3, #20
   82e30:	601a      	str	r2, [r3, #0]
        }
        Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
   82e32:	79fb      	ldrb	r3, [r7, #7]
   82e34:	4a03      	ldr	r2, [pc, #12]	; (82e44 <_Z13Servo_Handler18timer16_Sequence_tP2Tch+0x214>)
   82e36:	21ff      	movs	r1, #255	; 0xff
   82e38:	54d1      	strb	r1, [r2, r3]
    }
}
   82e3a:	bf00      	nop
   82e3c:	370c      	adds	r7, #12
   82e3e:	46bd      	mov	sp, r7
   82e40:	bd90      	pop	{r4, r7, pc}
   82e42:	bf00      	nop
   82e44:	2007139c 	.word	0x2007139c
   82e48:	20071398 	.word	0x20071398
   82e4c:	200711b8 	.word	0x200711b8
   82e50:	00081f29 	.word	0x00081f29
   82e54:	20070090 	.word	0x20070090
   82e58:	431bde83 	.word	0x431bde83

00082e5c <delayMS>:
/** calibration factor for delayMS */
#define CAL_FACTOR (F_CPU/7000)
/** delay between led error flashes
 * \param[in] millis milliseconds to delay
 */
static void delayMS(uint32_t millis) {
   82e5c:	b480      	push	{r7}
   82e5e:	b085      	sub	sp, #20
   82e60:	af00      	add	r7, sp, #0
   82e62:	6078      	str	r0, [r7, #4]
  uint32_t iterations = millis * CAL_FACTOR;
   82e64:	687b      	ldr	r3, [r7, #4]
   82e66:	f642 62e0 	movw	r2, #12000	; 0x2ee0
   82e6a:	fb02 f303 	mul.w	r3, r2, r3
   82e6e:	60bb      	str	r3, [r7, #8]
  uint32_t i;
  for(i = 0; i < iterations; ++i) {
   82e70:	2300      	movs	r3, #0
   82e72:	60fb      	str	r3, [r7, #12]
   82e74:	e003      	b.n	82e7e <delayMS+0x22>
    asm volatile("nop\n\t");
   82e76:	bf00      	nop
 * \param[in] millis milliseconds to delay
 */
static void delayMS(uint32_t millis) {
  uint32_t iterations = millis * CAL_FACTOR;
  uint32_t i;
  for(i = 0; i < iterations; ++i) {
   82e78:	68fb      	ldr	r3, [r7, #12]
   82e7a:	3301      	adds	r3, #1
   82e7c:	60fb      	str	r3, [r7, #12]
   82e7e:	68fa      	ldr	r2, [r7, #12]
   82e80:	68bb      	ldr	r3, [r7, #8]
   82e82:	429a      	cmp	r2, r3
   82e84:	d3f7      	bcc.n	82e76 <delayMS+0x1a>
    asm volatile("nop\n\t");
  }
}
   82e86:	bf00      	nop
   82e88:	3714      	adds	r7, #20
   82e8a:	46bd      	mov	sp, r7
   82e8c:	bc80      	pop	{r7}
   82e8e:	4770      	bx	lr

00082e90 <errorBlink>:
//------------------------------------------------------------------------------
/** Blink error pattern
 *
 * \param[in] n  number of short pulses
 */
static void errorBlink(int n) {
   82e90:	b580      	push	{r7, lr}
   82e92:	b084      	sub	sp, #16
   82e94:	af00      	add	r7, sp, #0
   82e96:	6078      	str	r0, [r7, #4]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
   82e98:	b672      	cpsid	i
	noInterrupts();
  pinMode(13, OUTPUT);
   82e9a:	2101      	movs	r1, #1
   82e9c:	200d      	movs	r0, #13
   82e9e:	4b10      	ldr	r3, [pc, #64]	; (82ee0 <errorBlink+0x50>)
   82ea0:	4798      	blx	r3
  for (;;) {
    int i;
    for (i = 0; i < n; i++) {
   82ea2:	2300      	movs	r3, #0
   82ea4:	60fb      	str	r3, [r7, #12]
   82ea6:	e012      	b.n	82ece <errorBlink+0x3e>
      digitalWrite(13, 1);
   82ea8:	2101      	movs	r1, #1
   82eaa:	200d      	movs	r0, #13
   82eac:	4b0d      	ldr	r3, [pc, #52]	; (82ee4 <errorBlink+0x54>)
   82eae:	4798      	blx	r3
      delayMS(300);
   82eb0:	f44f 7096 	mov.w	r0, #300	; 0x12c
   82eb4:	4b0c      	ldr	r3, [pc, #48]	; (82ee8 <errorBlink+0x58>)
   82eb6:	4798      	blx	r3
      digitalWrite(13, 0);
   82eb8:	2100      	movs	r1, #0
   82eba:	200d      	movs	r0, #13
   82ebc:	4b09      	ldr	r3, [pc, #36]	; (82ee4 <errorBlink+0x54>)
   82ebe:	4798      	blx	r3
      delayMS(300);
   82ec0:	f44f 7096 	mov.w	r0, #300	; 0x12c
   82ec4:	4b08      	ldr	r3, [pc, #32]	; (82ee8 <errorBlink+0x58>)
   82ec6:	4798      	blx	r3
static void errorBlink(int n) {
	noInterrupts();
  pinMode(13, OUTPUT);
  for (;;) {
    int i;
    for (i = 0; i < n; i++) {
   82ec8:	68fb      	ldr	r3, [r7, #12]
   82eca:	3301      	adds	r3, #1
   82ecc:	60fb      	str	r3, [r7, #12]
   82ece:	68fa      	ldr	r2, [r7, #12]
   82ed0:	687b      	ldr	r3, [r7, #4]
   82ed2:	429a      	cmp	r2, r3
   82ed4:	dbe8      	blt.n	82ea8 <errorBlink+0x18>
      digitalWrite(13, 1);
      delayMS(300);
      digitalWrite(13, 0);
      delayMS(300);
    }
    delayMS(2000);
   82ed6:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
   82eda:	4b03      	ldr	r3, [pc, #12]	; (82ee8 <errorBlink+0x58>)
   82edc:	4798      	blx	r3
  }
   82ede:	e7e0      	b.n	82ea2 <errorBlink+0x12>
   82ee0:	00081cc5 	.word	0x00081cc5
   82ee4:	00081f29 	.word	0x00081f29
   82ee8:	00082e5d 	.word	0x00082e5d

00082eec <assertBlink>:
}
//------------------------------------------------------------------------------
/** assertBlink
 * Blink one short pulse every two seconds if configASSERT fails.
*/
void assertBlink() {
   82eec:	b580      	push	{r7, lr}
   82eee:	af00      	add	r7, sp, #0
  errorBlink(1);
   82ef0:	2001      	movs	r0, #1
   82ef2:	4b02      	ldr	r3, [pc, #8]	; (82efc <assertBlink+0x10>)
   82ef4:	4798      	blx	r3
}
   82ef6:	bf00      	nop
   82ef8:	bd80      	pop	{r7, pc}
   82efa:	bf00      	nop
   82efc:	00082e91 	.word	0x00082e91

00082f00 <vApplicationMallocFailedHook>:
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
void vApplicationMallocFailedHook() {
   82f00:	b580      	push	{r7, lr}
   82f02:	af00      	add	r7, sp, #0
  errorBlink(2);
   82f04:	2002      	movs	r0, #2
   82f06:	4b02      	ldr	r3, [pc, #8]	; (82f10 <vApplicationMallocFailedHook+0x10>)
   82f08:	4798      	blx	r3
}
   82f0a:	bf00      	nop
   82f0c:	bd80      	pop	{r7, pc}
   82f0e:	bf00      	nop
   82f10:	00082e91 	.word	0x00082e91

00082f14 <vApplicationIdleHook>:
	specified, or call vTaskDelay()).  If the application makes use of the
	vTaskDelete() API function (as this demo application does) then it is also
	important that vApplicationIdleHook() is permitted to return to its calling
	function, because it is the responsibility of the idle task to clean up
	memory allocated by the kernel to any task that has since been deleted. */
void  __attribute__((weak)) vApplicationIdleHook( void ) {
   82f14:	b580      	push	{r7, lr}
   82f16:	af00      	add	r7, sp, #0
  void loop();
  loop();
   82f18:	4b01      	ldr	r3, [pc, #4]	; (82f20 <vApplicationIdleHook+0xc>)
   82f1a:	4798      	blx	r3
}
   82f1c:	bf00      	nop
   82f1e:	bd80      	pop	{r7, pc}
   82f20:	00080165 	.word	0x00080165

00082f24 <vApplicationStackOverflowHook>:
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected.
  \param[in] pxTask Task handle
  \param[in] pcTaskName Task name
  */
void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName) {
   82f24:	b580      	push	{r7, lr}
   82f26:	b082      	sub	sp, #8
   82f28:	af00      	add	r7, sp, #0
   82f2a:	6078      	str	r0, [r7, #4]
   82f2c:	6039      	str	r1, [r7, #0]
	(void) pcTaskName;
	(void) pxTask;
	errorBlink(3);
   82f2e:	2003      	movs	r0, #3
   82f30:	4b02      	ldr	r3, [pc, #8]	; (82f3c <vApplicationStackOverflowHook+0x18>)
   82f32:	4798      	blx	r3
}
   82f34:	bf00      	nop
   82f36:	3708      	adds	r7, #8
   82f38:	46bd      	mov	sp, r7
   82f3a:	bd80      	pop	{r7, pc}
   82f3c:	00082e91 	.word	0x00082e91

00082f40 <HardFault_Handler>:
//------------------------------------------------------------------------------
// catch Teensy 3 and Due exceptions
/** Hard fault - blink four short flash every two seconds */
void hard_fault_isr()	{errorBlink(4);}
/** Hard fault - blink four short flash every two seconds */
void HardFault_Handler() 	{errorBlink(4);}
   82f40:	b580      	push	{r7, lr}
   82f42:	af00      	add	r7, sp, #0
   82f44:	2004      	movs	r0, #4
   82f46:	4b02      	ldr	r3, [pc, #8]	; (82f50 <HardFault_Handler+0x10>)
   82f48:	4798      	blx	r3
   82f4a:	bf00      	nop
   82f4c:	bd80      	pop	{r7, pc}
   82f4e:	bf00      	nop
   82f50:	00082e91 	.word	0x00082e91

00082f54 <BusFault_Handler>:

/** Bus fault - blink five short flashes every two seconds */
void bus_fault_isr() {errorBlink(5);}
/** Bus fault - blink five short flashes every two seconds */
void BusFault_Handler() {errorBlink(5);}
   82f54:	b580      	push	{r7, lr}
   82f56:	af00      	add	r7, sp, #0
   82f58:	2005      	movs	r0, #5
   82f5a:	4b02      	ldr	r3, [pc, #8]	; (82f64 <BusFault_Handler+0x10>)
   82f5c:	4798      	blx	r3
   82f5e:	bf00      	nop
   82f60:	bd80      	pop	{r7, pc}
   82f62:	bf00      	nop
   82f64:	00082e91 	.word	0x00082e91

00082f68 <UsageFault_Handler>:

/** Usage fault - blink six short flashes every two seconds */
void usage_fault_isr() {errorBlink(6);}
/** Usage fault - blink six short flashes every two seconds */
void UsageFault_Handler() {errorBlink(6);}
   82f68:	b580      	push	{r7, lr}
   82f6a:	af00      	add	r7, sp, #0
   82f6c:	2006      	movs	r0, #6
   82f6e:	4b02      	ldr	r3, [pc, #8]	; (82f78 <UsageFault_Handler+0x10>)
   82f70:	4798      	blx	r3
   82f72:	bf00      	nop
   82f74:	bd80      	pop	{r7, pc}
   82f76:	bf00      	nop
   82f78:	00082e91 	.word	0x00082e91

00082f7c <vApplicationTickHook>:
	/** This function will be called by each tick interrupt if
	configUSE_TICK_HOOK is set to 1 in FreeRTOSConfig.h.  User code can be
	added here, but the tick hook is called from an interrupt context, so
	code must not attempt to block, and only the interrupt safe FreeRTOS API
	functions can be used (those that end in FromISR()). */
void __attribute__((weak)) vApplicationTickHook() {
   82f7c:	b480      	push	{r7}
   82f7e:	af00      	add	r7, sp, #0
}
   82f80:	bf00      	nop
   82f82:	46bd      	mov	sp, r7
   82f84:	bc80      	pop	{r7}
   82f86:	4770      	bx	lr

00082f88 <_ZN15StringSumHelperC1ERK6String>:
};

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
   82f88:	b580      	push	{r7, lr}
   82f8a:	b082      	sub	sp, #8
   82f8c:	af00      	add	r7, sp, #0
   82f8e:	6078      	str	r0, [r7, #4]
   82f90:	6039      	str	r1, [r7, #0]
   82f92:	687b      	ldr	r3, [r7, #4]
   82f94:	6839      	ldr	r1, [r7, #0]
   82f96:	4618      	mov	r0, r3
   82f98:	4b03      	ldr	r3, [pc, #12]	; (82fa8 <_ZN15StringSumHelperC1ERK6String+0x20>)
   82f9a:	4798      	blx	r3
   82f9c:	687b      	ldr	r3, [r7, #4]
   82f9e:	4618      	mov	r0, r3
   82fa0:	3708      	adds	r7, #8
   82fa2:	46bd      	mov	sp, r7
   82fa4:	bd80      	pop	{r7, pc}
   82fa6:	bf00      	nop
   82fa8:	00089049 	.word	0x00089049

00082fac <_ZN3ard5ArdOs11getInstanceEv>:
      UNINIT, RUNNING
    } eOsState;

    //retrieve the singleton instance (you should prefer the use of the g_ArdOs maccro)
    static ArdOs&
    getInstance ()
   82fac:	b480      	push	{r7}
   82fae:	af00      	add	r7, sp, #0
    {
      return instance;
   82fb0:	4b02      	ldr	r3, [pc, #8]	; (82fbc <_ZN3ard5ArdOs11getInstanceEv+0x10>)
    }
   82fb2:	4618      	mov	r0, r3
   82fb4:	46bd      	mov	sp, r7
   82fb6:	bc80      	pop	{r7}
   82fb8:	4770      	bx	lr
   82fba:	bf00      	nop
   82fbc:	200713a8 	.word	0x200713a8

00082fc0 <enterIdleCB>:
{
 Signal_wait(infinite);
}

void enterIdleCB()
{
   82fc0:	b580      	push	{r7, lr}
   82fc2:	af00      	add	r7, sp, #0
  digitalWrite (HEARTBEAT_PIN, LOW);
   82fc4:	2100      	movs	r1, #0
   82fc6:	2048      	movs	r0, #72	; 0x48
   82fc8:	4b01      	ldr	r3, [pc, #4]	; (82fd0 <enterIdleCB+0x10>)
   82fca:	4798      	blx	r3
}
   82fcc:	bf00      	nop
   82fce:	bd80      	pop	{r7, pc}
   82fd0:	00081f29 	.word	0x00081f29

00082fd4 <exitIdleCB>:

void exitIdleCB()
{
   82fd4:	b580      	push	{r7, lr}
   82fd6:	af00      	add	r7, sp, #0
  digitalWrite (HEARTBEAT_PIN, HIGH);
   82fd8:	2101      	movs	r1, #1
   82fda:	2048      	movs	r0, #72	; 0x48
   82fdc:	4b01      	ldr	r3, [pc, #4]	; (82fe4 <exitIdleCB+0x10>)
   82fde:	4798      	blx	r3
}
   82fe0:	bf00      	nop
   82fe2:	bd80      	pop	{r7, pc}
   82fe4:	00081f29 	.word	0x00081f29

00082fe8 <_ZN15StringSumHelperD1Ev>:
       #if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
	void move(String &rhs);
	#endif
};

class StringSumHelper : public String
   82fe8:	b580      	push	{r7, lr}
   82fea:	b082      	sub	sp, #8
   82fec:	af00      	add	r7, sp, #0
   82fee:	6078      	str	r0, [r7, #4]
   82ff0:	687b      	ldr	r3, [r7, #4]
   82ff2:	4618      	mov	r0, r3
   82ff4:	4b03      	ldr	r3, [pc, #12]	; (83004 <_ZN15StringSumHelperD1Ev+0x1c>)
   82ff6:	4798      	blx	r3
   82ff8:	687b      	ldr	r3, [r7, #4]
   82ffa:	4618      	mov	r0, r3
   82ffc:	3708      	adds	r7, #8
   82ffe:	46bd      	mov	sp, r7
   83000:	bd80      	pop	{r7, pc}
   83002:	bf00      	nop
   83004:	00089145 	.word	0x00089145

00083008 <_Z16ArdOs_genericRunPv>:
ArdOs ArdOs::instance = ArdOs ();

//helper to prevent user from exiting their threads, as it push FreeRtos in assert
void
ArdOs_genericRun (void* pvParameters)
{
   83008:	b590      	push	{r4, r7, lr}
   8300a:	b0a3      	sub	sp, #140	; 0x8c
   8300c:	af00      	add	r7, sp, #0
   8300e:	6078      	str	r0, [r7, #4]
  ArdOs::genericRunParams* params =
      reinterpret_cast<ArdOs::genericRunParams*> (pvParameters);
   83010:	687b      	ldr	r3, [r7, #4]
   83012:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  ardAssert(params != NULL, "Generic params cast failed.");
   83016:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   8301a:	2b00      	cmp	r3, #0
   8301c:	d137      	bne.n	8308e <_Z16ArdOs_genericRunPv+0x86>
   8301e:	4b7f      	ldr	r3, [pc, #508]	; (8321c <_Z16ArdOs_genericRunPv+0x214>)
   83020:	4798      	blx	r3
   83022:	4604      	mov	r4, r0
   83024:	f107 0330 	add.w	r3, r7, #48	; 0x30
   83028:	497d      	ldr	r1, [pc, #500]	; (83220 <_Z16ArdOs_genericRunPv+0x218>)
   8302a:	4618      	mov	r0, r3
   8302c:	4b7d      	ldr	r3, [pc, #500]	; (83224 <_Z16ArdOs_genericRunPv+0x21c>)
   8302e:	4798      	blx	r3
   83030:	f107 0230 	add.w	r2, r7, #48	; 0x30
   83034:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83038:	4611      	mov	r1, r2
   8303a:	4618      	mov	r0, r3
   8303c:	4b7a      	ldr	r3, [pc, #488]	; (83228 <_Z16ArdOs_genericRunPv+0x220>)
   8303e:	4798      	blx	r3
   83040:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83044:	4979      	ldr	r1, [pc, #484]	; (8322c <_Z16ArdOs_genericRunPv+0x224>)
   83046:	4618      	mov	r0, r3
   83048:	4b79      	ldr	r3, [pc, #484]	; (83230 <_Z16ArdOs_genericRunPv+0x228>)
   8304a:	4798      	blx	r3
   8304c:	4603      	mov	r3, r0
   8304e:	461a      	mov	r2, r3
   83050:	f107 0318 	add.w	r3, r7, #24
   83054:	4611      	mov	r1, r2
   83056:	4618      	mov	r0, r3
   83058:	4b76      	ldr	r3, [pc, #472]	; (83234 <_Z16ArdOs_genericRunPv+0x22c>)
   8305a:	4798      	blx	r3
   8305c:	f107 0318 	add.w	r3, r7, #24
   83060:	4619      	mov	r1, r3
   83062:	4620      	mov	r0, r4
   83064:	4b74      	ldr	r3, [pc, #464]	; (83238 <_Z16ArdOs_genericRunPv+0x230>)
   83066:	4798      	blx	r3
   83068:	f107 0318 	add.w	r3, r7, #24
   8306c:	4618      	mov	r0, r3
   8306e:	4b73      	ldr	r3, [pc, #460]	; (8323c <_Z16ArdOs_genericRunPv+0x234>)
   83070:	4798      	blx	r3
   83072:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83076:	4618      	mov	r0, r3
   83078:	4b71      	ldr	r3, [pc, #452]	; (83240 <_Z16ArdOs_genericRunPv+0x238>)
   8307a:	4798      	blx	r3
   8307c:	f107 0330 	add.w	r3, r7, #48	; 0x30
   83080:	4618      	mov	r0, r3
   83082:	4b6e      	ldr	r3, [pc, #440]	; (8323c <_Z16ArdOs_genericRunPv+0x234>)
   83084:	4798      	blx	r3
   83086:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   8308a:	4b6e      	ldr	r3, [pc, #440]	; (83244 <_Z16ArdOs_genericRunPv+0x23c>)
   8308c:	4798      	blx	r3

  //Informs that the task is started
  char taskName[configMAX_TASK_NAME_LEN];
  ard_getTaskName (taskName);
   8308e:	f107 030c 	add.w	r3, r7, #12
   83092:	4618      	mov	r0, r3
   83094:	4b6c      	ldr	r3, [pc, #432]	; (83248 <_Z16ArdOs_genericRunPv+0x240>)
   83096:	4798      	blx	r3
  g_ArdOs.dprintln (String ("[ArdOs] ") + taskName + " is running.");
   83098:	4b60      	ldr	r3, [pc, #384]	; (8321c <_Z16ArdOs_genericRunPv+0x214>)
   8309a:	4798      	blx	r3
   8309c:	4604      	mov	r4, r0
   8309e:	f107 0354 	add.w	r3, r7, #84	; 0x54
   830a2:	496a      	ldr	r1, [pc, #424]	; (8324c <_Z16ArdOs_genericRunPv+0x244>)
   830a4:	4618      	mov	r0, r3
   830a6:	4b5f      	ldr	r3, [pc, #380]	; (83224 <_Z16ArdOs_genericRunPv+0x21c>)
   830a8:	4798      	blx	r3
   830aa:	f107 0254 	add.w	r2, r7, #84	; 0x54
   830ae:	f107 0348 	add.w	r3, r7, #72	; 0x48
   830b2:	4611      	mov	r1, r2
   830b4:	4618      	mov	r0, r3
   830b6:	4b5c      	ldr	r3, [pc, #368]	; (83228 <_Z16ArdOs_genericRunPv+0x220>)
   830b8:	4798      	blx	r3
   830ba:	f107 020c 	add.w	r2, r7, #12
   830be:	f107 0348 	add.w	r3, r7, #72	; 0x48
   830c2:	4611      	mov	r1, r2
   830c4:	4618      	mov	r0, r3
   830c6:	4b5a      	ldr	r3, [pc, #360]	; (83230 <_Z16ArdOs_genericRunPv+0x228>)
   830c8:	4798      	blx	r3
   830ca:	4603      	mov	r3, r0
   830cc:	4960      	ldr	r1, [pc, #384]	; (83250 <_Z16ArdOs_genericRunPv+0x248>)
   830ce:	4618      	mov	r0, r3
   830d0:	4b57      	ldr	r3, [pc, #348]	; (83230 <_Z16ArdOs_genericRunPv+0x228>)
   830d2:	4798      	blx	r3
   830d4:	4603      	mov	r3, r0
   830d6:	461a      	mov	r2, r3
   830d8:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   830dc:	4611      	mov	r1, r2
   830de:	4618      	mov	r0, r3
   830e0:	4b54      	ldr	r3, [pc, #336]	; (83234 <_Z16ArdOs_genericRunPv+0x22c>)
   830e2:	4798      	blx	r3
   830e4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   830e8:	4619      	mov	r1, r3
   830ea:	4620      	mov	r0, r4
   830ec:	4b52      	ldr	r3, [pc, #328]	; (83238 <_Z16ArdOs_genericRunPv+0x230>)
   830ee:	4798      	blx	r3
   830f0:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   830f4:	4618      	mov	r0, r3
   830f6:	4b51      	ldr	r3, [pc, #324]	; (8323c <_Z16ArdOs_genericRunPv+0x234>)
   830f8:	4798      	blx	r3
   830fa:	f107 0348 	add.w	r3, r7, #72	; 0x48
   830fe:	4618      	mov	r0, r3
   83100:	4b4f      	ldr	r3, [pc, #316]	; (83240 <_Z16ArdOs_genericRunPv+0x238>)
   83102:	4798      	blx	r3
   83104:	f107 0354 	add.w	r3, r7, #84	; 0x54
   83108:	4618      	mov	r0, r3
   8310a:	4b4c      	ldr	r3, [pc, #304]	; (8323c <_Z16ArdOs_genericRunPv+0x234>)
   8310c:	4798      	blx	r3

  //The thread is periodic
  if (params->period)
   8310e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   83112:	891b      	ldrh	r3, [r3, #8]
   83114:	2b00      	cmp	r3, #0
   83116:	d023      	beq.n	83160 <_Z16ArdOs_genericRunPv+0x158>
    {
      TickType_t lastWakeTime = xTaskGetTickCount();
   83118:	4b4e      	ldr	r3, [pc, #312]	; (83254 <_Z16ArdOs_genericRunPv+0x24c>)
   8311a:	4798      	blx	r3
   8311c:	4603      	mov	r3, r0
   8311e:	60bb      	str	r3, [r7, #8]
      while(2)/* because 1 is has-been*/
      {
	  //Run either the function or the class run method
	  if (params->pClass)
   83120:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   83124:	681b      	ldr	r3, [r3, #0]
   83126:	2b00      	cmp	r3, #0
   83128:	d00b      	beq.n	83142 <_Z16ArdOs_genericRunPv+0x13a>
	    params->pClass->run ();
   8312a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   8312e:	681b      	ldr	r3, [r3, #0]
   83130:	681b      	ldr	r3, [r3, #0]
   83132:	3304      	adds	r3, #4
   83134:	681b      	ldr	r3, [r3, #0]
   83136:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
   8313a:	6812      	ldr	r2, [r2, #0]
   8313c:	4610      	mov	r0, r2
   8313e:	4798      	blx	r3
   83140:	e003      	b.n	8314a <_Z16ArdOs_genericRunPv+0x142>
	  else
	    params->method ();
   83142:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   83146:	685b      	ldr	r3, [r3, #4]
   83148:	4798      	blx	r3

	  //wait until next period
	  vTaskDelayUntil( &lastWakeTime, params->period );
   8314a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   8314e:	891b      	ldrh	r3, [r3, #8]
   83150:	461a      	mov	r2, r3
   83152:	f107 0308 	add.w	r3, r7, #8
   83156:	4611      	mov	r1, r2
   83158:	4618      	mov	r0, r3
   8315a:	4b3f      	ldr	r3, [pc, #252]	; (83258 <_Z16ArdOs_genericRunPv+0x250>)
   8315c:	4798      	blx	r3

  //The thread is periodic
  if (params->period)
    {
      TickType_t lastWakeTime = xTaskGetTickCount();
      while(2)/* because 1 is has-been*/
   8315e:	e7df      	b.n	83120 <_Z16ArdOs_genericRunPv+0x118>
    }
  //The thread isnot periodic
  else
    {
      //Run either the function or the class run method
      if (params->pClass)
   83160:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   83164:	681b      	ldr	r3, [r3, #0]
   83166:	2b00      	cmp	r3, #0
   83168:	d00b      	beq.n	83182 <_Z16ArdOs_genericRunPv+0x17a>
	params->pClass->run ();
   8316a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   8316e:	681b      	ldr	r3, [r3, #0]
   83170:	681b      	ldr	r3, [r3, #0]
   83172:	3304      	adds	r3, #4
   83174:	681b      	ldr	r3, [r3, #0]
   83176:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
   8317a:	6812      	ldr	r2, [r2, #0]
   8317c:	4610      	mov	r0, r2
   8317e:	4798      	blx	r3
   83180:	e003      	b.n	8318a <_Z16ArdOs_genericRunPv+0x182>
      else
	params->method ();
   83182:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   83186:	685b      	ldr	r3, [r3, #4]
   83188:	4798      	blx	r3

      //Wait infinitly so that the thread context is never exited (else FreeRtos would asserts)
      g_ArdOs.dprintln (String ("[ArdOs] ") + taskName + " is finished.");
   8318a:	4b24      	ldr	r3, [pc, #144]	; (8321c <_Z16ArdOs_genericRunPv+0x214>)
   8318c:	4798      	blx	r3
   8318e:	4604      	mov	r4, r0
   83190:	f107 0378 	add.w	r3, r7, #120	; 0x78
   83194:	492d      	ldr	r1, [pc, #180]	; (8324c <_Z16ArdOs_genericRunPv+0x244>)
   83196:	4618      	mov	r0, r3
   83198:	4b22      	ldr	r3, [pc, #136]	; (83224 <_Z16ArdOs_genericRunPv+0x21c>)
   8319a:	4798      	blx	r3
   8319c:	f107 0278 	add.w	r2, r7, #120	; 0x78
   831a0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
   831a4:	4611      	mov	r1, r2
   831a6:	4618      	mov	r0, r3
   831a8:	4b1f      	ldr	r3, [pc, #124]	; (83228 <_Z16ArdOs_genericRunPv+0x220>)
   831aa:	4798      	blx	r3
   831ac:	f107 020c 	add.w	r2, r7, #12
   831b0:	f107 036c 	add.w	r3, r7, #108	; 0x6c
   831b4:	4611      	mov	r1, r2
   831b6:	4618      	mov	r0, r3
   831b8:	4b1d      	ldr	r3, [pc, #116]	; (83230 <_Z16ArdOs_genericRunPv+0x228>)
   831ba:	4798      	blx	r3
   831bc:	4603      	mov	r3, r0
   831be:	4927      	ldr	r1, [pc, #156]	; (8325c <_Z16ArdOs_genericRunPv+0x254>)
   831c0:	4618      	mov	r0, r3
   831c2:	4b1b      	ldr	r3, [pc, #108]	; (83230 <_Z16ArdOs_genericRunPv+0x228>)
   831c4:	4798      	blx	r3
   831c6:	4603      	mov	r3, r0
   831c8:	461a      	mov	r2, r3
   831ca:	f107 0360 	add.w	r3, r7, #96	; 0x60
   831ce:	4611      	mov	r1, r2
   831d0:	4618      	mov	r0, r3
   831d2:	4b18      	ldr	r3, [pc, #96]	; (83234 <_Z16ArdOs_genericRunPv+0x22c>)
   831d4:	4798      	blx	r3
   831d6:	f107 0360 	add.w	r3, r7, #96	; 0x60
   831da:	4619      	mov	r1, r3
   831dc:	4620      	mov	r0, r4
   831de:	4b16      	ldr	r3, [pc, #88]	; (83238 <_Z16ArdOs_genericRunPv+0x230>)
   831e0:	4798      	blx	r3
   831e2:	f107 0360 	add.w	r3, r7, #96	; 0x60
   831e6:	4618      	mov	r0, r3
   831e8:	4b14      	ldr	r3, [pc, #80]	; (8323c <_Z16ArdOs_genericRunPv+0x234>)
   831ea:	4798      	blx	r3
   831ec:	f107 036c 	add.w	r3, r7, #108	; 0x6c
   831f0:	4618      	mov	r0, r3
   831f2:	4b13      	ldr	r3, [pc, #76]	; (83240 <_Z16ArdOs_genericRunPv+0x238>)
   831f4:	4798      	blx	r3
   831f6:	f107 0378 	add.w	r3, r7, #120	; 0x78
   831fa:	4618      	mov	r0, r3
   831fc:	4b0f      	ldr	r3, [pc, #60]	; (8323c <_Z16ArdOs_genericRunPv+0x234>)
   831fe:	4798      	blx	r3
      g_ArdOs.Signal_wait(infinite);
   83200:	4b06      	ldr	r3, [pc, #24]	; (8321c <_Z16ArdOs_genericRunPv+0x214>)
   83202:	4798      	blx	r3
   83204:	4602      	mov	r2, r0
   83206:	4b16      	ldr	r3, [pc, #88]	; (83260 <_Z16ArdOs_genericRunPv+0x258>)
   83208:	681b      	ldr	r3, [r3, #0]
   8320a:	4619      	mov	r1, r3
   8320c:	4610      	mov	r0, r2
   8320e:	4b15      	ldr	r3, [pc, #84]	; (83264 <_Z16ArdOs_genericRunPv+0x25c>)
   83210:	4798      	blx	r3
    }

}
   83212:	bf00      	nop
   83214:	378c      	adds	r7, #140	; 0x8c
   83216:	46bd      	mov	sp, r7
   83218:	bd90      	pop	{r4, r7, pc}
   8321a:	bf00      	nop
   8321c:	00082fad 	.word	0x00082fad
   83220:	0009a02c 	.word	0x0009a02c
   83224:	00089009 	.word	0x00089009
   83228:	00082f89 	.word	0x00082f89
   8322c:	0009a058 	.word	0x0009a058
   83230:	0008951d 	.word	0x0008951d
   83234:	00089049 	.word	0x00089049
   83238:	00083845 	.word	0x00083845
   8323c:	00089145 	.word	0x00089145
   83240:	00082fe9 	.word	0x00082fe9
   83244:	00081c7d 	.word	0x00081c7d
   83248:	0008f0cd 	.word	0x0008f0cd
   8324c:	0009a074 	.word	0x0009a074
   83250:	0009a080 	.word	0x0009a080
   83254:	0008e171 	.word	0x0008e171
   83258:	0008de09 	.word	0x0008de09
   8325c:	0009a090 	.word	0x0009a090
   83260:	200713a4 	.word	0x200713a4
   83264:	00083e59 	.word	0x00083e59

00083268 <_ZN3ard5ArdOsC1Ev>:

ArdOs::ArdOs ()
   83268:	b580      	push	{r7, lr}
   8326a:	b082      	sub	sp, #8
   8326c:	af00      	add	r7, sp, #0
   8326e:	6078      	str	r0, [r7, #4]
{
  nextThreadRank = 0;
   83270:	687b      	ldr	r3, [r7, #4]
   83272:	2200      	movs	r2, #0
   83274:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
  heartbeatCounter = 0;
   83278:	687b      	ldr	r3, [r7, #4]
   8327a:	2200      	movs	r2, #0
   8327c:	669a      	str	r2, [r3, #104]	; 0x68
  heartbeatPinValue = 0;
   8327e:	687b      	ldr	r3, [r7, #4]
   83280:	2200      	movs	r2, #0
   83282:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c
  signalCount = 0;
   83286:	687b      	ldr	r3, [r7, #4]
   83288:	2200      	movs	r2, #0
   8328a:	831a      	strh	r2, [r3, #24]
  mutexCount = 0;
   8328c:	687b      	ldr	r3, [r7, #4]
   8328e:	2200      	movs	r2, #0
   83290:	835a      	strh	r2, [r3, #26]
  state = eOsState::UNINIT;
   83292:	687b      	ldr	r3, [r7, #4]
   83294:	2200      	movs	r2, #0
   83296:	671a      	str	r2, [r3, #112]	; 0x70
  bootDuration = 0;
   83298:	687b      	ldr	r3, [r7, #4]
   8329a:	2200      	movs	r2, #0
   8329c:	675a      	str	r2, [r3, #116]	; 0x74
  debugSerialMutex = NULL;
   8329e:	687b      	ldr	r3, [r7, #4]
   832a0:	2200      	movs	r2, #0
   832a2:	679a      	str	r2, [r3, #120]	; 0x78
  INIT_TABLE_TO_ZERO(threads);
   832a4:	687b      	ldr	r3, [r7, #4]
   832a6:	2218      	movs	r2, #24
   832a8:	2100      	movs	r1, #0
   832aa:	4618      	mov	r0, r3
   832ac:	4b06      	ldr	r3, [pc, #24]	; (832c8 <_ZN3ard5ArdOsC1Ev+0x60>)
   832ae:	4798      	blx	r3
  INIT_TABLE_TO_ZERO(params);
   832b0:	687b      	ldr	r3, [r7, #4]
   832b2:	331c      	adds	r3, #28
   832b4:	2248      	movs	r2, #72	; 0x48
   832b6:	2100      	movs	r1, #0
   832b8:	4618      	mov	r0, r3
   832ba:	4b03      	ldr	r3, [pc, #12]	; (832c8 <_ZN3ard5ArdOsC1Ev+0x60>)
   832bc:	4798      	blx	r3
}
   832be:	687b      	ldr	r3, [r7, #4]
   832c0:	4618      	mov	r0, r3
   832c2:	3708      	adds	r7, #8
   832c4:	46bd      	mov	sp, r7
   832c6:	bd80      	pop	{r7, pc}
   832c8:	00093cc5 	.word	0x00093cc5

000832cc <_ZN3ard5ArdOs4initEv>:

void
ArdOs::init ()
{
   832cc:	b590      	push	{r4, r7, lr}
   832ce:	b099      	sub	sp, #100	; 0x64
   832d0:	af00      	add	r7, sp, #0
   832d2:	6078      	str	r0, [r7, #4]
  ardAssert(state == eOsState::UNINIT, "ArdOs is not in the right state to do an init");
   832d4:	687b      	ldr	r3, [r7, #4]
   832d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   832d8:	2b00      	cmp	r3, #0
   832da:	d037      	beq.n	8334c <_ZN3ard5ArdOs4initEv+0x80>
   832dc:	4b53      	ldr	r3, [pc, #332]	; (8342c <_ZN3ard5ArdOs4initEv+0x160>)
   832de:	4798      	blx	r3
   832e0:	4604      	mov	r4, r0
   832e2:	f107 0324 	add.w	r3, r7, #36	; 0x24
   832e6:	4952      	ldr	r1, [pc, #328]	; (83430 <_ZN3ard5ArdOs4initEv+0x164>)
   832e8:	4618      	mov	r0, r3
   832ea:	4b52      	ldr	r3, [pc, #328]	; (83434 <_ZN3ard5ArdOs4initEv+0x168>)
   832ec:	4798      	blx	r3
   832ee:	f107 0224 	add.w	r2, r7, #36	; 0x24
   832f2:	f107 0318 	add.w	r3, r7, #24
   832f6:	4611      	mov	r1, r2
   832f8:	4618      	mov	r0, r3
   832fa:	4b4f      	ldr	r3, [pc, #316]	; (83438 <_ZN3ard5ArdOs4initEv+0x16c>)
   832fc:	4798      	blx	r3
   832fe:	f107 0318 	add.w	r3, r7, #24
   83302:	494e      	ldr	r1, [pc, #312]	; (8343c <_ZN3ard5ArdOs4initEv+0x170>)
   83304:	4618      	mov	r0, r3
   83306:	4b4e      	ldr	r3, [pc, #312]	; (83440 <_ZN3ard5ArdOs4initEv+0x174>)
   83308:	4798      	blx	r3
   8330a:	4603      	mov	r3, r0
   8330c:	461a      	mov	r2, r3
   8330e:	f107 030c 	add.w	r3, r7, #12
   83312:	4611      	mov	r1, r2
   83314:	4618      	mov	r0, r3
   83316:	4b4b      	ldr	r3, [pc, #300]	; (83444 <_ZN3ard5ArdOs4initEv+0x178>)
   83318:	4798      	blx	r3
   8331a:	f107 030c 	add.w	r3, r7, #12
   8331e:	4619      	mov	r1, r3
   83320:	4620      	mov	r0, r4
   83322:	4b49      	ldr	r3, [pc, #292]	; (83448 <_ZN3ard5ArdOs4initEv+0x17c>)
   83324:	4798      	blx	r3
   83326:	f107 030c 	add.w	r3, r7, #12
   8332a:	4618      	mov	r0, r3
   8332c:	4b47      	ldr	r3, [pc, #284]	; (8344c <_ZN3ard5ArdOs4initEv+0x180>)
   8332e:	4798      	blx	r3
   83330:	f107 0318 	add.w	r3, r7, #24
   83334:	4618      	mov	r0, r3
   83336:	4b46      	ldr	r3, [pc, #280]	; (83450 <_ZN3ard5ArdOs4initEv+0x184>)
   83338:	4798      	blx	r3
   8333a:	f107 0324 	add.w	r3, r7, #36	; 0x24
   8333e:	4618      	mov	r0, r3
   83340:	4b42      	ldr	r3, [pc, #264]	; (8344c <_ZN3ard5ArdOs4initEv+0x180>)
   83342:	4798      	blx	r3
   83344:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   83348:	4b42      	ldr	r3, [pc, #264]	; (83454 <_ZN3ard5ArdOs4initEv+0x188>)
   8334a:	4798      	blx	r3
  infinite = Signal_create ();
   8334c:	6878      	ldr	r0, [r7, #4]
   8334e:	4b42      	ldr	r3, [pc, #264]	; (83458 <_ZN3ard5ArdOs4initEv+0x18c>)
   83350:	4798      	blx	r3
   83352:	4602      	mov	r2, r0
   83354:	4b41      	ldr	r3, [pc, #260]	; (8345c <_ZN3ard5ArdOs4initEv+0x190>)
   83356:	601a      	str	r2, [r3, #0]
  debugSerialMutex = Mutex_create();
   83358:	6878      	ldr	r0, [r7, #4]
   8335a:	4b41      	ldr	r3, [pc, #260]	; (83460 <_ZN3ard5ArdOs4initEv+0x194>)
   8335c:	4798      	blx	r3
   8335e:	4602      	mov	r2, r0
   83360:	687b      	ldr	r3, [r7, #4]
   83362:	679a      	str	r2, [r3, #120]	; 0x78

  digitalWrite (LED_DUE_L, LOW);
   83364:	2100      	movs	r1, #0
   83366:	200d      	movs	r0, #13
   83368:	4b3e      	ldr	r3, [pc, #248]	; (83464 <_ZN3ard5ArdOs4initEv+0x198>)
   8336a:	4798      	blx	r3
  digitalWrite (HEARTBEAT_PIN, heartbeatPinValue);
   8336c:	687b      	ldr	r3, [r7, #4]
   8336e:	f993 306c 	ldrsb.w	r3, [r3, #108]	; 0x6c
   83372:	4619      	mov	r1, r3
   83374:	2048      	movs	r0, #72	; 0x48
   83376:	4b3b      	ldr	r3, [pc, #236]	; (83464 <_ZN3ard5ArdOs4initEv+0x198>)
   83378:	4798      	blx	r3

  // start FreeRTOS
  state = eOsState::RUNNING;
   8337a:	687b      	ldr	r3, [r7, #4]
   8337c:	2201      	movs	r2, #1
   8337e:	671a      	str	r2, [r3, #112]	; 0x70
  bootDuration = millis ();
   83380:	4b39      	ldr	r3, [pc, #228]	; (83468 <_ZN3ard5ArdOs4initEv+0x19c>)
   83382:	4798      	blx	r3
   83384:	4602      	mov	r2, r0
   83386:	687b      	ldr	r3, [r7, #4]
   83388:	675a      	str	r2, [r3, #116]	; 0x74
  dprintln (
      String ("[ArdOs] ") + "Robot is booted successfully, it took " + bootDuration
   8338a:	f107 0348 	add.w	r3, r7, #72	; 0x48
   8338e:	4937      	ldr	r1, [pc, #220]	; (8346c <_ZN3ard5ArdOs4initEv+0x1a0>)
   83390:	4618      	mov	r0, r3
   83392:	4b28      	ldr	r3, [pc, #160]	; (83434 <_ZN3ard5ArdOs4initEv+0x168>)
   83394:	4798      	blx	r3
   83396:	f107 0248 	add.w	r2, r7, #72	; 0x48
   8339a:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   8339e:	4611      	mov	r1, r2
   833a0:	4618      	mov	r0, r3
   833a2:	4b25      	ldr	r3, [pc, #148]	; (83438 <_ZN3ard5ArdOs4initEv+0x16c>)
   833a4:	4798      	blx	r3
   833a6:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   833aa:	4931      	ldr	r1, [pc, #196]	; (83470 <_ZN3ard5ArdOs4initEv+0x1a4>)
   833ac:	4618      	mov	r0, r3
   833ae:	4b24      	ldr	r3, [pc, #144]	; (83440 <_ZN3ard5ArdOs4initEv+0x174>)
   833b0:	4798      	blx	r3
   833b2:	4602      	mov	r2, r0
   833b4:	687b      	ldr	r3, [r7, #4]
   833b6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
   833b8:	4619      	mov	r1, r3
   833ba:	4610      	mov	r0, r2
   833bc:	4b2d      	ldr	r3, [pc, #180]	; (83474 <_ZN3ard5ArdOs4initEv+0x1a8>)
   833be:	4798      	blx	r3
   833c0:	4603      	mov	r3, r0
	  + " ms.");
   833c2:	492d      	ldr	r1, [pc, #180]	; (83478 <_ZN3ard5ArdOs4initEv+0x1ac>)
   833c4:	4618      	mov	r0, r3
   833c6:	4b1e      	ldr	r3, [pc, #120]	; (83440 <_ZN3ard5ArdOs4initEv+0x174>)
   833c8:	4798      	blx	r3
   833ca:	4603      	mov	r3, r0
  digitalWrite (HEARTBEAT_PIN, heartbeatPinValue);

  // start FreeRTOS
  state = eOsState::RUNNING;
  bootDuration = millis ();
  dprintln (
   833cc:	461a      	mov	r2, r3
   833ce:	f107 0330 	add.w	r3, r7, #48	; 0x30
   833d2:	4611      	mov	r1, r2
   833d4:	4618      	mov	r0, r3
   833d6:	4b1b      	ldr	r3, [pc, #108]	; (83444 <_ZN3ard5ArdOs4initEv+0x178>)
   833d8:	4798      	blx	r3
      String ("[ArdOs] ") + "Robot is booted successfully, it took " + bootDuration
	  + " ms.");
   833da:	f107 0330 	add.w	r3, r7, #48	; 0x30
   833de:	4619      	mov	r1, r3
   833e0:	6878      	ldr	r0, [r7, #4]
   833e2:	4b19      	ldr	r3, [pc, #100]	; (83448 <_ZN3ard5ArdOs4initEv+0x17c>)
   833e4:	4798      	blx	r3
  digitalWrite (HEARTBEAT_PIN, heartbeatPinValue);

  // start FreeRTOS
  state = eOsState::RUNNING;
  bootDuration = millis ();
  dprintln (
   833e6:	f107 0330 	add.w	r3, r7, #48	; 0x30
   833ea:	4618      	mov	r0, r3
   833ec:	4b17      	ldr	r3, [pc, #92]	; (8344c <_ZN3ard5ArdOs4initEv+0x180>)
   833ee:	4798      	blx	r3
      String ("[ArdOs] ") + "Robot is booted successfully, it took " + bootDuration
   833f0:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   833f4:	4618      	mov	r0, r3
   833f6:	4b16      	ldr	r3, [pc, #88]	; (83450 <_ZN3ard5ArdOs4initEv+0x184>)
   833f8:	4798      	blx	r3
   833fa:	f107 0348 	add.w	r3, r7, #72	; 0x48
   833fe:	4618      	mov	r0, r3
   83400:	4b12      	ldr	r3, [pc, #72]	; (8344c <_ZN3ard5ArdOs4initEv+0x180>)
   83402:	4798      	blx	r3
	  + " ms.");
  vTaskStartScheduler ();
   83404:	4b1d      	ldr	r3, [pc, #116]	; (8347c <_ZN3ard5ArdOs4initEv+0x1b0>)
   83406:	4798      	blx	r3

  // should never reach this as the vTaskStartScheduler never ends
  dprintln ("ERROR : Scheduler exited !");
   83408:	f107 0354 	add.w	r3, r7, #84	; 0x54
   8340c:	491c      	ldr	r1, [pc, #112]	; (83480 <_ZN3ard5ArdOs4initEv+0x1b4>)
   8340e:	4618      	mov	r0, r3
   83410:	4b08      	ldr	r3, [pc, #32]	; (83434 <_ZN3ard5ArdOs4initEv+0x168>)
   83412:	4798      	blx	r3
   83414:	f107 0354 	add.w	r3, r7, #84	; 0x54
   83418:	4619      	mov	r1, r3
   8341a:	6878      	ldr	r0, [r7, #4]
   8341c:	4b0a      	ldr	r3, [pc, #40]	; (83448 <_ZN3ard5ArdOs4initEv+0x17c>)
   8341e:	4798      	blx	r3
   83420:	f107 0354 	add.w	r3, r7, #84	; 0x54
   83424:	4618      	mov	r0, r3
   83426:	4b09      	ldr	r3, [pc, #36]	; (8344c <_ZN3ard5ArdOs4initEv+0x180>)
   83428:	4798      	blx	r3
  while (1)
   8342a:	e7fe      	b.n	8342a <_ZN3ard5ArdOs4initEv+0x15e>
   8342c:	00082fad 	.word	0x00082fad
   83430:	0009a02c 	.word	0x0009a02c
   83434:	00089009 	.word	0x00089009
   83438:	00082f89 	.word	0x00082f89
   8343c:	0009a0a0 	.word	0x0009a0a0
   83440:	0008951d 	.word	0x0008951d
   83444:	00089049 	.word	0x00089049
   83448:	00083845 	.word	0x00083845
   8344c:	00089145 	.word	0x00089145
   83450:	00082fe9 	.word	0x00082fe9
   83454:	00081c7d 	.word	0x00081c7d
   83458:	00083c45 	.word	0x00083c45
   8345c:	200713a4 	.word	0x200713a4
   83460:	00083f21 	.word	0x00083f21
   83464:	00081f29 	.word	0x00081f29
   83468:	00081bb1 	.word	0x00081bb1
   8346c:	0009a074 	.word	0x0009a074
   83470:	0009a0d0 	.word	0x0009a0d0
   83474:	00089601 	.word	0x00089601
   83478:	0009a0f8 	.word	0x0009a0f8
   8347c:	0008df9d 	.word	0x0008df9d
   83480:	0009a100 	.word	0x0009a100

00083484 <_ZN3ard5ArdOs12displayStatsEv>:
    };
}

void
ArdOs::displayStats ()
{
   83484:	b590      	push	{r4, r7, lr}
   83486:	f5ad 7d01 	sub.w	sp, sp, #516	; 0x204
   8348a:	af00      	add	r7, sp, #0
   8348c:	1d3b      	adds	r3, r7, #4
   8348e:	6018      	str	r0, [r3, #0]
  char text[40 * configMAX_PRIORITIES];
  vTaskList (text);
   83490:	f107 0308 	add.w	r3, r7, #8
   83494:	4618      	mov	r0, r3
   83496:	4bb6      	ldr	r3, [pc, #728]	; (83770 <_ZN3ard5ArdOs12displayStatsEv+0x2ec>)
   83498:	4798      	blx	r3
  dprintln ("--------------- ArdOs Stats  ------------------");
   8349a:	f107 03f8 	add.w	r3, r7, #248	; 0xf8
   8349e:	49b5      	ldr	r1, [pc, #724]	; (83774 <_ZN3ard5ArdOs12displayStatsEv+0x2f0>)
   834a0:	4618      	mov	r0, r3
   834a2:	4bb5      	ldr	r3, [pc, #724]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   834a4:	4798      	blx	r3
   834a6:	f107 02f8 	add.w	r2, r7, #248	; 0xf8
   834aa:	1d3b      	adds	r3, r7, #4
   834ac:	4611      	mov	r1, r2
   834ae:	6818      	ldr	r0, [r3, #0]
   834b0:	4bb2      	ldr	r3, [pc, #712]	; (8377c <_ZN3ard5ArdOs12displayStatsEv+0x2f8>)
   834b2:	4798      	blx	r3
   834b4:	f107 03f8 	add.w	r3, r7, #248	; 0xf8
   834b8:	4618      	mov	r0, r3
   834ba:	4bb1      	ldr	r3, [pc, #708]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   834bc:	4798      	blx	r3
  dprintln ("|   Thread   | State | Prio | Free stack | ID |");
   834be:	f507 7382 	add.w	r3, r7, #260	; 0x104
   834c2:	49b0      	ldr	r1, [pc, #704]	; (83784 <_ZN3ard5ArdOs12displayStatsEv+0x300>)
   834c4:	4618      	mov	r0, r3
   834c6:	4bac      	ldr	r3, [pc, #688]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   834c8:	4798      	blx	r3
   834ca:	f507 7282 	add.w	r2, r7, #260	; 0x104
   834ce:	1d3b      	adds	r3, r7, #4
   834d0:	4611      	mov	r1, r2
   834d2:	6818      	ldr	r0, [r3, #0]
   834d4:	4ba9      	ldr	r3, [pc, #676]	; (8377c <_ZN3ard5ArdOs12displayStatsEv+0x2f8>)
   834d6:	4798      	blx	r3
   834d8:	f507 7382 	add.w	r3, r7, #260	; 0x104
   834dc:	4618      	mov	r0, r3
   834de:	4ba8      	ldr	r3, [pc, #672]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   834e0:	4798      	blx	r3
  dprintln ("-----------------------------------------------");
   834e2:	f507 7388 	add.w	r3, r7, #272	; 0x110
   834e6:	49a8      	ldr	r1, [pc, #672]	; (83788 <_ZN3ard5ArdOs12displayStatsEv+0x304>)
   834e8:	4618      	mov	r0, r3
   834ea:	4ba3      	ldr	r3, [pc, #652]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   834ec:	4798      	blx	r3
   834ee:	f507 7288 	add.w	r2, r7, #272	; 0x110
   834f2:	1d3b      	adds	r3, r7, #4
   834f4:	4611      	mov	r1, r2
   834f6:	6818      	ldr	r0, [r3, #0]
   834f8:	4ba0      	ldr	r3, [pc, #640]	; (8377c <_ZN3ard5ArdOs12displayStatsEv+0x2f8>)
   834fa:	4798      	blx	r3
   834fc:	f507 7388 	add.w	r3, r7, #272	; 0x110
   83500:	4618      	mov	r0, r3
   83502:	4b9f      	ldr	r3, [pc, #636]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   83504:	4798      	blx	r3
  dprintln (text);
   83506:	f107 0208 	add.w	r2, r7, #8
   8350a:	f507 738e 	add.w	r3, r7, #284	; 0x11c
   8350e:	4611      	mov	r1, r2
   83510:	4618      	mov	r0, r3
   83512:	4b99      	ldr	r3, [pc, #612]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   83514:	4798      	blx	r3
   83516:	f507 728e 	add.w	r2, r7, #284	; 0x11c
   8351a:	1d3b      	adds	r3, r7, #4
   8351c:	4611      	mov	r1, r2
   8351e:	6818      	ldr	r0, [r3, #0]
   83520:	4b96      	ldr	r3, [pc, #600]	; (8377c <_ZN3ard5ArdOs12displayStatsEv+0x2f8>)
   83522:	4798      	blx	r3
   83524:	f507 738e 	add.w	r3, r7, #284	; 0x11c
   83528:	4618      	mov	r0, r3
   8352a:	4b95      	ldr	r3, [pc, #596]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   8352c:	4798      	blx	r3
  dprintln (
   8352e:	f507 7394 	add.w	r3, r7, #296	; 0x128
   83532:	4996      	ldr	r1, [pc, #600]	; (8378c <_ZN3ard5ArdOs12displayStatsEv+0x308>)
   83534:	4618      	mov	r0, r3
   83536:	4b90      	ldr	r3, [pc, #576]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   83538:	4798      	blx	r3
      " * States : blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').");
   8353a:	f507 7294 	add.w	r2, r7, #296	; 0x128
   8353e:	1d3b      	adds	r3, r7, #4
   83540:	4611      	mov	r1, r2
   83542:	6818      	ldr	r0, [r3, #0]
   83544:	4b8d      	ldr	r3, [pc, #564]	; (8377c <_ZN3ard5ArdOs12displayStatsEv+0x2f8>)
   83546:	4798      	blx	r3
  vTaskList (text);
  dprintln ("--------------- ArdOs Stats  ------------------");
  dprintln ("|   Thread   | State | Prio | Free stack | ID |");
  dprintln ("-----------------------------------------------");
  dprintln (text);
  dprintln (
   83548:	f507 7394 	add.w	r3, r7, #296	; 0x128
   8354c:	4618      	mov	r0, r3
   8354e:	4b8c      	ldr	r3, [pc, #560]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   83550:	4798      	blx	r3
      " * States : blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').");
  dprintln (" * Priority : higher number, higher priority");
   83552:	f507 739a 	add.w	r3, r7, #308	; 0x134
   83556:	498e      	ldr	r1, [pc, #568]	; (83790 <_ZN3ard5ArdOs12displayStatsEv+0x30c>)
   83558:	4618      	mov	r0, r3
   8355a:	4b87      	ldr	r3, [pc, #540]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   8355c:	4798      	blx	r3
   8355e:	f507 729a 	add.w	r2, r7, #308	; 0x134
   83562:	1d3b      	adds	r3, r7, #4
   83564:	4611      	mov	r1, r2
   83566:	6818      	ldr	r0, [r3, #0]
   83568:	4b84      	ldr	r3, [pc, #528]	; (8377c <_ZN3ard5ArdOs12displayStatsEv+0x2f8>)
   8356a:	4798      	blx	r3
   8356c:	f507 739a 	add.w	r3, r7, #308	; 0x134
   83570:	4618      	mov	r0, r3
   83572:	4b83      	ldr	r3, [pc, #524]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   83574:	4798      	blx	r3
  dprintln ("-----------------------------------------------");
   83576:	f507 73a0 	add.w	r3, r7, #320	; 0x140
   8357a:	4983      	ldr	r1, [pc, #524]	; (83788 <_ZN3ard5ArdOs12displayStatsEv+0x304>)
   8357c:	4618      	mov	r0, r3
   8357e:	4b7e      	ldr	r3, [pc, #504]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   83580:	4798      	blx	r3
   83582:	f507 72a0 	add.w	r2, r7, #320	; 0x140
   83586:	1d3b      	adds	r3, r7, #4
   83588:	4611      	mov	r1, r2
   8358a:	6818      	ldr	r0, [r3, #0]
   8358c:	4b7b      	ldr	r3, [pc, #492]	; (8377c <_ZN3ard5ArdOs12displayStatsEv+0x2f8>)
   8358e:	4798      	blx	r3
   83590:	f507 73a0 	add.w	r3, r7, #320	; 0x140
   83594:	4618      	mov	r0, r3
   83596:	4b7a      	ldr	r3, [pc, #488]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   83598:	4798      	blx	r3
  dprintln (
      String ("Nb Threads : ") + String (nextThreadRank + 2) + " / "
   8359a:	f507 73b2 	add.w	r3, r7, #356	; 0x164
   8359e:	497d      	ldr	r1, [pc, #500]	; (83794 <_ZN3ard5ArdOs12displayStatsEv+0x310>)
   835a0:	4618      	mov	r0, r3
   835a2:	4b75      	ldr	r3, [pc, #468]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   835a4:	4798      	blx	r3
   835a6:	f507 72b2 	add.w	r2, r7, #356	; 0x164
   835aa:	f507 73ac 	add.w	r3, r7, #344	; 0x158
   835ae:	4611      	mov	r1, r2
   835b0:	4618      	mov	r0, r3
   835b2:	4b79      	ldr	r3, [pc, #484]	; (83798 <_ZN3ard5ArdOs12displayStatsEv+0x314>)
   835b4:	4798      	blx	r3
   835b6:	1d3b      	adds	r3, r7, #4
   835b8:	681b      	ldr	r3, [r3, #0]
   835ba:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
   835be:	1c99      	adds	r1, r3, #2
   835c0:	f507 73b8 	add.w	r3, r7, #368	; 0x170
   835c4:	220a      	movs	r2, #10
   835c6:	4618      	mov	r0, r3
   835c8:	4b74      	ldr	r3, [pc, #464]	; (8379c <_ZN3ard5ArdOs12displayStatsEv+0x318>)
   835ca:	4798      	blx	r3
   835cc:	f507 72b8 	add.w	r2, r7, #368	; 0x170
   835d0:	f507 73ac 	add.w	r3, r7, #344	; 0x158
   835d4:	4611      	mov	r1, r2
   835d6:	4618      	mov	r0, r3
   835d8:	4b71      	ldr	r3, [pc, #452]	; (837a0 <_ZN3ard5ArdOs12displayStatsEv+0x31c>)
   835da:	4798      	blx	r3
   835dc:	4603      	mov	r3, r0
   835de:	4971      	ldr	r1, [pc, #452]	; (837a4 <_ZN3ard5ArdOs12displayStatsEv+0x320>)
   835e0:	4618      	mov	r0, r3
   835e2:	4b71      	ldr	r3, [pc, #452]	; (837a8 <_ZN3ard5ArdOs12displayStatsEv+0x324>)
   835e4:	4798      	blx	r3
   835e6:	4604      	mov	r4, r0
	  + String(configMAX_PRIORITIES + 1));
   835e8:	f507 73be 	add.w	r3, r7, #380	; 0x17c
   835ec:	220a      	movs	r2, #10
   835ee:	2107      	movs	r1, #7
   835f0:	4618      	mov	r0, r3
   835f2:	4b6a      	ldr	r3, [pc, #424]	; (8379c <_ZN3ard5ArdOs12displayStatsEv+0x318>)
   835f4:	4798      	blx	r3
   835f6:	f507 73be 	add.w	r3, r7, #380	; 0x17c
   835fa:	4619      	mov	r1, r3
   835fc:	4620      	mov	r0, r4
   835fe:	4b68      	ldr	r3, [pc, #416]	; (837a0 <_ZN3ard5ArdOs12displayStatsEv+0x31c>)
   83600:	4798      	blx	r3
   83602:	4603      	mov	r3, r0
  dprintln (text);
  dprintln (
      " * States : blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').");
  dprintln (" * Priority : higher number, higher priority");
  dprintln ("-----------------------------------------------");
  dprintln (
   83604:	461a      	mov	r2, r3
   83606:	f507 73a6 	add.w	r3, r7, #332	; 0x14c
   8360a:	4611      	mov	r1, r2
   8360c:	4618      	mov	r0, r3
   8360e:	4b67      	ldr	r3, [pc, #412]	; (837ac <_ZN3ard5ArdOs12displayStatsEv+0x328>)
   83610:	4798      	blx	r3
      String ("Nb Threads : ") + String (nextThreadRank + 2) + " / "
	  + String(configMAX_PRIORITIES + 1));
   83612:	f507 72a6 	add.w	r2, r7, #332	; 0x14c
   83616:	1d3b      	adds	r3, r7, #4
   83618:	4611      	mov	r1, r2
   8361a:	6818      	ldr	r0, [r3, #0]
   8361c:	4b57      	ldr	r3, [pc, #348]	; (8377c <_ZN3ard5ArdOs12displayStatsEv+0x2f8>)
   8361e:	4798      	blx	r3
  dprintln (text);
  dprintln (
      " * States : blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').");
  dprintln (" * Priority : higher number, higher priority");
  dprintln ("-----------------------------------------------");
  dprintln (
   83620:	f507 73a6 	add.w	r3, r7, #332	; 0x14c
   83624:	4618      	mov	r0, r3
   83626:	4b56      	ldr	r3, [pc, #344]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   83628:	4798      	blx	r3
      String ("Nb Threads : ") + String (nextThreadRank + 2) + " / "
	  + String(configMAX_PRIORITIES + 1));
   8362a:	f507 73be 	add.w	r3, r7, #380	; 0x17c
   8362e:	4618      	mov	r0, r3
   83630:	4b53      	ldr	r3, [pc, #332]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   83632:	4798      	blx	r3
  dprintln (
      " * States : blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').");
  dprintln (" * Priority : higher number, higher priority");
  dprintln ("-----------------------------------------------");
  dprintln (
      String ("Nb Threads : ") + String (nextThreadRank + 2) + " / "
   83634:	f507 73b8 	add.w	r3, r7, #368	; 0x170
   83638:	4618      	mov	r0, r3
   8363a:	4b51      	ldr	r3, [pc, #324]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   8363c:	4798      	blx	r3
   8363e:	f507 73ac 	add.w	r3, r7, #344	; 0x158
   83642:	4618      	mov	r0, r3
   83644:	4b5a      	ldr	r3, [pc, #360]	; (837b0 <_ZN3ard5ArdOs12displayStatsEv+0x32c>)
   83646:	4798      	blx	r3
   83648:	f507 73b2 	add.w	r3, r7, #356	; 0x164
   8364c:	4618      	mov	r0, r3
   8364e:	4b4c      	ldr	r3, [pc, #304]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   83650:	4798      	blx	r3
	  + String(configMAX_PRIORITIES + 1));
  dprintln (String ("Nb Mutexes : ") + mutexCount);
   83652:	f507 73d0 	add.w	r3, r7, #416	; 0x1a0
   83656:	4957      	ldr	r1, [pc, #348]	; (837b4 <_ZN3ard5ArdOs12displayStatsEv+0x330>)
   83658:	4618      	mov	r0, r3
   8365a:	4b47      	ldr	r3, [pc, #284]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   8365c:	4798      	blx	r3
   8365e:	f507 72d0 	add.w	r2, r7, #416	; 0x1a0
   83662:	f507 73ca 	add.w	r3, r7, #404	; 0x194
   83666:	4611      	mov	r1, r2
   83668:	4618      	mov	r0, r3
   8366a:	4b4b      	ldr	r3, [pc, #300]	; (83798 <_ZN3ard5ArdOs12displayStatsEv+0x314>)
   8366c:	4798      	blx	r3
   8366e:	1d3b      	adds	r3, r7, #4
   83670:	681b      	ldr	r3, [r3, #0]
   83672:	8b5b      	ldrh	r3, [r3, #26]
   83674:	461a      	mov	r2, r3
   83676:	f507 73ca 	add.w	r3, r7, #404	; 0x194
   8367a:	4611      	mov	r1, r2
   8367c:	4618      	mov	r0, r3
   8367e:	4b4e      	ldr	r3, [pc, #312]	; (837b8 <_ZN3ard5ArdOs12displayStatsEv+0x334>)
   83680:	4798      	blx	r3
   83682:	4603      	mov	r3, r0
   83684:	461a      	mov	r2, r3
   83686:	f507 73c4 	add.w	r3, r7, #392	; 0x188
   8368a:	4611      	mov	r1, r2
   8368c:	4618      	mov	r0, r3
   8368e:	4b47      	ldr	r3, [pc, #284]	; (837ac <_ZN3ard5ArdOs12displayStatsEv+0x328>)
   83690:	4798      	blx	r3
   83692:	f507 72c4 	add.w	r2, r7, #392	; 0x188
   83696:	1d3b      	adds	r3, r7, #4
   83698:	4611      	mov	r1, r2
   8369a:	6818      	ldr	r0, [r3, #0]
   8369c:	4b37      	ldr	r3, [pc, #220]	; (8377c <_ZN3ard5ArdOs12displayStatsEv+0x2f8>)
   8369e:	4798      	blx	r3
   836a0:	f507 73c4 	add.w	r3, r7, #392	; 0x188
   836a4:	4618      	mov	r0, r3
   836a6:	4b36      	ldr	r3, [pc, #216]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   836a8:	4798      	blx	r3
   836aa:	f507 73ca 	add.w	r3, r7, #404	; 0x194
   836ae:	4618      	mov	r0, r3
   836b0:	4b3f      	ldr	r3, [pc, #252]	; (837b0 <_ZN3ard5ArdOs12displayStatsEv+0x32c>)
   836b2:	4798      	blx	r3
   836b4:	f507 73d0 	add.w	r3, r7, #416	; 0x1a0
   836b8:	4618      	mov	r0, r3
   836ba:	4b31      	ldr	r3, [pc, #196]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   836bc:	4798      	blx	r3
  dprintln (String ("Nb Signals : ") + signalCount);
   836be:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
   836c2:	493e      	ldr	r1, [pc, #248]	; (837bc <_ZN3ard5ArdOs12displayStatsEv+0x338>)
   836c4:	4618      	mov	r0, r3
   836c6:	4b2c      	ldr	r3, [pc, #176]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   836c8:	4798      	blx	r3
   836ca:	f507 72e2 	add.w	r2, r7, #452	; 0x1c4
   836ce:	f507 73dc 	add.w	r3, r7, #440	; 0x1b8
   836d2:	4611      	mov	r1, r2
   836d4:	4618      	mov	r0, r3
   836d6:	4b30      	ldr	r3, [pc, #192]	; (83798 <_ZN3ard5ArdOs12displayStatsEv+0x314>)
   836d8:	4798      	blx	r3
   836da:	1d3b      	adds	r3, r7, #4
   836dc:	681b      	ldr	r3, [r3, #0]
   836de:	8b1b      	ldrh	r3, [r3, #24]
   836e0:	461a      	mov	r2, r3
   836e2:	f507 73dc 	add.w	r3, r7, #440	; 0x1b8
   836e6:	4611      	mov	r1, r2
   836e8:	4618      	mov	r0, r3
   836ea:	4b33      	ldr	r3, [pc, #204]	; (837b8 <_ZN3ard5ArdOs12displayStatsEv+0x334>)
   836ec:	4798      	blx	r3
   836ee:	4603      	mov	r3, r0
   836f0:	461a      	mov	r2, r3
   836f2:	f507 73d6 	add.w	r3, r7, #428	; 0x1ac
   836f6:	4611      	mov	r1, r2
   836f8:	4618      	mov	r0, r3
   836fa:	4b2c      	ldr	r3, [pc, #176]	; (837ac <_ZN3ard5ArdOs12displayStatsEv+0x328>)
   836fc:	4798      	blx	r3
   836fe:	f507 72d6 	add.w	r2, r7, #428	; 0x1ac
   83702:	1d3b      	adds	r3, r7, #4
   83704:	4611      	mov	r1, r2
   83706:	6818      	ldr	r0, [r3, #0]
   83708:	4b1c      	ldr	r3, [pc, #112]	; (8377c <_ZN3ard5ArdOs12displayStatsEv+0x2f8>)
   8370a:	4798      	blx	r3
   8370c:	f507 73d6 	add.w	r3, r7, #428	; 0x1ac
   83710:	4618      	mov	r0, r3
   83712:	4b1b      	ldr	r3, [pc, #108]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   83714:	4798      	blx	r3
   83716:	f507 73dc 	add.w	r3, r7, #440	; 0x1b8
   8371a:	4618      	mov	r0, r3
   8371c:	4b24      	ldr	r3, [pc, #144]	; (837b0 <_ZN3ard5ArdOs12displayStatsEv+0x32c>)
   8371e:	4798      	blx	r3
   83720:	f507 73e2 	add.w	r3, r7, #452	; 0x1c4
   83724:	4618      	mov	r0, r3
   83726:	4b16      	ldr	r3, [pc, #88]	; (83780 <_ZN3ard5ArdOs12displayStatsEv+0x2fc>)
   83728:	4798      	blx	r3
  dprintln (String ("Booted in ") + bootDuration + " ms.");
   8372a:	f507 73f4 	add.w	r3, r7, #488	; 0x1e8
   8372e:	4924      	ldr	r1, [pc, #144]	; (837c0 <_ZN3ard5ArdOs12displayStatsEv+0x33c>)
   83730:	4618      	mov	r0, r3
   83732:	4b11      	ldr	r3, [pc, #68]	; (83778 <_ZN3ard5ArdOs12displayStatsEv+0x2f4>)
   83734:	4798      	blx	r3
   83736:	f507 72f4 	add.w	r2, r7, #488	; 0x1e8
   8373a:	f507 73ee 	add.w	r3, r7, #476	; 0x1dc
   8373e:	4611      	mov	r1, r2
   83740:	4618      	mov	r0, r3
   83742:	4b15      	ldr	r3, [pc, #84]	; (83798 <_ZN3ard5ArdOs12displayStatsEv+0x314>)
   83744:	4798      	blx	r3
   83746:	1d3b      	adds	r3, r7, #4
   83748:	681b      	ldr	r3, [r3, #0]
   8374a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
   8374c:	f507 73ee 	add.w	r3, r7, #476	; 0x1dc
   83750:	4611      	mov	r1, r2
   83752:	4618      	mov	r0, r3
   83754:	4b1b      	ldr	r3, [pc, #108]	; (837c4 <_ZN3ard5ArdOs12displayStatsEv+0x340>)
   83756:	4798      	blx	r3
   83758:	4603      	mov	r3, r0
   8375a:	491b      	ldr	r1, [pc, #108]	; (837c8 <_ZN3ard5ArdOs12displayStatsEv+0x344>)
   8375c:	4618      	mov	r0, r3
   8375e:	4b12      	ldr	r3, [pc, #72]	; (837a8 <_ZN3ard5ArdOs12displayStatsEv+0x324>)
   83760:	4798      	blx	r3
   83762:	4603      	mov	r3, r0
   83764:	461a      	mov	r2, r3
   83766:	f507 73e8 	add.w	r3, r7, #464	; 0x1d0
   8376a:	4611      	mov	r1, r2
   8376c:	4618      	mov	r0, r3
   8376e:	e02d      	b.n	837cc <_ZN3ard5ArdOs12displayStatsEv+0x348>
   83770:	0008ef91 	.word	0x0008ef91
   83774:	0009a11c 	.word	0x0009a11c
   83778:	00089009 	.word	0x00089009
   8377c:	00083845 	.word	0x00083845
   83780:	00089145 	.word	0x00089145
   83784:	0009a14c 	.word	0x0009a14c
   83788:	0009a17c 	.word	0x0009a17c
   8378c:	0009a1ac 	.word	0x0009a1ac
   83790:	0009a1f8 	.word	0x0009a1f8
   83794:	0009a228 	.word	0x0009a228
   83798:	00082f89 	.word	0x00082f89
   8379c:	000890bd 	.word	0x000890bd
   837a0:	000894d5 	.word	0x000894d5
   837a4:	0009a238 	.word	0x0009a238
   837a8:	0008951d 	.word	0x0008951d
   837ac:	00089049 	.word	0x00089049
   837b0:	00082fe9 	.word	0x00082fe9
   837b4:	0009a23c 	.word	0x0009a23c
   837b8:	000895bd 	.word	0x000895bd
   837bc:	0009a24c 	.word	0x0009a24c
   837c0:	0009a25c 	.word	0x0009a25c
   837c4:	00089601 	.word	0x00089601
   837c8:	0009a0f8 	.word	0x0009a0f8
   837cc:	4b17      	ldr	r3, [pc, #92]	; (8382c <_ZN3ard5ArdOs12displayStatsEv+0x3a8>)
   837ce:	4798      	blx	r3
   837d0:	f507 72e8 	add.w	r2, r7, #464	; 0x1d0
   837d4:	1d3b      	adds	r3, r7, #4
   837d6:	4611      	mov	r1, r2
   837d8:	6818      	ldr	r0, [r3, #0]
   837da:	4b15      	ldr	r3, [pc, #84]	; (83830 <_ZN3ard5ArdOs12displayStatsEv+0x3ac>)
   837dc:	4798      	blx	r3
   837de:	f507 73e8 	add.w	r3, r7, #464	; 0x1d0
   837e2:	4618      	mov	r0, r3
   837e4:	4b13      	ldr	r3, [pc, #76]	; (83834 <_ZN3ard5ArdOs12displayStatsEv+0x3b0>)
   837e6:	4798      	blx	r3
   837e8:	f507 73ee 	add.w	r3, r7, #476	; 0x1dc
   837ec:	4618      	mov	r0, r3
   837ee:	4b12      	ldr	r3, [pc, #72]	; (83838 <_ZN3ard5ArdOs12displayStatsEv+0x3b4>)
   837f0:	4798      	blx	r3
   837f2:	f507 73f4 	add.w	r3, r7, #488	; 0x1e8
   837f6:	4618      	mov	r0, r3
   837f8:	4b0e      	ldr	r3, [pc, #56]	; (83834 <_ZN3ard5ArdOs12displayStatsEv+0x3b0>)
   837fa:	4798      	blx	r3
  dprintln ("-----------------------------------------------");
   837fc:	f507 73fa 	add.w	r3, r7, #500	; 0x1f4
   83800:	490e      	ldr	r1, [pc, #56]	; (8383c <_ZN3ard5ArdOs12displayStatsEv+0x3b8>)
   83802:	4618      	mov	r0, r3
   83804:	4b0e      	ldr	r3, [pc, #56]	; (83840 <_ZN3ard5ArdOs12displayStatsEv+0x3bc>)
   83806:	4798      	blx	r3
   83808:	f507 72fa 	add.w	r2, r7, #500	; 0x1f4
   8380c:	1d3b      	adds	r3, r7, #4
   8380e:	4611      	mov	r1, r2
   83810:	6818      	ldr	r0, [r3, #0]
   83812:	4b07      	ldr	r3, [pc, #28]	; (83830 <_ZN3ard5ArdOs12displayStatsEv+0x3ac>)
   83814:	4798      	blx	r3
   83816:	f507 73fa 	add.w	r3, r7, #500	; 0x1f4
   8381a:	4618      	mov	r0, r3
   8381c:	4b05      	ldr	r3, [pc, #20]	; (83834 <_ZN3ard5ArdOs12displayStatsEv+0x3b0>)
   8381e:	4798      	blx	r3

  //TODO static reportStackSizes
  //TODO static reportCpuConsumption
}
   83820:	bf00      	nop
   83822:	f507 7701 	add.w	r7, r7, #516	; 0x204
   83826:	46bd      	mov	sp, r7
   83828:	bd90      	pop	{r4, r7, pc}
   8382a:	bf00      	nop
   8382c:	00089049 	.word	0x00089049
   83830:	00083845 	.word	0x00083845
   83834:	00089145 	.word	0x00089145
   83838:	00082fe9 	.word	0x00082fe9
   8383c:	0009a17c 	.word	0x0009a17c
   83840:	00089009 	.word	0x00089009

00083844 <_ZN3ard5ArdOs8dprintlnE6String>:

void
ArdOs::dprintln(String s)
{
   83844:	b590      	push	{r4, r7, lr}
   83846:	b083      	sub	sp, #12
   83848:	af00      	add	r7, sp, #0
   8384a:	6078      	str	r0, [r7, #4]
   8384c:	6039      	str	r1, [r7, #0]
  //it's not possible to protect the link until the OS is setup (then the mutex pointer is no more NULL
  //but when set, use the mutex.
  if(debugSerialMutex)
   8384e:	687b      	ldr	r3, [r7, #4]
   83850:	6f9b      	ldr	r3, [r3, #120]	; 0x78
   83852:	2b00      	cmp	r3, #0
   83854:	d015      	beq.n	83882 <_ZN3ard5ArdOs8dprintlnE6String+0x3e>
    {
      xSemaphoreGive(debugSerialMutex);
   83856:	687b      	ldr	r3, [r7, #4]
   83858:	6f98      	ldr	r0, [r3, #120]	; 0x78
   8385a:	2300      	movs	r3, #0
   8385c:	2200      	movs	r2, #0
   8385e:	2100      	movs	r1, #0
   83860:	4c0d      	ldr	r4, [pc, #52]	; (83898 <_ZN3ard5ArdOs8dprintlnE6String+0x54>)
   83862:	47a0      	blx	r4
      Serial.println(s);
   83864:	6839      	ldr	r1, [r7, #0]
   83866:	480d      	ldr	r0, [pc, #52]	; (8389c <_ZN3ard5ArdOs8dprintlnE6String+0x58>)
   83868:	4b0d      	ldr	r3, [pc, #52]	; (838a0 <_ZN3ard5ArdOs8dprintlnE6String+0x5c>)
   8386a:	4798      	blx	r3
      Serial.flush();
   8386c:	480b      	ldr	r0, [pc, #44]	; (8389c <_ZN3ard5ArdOs8dprintlnE6String+0x58>)
   8386e:	4b0d      	ldr	r3, [pc, #52]	; (838a4 <_ZN3ard5ArdOs8dprintlnE6String+0x60>)
   83870:	4798      	blx	r3
      xSemaphoreGive(debugSerialMutex);
   83872:	687b      	ldr	r3, [r7, #4]
   83874:	6f98      	ldr	r0, [r3, #120]	; 0x78
   83876:	2300      	movs	r3, #0
   83878:	2200      	movs	r2, #0
   8387a:	2100      	movs	r1, #0
   8387c:	4c06      	ldr	r4, [pc, #24]	; (83898 <_ZN3ard5ArdOs8dprintlnE6String+0x54>)
   8387e:	47a0      	blx	r4
  else
    {
      Serial.println(s);
      Serial.flush();
    }
}
   83880:	e006      	b.n	83890 <_ZN3ard5ArdOs8dprintlnE6String+0x4c>
      Serial.flush();
      xSemaphoreGive(debugSerialMutex);
    }
  else
    {
      Serial.println(s);
   83882:	6839      	ldr	r1, [r7, #0]
   83884:	4805      	ldr	r0, [pc, #20]	; (8389c <_ZN3ard5ArdOs8dprintlnE6String+0x58>)
   83886:	4b06      	ldr	r3, [pc, #24]	; (838a0 <_ZN3ard5ArdOs8dprintlnE6String+0x5c>)
   83888:	4798      	blx	r3
      Serial.flush();
   8388a:	4804      	ldr	r0, [pc, #16]	; (8389c <_ZN3ard5ArdOs8dprintlnE6String+0x58>)
   8388c:	4b05      	ldr	r3, [pc, #20]	; (838a4 <_ZN3ard5ArdOs8dprintlnE6String+0x60>)
   8388e:	4798      	blx	r3
    }
}
   83890:	bf00      	nop
   83892:	370c      	adds	r7, #12
   83894:	46bd      	mov	sp, r7
   83896:	bd90      	pop	{r4, r7, pc}
   83898:	0008d44d 	.word	0x0008d44d
   8389c:	20070dd8 	.word	0x20070dd8
   838a0:	000879f9 	.word	0x000879f9
   838a4:	000807f1 	.word	0x000807f1

000838a8 <_ZN3ard5ArdOs16createThread_CppEPKcRNS_7IThreadEtt>:
}

void
ArdOs::createThread_Cpp (const char * const name, IThread& pClass,
			 uint16_t stack, uint16_t priority)
{
   838a8:	b590      	push	{r4, r7, lr}
   838aa:	b087      	sub	sp, #28
   838ac:	af02      	add	r7, sp, #8
   838ae:	60f8      	str	r0, [r7, #12]
   838b0:	60b9      	str	r1, [r7, #8]
   838b2:	607a      	str	r2, [r7, #4]
   838b4:	807b      	strh	r3, [r7, #2]
  createPeriodicThread_Cpp (name, pClass, stack, priority, 0);
   838b6:	887a      	ldrh	r2, [r7, #2]
   838b8:	2300      	movs	r3, #0
   838ba:	9301      	str	r3, [sp, #4]
   838bc:	8c3b      	ldrh	r3, [r7, #32]
   838be:	9300      	str	r3, [sp, #0]
   838c0:	4613      	mov	r3, r2
   838c2:	687a      	ldr	r2, [r7, #4]
   838c4:	68b9      	ldr	r1, [r7, #8]
   838c6:	68f8      	ldr	r0, [r7, #12]
   838c8:	4c02      	ldr	r4, [pc, #8]	; (838d4 <_ZN3ard5ArdOs16createThread_CppEPKcRNS_7IThreadEtt+0x2c>)
   838ca:	47a0      	blx	r4
}
   838cc:	bf00      	nop
   838ce:	3714      	adds	r7, #20
   838d0:	46bd      	mov	sp, r7
   838d2:	bd90      	pop	{r4, r7, pc}
   838d4:	000838d9 	.word	0x000838d9

000838d8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt>:

void
ArdOs::createPeriodicThread_Cpp (const char * const name, IThread& pClass,
				 uint16_t stack, uint16_t priority,
				 uint16_t periodMs)
{
   838d8:	b5b0      	push	{r4, r5, r7, lr}
   838da:	b0b2      	sub	sp, #200	; 0xc8
   838dc:	af04      	add	r7, sp, #16
   838de:	60f8      	str	r0, [r7, #12]
   838e0:	60b9      	str	r1, [r7, #8]
   838e2:	607a      	str	r2, [r7, #4]
   838e4:	807b      	strh	r3, [r7, #2]
  ardAssert(state == eOsState::UNINIT,
   838e6:	68fb      	ldr	r3, [r7, #12]
   838e8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   838ea:	2b00      	cmp	r3, #0
   838ec:	d037      	beq.n	8395e <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x86>
   838ee:	4bb8      	ldr	r3, [pc, #736]	; (83bd0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x2f8>)
   838f0:	4798      	blx	r3
   838f2:	4604      	mov	r4, r0
   838f4:	f107 0328 	add.w	r3, r7, #40	; 0x28
   838f8:	49b6      	ldr	r1, [pc, #728]	; (83bd4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x2fc>)
   838fa:	4618      	mov	r0, r3
   838fc:	4bb6      	ldr	r3, [pc, #728]	; (83bd8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x300>)
   838fe:	4798      	blx	r3
   83900:	f107 0228 	add.w	r2, r7, #40	; 0x28
   83904:	f107 031c 	add.w	r3, r7, #28
   83908:	4611      	mov	r1, r2
   8390a:	4618      	mov	r0, r3
   8390c:	4bb3      	ldr	r3, [pc, #716]	; (83bdc <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x304>)
   8390e:	4798      	blx	r3
   83910:	f107 031c 	add.w	r3, r7, #28
   83914:	49b2      	ldr	r1, [pc, #712]	; (83be0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x308>)
   83916:	4618      	mov	r0, r3
   83918:	4bb2      	ldr	r3, [pc, #712]	; (83be4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x30c>)
   8391a:	4798      	blx	r3
   8391c:	4603      	mov	r3, r0
   8391e:	461a      	mov	r2, r3
   83920:	f107 0310 	add.w	r3, r7, #16
   83924:	4611      	mov	r1, r2
   83926:	4618      	mov	r0, r3
   83928:	4baf      	ldr	r3, [pc, #700]	; (83be8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x310>)
   8392a:	4798      	blx	r3
   8392c:	f107 0310 	add.w	r3, r7, #16
   83930:	4619      	mov	r1, r3
   83932:	4620      	mov	r0, r4
   83934:	4bad      	ldr	r3, [pc, #692]	; (83bec <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x314>)
   83936:	4798      	blx	r3
   83938:	f107 0310 	add.w	r3, r7, #16
   8393c:	4618      	mov	r0, r3
   8393e:	4bac      	ldr	r3, [pc, #688]	; (83bf0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x318>)
   83940:	4798      	blx	r3
   83942:	f107 031c 	add.w	r3, r7, #28
   83946:	4618      	mov	r0, r3
   83948:	4baa      	ldr	r3, [pc, #680]	; (83bf4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x31c>)
   8394a:	4798      	blx	r3
   8394c:	f107 0328 	add.w	r3, r7, #40	; 0x28
   83950:	4618      	mov	r0, r3
   83952:	4ba7      	ldr	r3, [pc, #668]	; (83bf0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x318>)
   83954:	4798      	blx	r3
   83956:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   8395a:	4ba7      	ldr	r3, [pc, #668]	; (83bf8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x320>)
   8395c:	4798      	blx	r3
	    "ArdOs is not in the right state to do a thread creation");

  //Check inputs
  ardAssert(nextThreadRank <= configMAX_PRIORITIES - 1, "Too many threads."); //there is configMAX_PRIORITIES + 1 threads, but 2 are reserved for IDLE task, and Arduino OS task so +1-2 = -1
   8395e:	68fb      	ldr	r3, [r7, #12]
   83960:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
   83964:	2b05      	cmp	r3, #5
   83966:	d937      	bls.n	839d8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x100>
   83968:	4b99      	ldr	r3, [pc, #612]	; (83bd0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x2f8>)
   8396a:	4798      	blx	r3
   8396c:	4604      	mov	r4, r0
   8396e:	f107 034c 	add.w	r3, r7, #76	; 0x4c
   83972:	4998      	ldr	r1, [pc, #608]	; (83bd4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x2fc>)
   83974:	4618      	mov	r0, r3
   83976:	4b98      	ldr	r3, [pc, #608]	; (83bd8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x300>)
   83978:	4798      	blx	r3
   8397a:	f107 024c 	add.w	r2, r7, #76	; 0x4c
   8397e:	f107 0340 	add.w	r3, r7, #64	; 0x40
   83982:	4611      	mov	r1, r2
   83984:	4618      	mov	r0, r3
   83986:	4b95      	ldr	r3, [pc, #596]	; (83bdc <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x304>)
   83988:	4798      	blx	r3
   8398a:	f107 0340 	add.w	r3, r7, #64	; 0x40
   8398e:	499b      	ldr	r1, [pc, #620]	; (83bfc <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x324>)
   83990:	4618      	mov	r0, r3
   83992:	4b94      	ldr	r3, [pc, #592]	; (83be4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x30c>)
   83994:	4798      	blx	r3
   83996:	4603      	mov	r3, r0
   83998:	461a      	mov	r2, r3
   8399a:	f107 0334 	add.w	r3, r7, #52	; 0x34
   8399e:	4611      	mov	r1, r2
   839a0:	4618      	mov	r0, r3
   839a2:	4b91      	ldr	r3, [pc, #580]	; (83be8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x310>)
   839a4:	4798      	blx	r3
   839a6:	f107 0334 	add.w	r3, r7, #52	; 0x34
   839aa:	4619      	mov	r1, r3
   839ac:	4620      	mov	r0, r4
   839ae:	4b8f      	ldr	r3, [pc, #572]	; (83bec <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x314>)
   839b0:	4798      	blx	r3
   839b2:	f107 0334 	add.w	r3, r7, #52	; 0x34
   839b6:	4618      	mov	r0, r3
   839b8:	4b8d      	ldr	r3, [pc, #564]	; (83bf0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x318>)
   839ba:	4798      	blx	r3
   839bc:	f107 0340 	add.w	r3, r7, #64	; 0x40
   839c0:	4618      	mov	r0, r3
   839c2:	4b8c      	ldr	r3, [pc, #560]	; (83bf4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x31c>)
   839c4:	4798      	blx	r3
   839c6:	f107 034c 	add.w	r3, r7, #76	; 0x4c
   839ca:	4618      	mov	r0, r3
   839cc:	4b88      	ldr	r3, [pc, #544]	; (83bf0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x318>)
   839ce:	4798      	blx	r3
   839d0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   839d4:	4b88      	ldr	r3, [pc, #544]	; (83bf8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x320>)
   839d6:	4798      	blx	r3
  ardAssert(priority <= configMAX_PRIORITIES - 1,
   839d8:	f8b7 30c8 	ldrh.w	r3, [r7, #200]	; 0xc8
   839dc:	2b05      	cmp	r3, #5
   839de:	d96d      	bls.n	83abc <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x1e4>
   839e0:	4b7b      	ldr	r3, [pc, #492]	; (83bd0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x2f8>)
   839e2:	4798      	blx	r3
   839e4:	4604      	mov	r4, r0
   839e6:	f107 0370 	add.w	r3, r7, #112	; 0x70
   839ea:	497a      	ldr	r1, [pc, #488]	; (83bd4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x2fc>)
   839ec:	4618      	mov	r0, r3
   839ee:	4b7a      	ldr	r3, [pc, #488]	; (83bd8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x300>)
   839f0:	4798      	blx	r3
   839f2:	f107 0270 	add.w	r2, r7, #112	; 0x70
   839f6:	f107 0364 	add.w	r3, r7, #100	; 0x64
   839fa:	4611      	mov	r1, r2
   839fc:	4618      	mov	r0, r3
   839fe:	4b77      	ldr	r3, [pc, #476]	; (83bdc <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x304>)
   83a00:	4798      	blx	r3
   83a02:	f107 037c 	add.w	r3, r7, #124	; 0x7c
   83a06:	68b9      	ldr	r1, [r7, #8]
   83a08:	4618      	mov	r0, r3
   83a0a:	4b73      	ldr	r3, [pc, #460]	; (83bd8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x300>)
   83a0c:	4798      	blx	r3
   83a0e:	f107 027c 	add.w	r2, r7, #124	; 0x7c
   83a12:	f107 0364 	add.w	r3, r7, #100	; 0x64
   83a16:	4611      	mov	r1, r2
   83a18:	4618      	mov	r0, r3
   83a1a:	4b79      	ldr	r3, [pc, #484]	; (83c00 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x328>)
   83a1c:	4798      	blx	r3
   83a1e:	4603      	mov	r3, r0
   83a20:	4978      	ldr	r1, [pc, #480]	; (83c04 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x32c>)
   83a22:	4618      	mov	r0, r3
   83a24:	4b6f      	ldr	r3, [pc, #444]	; (83be4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x30c>)
   83a26:	4798      	blx	r3
   83a28:	4602      	mov	r2, r0
   83a2a:	f8b7 30c8 	ldrh.w	r3, [r7, #200]	; 0xc8
   83a2e:	4619      	mov	r1, r3
   83a30:	4610      	mov	r0, r2
   83a32:	4b75      	ldr	r3, [pc, #468]	; (83c08 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x330>)
   83a34:	4798      	blx	r3
   83a36:	4603      	mov	r3, r0
   83a38:	4974      	ldr	r1, [pc, #464]	; (83c0c <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x334>)
   83a3a:	4618      	mov	r0, r3
   83a3c:	4b69      	ldr	r3, [pc, #420]	; (83be4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x30c>)
   83a3e:	4798      	blx	r3
   83a40:	4605      	mov	r5, r0
   83a42:	f107 0388 	add.w	r3, r7, #136	; 0x88
   83a46:	220a      	movs	r2, #10
   83a48:	2105      	movs	r1, #5
   83a4a:	4618      	mov	r0, r3
   83a4c:	4b70      	ldr	r3, [pc, #448]	; (83c10 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x338>)
   83a4e:	4798      	blx	r3
   83a50:	f107 0388 	add.w	r3, r7, #136	; 0x88
   83a54:	4619      	mov	r1, r3
   83a56:	4628      	mov	r0, r5
   83a58:	4b69      	ldr	r3, [pc, #420]	; (83c00 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x328>)
   83a5a:	4798      	blx	r3
   83a5c:	4603      	mov	r3, r0
   83a5e:	496d      	ldr	r1, [pc, #436]	; (83c14 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x33c>)
   83a60:	4618      	mov	r0, r3
   83a62:	4b60      	ldr	r3, [pc, #384]	; (83be4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x30c>)
   83a64:	4798      	blx	r3
   83a66:	4603      	mov	r3, r0
   83a68:	461a      	mov	r2, r3
   83a6a:	f107 0358 	add.w	r3, r7, #88	; 0x58
   83a6e:	4611      	mov	r1, r2
   83a70:	4618      	mov	r0, r3
   83a72:	4b5d      	ldr	r3, [pc, #372]	; (83be8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x310>)
   83a74:	4798      	blx	r3
   83a76:	f107 0358 	add.w	r3, r7, #88	; 0x58
   83a7a:	4619      	mov	r1, r3
   83a7c:	4620      	mov	r0, r4
   83a7e:	4b5b      	ldr	r3, [pc, #364]	; (83bec <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x314>)
   83a80:	4798      	blx	r3
   83a82:	f107 0358 	add.w	r3, r7, #88	; 0x58
   83a86:	4618      	mov	r0, r3
   83a88:	4b59      	ldr	r3, [pc, #356]	; (83bf0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x318>)
   83a8a:	4798      	blx	r3
   83a8c:	f107 0388 	add.w	r3, r7, #136	; 0x88
   83a90:	4618      	mov	r0, r3
   83a92:	4b57      	ldr	r3, [pc, #348]	; (83bf0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x318>)
   83a94:	4798      	blx	r3
   83a96:	f107 037c 	add.w	r3, r7, #124	; 0x7c
   83a9a:	4618      	mov	r0, r3
   83a9c:	4b54      	ldr	r3, [pc, #336]	; (83bf0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x318>)
   83a9e:	4798      	blx	r3
   83aa0:	f107 0364 	add.w	r3, r7, #100	; 0x64
   83aa4:	4618      	mov	r0, r3
   83aa6:	4b53      	ldr	r3, [pc, #332]	; (83bf4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x31c>)
   83aa8:	4798      	blx	r3
   83aaa:	f107 0370 	add.w	r3, r7, #112	; 0x70
   83aae:	4618      	mov	r0, r3
   83ab0:	4b4f      	ldr	r3, [pc, #316]	; (83bf0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x318>)
   83ab2:	4798      	blx	r3
   83ab4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   83ab8:	4b4f      	ldr	r3, [pc, #316]	; (83bf8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x320>)
   83aba:	4798      	blx	r3
	    String(name) + " priority ("+priority+") is too high (max is "+String(configMAX_PRIORITIES - 1)+"), check for stack/priority order or increase max value in FreeRtosConfig.h."); // configMAX_PRIORITIES is reserved for OS thread


  //fill the params
  params[nextThreadRank].pClass = &pClass;
   83abc:	68fb      	ldr	r3, [r7, #12]
   83abe:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
   83ac2:	4619      	mov	r1, r3
   83ac4:	68fa      	ldr	r2, [r7, #12]
   83ac6:	460b      	mov	r3, r1
   83ac8:	005b      	lsls	r3, r3, #1
   83aca:	440b      	add	r3, r1
   83acc:	009b      	lsls	r3, r3, #2
   83ace:	4413      	add	r3, r2
   83ad0:	331c      	adds	r3, #28
   83ad2:	687a      	ldr	r2, [r7, #4]
   83ad4:	601a      	str	r2, [r3, #0]
  params[nextThreadRank].method = NULL;
   83ad6:	68fb      	ldr	r3, [r7, #12]
   83ad8:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
   83adc:	4619      	mov	r1, r3
   83ade:	68fa      	ldr	r2, [r7, #12]
   83ae0:	460b      	mov	r3, r1
   83ae2:	005b      	lsls	r3, r3, #1
   83ae4:	440b      	add	r3, r1
   83ae6:	009b      	lsls	r3, r3, #2
   83ae8:	4413      	add	r3, r2
   83aea:	3320      	adds	r3, #32
   83aec:	2200      	movs	r2, #0
   83aee:	601a      	str	r2, [r3, #0]
  params[nextThreadRank].period = periodMs;
   83af0:	68fb      	ldr	r3, [r7, #12]
   83af2:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
   83af6:	4619      	mov	r1, r3
   83af8:	68fa      	ldr	r2, [r7, #12]
   83afa:	460b      	mov	r3, r1
   83afc:	005b      	lsls	r3, r3, #1
   83afe:	440b      	add	r3, r1
   83b00:	009b      	lsls	r3, r3, #2
   83b02:	4413      	add	r3, r2
   83b04:	3324      	adds	r3, #36	; 0x24
   83b06:	f8b7 20cc 	ldrh.w	r2, [r7, #204]	; 0xcc
   83b0a:	801a      	strh	r2, [r3, #0]

  //create the thread
  ardAssert(
   83b0c:	68fb      	ldr	r3, [r7, #12]
   83b0e:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
   83b12:	461a      	mov	r2, r3
   83b14:	4613      	mov	r3, r2
   83b16:	005b      	lsls	r3, r3, #1
   83b18:	4413      	add	r3, r2
   83b1a:	009b      	lsls	r3, r3, #2
   83b1c:	3318      	adds	r3, #24
   83b1e:	68fa      	ldr	r2, [r7, #12]
   83b20:	4413      	add	r3, r2
   83b22:	1d1c      	adds	r4, r3, #4
   83b24:	f8b7 30c8 	ldrh.w	r3, [r7, #200]	; 0xc8
   83b28:	68fa      	ldr	r2, [r7, #12]
   83b2a:	f892 2064 	ldrb.w	r2, [r2, #100]	; 0x64
   83b2e:	4611      	mov	r1, r2
   83b30:	68fa      	ldr	r2, [r7, #12]
   83b32:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
   83b36:	8878      	ldrh	r0, [r7, #2]
   83b38:	2100      	movs	r1, #0
   83b3a:	9103      	str	r1, [sp, #12]
   83b3c:	2100      	movs	r1, #0
   83b3e:	9102      	str	r1, [sp, #8]
   83b40:	9201      	str	r2, [sp, #4]
   83b42:	9300      	str	r3, [sp, #0]
   83b44:	4623      	mov	r3, r4
   83b46:	4602      	mov	r2, r0
   83b48:	68b9      	ldr	r1, [r7, #8]
   83b4a:	4833      	ldr	r0, [pc, #204]	; (83c18 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x340>)
   83b4c:	4c33      	ldr	r4, [pc, #204]	; (83c1c <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x344>)
   83b4e:	47a0      	blx	r4
   83b50:	4603      	mov	r3, r0
   83b52:	2b01      	cmp	r3, #1
   83b54:	bf14      	ite	ne
   83b56:	2301      	movne	r3, #1
   83b58:	2300      	moveq	r3, #0
   83b5a:	b2db      	uxtb	r3, r3
   83b5c:	2b00      	cmp	r3, #0
   83b5e:	d063      	beq.n	83c28 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x350>
   83b60:	4b1b      	ldr	r3, [pc, #108]	; (83bd0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x2f8>)
   83b62:	4798      	blx	r3
   83b64:	4604      	mov	r4, r0
   83b66:	f107 03ac 	add.w	r3, r7, #172	; 0xac
   83b6a:	491a      	ldr	r1, [pc, #104]	; (83bd4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x2fc>)
   83b6c:	4618      	mov	r0, r3
   83b6e:	4b1a      	ldr	r3, [pc, #104]	; (83bd8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x300>)
   83b70:	4798      	blx	r3
   83b72:	f107 02ac 	add.w	r2, r7, #172	; 0xac
   83b76:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
   83b7a:	4611      	mov	r1, r2
   83b7c:	4618      	mov	r0, r3
   83b7e:	4b17      	ldr	r3, [pc, #92]	; (83bdc <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x304>)
   83b80:	4798      	blx	r3
   83b82:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
   83b86:	4926      	ldr	r1, [pc, #152]	; (83c20 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x348>)
   83b88:	4618      	mov	r0, r3
   83b8a:	4b16      	ldr	r3, [pc, #88]	; (83be4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x30c>)
   83b8c:	4798      	blx	r3
   83b8e:	4603      	mov	r3, r0
   83b90:	461a      	mov	r2, r3
   83b92:	f107 0394 	add.w	r3, r7, #148	; 0x94
   83b96:	4611      	mov	r1, r2
   83b98:	4618      	mov	r0, r3
   83b9a:	4b13      	ldr	r3, [pc, #76]	; (83be8 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x310>)
   83b9c:	4798      	blx	r3
   83b9e:	f107 0394 	add.w	r3, r7, #148	; 0x94
   83ba2:	4619      	mov	r1, r3
   83ba4:	4620      	mov	r0, r4
   83ba6:	4b11      	ldr	r3, [pc, #68]	; (83bec <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x314>)
   83ba8:	4798      	blx	r3
   83baa:	f107 0394 	add.w	r3, r7, #148	; 0x94
   83bae:	4618      	mov	r0, r3
   83bb0:	4b0f      	ldr	r3, [pc, #60]	; (83bf0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x318>)
   83bb2:	4798      	blx	r3
   83bb4:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
   83bb8:	4618      	mov	r0, r3
   83bba:	4b0e      	ldr	r3, [pc, #56]	; (83bf4 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x31c>)
   83bbc:	4798      	blx	r3
   83bbe:	f107 03ac 	add.w	r3, r7, #172	; 0xac
   83bc2:	4618      	mov	r0, r3
   83bc4:	4b0a      	ldr	r3, [pc, #40]	; (83bf0 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x318>)
   83bc6:	4798      	blx	r3
   83bc8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   83bcc:	e02a      	b.n	83c24 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x34c>
   83bce:	bf00      	nop
   83bd0:	00082fad 	.word	0x00082fad
   83bd4:	0009a02c 	.word	0x0009a02c
   83bd8:	00089009 	.word	0x00089009
   83bdc:	00082f89 	.word	0x00082f89
   83be0:	0009a268 	.word	0x0009a268
   83be4:	0008951d 	.word	0x0008951d
   83be8:	00089049 	.word	0x00089049
   83bec:	00083845 	.word	0x00083845
   83bf0:	00089145 	.word	0x00089145
   83bf4:	00082fe9 	.word	0x00082fe9
   83bf8:	00081c7d 	.word	0x00081c7d
   83bfc:	0009a2a0 	.word	0x0009a2a0
   83c00:	000894d5 	.word	0x000894d5
   83c04:	0009a2b4 	.word	0x0009a2b4
   83c08:	000895bd 	.word	0x000895bd
   83c0c:	0009a2c0 	.word	0x0009a2c0
   83c10:	000890bd 	.word	0x000890bd
   83c14:	0009a2d8 	.word	0x0009a2d8
   83c18:	00083009 	.word	0x00083009
   83c1c:	0008dc85 	.word	0x0008dc85
   83c20:	0009a328 	.word	0x0009a328
   83c24:	4b06      	ldr	r3, [pc, #24]	; (83c40 <_ZN3ard5ArdOs24createPeriodicThread_CppEPKcRNS_7IThreadEttt+0x368>)
   83c26:	4798      	blx	r3
      pdPASS == xTaskCreate(ArdOs_genericRun, name, stack, reinterpret_cast<void*>(&params[nextThreadRank]), priority, threads[nextThreadRank]),
      "Task creation failed.");

  //increment the table index
  ++nextThreadRank;
   83c28:	68fb      	ldr	r3, [r7, #12]
   83c2a:	f893 3064 	ldrb.w	r3, [r3, #100]	; 0x64
   83c2e:	3301      	adds	r3, #1
   83c30:	b2da      	uxtb	r2, r3
   83c32:	68fb      	ldr	r3, [r7, #12]
   83c34:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
}
   83c38:	bf00      	nop
   83c3a:	37b8      	adds	r7, #184	; 0xb8
   83c3c:	46bd      	mov	sp, r7
   83c3e:	bdb0      	pop	{r4, r5, r7, pc}
   83c40:	00081c7d 	.word	0x00081c7d

00083c44 <_ZN3ard5ArdOs13Signal_createEv>:

Signal
ArdOs::Signal_create ()
{
   83c44:	b590      	push	{r4, r7, lr}
   83c46:	b097      	sub	sp, #92	; 0x5c
   83c48:	af00      	add	r7, sp, #0
   83c4a:	6078      	str	r0, [r7, #4]
  ardAssert(state == eOsState::UNINIT,
   83c4c:	687b      	ldr	r3, [r7, #4]
   83c4e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   83c50:	2b00      	cmp	r3, #0
   83c52:	d037      	beq.n	83cc4 <_ZN3ard5ArdOs13Signal_createEv+0x80>
   83c54:	4b41      	ldr	r3, [pc, #260]	; (83d5c <_ZN3ard5ArdOs13Signal_createEv+0x118>)
   83c56:	4798      	blx	r3
   83c58:	4604      	mov	r4, r0
   83c5a:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83c5e:	4940      	ldr	r1, [pc, #256]	; (83d60 <_ZN3ard5ArdOs13Signal_createEv+0x11c>)
   83c60:	4618      	mov	r0, r3
   83c62:	4b40      	ldr	r3, [pc, #256]	; (83d64 <_ZN3ard5ArdOs13Signal_createEv+0x120>)
   83c64:	4798      	blx	r3
   83c66:	f107 0224 	add.w	r2, r7, #36	; 0x24
   83c6a:	f107 0318 	add.w	r3, r7, #24
   83c6e:	4611      	mov	r1, r2
   83c70:	4618      	mov	r0, r3
   83c72:	4b3d      	ldr	r3, [pc, #244]	; (83d68 <_ZN3ard5ArdOs13Signal_createEv+0x124>)
   83c74:	4798      	blx	r3
   83c76:	f107 0318 	add.w	r3, r7, #24
   83c7a:	493c      	ldr	r1, [pc, #240]	; (83d6c <_ZN3ard5ArdOs13Signal_createEv+0x128>)
   83c7c:	4618      	mov	r0, r3
   83c7e:	4b3c      	ldr	r3, [pc, #240]	; (83d70 <_ZN3ard5ArdOs13Signal_createEv+0x12c>)
   83c80:	4798      	blx	r3
   83c82:	4603      	mov	r3, r0
   83c84:	461a      	mov	r2, r3
   83c86:	f107 030c 	add.w	r3, r7, #12
   83c8a:	4611      	mov	r1, r2
   83c8c:	4618      	mov	r0, r3
   83c8e:	4b39      	ldr	r3, [pc, #228]	; (83d74 <_ZN3ard5ArdOs13Signal_createEv+0x130>)
   83c90:	4798      	blx	r3
   83c92:	f107 030c 	add.w	r3, r7, #12
   83c96:	4619      	mov	r1, r3
   83c98:	4620      	mov	r0, r4
   83c9a:	4b37      	ldr	r3, [pc, #220]	; (83d78 <_ZN3ard5ArdOs13Signal_createEv+0x134>)
   83c9c:	4798      	blx	r3
   83c9e:	f107 030c 	add.w	r3, r7, #12
   83ca2:	4618      	mov	r0, r3
   83ca4:	4b35      	ldr	r3, [pc, #212]	; (83d7c <_ZN3ard5ArdOs13Signal_createEv+0x138>)
   83ca6:	4798      	blx	r3
   83ca8:	f107 0318 	add.w	r3, r7, #24
   83cac:	4618      	mov	r0, r3
   83cae:	4b34      	ldr	r3, [pc, #208]	; (83d80 <_ZN3ard5ArdOs13Signal_createEv+0x13c>)
   83cb0:	4798      	blx	r3
   83cb2:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83cb6:	4618      	mov	r0, r3
   83cb8:	4b30      	ldr	r3, [pc, #192]	; (83d7c <_ZN3ard5ArdOs13Signal_createEv+0x138>)
   83cba:	4798      	blx	r3
   83cbc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   83cc0:	4b30      	ldr	r3, [pc, #192]	; (83d84 <_ZN3ard5ArdOs13Signal_createEv+0x140>)
   83cc2:	4798      	blx	r3
	    "ArdOs is not in the right state to do a signal creation");
  Signal s = xSemaphoreCreateBinary();
   83cc4:	2203      	movs	r2, #3
   83cc6:	2100      	movs	r1, #0
   83cc8:	2001      	movs	r0, #1
   83cca:	4b2f      	ldr	r3, [pc, #188]	; (83d88 <_ZN3ard5ArdOs13Signal_createEv+0x144>)
   83ccc:	4798      	blx	r3
   83cce:	6578      	str	r0, [r7, #84]	; 0x54
  ardAssert(s != NULL, "No more heap");
   83cd0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   83cd2:	2b00      	cmp	r3, #0
   83cd4:	d137      	bne.n	83d46 <_ZN3ard5ArdOs13Signal_createEv+0x102>
   83cd6:	4b21      	ldr	r3, [pc, #132]	; (83d5c <_ZN3ard5ArdOs13Signal_createEv+0x118>)
   83cd8:	4798      	blx	r3
   83cda:	4604      	mov	r4, r0
   83cdc:	f107 0348 	add.w	r3, r7, #72	; 0x48
   83ce0:	491f      	ldr	r1, [pc, #124]	; (83d60 <_ZN3ard5ArdOs13Signal_createEv+0x11c>)
   83ce2:	4618      	mov	r0, r3
   83ce4:	4b1f      	ldr	r3, [pc, #124]	; (83d64 <_ZN3ard5ArdOs13Signal_createEv+0x120>)
   83ce6:	4798      	blx	r3
   83ce8:	f107 0248 	add.w	r2, r7, #72	; 0x48
   83cec:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   83cf0:	4611      	mov	r1, r2
   83cf2:	4618      	mov	r0, r3
   83cf4:	4b1c      	ldr	r3, [pc, #112]	; (83d68 <_ZN3ard5ArdOs13Signal_createEv+0x124>)
   83cf6:	4798      	blx	r3
   83cf8:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   83cfc:	4923      	ldr	r1, [pc, #140]	; (83d8c <_ZN3ard5ArdOs13Signal_createEv+0x148>)
   83cfe:	4618      	mov	r0, r3
   83d00:	4b1b      	ldr	r3, [pc, #108]	; (83d70 <_ZN3ard5ArdOs13Signal_createEv+0x12c>)
   83d02:	4798      	blx	r3
   83d04:	4603      	mov	r3, r0
   83d06:	461a      	mov	r2, r3
   83d08:	f107 0330 	add.w	r3, r7, #48	; 0x30
   83d0c:	4611      	mov	r1, r2
   83d0e:	4618      	mov	r0, r3
   83d10:	4b18      	ldr	r3, [pc, #96]	; (83d74 <_ZN3ard5ArdOs13Signal_createEv+0x130>)
   83d12:	4798      	blx	r3
   83d14:	f107 0330 	add.w	r3, r7, #48	; 0x30
   83d18:	4619      	mov	r1, r3
   83d1a:	4620      	mov	r0, r4
   83d1c:	4b16      	ldr	r3, [pc, #88]	; (83d78 <_ZN3ard5ArdOs13Signal_createEv+0x134>)
   83d1e:	4798      	blx	r3
   83d20:	f107 0330 	add.w	r3, r7, #48	; 0x30
   83d24:	4618      	mov	r0, r3
   83d26:	4b15      	ldr	r3, [pc, #84]	; (83d7c <_ZN3ard5ArdOs13Signal_createEv+0x138>)
   83d28:	4798      	blx	r3
   83d2a:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   83d2e:	4618      	mov	r0, r3
   83d30:	4b13      	ldr	r3, [pc, #76]	; (83d80 <_ZN3ard5ArdOs13Signal_createEv+0x13c>)
   83d32:	4798      	blx	r3
   83d34:	f107 0348 	add.w	r3, r7, #72	; 0x48
   83d38:	4618      	mov	r0, r3
   83d3a:	4b10      	ldr	r3, [pc, #64]	; (83d7c <_ZN3ard5ArdOs13Signal_createEv+0x138>)
   83d3c:	4798      	blx	r3
   83d3e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   83d42:	4b10      	ldr	r3, [pc, #64]	; (83d84 <_ZN3ard5ArdOs13Signal_createEv+0x140>)
   83d44:	4798      	blx	r3
  ++signalCount;
   83d46:	687b      	ldr	r3, [r7, #4]
   83d48:	8b1b      	ldrh	r3, [r3, #24]
   83d4a:	3301      	adds	r3, #1
   83d4c:	b29a      	uxth	r2, r3
   83d4e:	687b      	ldr	r3, [r7, #4]
   83d50:	831a      	strh	r2, [r3, #24]
  return s;
   83d52:	6d7b      	ldr	r3, [r7, #84]	; 0x54
}
   83d54:	4618      	mov	r0, r3
   83d56:	375c      	adds	r7, #92	; 0x5c
   83d58:	46bd      	mov	sp, r7
   83d5a:	bd90      	pop	{r4, r7, pc}
   83d5c:	00082fad 	.word	0x00082fad
   83d60:	0009a02c 	.word	0x0009a02c
   83d64:	00089009 	.word	0x00089009
   83d68:	00082f89 	.word	0x00082f89
   83d6c:	0009a340 	.word	0x0009a340
   83d70:	0008951d 	.word	0x0008951d
   83d74:	00089049 	.word	0x00089049
   83d78:	00083845 	.word	0x00083845
   83d7c:	00089145 	.word	0x00089145
   83d80:	00082fe9 	.word	0x00082fe9
   83d84:	00081c7d 	.word	0x00081c7d
   83d88:	0008d2bd 	.word	0x0008d2bd
   83d8c:	0009a378 	.word	0x0009a378

00083d90 <_ZN3ard5ArdOs10Signal_setEPv>:

void
ArdOs::Signal_set (Signal s)
{
   83d90:	b590      	push	{r4, r7, lr}
   83d92:	b08d      	sub	sp, #52	; 0x34
   83d94:	af00      	add	r7, sp, #0
   83d96:	6078      	str	r0, [r7, #4]
   83d98:	6039      	str	r1, [r7, #0]
  ardAssert(state == eOsState::RUNNING,
   83d9a:	687b      	ldr	r3, [r7, #4]
   83d9c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   83d9e:	2b01      	cmp	r3, #1
   83da0:	d037      	beq.n	83e12 <_ZN3ard5ArdOs10Signal_setEPv+0x82>
   83da2:	4b21      	ldr	r3, [pc, #132]	; (83e28 <_ZN3ard5ArdOs10Signal_setEPv+0x98>)
   83da4:	4798      	blx	r3
   83da6:	4604      	mov	r4, r0
   83da8:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83dac:	491f      	ldr	r1, [pc, #124]	; (83e2c <_ZN3ard5ArdOs10Signal_setEPv+0x9c>)
   83dae:	4618      	mov	r0, r3
   83db0:	4b1f      	ldr	r3, [pc, #124]	; (83e30 <_ZN3ard5ArdOs10Signal_setEPv+0xa0>)
   83db2:	4798      	blx	r3
   83db4:	f107 0224 	add.w	r2, r7, #36	; 0x24
   83db8:	f107 0318 	add.w	r3, r7, #24
   83dbc:	4611      	mov	r1, r2
   83dbe:	4618      	mov	r0, r3
   83dc0:	4b1c      	ldr	r3, [pc, #112]	; (83e34 <_ZN3ard5ArdOs10Signal_setEPv+0xa4>)
   83dc2:	4798      	blx	r3
   83dc4:	f107 0318 	add.w	r3, r7, #24
   83dc8:	491b      	ldr	r1, [pc, #108]	; (83e38 <_ZN3ard5ArdOs10Signal_setEPv+0xa8>)
   83dca:	4618      	mov	r0, r3
   83dcc:	4b1b      	ldr	r3, [pc, #108]	; (83e3c <_ZN3ard5ArdOs10Signal_setEPv+0xac>)
   83dce:	4798      	blx	r3
   83dd0:	4603      	mov	r3, r0
   83dd2:	461a      	mov	r2, r3
   83dd4:	f107 030c 	add.w	r3, r7, #12
   83dd8:	4611      	mov	r1, r2
   83dda:	4618      	mov	r0, r3
   83ddc:	4b18      	ldr	r3, [pc, #96]	; (83e40 <_ZN3ard5ArdOs10Signal_setEPv+0xb0>)
   83dde:	4798      	blx	r3
   83de0:	f107 030c 	add.w	r3, r7, #12
   83de4:	4619      	mov	r1, r3
   83de6:	4620      	mov	r0, r4
   83de8:	4b16      	ldr	r3, [pc, #88]	; (83e44 <_ZN3ard5ArdOs10Signal_setEPv+0xb4>)
   83dea:	4798      	blx	r3
   83dec:	f107 030c 	add.w	r3, r7, #12
   83df0:	4618      	mov	r0, r3
   83df2:	4b15      	ldr	r3, [pc, #84]	; (83e48 <_ZN3ard5ArdOs10Signal_setEPv+0xb8>)
   83df4:	4798      	blx	r3
   83df6:	f107 0318 	add.w	r3, r7, #24
   83dfa:	4618      	mov	r0, r3
   83dfc:	4b13      	ldr	r3, [pc, #76]	; (83e4c <_ZN3ard5ArdOs10Signal_setEPv+0xbc>)
   83dfe:	4798      	blx	r3
   83e00:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83e04:	4618      	mov	r0, r3
   83e06:	4b10      	ldr	r3, [pc, #64]	; (83e48 <_ZN3ard5ArdOs10Signal_setEPv+0xb8>)
   83e08:	4798      	blx	r3
   83e0a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   83e0e:	4b10      	ldr	r3, [pc, #64]	; (83e50 <_ZN3ard5ArdOs10Signal_setEPv+0xc0>)
   83e10:	4798      	blx	r3
	    "ArdOs is not in the right state to set a signal.");
  xSemaphoreGive(s);
   83e12:	2300      	movs	r3, #0
   83e14:	2200      	movs	r2, #0
   83e16:	2100      	movs	r1, #0
   83e18:	6838      	ldr	r0, [r7, #0]
   83e1a:	4c0e      	ldr	r4, [pc, #56]	; (83e54 <_ZN3ard5ArdOs10Signal_setEPv+0xc4>)
   83e1c:	47a0      	blx	r4
}
   83e1e:	bf00      	nop
   83e20:	3734      	adds	r7, #52	; 0x34
   83e22:	46bd      	mov	sp, r7
   83e24:	bd90      	pop	{r4, r7, pc}
   83e26:	bf00      	nop
   83e28:	00082fad 	.word	0x00082fad
   83e2c:	0009a02c 	.word	0x0009a02c
   83e30:	00089009 	.word	0x00089009
   83e34:	00082f89 	.word	0x00082f89
   83e38:	0009a388 	.word	0x0009a388
   83e3c:	0008951d 	.word	0x0008951d
   83e40:	00089049 	.word	0x00089049
   83e44:	00083845 	.word	0x00083845
   83e48:	00089145 	.word	0x00089145
   83e4c:	00082fe9 	.word	0x00082fe9
   83e50:	00081c7d 	.word	0x00081c7d
   83e54:	0008d44d 	.word	0x0008d44d

00083e58 <_ZN3ard5ArdOs11Signal_waitEPv>:
//  xSemaphoreGiveFromISR(sem, &xHigherPriorityTaskWoken);
//}

void
ArdOs::Signal_wait (Signal s)
{
   83e58:	b590      	push	{r4, r7, lr}
   83e5a:	b08d      	sub	sp, #52	; 0x34
   83e5c:	af00      	add	r7, sp, #0
   83e5e:	6078      	str	r0, [r7, #4]
   83e60:	6039      	str	r1, [r7, #0]
  ardAssert(state == eOsState::RUNNING,
   83e62:	687b      	ldr	r3, [r7, #4]
   83e64:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   83e66:	2b01      	cmp	r3, #1
   83e68:	d037      	beq.n	83eda <_ZN3ard5ArdOs11Signal_waitEPv+0x82>
   83e6a:	4b21      	ldr	r3, [pc, #132]	; (83ef0 <_ZN3ard5ArdOs11Signal_waitEPv+0x98>)
   83e6c:	4798      	blx	r3
   83e6e:	4604      	mov	r4, r0
   83e70:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83e74:	491f      	ldr	r1, [pc, #124]	; (83ef4 <_ZN3ard5ArdOs11Signal_waitEPv+0x9c>)
   83e76:	4618      	mov	r0, r3
   83e78:	4b1f      	ldr	r3, [pc, #124]	; (83ef8 <_ZN3ard5ArdOs11Signal_waitEPv+0xa0>)
   83e7a:	4798      	blx	r3
   83e7c:	f107 0224 	add.w	r2, r7, #36	; 0x24
   83e80:	f107 0318 	add.w	r3, r7, #24
   83e84:	4611      	mov	r1, r2
   83e86:	4618      	mov	r0, r3
   83e88:	4b1c      	ldr	r3, [pc, #112]	; (83efc <_ZN3ard5ArdOs11Signal_waitEPv+0xa4>)
   83e8a:	4798      	blx	r3
   83e8c:	f107 0318 	add.w	r3, r7, #24
   83e90:	491b      	ldr	r1, [pc, #108]	; (83f00 <_ZN3ard5ArdOs11Signal_waitEPv+0xa8>)
   83e92:	4618      	mov	r0, r3
   83e94:	4b1b      	ldr	r3, [pc, #108]	; (83f04 <_ZN3ard5ArdOs11Signal_waitEPv+0xac>)
   83e96:	4798      	blx	r3
   83e98:	4603      	mov	r3, r0
   83e9a:	461a      	mov	r2, r3
   83e9c:	f107 030c 	add.w	r3, r7, #12
   83ea0:	4611      	mov	r1, r2
   83ea2:	4618      	mov	r0, r3
   83ea4:	4b18      	ldr	r3, [pc, #96]	; (83f08 <_ZN3ard5ArdOs11Signal_waitEPv+0xb0>)
   83ea6:	4798      	blx	r3
   83ea8:	f107 030c 	add.w	r3, r7, #12
   83eac:	4619      	mov	r1, r3
   83eae:	4620      	mov	r0, r4
   83eb0:	4b16      	ldr	r3, [pc, #88]	; (83f0c <_ZN3ard5ArdOs11Signal_waitEPv+0xb4>)
   83eb2:	4798      	blx	r3
   83eb4:	f107 030c 	add.w	r3, r7, #12
   83eb8:	4618      	mov	r0, r3
   83eba:	4b15      	ldr	r3, [pc, #84]	; (83f10 <_ZN3ard5ArdOs11Signal_waitEPv+0xb8>)
   83ebc:	4798      	blx	r3
   83ebe:	f107 0318 	add.w	r3, r7, #24
   83ec2:	4618      	mov	r0, r3
   83ec4:	4b13      	ldr	r3, [pc, #76]	; (83f14 <_ZN3ard5ArdOs11Signal_waitEPv+0xbc>)
   83ec6:	4798      	blx	r3
   83ec8:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83ecc:	4618      	mov	r0, r3
   83ece:	4b10      	ldr	r3, [pc, #64]	; (83f10 <_ZN3ard5ArdOs11Signal_waitEPv+0xb8>)
   83ed0:	4798      	blx	r3
   83ed2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   83ed6:	4b10      	ldr	r3, [pc, #64]	; (83f18 <_ZN3ard5ArdOs11Signal_waitEPv+0xc0>)
   83ed8:	4798      	blx	r3
	    "ArdOs is not in the right state to wait for a signal.");
  xSemaphoreTake(s, portMAX_DELAY);
   83eda:	2300      	movs	r3, #0
   83edc:	f04f 32ff 	mov.w	r2, #4294967295
   83ee0:	2100      	movs	r1, #0
   83ee2:	6838      	ldr	r0, [r7, #0]
   83ee4:	4c0d      	ldr	r4, [pc, #52]	; (83f1c <_ZN3ard5ArdOs11Signal_waitEPv+0xc4>)
   83ee6:	47a0      	blx	r4
}
   83ee8:	bf00      	nop
   83eea:	3734      	adds	r7, #52	; 0x34
   83eec:	46bd      	mov	sp, r7
   83eee:	bd90      	pop	{r4, r7, pc}
   83ef0:	00082fad 	.word	0x00082fad
   83ef4:	0009a02c 	.word	0x0009a02c
   83ef8:	00089009 	.word	0x00089009
   83efc:	00082f89 	.word	0x00082f89
   83f00:	0009a3bc 	.word	0x0009a3bc
   83f04:	0008951d 	.word	0x0008951d
   83f08:	00089049 	.word	0x00089049
   83f0c:	00083845 	.word	0x00083845
   83f10:	00089145 	.word	0x00089145
   83f14:	00082fe9 	.word	0x00082fe9
   83f18:	00081c7d 	.word	0x00081c7d
   83f1c:	0008d735 	.word	0x0008d735

00083f20 <_ZN3ard5ArdOs12Mutex_createEv>:

Mutex
ArdOs::Mutex_create ()
{
   83f20:	b590      	push	{r4, r7, lr}
   83f22:	b097      	sub	sp, #92	; 0x5c
   83f24:	af00      	add	r7, sp, #0
   83f26:	6078      	str	r0, [r7, #4]
  ardAssert(state == eOsState::UNINIT,
   83f28:	687b      	ldr	r3, [r7, #4]
   83f2a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   83f2c:	2b00      	cmp	r3, #0
   83f2e:	d037      	beq.n	83fa0 <_ZN3ard5ArdOs12Mutex_createEv+0x80>
   83f30:	4b40      	ldr	r3, [pc, #256]	; (84034 <_ZN3ard5ArdOs12Mutex_createEv+0x114>)
   83f32:	4798      	blx	r3
   83f34:	4604      	mov	r4, r0
   83f36:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83f3a:	493f      	ldr	r1, [pc, #252]	; (84038 <_ZN3ard5ArdOs12Mutex_createEv+0x118>)
   83f3c:	4618      	mov	r0, r3
   83f3e:	4b3f      	ldr	r3, [pc, #252]	; (8403c <_ZN3ard5ArdOs12Mutex_createEv+0x11c>)
   83f40:	4798      	blx	r3
   83f42:	f107 0224 	add.w	r2, r7, #36	; 0x24
   83f46:	f107 0318 	add.w	r3, r7, #24
   83f4a:	4611      	mov	r1, r2
   83f4c:	4618      	mov	r0, r3
   83f4e:	4b3c      	ldr	r3, [pc, #240]	; (84040 <_ZN3ard5ArdOs12Mutex_createEv+0x120>)
   83f50:	4798      	blx	r3
   83f52:	f107 0318 	add.w	r3, r7, #24
   83f56:	493b      	ldr	r1, [pc, #236]	; (84044 <_ZN3ard5ArdOs12Mutex_createEv+0x124>)
   83f58:	4618      	mov	r0, r3
   83f5a:	4b3b      	ldr	r3, [pc, #236]	; (84048 <_ZN3ard5ArdOs12Mutex_createEv+0x128>)
   83f5c:	4798      	blx	r3
   83f5e:	4603      	mov	r3, r0
   83f60:	461a      	mov	r2, r3
   83f62:	f107 030c 	add.w	r3, r7, #12
   83f66:	4611      	mov	r1, r2
   83f68:	4618      	mov	r0, r3
   83f6a:	4b38      	ldr	r3, [pc, #224]	; (8404c <_ZN3ard5ArdOs12Mutex_createEv+0x12c>)
   83f6c:	4798      	blx	r3
   83f6e:	f107 030c 	add.w	r3, r7, #12
   83f72:	4619      	mov	r1, r3
   83f74:	4620      	mov	r0, r4
   83f76:	4b36      	ldr	r3, [pc, #216]	; (84050 <_ZN3ard5ArdOs12Mutex_createEv+0x130>)
   83f78:	4798      	blx	r3
   83f7a:	f107 030c 	add.w	r3, r7, #12
   83f7e:	4618      	mov	r0, r3
   83f80:	4b34      	ldr	r3, [pc, #208]	; (84054 <_ZN3ard5ArdOs12Mutex_createEv+0x134>)
   83f82:	4798      	blx	r3
   83f84:	f107 0318 	add.w	r3, r7, #24
   83f88:	4618      	mov	r0, r3
   83f8a:	4b33      	ldr	r3, [pc, #204]	; (84058 <_ZN3ard5ArdOs12Mutex_createEv+0x138>)
   83f8c:	4798      	blx	r3
   83f8e:	f107 0324 	add.w	r3, r7, #36	; 0x24
   83f92:	4618      	mov	r0, r3
   83f94:	4b2f      	ldr	r3, [pc, #188]	; (84054 <_ZN3ard5ArdOs12Mutex_createEv+0x134>)
   83f96:	4798      	blx	r3
   83f98:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   83f9c:	4b2f      	ldr	r3, [pc, #188]	; (8405c <_ZN3ard5ArdOs12Mutex_createEv+0x13c>)
   83f9e:	4798      	blx	r3
	    "ArdOs is not in the right state to do a mutex creation");
  Mutex m = xSemaphoreCreateMutex();
   83fa0:	2001      	movs	r0, #1
   83fa2:	4b2f      	ldr	r3, [pc, #188]	; (84060 <_ZN3ard5ArdOs12Mutex_createEv+0x140>)
   83fa4:	4798      	blx	r3
   83fa6:	6578      	str	r0, [r7, #84]	; 0x54
  ardAssert(m != NULL, "No more heap");
   83fa8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   83faa:	2b00      	cmp	r3, #0
   83fac:	d137      	bne.n	8401e <_ZN3ard5ArdOs12Mutex_createEv+0xfe>
   83fae:	4b21      	ldr	r3, [pc, #132]	; (84034 <_ZN3ard5ArdOs12Mutex_createEv+0x114>)
   83fb0:	4798      	blx	r3
   83fb2:	4604      	mov	r4, r0
   83fb4:	f107 0348 	add.w	r3, r7, #72	; 0x48
   83fb8:	491f      	ldr	r1, [pc, #124]	; (84038 <_ZN3ard5ArdOs12Mutex_createEv+0x118>)
   83fba:	4618      	mov	r0, r3
   83fbc:	4b1f      	ldr	r3, [pc, #124]	; (8403c <_ZN3ard5ArdOs12Mutex_createEv+0x11c>)
   83fbe:	4798      	blx	r3
   83fc0:	f107 0248 	add.w	r2, r7, #72	; 0x48
   83fc4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   83fc8:	4611      	mov	r1, r2
   83fca:	4618      	mov	r0, r3
   83fcc:	4b1c      	ldr	r3, [pc, #112]	; (84040 <_ZN3ard5ArdOs12Mutex_createEv+0x120>)
   83fce:	4798      	blx	r3
   83fd0:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   83fd4:	4923      	ldr	r1, [pc, #140]	; (84064 <_ZN3ard5ArdOs12Mutex_createEv+0x144>)
   83fd6:	4618      	mov	r0, r3
   83fd8:	4b1b      	ldr	r3, [pc, #108]	; (84048 <_ZN3ard5ArdOs12Mutex_createEv+0x128>)
   83fda:	4798      	blx	r3
   83fdc:	4603      	mov	r3, r0
   83fde:	461a      	mov	r2, r3
   83fe0:	f107 0330 	add.w	r3, r7, #48	; 0x30
   83fe4:	4611      	mov	r1, r2
   83fe6:	4618      	mov	r0, r3
   83fe8:	4b18      	ldr	r3, [pc, #96]	; (8404c <_ZN3ard5ArdOs12Mutex_createEv+0x12c>)
   83fea:	4798      	blx	r3
   83fec:	f107 0330 	add.w	r3, r7, #48	; 0x30
   83ff0:	4619      	mov	r1, r3
   83ff2:	4620      	mov	r0, r4
   83ff4:	4b16      	ldr	r3, [pc, #88]	; (84050 <_ZN3ard5ArdOs12Mutex_createEv+0x130>)
   83ff6:	4798      	blx	r3
   83ff8:	f107 0330 	add.w	r3, r7, #48	; 0x30
   83ffc:	4618      	mov	r0, r3
   83ffe:	4b15      	ldr	r3, [pc, #84]	; (84054 <_ZN3ard5ArdOs12Mutex_createEv+0x134>)
   84000:	4798      	blx	r3
   84002:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   84006:	4618      	mov	r0, r3
   84008:	4b13      	ldr	r3, [pc, #76]	; (84058 <_ZN3ard5ArdOs12Mutex_createEv+0x138>)
   8400a:	4798      	blx	r3
   8400c:	f107 0348 	add.w	r3, r7, #72	; 0x48
   84010:	4618      	mov	r0, r3
   84012:	4b10      	ldr	r3, [pc, #64]	; (84054 <_ZN3ard5ArdOs12Mutex_createEv+0x134>)
   84014:	4798      	blx	r3
   84016:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   8401a:	4b10      	ldr	r3, [pc, #64]	; (8405c <_ZN3ard5ArdOs12Mutex_createEv+0x13c>)
   8401c:	4798      	blx	r3
  ++mutexCount;
   8401e:	687b      	ldr	r3, [r7, #4]
   84020:	8b5b      	ldrh	r3, [r3, #26]
   84022:	3301      	adds	r3, #1
   84024:	b29a      	uxth	r2, r3
   84026:	687b      	ldr	r3, [r7, #4]
   84028:	835a      	strh	r2, [r3, #26]
  return m;
   8402a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
}
   8402c:	4618      	mov	r0, r3
   8402e:	375c      	adds	r7, #92	; 0x5c
   84030:	46bd      	mov	sp, r7
   84032:	bd90      	pop	{r4, r7, pc}
   84034:	00082fad 	.word	0x00082fad
   84038:	0009a02c 	.word	0x0009a02c
   8403c:	00089009 	.word	0x00089009
   84040:	00082f89 	.word	0x00082f89
   84044:	0009a3f4 	.word	0x0009a3f4
   84048:	0008951d 	.word	0x0008951d
   8404c:	00089049 	.word	0x00089049
   84050:	00083845 	.word	0x00083845
   84054:	00089145 	.word	0x00089145
   84058:	00082fe9 	.word	0x00082fe9
   8405c:	00081c7d 	.word	0x00081c7d
   84060:	0008d361 	.word	0x0008d361
   84064:	0009a378 	.word	0x0009a378

00084068 <_ZN3ard5ArdOs10Mutex_lockEPv>:

void
ArdOs::Mutex_lock (Mutex s)
{
   84068:	b590      	push	{r4, r7, lr}
   8406a:	b08d      	sub	sp, #52	; 0x34
   8406c:	af00      	add	r7, sp, #0
   8406e:	6078      	str	r0, [r7, #4]
   84070:	6039      	str	r1, [r7, #0]
  ardAssert(state == eOsState::RUNNING, "ArdOs is not in the right state to lock a mutex");
   84072:	687b      	ldr	r3, [r7, #4]
   84074:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   84076:	2b01      	cmp	r3, #1
   84078:	d037      	beq.n	840ea <_ZN3ard5ArdOs10Mutex_lockEPv+0x82>
   8407a:	4b21      	ldr	r3, [pc, #132]	; (84100 <_ZN3ard5ArdOs10Mutex_lockEPv+0x98>)
   8407c:	4798      	blx	r3
   8407e:	4604      	mov	r4, r0
   84080:	f107 0324 	add.w	r3, r7, #36	; 0x24
   84084:	491f      	ldr	r1, [pc, #124]	; (84104 <_ZN3ard5ArdOs10Mutex_lockEPv+0x9c>)
   84086:	4618      	mov	r0, r3
   84088:	4b1f      	ldr	r3, [pc, #124]	; (84108 <_ZN3ard5ArdOs10Mutex_lockEPv+0xa0>)
   8408a:	4798      	blx	r3
   8408c:	f107 0224 	add.w	r2, r7, #36	; 0x24
   84090:	f107 0318 	add.w	r3, r7, #24
   84094:	4611      	mov	r1, r2
   84096:	4618      	mov	r0, r3
   84098:	4b1c      	ldr	r3, [pc, #112]	; (8410c <_ZN3ard5ArdOs10Mutex_lockEPv+0xa4>)
   8409a:	4798      	blx	r3
   8409c:	f107 0318 	add.w	r3, r7, #24
   840a0:	491b      	ldr	r1, [pc, #108]	; (84110 <_ZN3ard5ArdOs10Mutex_lockEPv+0xa8>)
   840a2:	4618      	mov	r0, r3
   840a4:	4b1b      	ldr	r3, [pc, #108]	; (84114 <_ZN3ard5ArdOs10Mutex_lockEPv+0xac>)
   840a6:	4798      	blx	r3
   840a8:	4603      	mov	r3, r0
   840aa:	461a      	mov	r2, r3
   840ac:	f107 030c 	add.w	r3, r7, #12
   840b0:	4611      	mov	r1, r2
   840b2:	4618      	mov	r0, r3
   840b4:	4b18      	ldr	r3, [pc, #96]	; (84118 <_ZN3ard5ArdOs10Mutex_lockEPv+0xb0>)
   840b6:	4798      	blx	r3
   840b8:	f107 030c 	add.w	r3, r7, #12
   840bc:	4619      	mov	r1, r3
   840be:	4620      	mov	r0, r4
   840c0:	4b16      	ldr	r3, [pc, #88]	; (8411c <_ZN3ard5ArdOs10Mutex_lockEPv+0xb4>)
   840c2:	4798      	blx	r3
   840c4:	f107 030c 	add.w	r3, r7, #12
   840c8:	4618      	mov	r0, r3
   840ca:	4b15      	ldr	r3, [pc, #84]	; (84120 <_ZN3ard5ArdOs10Mutex_lockEPv+0xb8>)
   840cc:	4798      	blx	r3
   840ce:	f107 0318 	add.w	r3, r7, #24
   840d2:	4618      	mov	r0, r3
   840d4:	4b13      	ldr	r3, [pc, #76]	; (84124 <_ZN3ard5ArdOs10Mutex_lockEPv+0xbc>)
   840d6:	4798      	blx	r3
   840d8:	f107 0324 	add.w	r3, r7, #36	; 0x24
   840dc:	4618      	mov	r0, r3
   840de:	4b10      	ldr	r3, [pc, #64]	; (84120 <_ZN3ard5ArdOs10Mutex_lockEPv+0xb8>)
   840e0:	4798      	blx	r3
   840e2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   840e6:	4b10      	ldr	r3, [pc, #64]	; (84128 <_ZN3ard5ArdOs10Mutex_lockEPv+0xc0>)
   840e8:	4798      	blx	r3
  xSemaphoreTake(s, portMAX_DELAY);
   840ea:	2300      	movs	r3, #0
   840ec:	f04f 32ff 	mov.w	r2, #4294967295
   840f0:	2100      	movs	r1, #0
   840f2:	6838      	ldr	r0, [r7, #0]
   840f4:	4c0d      	ldr	r4, [pc, #52]	; (8412c <_ZN3ard5ArdOs10Mutex_lockEPv+0xc4>)
   840f6:	47a0      	blx	r4
}
   840f8:	bf00      	nop
   840fa:	3734      	adds	r7, #52	; 0x34
   840fc:	46bd      	mov	sp, r7
   840fe:	bd90      	pop	{r4, r7, pc}
   84100:	00082fad 	.word	0x00082fad
   84104:	0009a02c 	.word	0x0009a02c
   84108:	00089009 	.word	0x00089009
   8410c:	00082f89 	.word	0x00082f89
   84110:	0009a42c 	.word	0x0009a42c
   84114:	0008951d 	.word	0x0008951d
   84118:	00089049 	.word	0x00089049
   8411c:	00083845 	.word	0x00083845
   84120:	00089145 	.word	0x00089145
   84124:	00082fe9 	.word	0x00082fe9
   84128:	00081c7d 	.word	0x00081c7d
   8412c:	0008d735 	.word	0x0008d735

00084130 <_ZN3ard5ArdOs12Mutex_unlockEPv>:

void
ArdOs::Mutex_unlock (Mutex s)
{
   84130:	b590      	push	{r4, r7, lr}
   84132:	b08d      	sub	sp, #52	; 0x34
   84134:	af00      	add	r7, sp, #0
   84136:	6078      	str	r0, [r7, #4]
   84138:	6039      	str	r1, [r7, #0]
  ardAssert(state == eOsState::RUNNING,
   8413a:	687b      	ldr	r3, [r7, #4]
   8413c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   8413e:	2b01      	cmp	r3, #1
   84140:	d037      	beq.n	841b2 <_ZN3ard5ArdOs12Mutex_unlockEPv+0x82>
   84142:	4b21      	ldr	r3, [pc, #132]	; (841c8 <_ZN3ard5ArdOs12Mutex_unlockEPv+0x98>)
   84144:	4798      	blx	r3
   84146:	4604      	mov	r4, r0
   84148:	f107 0324 	add.w	r3, r7, #36	; 0x24
   8414c:	491f      	ldr	r1, [pc, #124]	; (841cc <_ZN3ard5ArdOs12Mutex_unlockEPv+0x9c>)
   8414e:	4618      	mov	r0, r3
   84150:	4b1f      	ldr	r3, [pc, #124]	; (841d0 <_ZN3ard5ArdOs12Mutex_unlockEPv+0xa0>)
   84152:	4798      	blx	r3
   84154:	f107 0224 	add.w	r2, r7, #36	; 0x24
   84158:	f107 0318 	add.w	r3, r7, #24
   8415c:	4611      	mov	r1, r2
   8415e:	4618      	mov	r0, r3
   84160:	4b1c      	ldr	r3, [pc, #112]	; (841d4 <_ZN3ard5ArdOs12Mutex_unlockEPv+0xa4>)
   84162:	4798      	blx	r3
   84164:	f107 0318 	add.w	r3, r7, #24
   84168:	491b      	ldr	r1, [pc, #108]	; (841d8 <_ZN3ard5ArdOs12Mutex_unlockEPv+0xa8>)
   8416a:	4618      	mov	r0, r3
   8416c:	4b1b      	ldr	r3, [pc, #108]	; (841dc <_ZN3ard5ArdOs12Mutex_unlockEPv+0xac>)
   8416e:	4798      	blx	r3
   84170:	4603      	mov	r3, r0
   84172:	461a      	mov	r2, r3
   84174:	f107 030c 	add.w	r3, r7, #12
   84178:	4611      	mov	r1, r2
   8417a:	4618      	mov	r0, r3
   8417c:	4b18      	ldr	r3, [pc, #96]	; (841e0 <_ZN3ard5ArdOs12Mutex_unlockEPv+0xb0>)
   8417e:	4798      	blx	r3
   84180:	f107 030c 	add.w	r3, r7, #12
   84184:	4619      	mov	r1, r3
   84186:	4620      	mov	r0, r4
   84188:	4b16      	ldr	r3, [pc, #88]	; (841e4 <_ZN3ard5ArdOs12Mutex_unlockEPv+0xb4>)
   8418a:	4798      	blx	r3
   8418c:	f107 030c 	add.w	r3, r7, #12
   84190:	4618      	mov	r0, r3
   84192:	4b15      	ldr	r3, [pc, #84]	; (841e8 <_ZN3ard5ArdOs12Mutex_unlockEPv+0xb8>)
   84194:	4798      	blx	r3
   84196:	f107 0318 	add.w	r3, r7, #24
   8419a:	4618      	mov	r0, r3
   8419c:	4b13      	ldr	r3, [pc, #76]	; (841ec <_ZN3ard5ArdOs12Mutex_unlockEPv+0xbc>)
   8419e:	4798      	blx	r3
   841a0:	f107 0324 	add.w	r3, r7, #36	; 0x24
   841a4:	4618      	mov	r0, r3
   841a6:	4b10      	ldr	r3, [pc, #64]	; (841e8 <_ZN3ard5ArdOs12Mutex_unlockEPv+0xb8>)
   841a8:	4798      	blx	r3
   841aa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   841ae:	4b10      	ldr	r3, [pc, #64]	; (841f0 <_ZN3ard5ArdOs12Mutex_unlockEPv+0xc0>)
   841b0:	4798      	blx	r3
	    "ArdOs is not in the right state to unlock a mutex");
  xSemaphoreGive(s);
   841b2:	2300      	movs	r3, #0
   841b4:	2200      	movs	r2, #0
   841b6:	2100      	movs	r1, #0
   841b8:	6838      	ldr	r0, [r7, #0]
   841ba:	4c0e      	ldr	r4, [pc, #56]	; (841f4 <_ZN3ard5ArdOs12Mutex_unlockEPv+0xc4>)
   841bc:	47a0      	blx	r4
}
   841be:	bf00      	nop
   841c0:	3734      	adds	r7, #52	; 0x34
   841c2:	46bd      	mov	sp, r7
   841c4:	bd90      	pop	{r4, r7, pc}
   841c6:	bf00      	nop
   841c8:	00082fad 	.word	0x00082fad
   841cc:	0009a02c 	.word	0x0009a02c
   841d0:	00089009 	.word	0x00089009
   841d4:	00082f89 	.word	0x00082f89
   841d8:	0009a45c 	.word	0x0009a45c
   841dc:	0008951d 	.word	0x0008951d
   841e0:	00089049 	.word	0x00089049
   841e4:	00083845 	.word	0x00083845
   841e8:	00089145 	.word	0x00089145
   841ec:	00082fe9 	.word	0x00082fe9
   841f0:	00081c7d 	.word	0x00081c7d
   841f4:	0008d44d 	.word	0x0008d44d

000841f8 <_ZN3ard5ArdOs16Semaphore_createEmm>:

Semaphore
ArdOs::Semaphore_create (const UBaseType_t maxCount,
			 const UBaseType_t initCount)
{
   841f8:	b590      	push	{r4, r7, lr}
   841fa:	b099      	sub	sp, #100	; 0x64
   841fc:	af00      	add	r7, sp, #0
   841fe:	60f8      	str	r0, [r7, #12]
   84200:	60b9      	str	r1, [r7, #8]
   84202:	607a      	str	r2, [r7, #4]
  ardAssert(state == eOsState::UNINIT,
   84204:	68fb      	ldr	r3, [r7, #12]
   84206:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   84208:	2b00      	cmp	r3, #0
   8420a:	d037      	beq.n	8427c <_ZN3ard5ArdOs16Semaphore_createEmm+0x84>
   8420c:	4b41      	ldr	r3, [pc, #260]	; (84314 <_ZN3ard5ArdOs16Semaphore_createEmm+0x11c>)
   8420e:	4798      	blx	r3
   84210:	4604      	mov	r4, r0
   84212:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   84216:	4940      	ldr	r1, [pc, #256]	; (84318 <_ZN3ard5ArdOs16Semaphore_createEmm+0x120>)
   84218:	4618      	mov	r0, r3
   8421a:	4b40      	ldr	r3, [pc, #256]	; (8431c <_ZN3ard5ArdOs16Semaphore_createEmm+0x124>)
   8421c:	4798      	blx	r3
   8421e:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   84222:	f107 0320 	add.w	r3, r7, #32
   84226:	4611      	mov	r1, r2
   84228:	4618      	mov	r0, r3
   8422a:	4b3d      	ldr	r3, [pc, #244]	; (84320 <_ZN3ard5ArdOs16Semaphore_createEmm+0x128>)
   8422c:	4798      	blx	r3
   8422e:	f107 0320 	add.w	r3, r7, #32
   84232:	493c      	ldr	r1, [pc, #240]	; (84324 <_ZN3ard5ArdOs16Semaphore_createEmm+0x12c>)
   84234:	4618      	mov	r0, r3
   84236:	4b3c      	ldr	r3, [pc, #240]	; (84328 <_ZN3ard5ArdOs16Semaphore_createEmm+0x130>)
   84238:	4798      	blx	r3
   8423a:	4603      	mov	r3, r0
   8423c:	461a      	mov	r2, r3
   8423e:	f107 0314 	add.w	r3, r7, #20
   84242:	4611      	mov	r1, r2
   84244:	4618      	mov	r0, r3
   84246:	4b39      	ldr	r3, [pc, #228]	; (8432c <_ZN3ard5ArdOs16Semaphore_createEmm+0x134>)
   84248:	4798      	blx	r3
   8424a:	f107 0314 	add.w	r3, r7, #20
   8424e:	4619      	mov	r1, r3
   84250:	4620      	mov	r0, r4
   84252:	4b37      	ldr	r3, [pc, #220]	; (84330 <_ZN3ard5ArdOs16Semaphore_createEmm+0x138>)
   84254:	4798      	blx	r3
   84256:	f107 0314 	add.w	r3, r7, #20
   8425a:	4618      	mov	r0, r3
   8425c:	4b35      	ldr	r3, [pc, #212]	; (84334 <_ZN3ard5ArdOs16Semaphore_createEmm+0x13c>)
   8425e:	4798      	blx	r3
   84260:	f107 0320 	add.w	r3, r7, #32
   84264:	4618      	mov	r0, r3
   84266:	4b34      	ldr	r3, [pc, #208]	; (84338 <_ZN3ard5ArdOs16Semaphore_createEmm+0x140>)
   84268:	4798      	blx	r3
   8426a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   8426e:	4618      	mov	r0, r3
   84270:	4b30      	ldr	r3, [pc, #192]	; (84334 <_ZN3ard5ArdOs16Semaphore_createEmm+0x13c>)
   84272:	4798      	blx	r3
   84274:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   84278:	4b30      	ldr	r3, [pc, #192]	; (8433c <_ZN3ard5ArdOs16Semaphore_createEmm+0x144>)
   8427a:	4798      	blx	r3
	    "ArdOs is not in the right state to do a semaphore creation");
  Semaphore s = xSemaphoreCreateCounting(maxCount, initCount);
   8427c:	6879      	ldr	r1, [r7, #4]
   8427e:	68b8      	ldr	r0, [r7, #8]
   84280:	4b2f      	ldr	r3, [pc, #188]	; (84340 <_ZN3ard5ArdOs16Semaphore_createEmm+0x148>)
   84282:	4798      	blx	r3
   84284:	65f8      	str	r0, [r7, #92]	; 0x5c
  ardAssert(s != NULL, "No more heap");
   84286:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   84288:	2b00      	cmp	r3, #0
   8428a:	d137      	bne.n	842fc <_ZN3ard5ArdOs16Semaphore_createEmm+0x104>
   8428c:	4b21      	ldr	r3, [pc, #132]	; (84314 <_ZN3ard5ArdOs16Semaphore_createEmm+0x11c>)
   8428e:	4798      	blx	r3
   84290:	4604      	mov	r4, r0
   84292:	f107 0350 	add.w	r3, r7, #80	; 0x50
   84296:	4920      	ldr	r1, [pc, #128]	; (84318 <_ZN3ard5ArdOs16Semaphore_createEmm+0x120>)
   84298:	4618      	mov	r0, r3
   8429a:	4b20      	ldr	r3, [pc, #128]	; (8431c <_ZN3ard5ArdOs16Semaphore_createEmm+0x124>)
   8429c:	4798      	blx	r3
   8429e:	f107 0250 	add.w	r2, r7, #80	; 0x50
   842a2:	f107 0344 	add.w	r3, r7, #68	; 0x44
   842a6:	4611      	mov	r1, r2
   842a8:	4618      	mov	r0, r3
   842aa:	4b1d      	ldr	r3, [pc, #116]	; (84320 <_ZN3ard5ArdOs16Semaphore_createEmm+0x128>)
   842ac:	4798      	blx	r3
   842ae:	f107 0344 	add.w	r3, r7, #68	; 0x44
   842b2:	4924      	ldr	r1, [pc, #144]	; (84344 <_ZN3ard5ArdOs16Semaphore_createEmm+0x14c>)
   842b4:	4618      	mov	r0, r3
   842b6:	4b1c      	ldr	r3, [pc, #112]	; (84328 <_ZN3ard5ArdOs16Semaphore_createEmm+0x130>)
   842b8:	4798      	blx	r3
   842ba:	4603      	mov	r3, r0
   842bc:	461a      	mov	r2, r3
   842be:	f107 0338 	add.w	r3, r7, #56	; 0x38
   842c2:	4611      	mov	r1, r2
   842c4:	4618      	mov	r0, r3
   842c6:	4b19      	ldr	r3, [pc, #100]	; (8432c <_ZN3ard5ArdOs16Semaphore_createEmm+0x134>)
   842c8:	4798      	blx	r3
   842ca:	f107 0338 	add.w	r3, r7, #56	; 0x38
   842ce:	4619      	mov	r1, r3
   842d0:	4620      	mov	r0, r4
   842d2:	4b17      	ldr	r3, [pc, #92]	; (84330 <_ZN3ard5ArdOs16Semaphore_createEmm+0x138>)
   842d4:	4798      	blx	r3
   842d6:	f107 0338 	add.w	r3, r7, #56	; 0x38
   842da:	4618      	mov	r0, r3
   842dc:	4b15      	ldr	r3, [pc, #84]	; (84334 <_ZN3ard5ArdOs16Semaphore_createEmm+0x13c>)
   842de:	4798      	blx	r3
   842e0:	f107 0344 	add.w	r3, r7, #68	; 0x44
   842e4:	4618      	mov	r0, r3
   842e6:	4b14      	ldr	r3, [pc, #80]	; (84338 <_ZN3ard5ArdOs16Semaphore_createEmm+0x140>)
   842e8:	4798      	blx	r3
   842ea:	f107 0350 	add.w	r3, r7, #80	; 0x50
   842ee:	4618      	mov	r0, r3
   842f0:	4b10      	ldr	r3, [pc, #64]	; (84334 <_ZN3ard5ArdOs16Semaphore_createEmm+0x13c>)
   842f2:	4798      	blx	r3
   842f4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   842f8:	4b10      	ldr	r3, [pc, #64]	; (8433c <_ZN3ard5ArdOs16Semaphore_createEmm+0x144>)
   842fa:	4798      	blx	r3
  ++signalCount;
   842fc:	68fb      	ldr	r3, [r7, #12]
   842fe:	8b1b      	ldrh	r3, [r3, #24]
   84300:	3301      	adds	r3, #1
   84302:	b29a      	uxth	r2, r3
   84304:	68fb      	ldr	r3, [r7, #12]
   84306:	831a      	strh	r2, [r3, #24]
  return s;
   84308:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
}
   8430a:	4618      	mov	r0, r3
   8430c:	3764      	adds	r7, #100	; 0x64
   8430e:	46bd      	mov	sp, r7
   84310:	bd90      	pop	{r4, r7, pc}
   84312:	bf00      	nop
   84314:	00082fad 	.word	0x00082fad
   84318:	0009a02c 	.word	0x0009a02c
   8431c:	00089009 	.word	0x00089009
   84320:	00082f89 	.word	0x00082f89
   84324:	0009a490 	.word	0x0009a490
   84328:	0008951d 	.word	0x0008951d
   8432c:	00089049 	.word	0x00089049
   84330:	00083845 	.word	0x00083845
   84334:	00089145 	.word	0x00089145
   84338:	00082fe9 	.word	0x00082fe9
   8433c:	00081c7d 	.word	0x00081c7d
   84340:	0008d3f9 	.word	0x0008d3f9
   84344:	0009a378 	.word	0x0009a378

00084348 <_ZN3ard5ArdOs14Semaphore_giveEPv>:

void
ArdOs::Semaphore_give (Semaphore s)
{
   84348:	b590      	push	{r4, r7, lr}
   8434a:	b08d      	sub	sp, #52	; 0x34
   8434c:	af00      	add	r7, sp, #0
   8434e:	6078      	str	r0, [r7, #4]
   84350:	6039      	str	r1, [r7, #0]
  ardAssert(state == eOsState::RUNNING,
   84352:	687b      	ldr	r3, [r7, #4]
   84354:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   84356:	2b01      	cmp	r3, #1
   84358:	d037      	beq.n	843ca <_ZN3ard5ArdOs14Semaphore_giveEPv+0x82>
   8435a:	4b21      	ldr	r3, [pc, #132]	; (843e0 <_ZN3ard5ArdOs14Semaphore_giveEPv+0x98>)
   8435c:	4798      	blx	r3
   8435e:	4604      	mov	r4, r0
   84360:	f107 0324 	add.w	r3, r7, #36	; 0x24
   84364:	491f      	ldr	r1, [pc, #124]	; (843e4 <_ZN3ard5ArdOs14Semaphore_giveEPv+0x9c>)
   84366:	4618      	mov	r0, r3
   84368:	4b1f      	ldr	r3, [pc, #124]	; (843e8 <_ZN3ard5ArdOs14Semaphore_giveEPv+0xa0>)
   8436a:	4798      	blx	r3
   8436c:	f107 0224 	add.w	r2, r7, #36	; 0x24
   84370:	f107 0318 	add.w	r3, r7, #24
   84374:	4611      	mov	r1, r2
   84376:	4618      	mov	r0, r3
   84378:	4b1c      	ldr	r3, [pc, #112]	; (843ec <_ZN3ard5ArdOs14Semaphore_giveEPv+0xa4>)
   8437a:	4798      	blx	r3
   8437c:	f107 0318 	add.w	r3, r7, #24
   84380:	491b      	ldr	r1, [pc, #108]	; (843f0 <_ZN3ard5ArdOs14Semaphore_giveEPv+0xa8>)
   84382:	4618      	mov	r0, r3
   84384:	4b1b      	ldr	r3, [pc, #108]	; (843f4 <_ZN3ard5ArdOs14Semaphore_giveEPv+0xac>)
   84386:	4798      	blx	r3
   84388:	4603      	mov	r3, r0
   8438a:	461a      	mov	r2, r3
   8438c:	f107 030c 	add.w	r3, r7, #12
   84390:	4611      	mov	r1, r2
   84392:	4618      	mov	r0, r3
   84394:	4b18      	ldr	r3, [pc, #96]	; (843f8 <_ZN3ard5ArdOs14Semaphore_giveEPv+0xb0>)
   84396:	4798      	blx	r3
   84398:	f107 030c 	add.w	r3, r7, #12
   8439c:	4619      	mov	r1, r3
   8439e:	4620      	mov	r0, r4
   843a0:	4b16      	ldr	r3, [pc, #88]	; (843fc <_ZN3ard5ArdOs14Semaphore_giveEPv+0xb4>)
   843a2:	4798      	blx	r3
   843a4:	f107 030c 	add.w	r3, r7, #12
   843a8:	4618      	mov	r0, r3
   843aa:	4b15      	ldr	r3, [pc, #84]	; (84400 <_ZN3ard5ArdOs14Semaphore_giveEPv+0xb8>)
   843ac:	4798      	blx	r3
   843ae:	f107 0318 	add.w	r3, r7, #24
   843b2:	4618      	mov	r0, r3
   843b4:	4b13      	ldr	r3, [pc, #76]	; (84404 <_ZN3ard5ArdOs14Semaphore_giveEPv+0xbc>)
   843b6:	4798      	blx	r3
   843b8:	f107 0324 	add.w	r3, r7, #36	; 0x24
   843bc:	4618      	mov	r0, r3
   843be:	4b10      	ldr	r3, [pc, #64]	; (84400 <_ZN3ard5ArdOs14Semaphore_giveEPv+0xb8>)
   843c0:	4798      	blx	r3
   843c2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   843c6:	4b10      	ldr	r3, [pc, #64]	; (84408 <_ZN3ard5ArdOs14Semaphore_giveEPv+0xc0>)
   843c8:	4798      	blx	r3
	    "ArdOs is not in the right state to give a semaphore");
  xSemaphoreGive(s);
   843ca:	2300      	movs	r3, #0
   843cc:	2200      	movs	r2, #0
   843ce:	2100      	movs	r1, #0
   843d0:	6838      	ldr	r0, [r7, #0]
   843d2:	4c0e      	ldr	r4, [pc, #56]	; (8440c <_ZN3ard5ArdOs14Semaphore_giveEPv+0xc4>)
   843d4:	47a0      	blx	r4
}
   843d6:	bf00      	nop
   843d8:	3734      	adds	r7, #52	; 0x34
   843da:	46bd      	mov	sp, r7
   843dc:	bd90      	pop	{r4, r7, pc}
   843de:	bf00      	nop
   843e0:	00082fad 	.word	0x00082fad
   843e4:	0009a02c 	.word	0x0009a02c
   843e8:	00089009 	.word	0x00089009
   843ec:	00082f89 	.word	0x00082f89
   843f0:	0009a4cc 	.word	0x0009a4cc
   843f4:	0008951d 	.word	0x0008951d
   843f8:	00089049 	.word	0x00089049
   843fc:	00083845 	.word	0x00083845
   84400:	00089145 	.word	0x00089145
   84404:	00082fe9 	.word	0x00082fe9
   84408:	00081c7d 	.word	0x00081c7d
   8440c:	0008d44d 	.word	0x0008d44d

00084410 <_ZN3ard5ArdOs14Semaphore_takeEPv>:

void
ArdOs::Semaphore_take (Semaphore s)
{
   84410:	b590      	push	{r4, r7, lr}
   84412:	b08d      	sub	sp, #52	; 0x34
   84414:	af00      	add	r7, sp, #0
   84416:	6078      	str	r0, [r7, #4]
   84418:	6039      	str	r1, [r7, #0]
  ardAssert(state == eOsState::RUNNING,
   8441a:	687b      	ldr	r3, [r7, #4]
   8441c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   8441e:	2b01      	cmp	r3, #1
   84420:	d037      	beq.n	84492 <_ZN3ard5ArdOs14Semaphore_takeEPv+0x82>
   84422:	4b21      	ldr	r3, [pc, #132]	; (844a8 <_ZN3ard5ArdOs14Semaphore_takeEPv+0x98>)
   84424:	4798      	blx	r3
   84426:	4604      	mov	r4, r0
   84428:	f107 0324 	add.w	r3, r7, #36	; 0x24
   8442c:	491f      	ldr	r1, [pc, #124]	; (844ac <_ZN3ard5ArdOs14Semaphore_takeEPv+0x9c>)
   8442e:	4618      	mov	r0, r3
   84430:	4b1f      	ldr	r3, [pc, #124]	; (844b0 <_ZN3ard5ArdOs14Semaphore_takeEPv+0xa0>)
   84432:	4798      	blx	r3
   84434:	f107 0224 	add.w	r2, r7, #36	; 0x24
   84438:	f107 0318 	add.w	r3, r7, #24
   8443c:	4611      	mov	r1, r2
   8443e:	4618      	mov	r0, r3
   84440:	4b1c      	ldr	r3, [pc, #112]	; (844b4 <_ZN3ard5ArdOs14Semaphore_takeEPv+0xa4>)
   84442:	4798      	blx	r3
   84444:	f107 0318 	add.w	r3, r7, #24
   84448:	491b      	ldr	r1, [pc, #108]	; (844b8 <_ZN3ard5ArdOs14Semaphore_takeEPv+0xa8>)
   8444a:	4618      	mov	r0, r3
   8444c:	4b1b      	ldr	r3, [pc, #108]	; (844bc <_ZN3ard5ArdOs14Semaphore_takeEPv+0xac>)
   8444e:	4798      	blx	r3
   84450:	4603      	mov	r3, r0
   84452:	461a      	mov	r2, r3
   84454:	f107 030c 	add.w	r3, r7, #12
   84458:	4611      	mov	r1, r2
   8445a:	4618      	mov	r0, r3
   8445c:	4b18      	ldr	r3, [pc, #96]	; (844c0 <_ZN3ard5ArdOs14Semaphore_takeEPv+0xb0>)
   8445e:	4798      	blx	r3
   84460:	f107 030c 	add.w	r3, r7, #12
   84464:	4619      	mov	r1, r3
   84466:	4620      	mov	r0, r4
   84468:	4b16      	ldr	r3, [pc, #88]	; (844c4 <_ZN3ard5ArdOs14Semaphore_takeEPv+0xb4>)
   8446a:	4798      	blx	r3
   8446c:	f107 030c 	add.w	r3, r7, #12
   84470:	4618      	mov	r0, r3
   84472:	4b15      	ldr	r3, [pc, #84]	; (844c8 <_ZN3ard5ArdOs14Semaphore_takeEPv+0xb8>)
   84474:	4798      	blx	r3
   84476:	f107 0318 	add.w	r3, r7, #24
   8447a:	4618      	mov	r0, r3
   8447c:	4b13      	ldr	r3, [pc, #76]	; (844cc <_ZN3ard5ArdOs14Semaphore_takeEPv+0xbc>)
   8447e:	4798      	blx	r3
   84480:	f107 0324 	add.w	r3, r7, #36	; 0x24
   84484:	4618      	mov	r0, r3
   84486:	4b10      	ldr	r3, [pc, #64]	; (844c8 <_ZN3ard5ArdOs14Semaphore_takeEPv+0xb8>)
   84488:	4798      	blx	r3
   8448a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   8448e:	4b10      	ldr	r3, [pc, #64]	; (844d0 <_ZN3ard5ArdOs14Semaphore_takeEPv+0xc0>)
   84490:	4798      	blx	r3
	    "ArdOs is not in the right state to take a semaphore");
  xSemaphoreTake(s, portMAX_DELAY);
   84492:	2300      	movs	r3, #0
   84494:	f04f 32ff 	mov.w	r2, #4294967295
   84498:	2100      	movs	r1, #0
   8449a:	6838      	ldr	r0, [r7, #0]
   8449c:	4c0d      	ldr	r4, [pc, #52]	; (844d4 <_ZN3ard5ArdOs14Semaphore_takeEPv+0xc4>)
   8449e:	47a0      	blx	r4
}
   844a0:	bf00      	nop
   844a2:	3734      	adds	r7, #52	; 0x34
   844a4:	46bd      	mov	sp, r7
   844a6:	bd90      	pop	{r4, r7, pc}
   844a8:	00082fad 	.word	0x00082fad
   844ac:	0009a02c 	.word	0x0009a02c
   844b0:	00089009 	.word	0x00089009
   844b4:	00082f89 	.word	0x00082f89
   844b8:	0009a500 	.word	0x0009a500
   844bc:	0008951d 	.word	0x0008951d
   844c0:	00089049 	.word	0x00089049
   844c4:	00083845 	.word	0x00083845
   844c8:	00089145 	.word	0x00089145
   844cc:	00082fe9 	.word	0x00082fe9
   844d0:	00081c7d 	.word	0x00081c7d
   844d4:	0008d735 	.word	0x0008d735

000844d8 <_Z41__static_initialization_and_destruction_0ii>:
ArdOs::Semaphore_tryTake (Semaphore s)
{
  ardAssert(state == eOsState::RUNNING,
	    "ArdOs is not in the right state to take a semaphore");
  return pdTRUE == xSemaphoreTake(s, 0);
}
   844d8:	b580      	push	{r7, lr}
   844da:	b082      	sub	sp, #8
   844dc:	af00      	add	r7, sp, #0
   844de:	6078      	str	r0, [r7, #4]
   844e0:	6039      	str	r1, [r7, #0]
   844e2:	687b      	ldr	r3, [r7, #4]
   844e4:	2b01      	cmp	r3, #1
   844e6:	d107      	bne.n	844f8 <_Z41__static_initialization_and_destruction_0ii+0x20>
   844e8:	683b      	ldr	r3, [r7, #0]
   844ea:	f64f 72ff 	movw	r2, #65535	; 0xffff
   844ee:	4293      	cmp	r3, r2
   844f0:	d102      	bne.n	844f8 <_Z41__static_initialization_and_destruction_0ii+0x20>
}

//-------------------------------------------------------------------------------

//singleton instanciation
ArdOs ArdOs::instance = ArdOs ();
   844f2:	4803      	ldr	r0, [pc, #12]	; (84500 <_Z41__static_initialization_and_destruction_0ii+0x28>)
   844f4:	4b03      	ldr	r3, [pc, #12]	; (84504 <_Z41__static_initialization_and_destruction_0ii+0x2c>)
   844f6:	4798      	blx	r3
ArdOs::Semaphore_tryTake (Semaphore s)
{
  ardAssert(state == eOsState::RUNNING,
	    "ArdOs is not in the right state to take a semaphore");
  return pdTRUE == xSemaphoreTake(s, 0);
}
   844f8:	bf00      	nop
   844fa:	3708      	adds	r7, #8
   844fc:	46bd      	mov	sp, r7
   844fe:	bd80      	pop	{r7, pc}
   84500:	200713a8 	.word	0x200713a8
   84504:	00083269 	.word	0x00083269

00084508 <_GLOBAL__sub_I_infinite>:
   84508:	b580      	push	{r7, lr}
   8450a:	af00      	add	r7, sp, #0
   8450c:	f64f 71ff 	movw	r1, #65535	; 0xffff
   84510:	2001      	movs	r0, #1
   84512:	4b01      	ldr	r3, [pc, #4]	; (84518 <_GLOBAL__sub_I_infinite+0x10>)
   84514:	4798      	blx	r3
   84516:	bd80      	pop	{r7, pc}
   84518:	000844d9 	.word	0x000844d9

0008451c <_Z22fio_manager_registerInPN3ard13FilteredInputE>:
FilteredInput* fio_manager_table[FIO_MANAGER_MAX_IO];
uint8_t fio_manager_nbIo = 0;

void
fio_manager_registerIn (FilteredInput* io)
{
   8451c:	b590      	push	{r4, r7, lr}
   8451e:	b095      	sub	sp, #84	; 0x54
   84520:	af00      	add	r7, sp, #0
   84522:	6078      	str	r0, [r7, #4]
  ardAssert(NULL != io, "fio_manager_registerIn received a null pointer");
   84524:	687b      	ldr	r3, [r7, #4]
   84526:	2b00      	cmp	r3, #0
   84528:	d137      	bne.n	8459a <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x7e>
   8452a:	4b41      	ldr	r3, [pc, #260]	; (84630 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x114>)
   8452c:	4798      	blx	r3
   8452e:	4604      	mov	r4, r0
   84530:	f107 0320 	add.w	r3, r7, #32
   84534:	493f      	ldr	r1, [pc, #252]	; (84634 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x118>)
   84536:	4618      	mov	r0, r3
   84538:	4b3f      	ldr	r3, [pc, #252]	; (84638 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x11c>)
   8453a:	4798      	blx	r3
   8453c:	f107 0220 	add.w	r2, r7, #32
   84540:	f107 0314 	add.w	r3, r7, #20
   84544:	4611      	mov	r1, r2
   84546:	4618      	mov	r0, r3
   84548:	4b3c      	ldr	r3, [pc, #240]	; (8463c <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x120>)
   8454a:	4798      	blx	r3
   8454c:	f107 0314 	add.w	r3, r7, #20
   84550:	493b      	ldr	r1, [pc, #236]	; (84640 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x124>)
   84552:	4618      	mov	r0, r3
   84554:	4b3b      	ldr	r3, [pc, #236]	; (84644 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x128>)
   84556:	4798      	blx	r3
   84558:	4603      	mov	r3, r0
   8455a:	461a      	mov	r2, r3
   8455c:	f107 0308 	add.w	r3, r7, #8
   84560:	4611      	mov	r1, r2
   84562:	4618      	mov	r0, r3
   84564:	4b38      	ldr	r3, [pc, #224]	; (84648 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x12c>)
   84566:	4798      	blx	r3
   84568:	f107 0308 	add.w	r3, r7, #8
   8456c:	4619      	mov	r1, r3
   8456e:	4620      	mov	r0, r4
   84570:	4b36      	ldr	r3, [pc, #216]	; (8464c <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x130>)
   84572:	4798      	blx	r3
   84574:	f107 0308 	add.w	r3, r7, #8
   84578:	4618      	mov	r0, r3
   8457a:	4b35      	ldr	r3, [pc, #212]	; (84650 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x134>)
   8457c:	4798      	blx	r3
   8457e:	f107 0314 	add.w	r3, r7, #20
   84582:	4618      	mov	r0, r3
   84584:	4b33      	ldr	r3, [pc, #204]	; (84654 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x138>)
   84586:	4798      	blx	r3
   84588:	f107 0320 	add.w	r3, r7, #32
   8458c:	4618      	mov	r0, r3
   8458e:	4b30      	ldr	r3, [pc, #192]	; (84650 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x134>)
   84590:	4798      	blx	r3
   84592:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   84596:	4b30      	ldr	r3, [pc, #192]	; (84658 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x13c>)
   84598:	4798      	blx	r3
  ardAssert(fio_manager_nbIo < FIO_MANAGER_MAX_IO,
   8459a:	4b30      	ldr	r3, [pc, #192]	; (8465c <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x140>)
   8459c:	781b      	ldrb	r3, [r3, #0]
   8459e:	2b09      	cmp	r3, #9
   845a0:	d937      	bls.n	84612 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0xf6>
   845a2:	4b23      	ldr	r3, [pc, #140]	; (84630 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x114>)
   845a4:	4798      	blx	r3
   845a6:	4604      	mov	r4, r0
   845a8:	f107 0344 	add.w	r3, r7, #68	; 0x44
   845ac:	4921      	ldr	r1, [pc, #132]	; (84634 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x118>)
   845ae:	4618      	mov	r0, r3
   845b0:	4b21      	ldr	r3, [pc, #132]	; (84638 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x11c>)
   845b2:	4798      	blx	r3
   845b4:	f107 0244 	add.w	r2, r7, #68	; 0x44
   845b8:	f107 0338 	add.w	r3, r7, #56	; 0x38
   845bc:	4611      	mov	r1, r2
   845be:	4618      	mov	r0, r3
   845c0:	4b1e      	ldr	r3, [pc, #120]	; (8463c <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x120>)
   845c2:	4798      	blx	r3
   845c4:	f107 0338 	add.w	r3, r7, #56	; 0x38
   845c8:	4925      	ldr	r1, [pc, #148]	; (84660 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x144>)
   845ca:	4618      	mov	r0, r3
   845cc:	4b1d      	ldr	r3, [pc, #116]	; (84644 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x128>)
   845ce:	4798      	blx	r3
   845d0:	4603      	mov	r3, r0
   845d2:	461a      	mov	r2, r3
   845d4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   845d8:	4611      	mov	r1, r2
   845da:	4618      	mov	r0, r3
   845dc:	4b1a      	ldr	r3, [pc, #104]	; (84648 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x12c>)
   845de:	4798      	blx	r3
   845e0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   845e4:	4619      	mov	r1, r3
   845e6:	4620      	mov	r0, r4
   845e8:	4b18      	ldr	r3, [pc, #96]	; (8464c <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x130>)
   845ea:	4798      	blx	r3
   845ec:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   845f0:	4618      	mov	r0, r3
   845f2:	4b17      	ldr	r3, [pc, #92]	; (84650 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x134>)
   845f4:	4798      	blx	r3
   845f6:	f107 0338 	add.w	r3, r7, #56	; 0x38
   845fa:	4618      	mov	r0, r3
   845fc:	4b15      	ldr	r3, [pc, #84]	; (84654 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x138>)
   845fe:	4798      	blx	r3
   84600:	f107 0344 	add.w	r3, r7, #68	; 0x44
   84604:	4618      	mov	r0, r3
   84606:	4b12      	ldr	r3, [pc, #72]	; (84650 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x134>)
   84608:	4798      	blx	r3
   8460a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   8460e:	4b12      	ldr	r3, [pc, #72]	; (84658 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x13c>)
   84610:	4798      	blx	r3
	    "fio_manager is full, can't add a new pin");
  fio_manager_table[fio_manager_nbIo++] = io;
   84612:	4b12      	ldr	r3, [pc, #72]	; (8465c <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x140>)
   84614:	781b      	ldrb	r3, [r3, #0]
   84616:	1c5a      	adds	r2, r3, #1
   84618:	b2d1      	uxtb	r1, r2
   8461a:	4a10      	ldr	r2, [pc, #64]	; (8465c <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x140>)
   8461c:	7011      	strb	r1, [r2, #0]
   8461e:	4619      	mov	r1, r3
   84620:	4a10      	ldr	r2, [pc, #64]	; (84664 <_Z22fio_manager_registerInPN3ard13FilteredInputE+0x148>)
   84622:	687b      	ldr	r3, [r7, #4]
   84624:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
   84628:	bf00      	nop
   8462a:	3754      	adds	r7, #84	; 0x54
   8462c:	46bd      	mov	sp, r7
   8462e:	bd90      	pop	{r4, r7, pc}
   84630:	00082fad 	.word	0x00082fad
   84634:	0009a534 	.word	0x0009a534
   84638:	00089009 	.word	0x00089009
   8463c:	00082f89 	.word	0x00082f89
   84640:	0009a544 	.word	0x0009a544
   84644:	0008951d 	.word	0x0008951d
   84648:	00089049 	.word	0x00089049
   8464c:	00083845 	.word	0x00083845
   84650:	00089145 	.word	0x00089145
   84654:	00082fe9 	.word	0x00082fe9
   84658:	00081c7d 	.word	0x00081c7d
   8465c:	2007144c 	.word	0x2007144c
   84660:	0009a574 	.word	0x0009a574
   84664:	20071424 	.word	0x20071424

00084668 <_ZN3ard20gpioToolsIsrCallbackEm>:

void
ard::gpioToolsIsrCallback (uint32_t period_us)
{
   84668:	b580      	push	{r7, lr}
   8466a:	b084      	sub	sp, #16
   8466c:	af00      	add	r7, sp, #0
   8466e:	6078      	str	r0, [r7, #4]
  for (int i = 0; i < fio_manager_nbIo; i++)
   84670:	2300      	movs	r3, #0
   84672:	60fb      	str	r3, [r7, #12]
   84674:	4b0a      	ldr	r3, [pc, #40]	; (846a0 <_ZN3ard20gpioToolsIsrCallbackEm+0x38>)
   84676:	781b      	ldrb	r3, [r3, #0]
   84678:	461a      	mov	r2, r3
   8467a:	68fb      	ldr	r3, [r7, #12]
   8467c:	429a      	cmp	r2, r3
   8467e:	dd0b      	ble.n	84698 <_ZN3ard20gpioToolsIsrCallbackEm+0x30>
    {
      fio_manager_table[i]->update (period_us);
   84680:	4a08      	ldr	r2, [pc, #32]	; (846a4 <_ZN3ard20gpioToolsIsrCallbackEm+0x3c>)
   84682:	68fb      	ldr	r3, [r7, #12]
   84684:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   84688:	6879      	ldr	r1, [r7, #4]
   8468a:	4618      	mov	r0, r3
   8468c:	4b06      	ldr	r3, [pc, #24]	; (846a8 <_ZN3ard20gpioToolsIsrCallbackEm+0x40>)
   8468e:	4798      	blx	r3
}

void
ard::gpioToolsIsrCallback (uint32_t period_us)
{
  for (int i = 0; i < fio_manager_nbIo; i++)
   84690:	68fb      	ldr	r3, [r7, #12]
   84692:	3301      	adds	r3, #1
   84694:	60fb      	str	r3, [r7, #12]
   84696:	e7ed      	b.n	84674 <_ZN3ard20gpioToolsIsrCallbackEm+0xc>
    {
      fio_manager_table[i]->update (period_us);
    }
}
   84698:	bf00      	nop
   8469a:	3710      	adds	r7, #16
   8469c:	46bd      	mov	sp, r7
   8469e:	bd80      	pop	{r7, pc}
   846a0:	2007144c 	.word	0x2007144c
   846a4:	20071424 	.word	0x20071424
   846a8:	00084801 	.word	0x00084801

000846ac <_ZN3ard8gpioInitEv>:

void
ard::gpioInit ()
{
   846ac:	b580      	push	{r7, lr}
   846ae:	b082      	sub	sp, #8
   846b0:	af00      	add	r7, sp, #0
  for (int i = 0; i < fio_manager_nbIo; i++)
   846b2:	2300      	movs	r3, #0
   846b4:	607b      	str	r3, [r7, #4]
   846b6:	4b0a      	ldr	r3, [pc, #40]	; (846e0 <_ZN3ard8gpioInitEv+0x34>)
   846b8:	781b      	ldrb	r3, [r3, #0]
   846ba:	461a      	mov	r2, r3
   846bc:	687b      	ldr	r3, [r7, #4]
   846be:	429a      	cmp	r2, r3
   846c0:	dd0a      	ble.n	846d8 <_ZN3ard8gpioInitEv+0x2c>
    {
      fio_manager_table[i]->init ();
   846c2:	4a08      	ldr	r2, [pc, #32]	; (846e4 <_ZN3ard8gpioInitEv+0x38>)
   846c4:	687b      	ldr	r3, [r7, #4]
   846c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   846ca:	4618      	mov	r0, r3
   846cc:	4b06      	ldr	r3, [pc, #24]	; (846e8 <_ZN3ard8gpioInitEv+0x3c>)
   846ce:	4798      	blx	r3
}

void
ard::gpioInit ()
{
  for (int i = 0; i < fio_manager_nbIo; i++)
   846d0:	687b      	ldr	r3, [r7, #4]
   846d2:	3301      	adds	r3, #1
   846d4:	607b      	str	r3, [r7, #4]
   846d6:	e7ee      	b.n	846b6 <_ZN3ard8gpioInitEv+0xa>
    {
      fio_manager_table[i]->init ();
    }
}
   846d8:	bf00      	nop
   846da:	3708      	adds	r7, #8
   846dc:	46bd      	mov	sp, r7
   846de:	bd80      	pop	{r7, pc}
   846e0:	2007144c 	.word	0x2007144c
   846e4:	20071424 	.word	0x20071424
   846e8:	00084919 	.word	0x00084919

000846ec <_ZN3ard13FilteredInputC1Ehmm>:

FilteredInput::FilteredInput (uint8_t pinId, uint32_t debounceHigh,
   846ec:	b580      	push	{r7, lr}
   846ee:	b084      	sub	sp, #16
   846f0:	af00      	add	r7, sp, #0
   846f2:	60f8      	str	r0, [r7, #12]
   846f4:	607a      	str	r2, [r7, #4]
   846f6:	603b      	str	r3, [r7, #0]
   846f8:	460b      	mov	r3, r1
   846fa:	72fb      	strb	r3, [r7, #11]
			      uint32_t debounceLow) :
    pin (pinId), signalAny (NULL), signalFalling (NULL), signalRising (NULL)
   846fc:	68fb      	ldr	r3, [r7, #12]
   846fe:	7afa      	ldrb	r2, [r7, #11]
   84700:	701a      	strb	r2, [r3, #0]
   84702:	68fb      	ldr	r3, [r7, #12]
   84704:	2200      	movs	r2, #0
   84706:	615a      	str	r2, [r3, #20]
   84708:	68fb      	ldr	r3, [r7, #12]
   8470a:	2200      	movs	r2, #0
   8470c:	619a      	str	r2, [r3, #24]
   8470e:	68fb      	ldr	r3, [r7, #12]
   84710:	2200      	movs	r2, #0
   84712:	61da      	str	r2, [r3, #28]
{
  reset ();
   84714:	68f8      	ldr	r0, [r7, #12]
   84716:	4b09      	ldr	r3, [pc, #36]	; (8473c <_ZN3ard13FilteredInputC1Ehmm+0x50>)
   84718:	4798      	blx	r3
  fio_manager_registerIn (this);
   8471a:	68f8      	ldr	r0, [r7, #12]
   8471c:	4b08      	ldr	r3, [pc, #32]	; (84740 <_ZN3ard13FilteredInputC1Ehmm+0x54>)
   8471e:	4798      	blx	r3
  setDebounceHigh (debounceHigh);
   84720:	6879      	ldr	r1, [r7, #4]
   84722:	68f8      	ldr	r0, [r7, #12]
   84724:	4b07      	ldr	r3, [pc, #28]	; (84744 <_ZN3ard13FilteredInputC1Ehmm+0x58>)
   84726:	4798      	blx	r3
  setDebounceLow (debounceLow);
   84728:	6839      	ldr	r1, [r7, #0]
   8472a:	68f8      	ldr	r0, [r7, #12]
   8472c:	4b06      	ldr	r3, [pc, #24]	; (84748 <_ZN3ard13FilteredInputC1Ehmm+0x5c>)
   8472e:	4798      	blx	r3
}
   84730:	68fb      	ldr	r3, [r7, #12]
   84732:	4618      	mov	r0, r3
   84734:	3710      	adds	r7, #16
   84736:	46bd      	mov	sp, r7
   84738:	bd80      	pop	{r7, pc}
   8473a:	bf00      	nop
   8473c:	000847dd 	.word	0x000847dd
   84740:	0008451d 	.word	0x0008451d
   84744:	0008474d 	.word	0x0008474d
   84748:	00084795 	.word	0x00084795

0008474c <_ZN3ard13FilteredInput15setDebounceHighEm>:

void
FilteredInput::setDebounceHigh (uint32_t debounce)
{
   8474c:	b590      	push	{r4, r7, lr}
   8474e:	b083      	sub	sp, #12
   84750:	af00      	add	r7, sp, #0
   84752:	6078      	str	r0, [r7, #4]
   84754:	6039      	str	r1, [r7, #0]
  debounceHighDuration = debounce * 1E3; //millis to us
   84756:	4b0b      	ldr	r3, [pc, #44]	; (84784 <_ZN3ard13FilteredInput15setDebounceHighEm+0x38>)
   84758:	6838      	ldr	r0, [r7, #0]
   8475a:	4798      	blx	r3
   8475c:	4c0a      	ldr	r4, [pc, #40]	; (84788 <_ZN3ard13FilteredInput15setDebounceHighEm+0x3c>)
   8475e:	f04f 0200 	mov.w	r2, #0
   84762:	4b0a      	ldr	r3, [pc, #40]	; (8478c <_ZN3ard13FilteredInput15setDebounceHighEm+0x40>)
   84764:	47a0      	blx	r4
   84766:	4603      	mov	r3, r0
   84768:	460c      	mov	r4, r1
   8476a:	4619      	mov	r1, r3
   8476c:	4622      	mov	r2, r4
   8476e:	4b08      	ldr	r3, [pc, #32]	; (84790 <_ZN3ard13FilteredInput15setDebounceHighEm+0x44>)
   84770:	4608      	mov	r0, r1
   84772:	4611      	mov	r1, r2
   84774:	4798      	blx	r3
   84776:	4602      	mov	r2, r0
   84778:	687b      	ldr	r3, [r7, #4]
   8477a:	605a      	str	r2, [r3, #4]
}
   8477c:	bf00      	nop
   8477e:	370c      	adds	r7, #12
   84780:	46bd      	mov	sp, r7
   84782:	bd90      	pop	{r4, r7, pc}
   84784:	00092691 	.word	0x00092691
   84788:	0009277d 	.word	0x0009277d
   8478c:	408f4000 	.word	0x408f4000
   84790:	00092d2d 	.word	0x00092d2d

00084794 <_ZN3ard13FilteredInput14setDebounceLowEm>:

void
FilteredInput::setDebounceLow (uint32_t debounce)
{
   84794:	b590      	push	{r4, r7, lr}
   84796:	b083      	sub	sp, #12
   84798:	af00      	add	r7, sp, #0
   8479a:	6078      	str	r0, [r7, #4]
   8479c:	6039      	str	r1, [r7, #0]
  debounceLowDuration = debounce * 1E3; //millis to us
   8479e:	4b0b      	ldr	r3, [pc, #44]	; (847cc <_ZN3ard13FilteredInput14setDebounceLowEm+0x38>)
   847a0:	6838      	ldr	r0, [r7, #0]
   847a2:	4798      	blx	r3
   847a4:	4c0a      	ldr	r4, [pc, #40]	; (847d0 <_ZN3ard13FilteredInput14setDebounceLowEm+0x3c>)
   847a6:	f04f 0200 	mov.w	r2, #0
   847aa:	4b0a      	ldr	r3, [pc, #40]	; (847d4 <_ZN3ard13FilteredInput14setDebounceLowEm+0x40>)
   847ac:	47a0      	blx	r4
   847ae:	4603      	mov	r3, r0
   847b0:	460c      	mov	r4, r1
   847b2:	4619      	mov	r1, r3
   847b4:	4622      	mov	r2, r4
   847b6:	4b08      	ldr	r3, [pc, #32]	; (847d8 <_ZN3ard13FilteredInput14setDebounceLowEm+0x44>)
   847b8:	4608      	mov	r0, r1
   847ba:	4611      	mov	r1, r2
   847bc:	4798      	blx	r3
   847be:	4602      	mov	r2, r0
   847c0:	687b      	ldr	r3, [r7, #4]
   847c2:	60da      	str	r2, [r3, #12]
}
   847c4:	bf00      	nop
   847c6:	370c      	adds	r7, #12
   847c8:	46bd      	mov	sp, r7
   847ca:	bd90      	pop	{r4, r7, pc}
   847cc:	00092691 	.word	0x00092691
   847d0:	0009277d 	.word	0x0009277d
   847d4:	408f4000 	.word	0x408f4000
   847d8:	00092d2d 	.word	0x00092d2d

000847dc <_ZN3ard13FilteredInput5resetEv>:
    }
}

void
FilteredInput::reset ()
{
   847dc:	b480      	push	{r7}
   847de:	b083      	sub	sp, #12
   847e0:	af00      	add	r7, sp, #0
   847e2:	6078      	str	r0, [r7, #4]
  debounceHighCount = 0;
   847e4:	687b      	ldr	r3, [r7, #4]
   847e6:	2200      	movs	r2, #0
   847e8:	609a      	str	r2, [r3, #8]
  debounceLowCount = 0;
   847ea:	687b      	ldr	r3, [r7, #4]
   847ec:	2200      	movs	r2, #0
   847ee:	611a      	str	r2, [r3, #16]
  filteredLevel = GPIO_LOW;
   847f0:	687b      	ldr	r3, [r7, #4]
   847f2:	2200      	movs	r2, #0
   847f4:	705a      	strb	r2, [r3, #1]
}
   847f6:	bf00      	nop
   847f8:	370c      	adds	r7, #12
   847fa:	46bd      	mov	sp, r7
   847fc:	bc80      	pop	{r7}
   847fe:	4770      	bx	lr

00084800 <_ZN3ard13FilteredInput6updateEm>:

void
FilteredInput::update (uint32_t period_us)
{
   84800:	b580      	push	{r7, lr}
   84802:	b082      	sub	sp, #8
   84804:	af00      	add	r7, sp, #0
   84806:	6078      	str	r0, [r7, #4]
   84808:	6039      	str	r1, [r7, #0]
  //Pin rising edge
  if (digitalRead (pin) == GPIO_HIGH && filteredLevel == GPIO_LOW)
   8480a:	687b      	ldr	r3, [r7, #4]
   8480c:	781b      	ldrb	r3, [r3, #0]
   8480e:	4618      	mov	r0, r3
   84810:	4b3e      	ldr	r3, [pc, #248]	; (8490c <_ZN3ard13FilteredInput6updateEm+0x10c>)
   84812:	4798      	blx	r3
   84814:	4603      	mov	r3, r0
   84816:	2b01      	cmp	r3, #1
   84818:	d105      	bne.n	84826 <_ZN3ard13FilteredInput6updateEm+0x26>
   8481a:	687b      	ldr	r3, [r7, #4]
   8481c:	785b      	ldrb	r3, [r3, #1]
   8481e:	2b00      	cmp	r3, #0
   84820:	d101      	bne.n	84826 <_ZN3ard13FilteredInput6updateEm+0x26>
   84822:	2301      	movs	r3, #1
   84824:	e000      	b.n	84828 <_ZN3ard13FilteredInput6updateEm+0x28>
   84826:	2300      	movs	r3, #0
   84828:	2b00      	cmp	r3, #0
   8482a:	d029      	beq.n	84880 <_ZN3ard13FilteredInput6updateEm+0x80>
    {
      debounceHighCount += period_us;
   8482c:	687b      	ldr	r3, [r7, #4]
   8482e:	689a      	ldr	r2, [r3, #8]
   84830:	683b      	ldr	r3, [r7, #0]
   84832:	441a      	add	r2, r3
   84834:	687b      	ldr	r3, [r7, #4]
   84836:	609a      	str	r2, [r3, #8]

      if (debounceHighDuration <= debounceHighCount)
   84838:	687b      	ldr	r3, [r7, #4]
   8483a:	685a      	ldr	r2, [r3, #4]
   8483c:	687b      	ldr	r3, [r7, #4]
   8483e:	689b      	ldr	r3, [r3, #8]
   84840:	429a      	cmp	r2, r3
   84842:	bf94      	ite	ls
   84844:	2301      	movls	r3, #1
   84846:	2300      	movhi	r3, #0
   84848:	b2db      	uxtb	r3, r3
   8484a:	2b00      	cmp	r3, #0
   8484c:	d059      	beq.n	84902 <_ZN3ard13FilteredInput6updateEm+0x102>
	{
	  debounceLowCount = 0;
   8484e:	687b      	ldr	r3, [r7, #4]
   84850:	2200      	movs	r2, #0
   84852:	611a      	str	r2, [r3, #16]
	  filteredLevel = GPIO_HIGH;
   84854:	687b      	ldr	r3, [r7, #4]
   84856:	2201      	movs	r2, #1
   84858:	705a      	strb	r2, [r3, #1]
	  g_ArdOs.Signal_set(signalAny);
   8485a:	4b2d      	ldr	r3, [pc, #180]	; (84910 <_ZN3ard13FilteredInput6updateEm+0x110>)
   8485c:	4798      	blx	r3
   8485e:	4602      	mov	r2, r0
   84860:	687b      	ldr	r3, [r7, #4]
   84862:	695b      	ldr	r3, [r3, #20]
   84864:	4619      	mov	r1, r3
   84866:	4610      	mov	r0, r2
   84868:	4b2a      	ldr	r3, [pc, #168]	; (84914 <_ZN3ard13FilteredInput6updateEm+0x114>)
   8486a:	4798      	blx	r3
	  g_ArdOs.Signal_set(signalRising);
   8486c:	4b28      	ldr	r3, [pc, #160]	; (84910 <_ZN3ard13FilteredInput6updateEm+0x110>)
   8486e:	4798      	blx	r3
   84870:	4602      	mov	r2, r0
   84872:	687b      	ldr	r3, [r7, #4]
   84874:	69db      	ldr	r3, [r3, #28]
   84876:	4619      	mov	r1, r3
   84878:	4610      	mov	r0, r2
   8487a:	4b26      	ldr	r3, [pc, #152]	; (84914 <_ZN3ard13FilteredInput6updateEm+0x114>)
   8487c:	4798      	blx	r3
  else
    {
      debounceLowCount = 0;
      debounceHighCount = 0;
    }
}
   8487e:	e040      	b.n	84902 <_ZN3ard13FilteredInput6updateEm+0x102>
	  filteredLevel = GPIO_HIGH;
	  g_ArdOs.Signal_set(signalAny);
	  g_ArdOs.Signal_set(signalRising);
	}
    }
  else if( digitalRead(pin) == GPIO_LOW && filteredLevel == GPIO_HIGH )
   84880:	687b      	ldr	r3, [r7, #4]
   84882:	781b      	ldrb	r3, [r3, #0]
   84884:	4618      	mov	r0, r3
   84886:	4b21      	ldr	r3, [pc, #132]	; (8490c <_ZN3ard13FilteredInput6updateEm+0x10c>)
   84888:	4798      	blx	r3
   8488a:	4603      	mov	r3, r0
   8488c:	2b00      	cmp	r3, #0
   8488e:	d105      	bne.n	8489c <_ZN3ard13FilteredInput6updateEm+0x9c>
   84890:	687b      	ldr	r3, [r7, #4]
   84892:	785b      	ldrb	r3, [r3, #1]
   84894:	2b01      	cmp	r3, #1
   84896:	d101      	bne.n	8489c <_ZN3ard13FilteredInput6updateEm+0x9c>
   84898:	2301      	movs	r3, #1
   8489a:	e000      	b.n	8489e <_ZN3ard13FilteredInput6updateEm+0x9e>
   8489c:	2300      	movs	r3, #0
   8489e:	2b00      	cmp	r3, #0
   848a0:	d029      	beq.n	848f6 <_ZN3ard13FilteredInput6updateEm+0xf6>
    {
      debounceLowCount += period_us;
   848a2:	687b      	ldr	r3, [r7, #4]
   848a4:	691a      	ldr	r2, [r3, #16]
   848a6:	683b      	ldr	r3, [r7, #0]
   848a8:	441a      	add	r2, r3
   848aa:	687b      	ldr	r3, [r7, #4]
   848ac:	611a      	str	r2, [r3, #16]

      if( debounceLowDuration <= debounceLowCount )
   848ae:	687b      	ldr	r3, [r7, #4]
   848b0:	68da      	ldr	r2, [r3, #12]
   848b2:	687b      	ldr	r3, [r7, #4]
   848b4:	691b      	ldr	r3, [r3, #16]
   848b6:	429a      	cmp	r2, r3
   848b8:	bf94      	ite	ls
   848ba:	2301      	movls	r3, #1
   848bc:	2300      	movhi	r3, #0
   848be:	b2db      	uxtb	r3, r3
   848c0:	2b00      	cmp	r3, #0
   848c2:	d01e      	beq.n	84902 <_ZN3ard13FilteredInput6updateEm+0x102>
	{
	  debounceHighCount = 0;
   848c4:	687b      	ldr	r3, [r7, #4]
   848c6:	2200      	movs	r2, #0
   848c8:	609a      	str	r2, [r3, #8]
	  filteredLevel = GPIO_LOW;
   848ca:	687b      	ldr	r3, [r7, #4]
   848cc:	2200      	movs	r2, #0
   848ce:	705a      	strb	r2, [r3, #1]
	  g_ArdOs.Signal_set(signalAny);
   848d0:	4b0f      	ldr	r3, [pc, #60]	; (84910 <_ZN3ard13FilteredInput6updateEm+0x110>)
   848d2:	4798      	blx	r3
   848d4:	4602      	mov	r2, r0
   848d6:	687b      	ldr	r3, [r7, #4]
   848d8:	695b      	ldr	r3, [r3, #20]
   848da:	4619      	mov	r1, r3
   848dc:	4610      	mov	r0, r2
   848de:	4b0d      	ldr	r3, [pc, #52]	; (84914 <_ZN3ard13FilteredInput6updateEm+0x114>)
   848e0:	4798      	blx	r3
	  g_ArdOs.Signal_set(signalFalling);
   848e2:	4b0b      	ldr	r3, [pc, #44]	; (84910 <_ZN3ard13FilteredInput6updateEm+0x110>)
   848e4:	4798      	blx	r3
   848e6:	4602      	mov	r2, r0
   848e8:	687b      	ldr	r3, [r7, #4]
   848ea:	699b      	ldr	r3, [r3, #24]
   848ec:	4619      	mov	r1, r3
   848ee:	4610      	mov	r0, r2
   848f0:	4b08      	ldr	r3, [pc, #32]	; (84914 <_ZN3ard13FilteredInput6updateEm+0x114>)
   848f2:	4798      	blx	r3
  else
    {
      debounceLowCount = 0;
      debounceHighCount = 0;
    }
}
   848f4:	e005      	b.n	84902 <_ZN3ard13FilteredInput6updateEm+0x102>
	  g_ArdOs.Signal_set(signalFalling);
	}
    }
  else
    {
      debounceLowCount = 0;
   848f6:	687b      	ldr	r3, [r7, #4]
   848f8:	2200      	movs	r2, #0
   848fa:	611a      	str	r2, [r3, #16]
      debounceHighCount = 0;
   848fc:	687b      	ldr	r3, [r7, #4]
   848fe:	2200      	movs	r2, #0
   84900:	609a      	str	r2, [r3, #8]
    }
}
   84902:	bf00      	nop
   84904:	3708      	adds	r7, #8
   84906:	46bd      	mov	sp, r7
   84908:	bd80      	pop	{r7, pc}
   8490a:	bf00      	nop
   8490c:	00082031 	.word	0x00082031
   84910:	00082fad 	.word	0x00082fad
   84914:	00083d91 	.word	0x00083d91

00084918 <_ZN3ard13FilteredInput4initEv>:

void
FilteredInput::init ()
{
   84918:	b580      	push	{r7, lr}
   8491a:	b082      	sub	sp, #8
   8491c:	af00      	add	r7, sp, #0
   8491e:	6078      	str	r0, [r7, #4]
  signalAny = g_ArdOs.Signal_create();
   84920:	4b0f      	ldr	r3, [pc, #60]	; (84960 <_ZN3ard13FilteredInput4initEv+0x48>)
   84922:	4798      	blx	r3
   84924:	4603      	mov	r3, r0
   84926:	4618      	mov	r0, r3
   84928:	4b0e      	ldr	r3, [pc, #56]	; (84964 <_ZN3ard13FilteredInput4initEv+0x4c>)
   8492a:	4798      	blx	r3
   8492c:	4602      	mov	r2, r0
   8492e:	687b      	ldr	r3, [r7, #4]
   84930:	615a      	str	r2, [r3, #20]
  signalFalling = g_ArdOs.Signal_create();
   84932:	4b0b      	ldr	r3, [pc, #44]	; (84960 <_ZN3ard13FilteredInput4initEv+0x48>)
   84934:	4798      	blx	r3
   84936:	4603      	mov	r3, r0
   84938:	4618      	mov	r0, r3
   8493a:	4b0a      	ldr	r3, [pc, #40]	; (84964 <_ZN3ard13FilteredInput4initEv+0x4c>)
   8493c:	4798      	blx	r3
   8493e:	4602      	mov	r2, r0
   84940:	687b      	ldr	r3, [r7, #4]
   84942:	619a      	str	r2, [r3, #24]
  signalAny = g_ArdOs.Signal_create();
   84944:	4b06      	ldr	r3, [pc, #24]	; (84960 <_ZN3ard13FilteredInput4initEv+0x48>)
   84946:	4798      	blx	r3
   84948:	4603      	mov	r3, r0
   8494a:	4618      	mov	r0, r3
   8494c:	4b05      	ldr	r3, [pc, #20]	; (84964 <_ZN3ard13FilteredInput4initEv+0x4c>)
   8494e:	4798      	blx	r3
   84950:	4602      	mov	r2, r0
   84952:	687b      	ldr	r3, [r7, #4]
   84954:	615a      	str	r2, [r3, #20]
}
   84956:	bf00      	nop
   84958:	3708      	adds	r7, #8
   8495a:	46bd      	mov	sp, r7
   8495c:	bd80      	pop	{r7, pc}
   8495e:	bf00      	nop
   84960:	00082fad 	.word	0x00082fad
   84964:	00083c45 	.word	0x00083c45

00084968 <_ZN3ard7IThreadD1Ev>:
    void delay(DelayMs delay)
    {
      vTaskDelay(delay);
    }

    virtual ~IThread(){};
   84968:	b580      	push	{r7, lr}
   8496a:	b082      	sub	sp, #8
   8496c:	af00      	add	r7, sp, #0
   8496e:	6078      	str	r0, [r7, #4]
   84970:	4a06      	ldr	r2, [pc, #24]	; (8498c <_ZN3ard7IThreadD1Ev+0x24>)
   84972:	687b      	ldr	r3, [r7, #4]
   84974:	601a      	str	r2, [r3, #0]
   84976:	2300      	movs	r3, #0
   84978:	2b00      	cmp	r3, #0
   8497a:	d002      	beq.n	84982 <_ZN3ard7IThreadD1Ev+0x1a>
   8497c:	6878      	ldr	r0, [r7, #4]
   8497e:	4b04      	ldr	r3, [pc, #16]	; (84990 <_ZN3ard7IThreadD1Ev+0x28>)
   84980:	4798      	blx	r3
   84982:	687b      	ldr	r3, [r7, #4]
   84984:	4618      	mov	r0, r3
   84986:	3708      	adds	r7, #8
   84988:	46bd      	mov	sp, r7
   8498a:	bd80      	pop	{r7, pc}
   8498c:	0009a5c4 	.word	0x0009a5c4
   84990:	0008788d 	.word	0x0008788d

00084994 <_ZN3ard7IThreadD0Ev>:
   84994:	b580      	push	{r7, lr}
   84996:	b082      	sub	sp, #8
   84998:	af00      	add	r7, sp, #0
   8499a:	6078      	str	r0, [r7, #4]
   8499c:	6878      	ldr	r0, [r7, #4]
   8499e:	4b05      	ldr	r3, [pc, #20]	; (849b4 <_ZN3ard7IThreadD0Ev+0x20>)
   849a0:	4798      	blx	r3
   849a2:	6878      	ldr	r0, [r7, #4]
   849a4:	4b04      	ldr	r3, [pc, #16]	; (849b8 <_ZN3ard7IThreadD0Ev+0x24>)
   849a6:	4798      	blx	r3
   849a8:	687b      	ldr	r3, [r7, #4]
   849aa:	4618      	mov	r0, r3
   849ac:	3708      	adds	r7, #8
   849ae:	46bd      	mov	sp, r7
   849b0:	bd80      	pop	{r7, pc}
   849b2:	bf00      	nop
   849b4:	00084969 	.word	0x00084969
   849b8:	0008788d 	.word	0x0008788d

000849bc <_ZN3ard6RgbLedC1Eiii>:

/*--------------------------------------------------------------------- */
/*   OUTPUT                                                             */
/*--------------------------------------------------------------------- */

RgbLed::RgbLed (int pin_r, int pin_g, int pin_b)
   849bc:	b480      	push	{r7}
   849be:	b085      	sub	sp, #20
   849c0:	af00      	add	r7, sp, #0
   849c2:	60f8      	str	r0, [r7, #12]
   849c4:	60b9      	str	r1, [r7, #8]
   849c6:	607a      	str	r2, [r7, #4]
   849c8:	603b      	str	r3, [r7, #0]
{
  m_r = pin_r;
   849ca:	68fb      	ldr	r3, [r7, #12]
   849cc:	68ba      	ldr	r2, [r7, #8]
   849ce:	605a      	str	r2, [r3, #4]
  m_g = pin_g;
   849d0:	68fb      	ldr	r3, [r7, #12]
   849d2:	687a      	ldr	r2, [r7, #4]
   849d4:	609a      	str	r2, [r3, #8]
  m_b = pin_b;
   849d6:	683a      	ldr	r2, [r7, #0]
   849d8:	68fb      	ldr	r3, [r7, #12]
   849da:	60da      	str	r2, [r3, #12]

  m_color = eRgb::WHITE;
   849dc:	68fb      	ldr	r3, [r7, #12]
   849de:	2206      	movs	r2, #6
   849e0:	701a      	strb	r2, [r3, #0]
  m_blink = eLedState::OFF;
   849e2:	68fb      	ldr	r3, [r7, #12]
   849e4:	2200      	movs	r2, #0
   849e6:	705a      	strb	r2, [r3, #1]

  lastState = 0;
   849e8:	68fb      	ldr	r3, [r7, #12]
   849ea:	2200      	movs	r2, #0
   849ec:	741a      	strb	r2, [r3, #16]
  m_on = false;
   849ee:	68fb      	ldr	r3, [r7, #12]
   849f0:	2200      	movs	r2, #0
   849f2:	745a      	strb	r2, [r3, #17]
}
   849f4:	68fb      	ldr	r3, [r7, #12]
   849f6:	4618      	mov	r0, r3
   849f8:	3714      	adds	r7, #20
   849fa:	46bd      	mov	sp, r7
   849fc:	bc80      	pop	{r7}
   849fe:	4770      	bx	lr

00084a00 <_ZN3ard6RgbLed3setENS_4eRgbENS_9eLedStateE>:

void
RgbLed::set (eRgb color, eLedState blink)
{
   84a00:	b480      	push	{r7}
   84a02:	b083      	sub	sp, #12
   84a04:	af00      	add	r7, sp, #0
   84a06:	6078      	str	r0, [r7, #4]
   84a08:	460b      	mov	r3, r1
   84a0a:	70fb      	strb	r3, [r7, #3]
   84a0c:	4613      	mov	r3, r2
   84a0e:	70bb      	strb	r3, [r7, #2]
  m_color = color;
   84a10:	687b      	ldr	r3, [r7, #4]
   84a12:	78fa      	ldrb	r2, [r7, #3]
   84a14:	701a      	strb	r2, [r3, #0]
  m_blink = blink;
   84a16:	687b      	ldr	r3, [r7, #4]
   84a18:	78ba      	ldrb	r2, [r7, #2]
   84a1a:	705a      	strb	r2, [r3, #1]
}
   84a1c:	bf00      	nop
   84a1e:	370c      	adds	r7, #12
   84a20:	46bd      	mov	sp, r7
   84a22:	bc80      	pop	{r7}
   84a24:	4770      	bx	lr
   84a26:	bf00      	nop

00084a28 <_ZN3ard6RgbLed3runEv>:
  m_blink = eLedState::OFF;
}

void
RgbLed::run ()
{
   84a28:	b580      	push	{r7, lr}
   84a2a:	b082      	sub	sp, #8
   84a2c:	af00      	add	r7, sp, #0
   84a2e:	6078      	str	r0, [r7, #4]
  if ((lastState % 2 == 0 && m_blink == eLedState::FAST_BLINK)
   84a30:	687b      	ldr	r3, [r7, #4]
   84a32:	7c1b      	ldrb	r3, [r3, #16]
   84a34:	f003 0301 	and.w	r3, r3, #1
   84a38:	2b00      	cmp	r3, #0
   84a3a:	d103      	bne.n	84a44 <_ZN3ard6RgbLed3runEv+0x1c>
   84a3c:	687b      	ldr	r3, [r7, #4]
   84a3e:	785b      	ldrb	r3, [r3, #1]
   84a40:	2b03      	cmp	r3, #3
   84a42:	d011      	beq.n	84a68 <_ZN3ard6RgbLed3runEv+0x40>
  	  || (lastState % 10 == 0 && m_blink == eLedState::SLOW_BLINK))
   84a44:	687b      	ldr	r3, [r7, #4]
   84a46:	7c1a      	ldrb	r2, [r3, #16]
   84a48:	4b1b      	ldr	r3, [pc, #108]	; (84ab8 <_ZN3ard6RgbLed3runEv+0x90>)
   84a4a:	fba3 1302 	umull	r1, r3, r3, r2
   84a4e:	08d9      	lsrs	r1, r3, #3
   84a50:	460b      	mov	r3, r1
   84a52:	009b      	lsls	r3, r3, #2
   84a54:	440b      	add	r3, r1
   84a56:	005b      	lsls	r3, r3, #1
   84a58:	1ad3      	subs	r3, r2, r3
   84a5a:	b2db      	uxtb	r3, r3
   84a5c:	2b00      	cmp	r3, #0
   84a5e:	d10b      	bne.n	84a78 <_ZN3ard6RgbLed3runEv+0x50>
   84a60:	687b      	ldr	r3, [r7, #4]
   84a62:	785b      	ldrb	r3, [r3, #1]
   84a64:	2b02      	cmp	r3, #2
   84a66:	d107      	bne.n	84a78 <_ZN3ard6RgbLed3runEv+0x50>
    m_on = !m_on;
   84a68:	687b      	ldr	r3, [r7, #4]
   84a6a:	7c5b      	ldrb	r3, [r3, #17]
   84a6c:	f083 0301 	eor.w	r3, r3, #1
   84a70:	b2da      	uxtb	r2, r3
   84a72:	687b      	ldr	r3, [r7, #4]
   84a74:	745a      	strb	r2, [r3, #17]
   84a76:	e00e      	b.n	84a96 <_ZN3ard6RgbLed3runEv+0x6e>
  else if (m_blink == eLedState::ON)
   84a78:	687b      	ldr	r3, [r7, #4]
   84a7a:	785b      	ldrb	r3, [r3, #1]
   84a7c:	2b01      	cmp	r3, #1
   84a7e:	d103      	bne.n	84a88 <_ZN3ard6RgbLed3runEv+0x60>
    m_on = true;
   84a80:	687b      	ldr	r3, [r7, #4]
   84a82:	2201      	movs	r2, #1
   84a84:	745a      	strb	r2, [r3, #17]
   84a86:	e006      	b.n	84a96 <_ZN3ard6RgbLed3runEv+0x6e>
  else if (m_blink == eLedState::OFF)
   84a88:	687b      	ldr	r3, [r7, #4]
   84a8a:	785b      	ldrb	r3, [r3, #1]
   84a8c:	2b00      	cmp	r3, #0
   84a8e:	d102      	bne.n	84a96 <_ZN3ard6RgbLed3runEv+0x6e>
    m_on = false;
   84a90:	687b      	ldr	r3, [r7, #4]
   84a92:	2200      	movs	r2, #0
   84a94:	745a      	strb	r2, [r3, #17]

  output (m_on);
   84a96:	687b      	ldr	r3, [r7, #4]
   84a98:	7c5b      	ldrb	r3, [r3, #17]
   84a9a:	4619      	mov	r1, r3
   84a9c:	6878      	ldr	r0, [r7, #4]
   84a9e:	4b07      	ldr	r3, [pc, #28]	; (84abc <_ZN3ard6RgbLed3runEv+0x94>)
   84aa0:	4798      	blx	r3
  lastState++;
   84aa2:	687b      	ldr	r3, [r7, #4]
   84aa4:	7c1b      	ldrb	r3, [r3, #16]
   84aa6:	3301      	adds	r3, #1
   84aa8:	b2da      	uxtb	r2, r3
   84aaa:	687b      	ldr	r3, [r7, #4]
   84aac:	741a      	strb	r2, [r3, #16]
}
   84aae:	bf00      	nop
   84ab0:	3708      	adds	r7, #8
   84ab2:	46bd      	mov	sp, r7
   84ab4:	bd80      	pop	{r7, pc}
   84ab6:	bf00      	nop
   84ab8:	cccccccd 	.word	0xcccccccd
   84abc:	00084ac1 	.word	0x00084ac1

00084ac0 <_ZN3ard6RgbLed6outputEb>:

void
RgbLed::output (bool _on)
{
   84ac0:	b580      	push	{r7, lr}
   84ac2:	b082      	sub	sp, #8
   84ac4:	af00      	add	r7, sp, #0
   84ac6:	6078      	str	r0, [r7, #4]
   84ac8:	460b      	mov	r3, r1
   84aca:	70fb      	strb	r3, [r7, #3]
  if (_on)
   84acc:	78fb      	ldrb	r3, [r7, #3]
   84ace:	2b00      	cmp	r3, #0
   84ad0:	f000 809c 	beq.w	84c0c <_ZN3ard6RgbLed6outputEb+0x14c>
    {
      switch (m_color)
   84ad4:	687b      	ldr	r3, [r7, #4]
   84ad6:	781b      	ldrb	r3, [r3, #0]
   84ad8:	2b06      	cmp	r3, #6
   84ada:	f200 80aa 	bhi.w	84c32 <_ZN3ard6RgbLed6outputEb+0x172>
   84ade:	a201      	add	r2, pc, #4	; (adr r2, 84ae4 <_ZN3ard6RgbLed6outputEb+0x24>)
   84ae0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   84ae4:	00084b01 	.word	0x00084b01
   84ae8:	00084b27 	.word	0x00084b27
   84aec:	00084b4d 	.word	0x00084b4d
   84af0:	00084b73 	.word	0x00084b73
   84af4:	00084b99 	.word	0x00084b99
   84af8:	00084bbf 	.word	0x00084bbf
   84afc:	00084be5 	.word	0x00084be5
	{
	case eRgb::RED:
	  digitalWrite (m_r, LOW);
   84b00:	687b      	ldr	r3, [r7, #4]
   84b02:	685b      	ldr	r3, [r3, #4]
   84b04:	2100      	movs	r1, #0
   84b06:	4618      	mov	r0, r3
   84b08:	4b4c      	ldr	r3, [pc, #304]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b0a:	4798      	blx	r3
	  digitalWrite (m_g, HIGH);
   84b0c:	687b      	ldr	r3, [r7, #4]
   84b0e:	689b      	ldr	r3, [r3, #8]
   84b10:	2101      	movs	r1, #1
   84b12:	4618      	mov	r0, r3
   84b14:	4b49      	ldr	r3, [pc, #292]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b16:	4798      	blx	r3
	  digitalWrite (m_b, HIGH);
   84b18:	687b      	ldr	r3, [r7, #4]
   84b1a:	68db      	ldr	r3, [r3, #12]
   84b1c:	2101      	movs	r1, #1
   84b1e:	4618      	mov	r0, r3
   84b20:	4b46      	ldr	r3, [pc, #280]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b22:	4798      	blx	r3
	  break;
   84b24:	e085      	b.n	84c32 <_ZN3ard6RgbLed6outputEb+0x172>
	case eRgb::GREEN:
	  digitalWrite (m_r, HIGH);
   84b26:	687b      	ldr	r3, [r7, #4]
   84b28:	685b      	ldr	r3, [r3, #4]
   84b2a:	2101      	movs	r1, #1
   84b2c:	4618      	mov	r0, r3
   84b2e:	4b43      	ldr	r3, [pc, #268]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b30:	4798      	blx	r3
	  digitalWrite (m_g, LOW);
   84b32:	687b      	ldr	r3, [r7, #4]
   84b34:	689b      	ldr	r3, [r3, #8]
   84b36:	2100      	movs	r1, #0
   84b38:	4618      	mov	r0, r3
   84b3a:	4b40      	ldr	r3, [pc, #256]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b3c:	4798      	blx	r3
	  digitalWrite (m_b, HIGH);
   84b3e:	687b      	ldr	r3, [r7, #4]
   84b40:	68db      	ldr	r3, [r3, #12]
   84b42:	2101      	movs	r1, #1
   84b44:	4618      	mov	r0, r3
   84b46:	4b3d      	ldr	r3, [pc, #244]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b48:	4798      	blx	r3
	  break;
   84b4a:	e072      	b.n	84c32 <_ZN3ard6RgbLed6outputEb+0x172>
	case eRgb::BLUE:
	  digitalWrite (m_r, HIGH);
   84b4c:	687b      	ldr	r3, [r7, #4]
   84b4e:	685b      	ldr	r3, [r3, #4]
   84b50:	2101      	movs	r1, #1
   84b52:	4618      	mov	r0, r3
   84b54:	4b39      	ldr	r3, [pc, #228]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b56:	4798      	blx	r3
	  digitalWrite (m_g, HIGH);
   84b58:	687b      	ldr	r3, [r7, #4]
   84b5a:	689b      	ldr	r3, [r3, #8]
   84b5c:	2101      	movs	r1, #1
   84b5e:	4618      	mov	r0, r3
   84b60:	4b36      	ldr	r3, [pc, #216]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b62:	4798      	blx	r3
	  digitalWrite (m_b, LOW);
   84b64:	687b      	ldr	r3, [r7, #4]
   84b66:	68db      	ldr	r3, [r3, #12]
   84b68:	2100      	movs	r1, #0
   84b6a:	4618      	mov	r0, r3
   84b6c:	4b33      	ldr	r3, [pc, #204]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b6e:	4798      	blx	r3
	  break;
   84b70:	e05f      	b.n	84c32 <_ZN3ard6RgbLed6outputEb+0x172>
	case eRgb::YELLOW:
	  digitalWrite (m_r, LOW);
   84b72:	687b      	ldr	r3, [r7, #4]
   84b74:	685b      	ldr	r3, [r3, #4]
   84b76:	2100      	movs	r1, #0
   84b78:	4618      	mov	r0, r3
   84b7a:	4b30      	ldr	r3, [pc, #192]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b7c:	4798      	blx	r3
	  digitalWrite (m_g, LOW);
   84b7e:	687b      	ldr	r3, [r7, #4]
   84b80:	689b      	ldr	r3, [r3, #8]
   84b82:	2100      	movs	r1, #0
   84b84:	4618      	mov	r0, r3
   84b86:	4b2d      	ldr	r3, [pc, #180]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b88:	4798      	blx	r3
	  digitalWrite (m_b, HIGH);
   84b8a:	687b      	ldr	r3, [r7, #4]
   84b8c:	68db      	ldr	r3, [r3, #12]
   84b8e:	2101      	movs	r1, #1
   84b90:	4618      	mov	r0, r3
   84b92:	4b2a      	ldr	r3, [pc, #168]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84b94:	4798      	blx	r3
	  break;
   84b96:	e04c      	b.n	84c32 <_ZN3ard6RgbLed6outputEb+0x172>
	case eRgb::CYAN:
	  digitalWrite (m_r, HIGH);
   84b98:	687b      	ldr	r3, [r7, #4]
   84b9a:	685b      	ldr	r3, [r3, #4]
   84b9c:	2101      	movs	r1, #1
   84b9e:	4618      	mov	r0, r3
   84ba0:	4b26      	ldr	r3, [pc, #152]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84ba2:	4798      	blx	r3
	  digitalWrite (m_g, LOW);
   84ba4:	687b      	ldr	r3, [r7, #4]
   84ba6:	689b      	ldr	r3, [r3, #8]
   84ba8:	2100      	movs	r1, #0
   84baa:	4618      	mov	r0, r3
   84bac:	4b23      	ldr	r3, [pc, #140]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84bae:	4798      	blx	r3
	  digitalWrite (m_b, LOW);
   84bb0:	687b      	ldr	r3, [r7, #4]
   84bb2:	68db      	ldr	r3, [r3, #12]
   84bb4:	2100      	movs	r1, #0
   84bb6:	4618      	mov	r0, r3
   84bb8:	4b20      	ldr	r3, [pc, #128]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84bba:	4798      	blx	r3
	  break;
   84bbc:	e039      	b.n	84c32 <_ZN3ard6RgbLed6outputEb+0x172>
	case eRgb::PURPLE:
	  digitalWrite (m_r, LOW);
   84bbe:	687b      	ldr	r3, [r7, #4]
   84bc0:	685b      	ldr	r3, [r3, #4]
   84bc2:	2100      	movs	r1, #0
   84bc4:	4618      	mov	r0, r3
   84bc6:	4b1d      	ldr	r3, [pc, #116]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84bc8:	4798      	blx	r3
	  digitalWrite (m_g, HIGH);
   84bca:	687b      	ldr	r3, [r7, #4]
   84bcc:	689b      	ldr	r3, [r3, #8]
   84bce:	2101      	movs	r1, #1
   84bd0:	4618      	mov	r0, r3
   84bd2:	4b1a      	ldr	r3, [pc, #104]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84bd4:	4798      	blx	r3
	  digitalWrite (m_b, LOW);
   84bd6:	687b      	ldr	r3, [r7, #4]
   84bd8:	68db      	ldr	r3, [r3, #12]
   84bda:	2100      	movs	r1, #0
   84bdc:	4618      	mov	r0, r3
   84bde:	4b17      	ldr	r3, [pc, #92]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84be0:	4798      	blx	r3
	  break;
   84be2:	e026      	b.n	84c32 <_ZN3ard6RgbLed6outputEb+0x172>
	case eRgb::WHITE:
	  digitalWrite (m_r, LOW);
   84be4:	687b      	ldr	r3, [r7, #4]
   84be6:	685b      	ldr	r3, [r3, #4]
   84be8:	2100      	movs	r1, #0
   84bea:	4618      	mov	r0, r3
   84bec:	4b13      	ldr	r3, [pc, #76]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84bee:	4798      	blx	r3
	  digitalWrite (m_g, LOW);
   84bf0:	687b      	ldr	r3, [r7, #4]
   84bf2:	689b      	ldr	r3, [r3, #8]
   84bf4:	2100      	movs	r1, #0
   84bf6:	4618      	mov	r0, r3
   84bf8:	4b10      	ldr	r3, [pc, #64]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84bfa:	4798      	blx	r3
	  digitalWrite (m_b, LOW);
   84bfc:	687b      	ldr	r3, [r7, #4]
   84bfe:	68db      	ldr	r3, [r3, #12]
   84c00:	2100      	movs	r1, #0
   84c02:	4618      	mov	r0, r3
   84c04:	4b0d      	ldr	r3, [pc, #52]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84c06:	4798      	blx	r3
	  break;
   84c08:	bf00      	nop
   84c0a:	e012      	b.n	84c32 <_ZN3ard6RgbLed6outputEb+0x172>
	  ;
	}
    }
  else
    {
      digitalWrite (m_r, HIGH);
   84c0c:	687b      	ldr	r3, [r7, #4]
   84c0e:	685b      	ldr	r3, [r3, #4]
   84c10:	2101      	movs	r1, #1
   84c12:	4618      	mov	r0, r3
   84c14:	4b09      	ldr	r3, [pc, #36]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84c16:	4798      	blx	r3
      digitalWrite (m_g, HIGH);
   84c18:	687b      	ldr	r3, [r7, #4]
   84c1a:	689b      	ldr	r3, [r3, #8]
   84c1c:	2101      	movs	r1, #1
   84c1e:	4618      	mov	r0, r3
   84c20:	4b06      	ldr	r3, [pc, #24]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84c22:	4798      	blx	r3
      digitalWrite (m_b, HIGH);
   84c24:	687b      	ldr	r3, [r7, #4]
   84c26:	68db      	ldr	r3, [r3, #12]
   84c28:	2101      	movs	r1, #1
   84c2a:	4618      	mov	r0, r3
   84c2c:	4b03      	ldr	r3, [pc, #12]	; (84c3c <_ZN3ard6RgbLed6outputEb+0x17c>)
   84c2e:	4798      	blx	r3
    }
}
   84c30:	e7ff      	b.n	84c32 <_ZN3ard6RgbLed6outputEb+0x172>
   84c32:	bf00      	nop
   84c34:	3708      	adds	r7, #8
   84c36:	46bd      	mov	sp, r7
   84c38:	bd80      	pop	{r7, pc}
   84c3a:	bf00      	nop
   84c3c:	00081f29 	.word	0x00081f29

00084c40 <_ZN3ard3LedC1Eib>:

//---------------------------------------------------------------------------

Led::Led (int pin, bool inverted) :
   84c40:	b480      	push	{r7}
   84c42:	b085      	sub	sp, #20
   84c44:	af00      	add	r7, sp, #0
   84c46:	60f8      	str	r0, [r7, #12]
   84c48:	60b9      	str	r1, [r7, #8]
   84c4a:	4613      	mov	r3, r2
   84c4c:	71fb      	strb	r3, [r7, #7]
    m_blink (eLedState::OFF), m_pin (pin), m_inverted(inverted), lastState(0U), m_on(false)
   84c4e:	68fb      	ldr	r3, [r7, #12]
   84c50:	2200      	movs	r2, #0
   84c52:	701a      	strb	r2, [r3, #0]
   84c54:	68fb      	ldr	r3, [r7, #12]
   84c56:	68ba      	ldr	r2, [r7, #8]
   84c58:	605a      	str	r2, [r3, #4]
   84c5a:	68fb      	ldr	r3, [r7, #12]
   84c5c:	79fa      	ldrb	r2, [r7, #7]
   84c5e:	721a      	strb	r2, [r3, #8]
   84c60:	68fb      	ldr	r3, [r7, #12]
   84c62:	2200      	movs	r2, #0
   84c64:	725a      	strb	r2, [r3, #9]
   84c66:	68fb      	ldr	r3, [r7, #12]
   84c68:	2200      	movs	r2, #0
   84c6a:	729a      	strb	r2, [r3, #10]
{
}
   84c6c:	68fb      	ldr	r3, [r7, #12]
   84c6e:	4618      	mov	r0, r3
   84c70:	3714      	adds	r7, #20
   84c72:	46bd      	mov	sp, r7
   84c74:	bc80      	pop	{r7}
   84c76:	4770      	bx	lr

00084c78 <_ZN3ard3Led2onEv>:

void
Led::on ()
{
   84c78:	b480      	push	{r7}
   84c7a:	b083      	sub	sp, #12
   84c7c:	af00      	add	r7, sp, #0
   84c7e:	6078      	str	r0, [r7, #4]
  m_blink = eLedState::ON;
   84c80:	687b      	ldr	r3, [r7, #4]
   84c82:	2201      	movs	r2, #1
   84c84:	701a      	strb	r2, [r3, #0]
}
   84c86:	bf00      	nop
   84c88:	370c      	adds	r7, #12
   84c8a:	46bd      	mov	sp, r7
   84c8c:	bc80      	pop	{r7}
   84c8e:	4770      	bx	lr

00084c90 <_ZN3ard3Led9slowBlinkEv>:

void
Led::slowBlink ()
{
   84c90:	b480      	push	{r7}
   84c92:	b083      	sub	sp, #12
   84c94:	af00      	add	r7, sp, #0
   84c96:	6078      	str	r0, [r7, #4]
  m_blink = eLedState::SLOW_BLINK;
   84c98:	687b      	ldr	r3, [r7, #4]
   84c9a:	2202      	movs	r2, #2
   84c9c:	701a      	strb	r2, [r3, #0]
}
   84c9e:	bf00      	nop
   84ca0:	370c      	adds	r7, #12
   84ca2:	46bd      	mov	sp, r7
   84ca4:	bc80      	pop	{r7}
   84ca6:	4770      	bx	lr

00084ca8 <_ZN3ard3Led3offEv>:
  m_blink = eLedState::FAST_BLINK;
}

void
Led::off ()
{
   84ca8:	b480      	push	{r7}
   84caa:	b083      	sub	sp, #12
   84cac:	af00      	add	r7, sp, #0
   84cae:	6078      	str	r0, [r7, #4]
  m_blink = eLedState::OFF;
   84cb0:	687b      	ldr	r3, [r7, #4]
   84cb2:	2200      	movs	r2, #0
   84cb4:	701a      	strb	r2, [r3, #0]
}
   84cb6:	bf00      	nop
   84cb8:	370c      	adds	r7, #12
   84cba:	46bd      	mov	sp, r7
   84cbc:	bc80      	pop	{r7}
   84cbe:	4770      	bx	lr

00084cc0 <_ZN3ard3Led3runEv>:


void
Led::run ()
{
   84cc0:	b580      	push	{r7, lr}
   84cc2:	b082      	sub	sp, #8
   84cc4:	af00      	add	r7, sp, #0
   84cc6:	6078      	str	r0, [r7, #4]
  if ((lastState % 3 == 0 && m_blink == eLedState::FAST_BLINK)
   84cc8:	687b      	ldr	r3, [r7, #4]
   84cca:	7a5a      	ldrb	r2, [r3, #9]
   84ccc:	4b2c      	ldr	r3, [pc, #176]	; (84d80 <_ZN3ard3Led3runEv+0xc0>)
   84cce:	fba3 1302 	umull	r1, r3, r3, r2
   84cd2:	0859      	lsrs	r1, r3, #1
   84cd4:	460b      	mov	r3, r1
   84cd6:	005b      	lsls	r3, r3, #1
   84cd8:	440b      	add	r3, r1
   84cda:	1ad3      	subs	r3, r2, r3
   84cdc:	b2db      	uxtb	r3, r3
   84cde:	2b00      	cmp	r3, #0
   84ce0:	d103      	bne.n	84cea <_ZN3ard3Led3runEv+0x2a>
   84ce2:	687b      	ldr	r3, [r7, #4]
   84ce4:	781b      	ldrb	r3, [r3, #0]
   84ce6:	2b03      	cmp	r3, #3
   84ce8:	d010      	beq.n	84d0c <_ZN3ard3Led3runEv+0x4c>
	  || (lastState % 15 == 0 && m_blink == eLedState::SLOW_BLINK))
   84cea:	687b      	ldr	r3, [r7, #4]
   84cec:	7a5a      	ldrb	r2, [r3, #9]
   84cee:	4b25      	ldr	r3, [pc, #148]	; (84d84 <_ZN3ard3Led3runEv+0xc4>)
   84cf0:	fba3 1302 	umull	r1, r3, r3, r2
   84cf4:	08d9      	lsrs	r1, r3, #3
   84cf6:	460b      	mov	r3, r1
   84cf8:	011b      	lsls	r3, r3, #4
   84cfa:	1a5b      	subs	r3, r3, r1
   84cfc:	1ad3      	subs	r3, r2, r3
   84cfe:	b2db      	uxtb	r3, r3
   84d00:	2b00      	cmp	r3, #0
   84d02:	d10b      	bne.n	84d1c <_ZN3ard3Led3runEv+0x5c>
   84d04:	687b      	ldr	r3, [r7, #4]
   84d06:	781b      	ldrb	r3, [r3, #0]
   84d08:	2b02      	cmp	r3, #2
   84d0a:	d107      	bne.n	84d1c <_ZN3ard3Led3runEv+0x5c>
    m_on = !m_on;
   84d0c:	687b      	ldr	r3, [r7, #4]
   84d0e:	7a9b      	ldrb	r3, [r3, #10]
   84d10:	f083 0301 	eor.w	r3, r3, #1
   84d14:	b2da      	uxtb	r2, r3
   84d16:	687b      	ldr	r3, [r7, #4]
   84d18:	729a      	strb	r2, [r3, #10]
   84d1a:	e00e      	b.n	84d3a <_ZN3ard3Led3runEv+0x7a>
  else if (m_blink == eLedState::ON)
   84d1c:	687b      	ldr	r3, [r7, #4]
   84d1e:	781b      	ldrb	r3, [r3, #0]
   84d20:	2b01      	cmp	r3, #1
   84d22:	d103      	bne.n	84d2c <_ZN3ard3Led3runEv+0x6c>
    m_on = true;
   84d24:	687b      	ldr	r3, [r7, #4]
   84d26:	2201      	movs	r2, #1
   84d28:	729a      	strb	r2, [r3, #10]
   84d2a:	e006      	b.n	84d3a <_ZN3ard3Led3runEv+0x7a>
  else if (m_blink == eLedState::OFF)
   84d2c:	687b      	ldr	r3, [r7, #4]
   84d2e:	781b      	ldrb	r3, [r3, #0]
   84d30:	2b00      	cmp	r3, #0
   84d32:	d102      	bne.n	84d3a <_ZN3ard3Led3runEv+0x7a>
    m_on = false;
   84d34:	687b      	ldr	r3, [r7, #4]
   84d36:	2200      	movs	r2, #0
   84d38:	729a      	strb	r2, [r3, #10]

  if(m_inverted)
   84d3a:	687b      	ldr	r3, [r7, #4]
   84d3c:	7a1b      	ldrb	r3, [r3, #8]
   84d3e:	2b00      	cmp	r3, #0
   84d40:	d00b      	beq.n	84d5a <_ZN3ard3Led3runEv+0x9a>
	digitalWrite(m_pin , 1 - m_on);
   84d42:	687b      	ldr	r3, [r7, #4]
   84d44:	685b      	ldr	r3, [r3, #4]
   84d46:	461a      	mov	r2, r3
   84d48:	687b      	ldr	r3, [r7, #4]
   84d4a:	7a9b      	ldrb	r3, [r3, #10]
   84d4c:	f1c3 0301 	rsb	r3, r3, #1
   84d50:	4619      	mov	r1, r3
   84d52:	4610      	mov	r0, r2
   84d54:	4b0c      	ldr	r3, [pc, #48]	; (84d88 <_ZN3ard3Led3runEv+0xc8>)
   84d56:	4798      	blx	r3
   84d58:	e008      	b.n	84d6c <_ZN3ard3Led3runEv+0xac>
  else
	digitalWrite(m_pin, m_on);
   84d5a:	687b      	ldr	r3, [r7, #4]
   84d5c:	685b      	ldr	r3, [r3, #4]
   84d5e:	461a      	mov	r2, r3
   84d60:	687b      	ldr	r3, [r7, #4]
   84d62:	7a9b      	ldrb	r3, [r3, #10]
   84d64:	4619      	mov	r1, r3
   84d66:	4610      	mov	r0, r2
   84d68:	4b07      	ldr	r3, [pc, #28]	; (84d88 <_ZN3ard3Led3runEv+0xc8>)
   84d6a:	4798      	blx	r3
  lastState++;
   84d6c:	687b      	ldr	r3, [r7, #4]
   84d6e:	7a5b      	ldrb	r3, [r3, #9]
   84d70:	3301      	adds	r3, #1
   84d72:	b2da      	uxtb	r2, r3
   84d74:	687b      	ldr	r3, [r7, #4]
   84d76:	725a      	strb	r2, [r3, #9]
}
   84d78:	bf00      	nop
   84d7a:	3708      	adds	r7, #8
   84d7c:	46bd      	mov	sp, r7
   84d7e:	bd80      	pop	{r7, pc}
   84d80:	aaaaaaab 	.word	0xaaaaaaab
   84d84:	88888889 	.word	0x88888889
   84d88:	00081f29 	.word	0x00081f29

00084d8c <_ZN3ard7IThreadC1Ev>:
  typedef uint32_t DelayMs;

  /**
   * Use this interface to declare you are a thread class
   */
  class IThread
   84d8c:	b480      	push	{r7}
   84d8e:	b083      	sub	sp, #12
   84d90:	af00      	add	r7, sp, #0
   84d92:	6078      	str	r0, [r7, #4]
   84d94:	4a04      	ldr	r2, [pc, #16]	; (84da8 <_ZN3ard7IThreadC1Ev+0x1c>)
   84d96:	687b      	ldr	r3, [r7, #4]
   84d98:	601a      	str	r2, [r3, #0]
   84d9a:	687b      	ldr	r3, [r7, #4]
   84d9c:	4618      	mov	r0, r3
   84d9e:	370c      	adds	r7, #12
   84da0:	46bd      	mov	sp, r7
   84da2:	bc80      	pop	{r7}
   84da4:	4770      	bx	lr
   84da6:	bf00      	nop
   84da8:	0009a5c4 	.word	0x0009a5c4

00084dac <_ZN3ard9HmiThreadC1Et>:

/*--------------------------------------------------------------------- */
/*   HMI                                                                */
/*--------------------------------------------------------------------- */

HmiThread::HmiThread(uint16_t period):
   84dac:	b590      	push	{r4, r7, lr}
   84dae:	b083      	sub	sp, #12
   84db0:	af00      	add	r7, sp, #0
   84db2:	6078      	str	r0, [r7, #4]
   84db4:	460b      	mov	r3, r1
   84db6:	807b      	strh	r3, [r7, #2]
    ledDue_L(LED_DUE_L),
    start(BUTTON_START, HMI_DEBOUNCE, HMI_DEBOUNCE),
    matchColor(BUTTON_COLOR, HMI_DEBOUNCE, HMI_DEBOUNCE),
    user1(BUTTON_USER1, HMI_DEBOUNCE, HMI_DEBOUNCE),
    user2(BUTTON_USER2, HMI_DEBOUNCE, HMI_DEBOUNCE),
    m_period(period)
   84db8:	687b      	ldr	r3, [r7, #4]
   84dba:	4618      	mov	r0, r3
   84dbc:	4b32      	ldr	r3, [pc, #200]	; (84e88 <_ZN3ard9HmiThreadC1Et+0xdc>)
   84dbe:	4798      	blx	r3
   84dc0:	4a32      	ldr	r2, [pc, #200]	; (84e8c <_ZN3ard9HmiThreadC1Et+0xe0>)
   84dc2:	687b      	ldr	r3, [r7, #4]
   84dc4:	601a      	str	r2, [r3, #0]
   84dc6:	687b      	ldr	r3, [r7, #4]
   84dc8:	1d18      	adds	r0, r3, #4
   84dca:	2335      	movs	r3, #53	; 0x35
   84dcc:	2234      	movs	r2, #52	; 0x34
   84dce:	2133      	movs	r1, #51	; 0x33
   84dd0:	4c2f      	ldr	r4, [pc, #188]	; (84e90 <_ZN3ard9HmiThreadC1Et+0xe4>)
   84dd2:	47a0      	blx	r4
   84dd4:	687b      	ldr	r3, [r7, #4]
   84dd6:	3318      	adds	r3, #24
   84dd8:	2200      	movs	r2, #0
   84dda:	212f      	movs	r1, #47	; 0x2f
   84ddc:	4618      	mov	r0, r3
   84dde:	4b2d      	ldr	r3, [pc, #180]	; (84e94 <_ZN3ard9HmiThreadC1Et+0xe8>)
   84de0:	4798      	blx	r3
   84de2:	687b      	ldr	r3, [r7, #4]
   84de4:	3324      	adds	r3, #36	; 0x24
   84de6:	2200      	movs	r2, #0
   84de8:	2130      	movs	r1, #48	; 0x30
   84dea:	4618      	mov	r0, r3
   84dec:	4b29      	ldr	r3, [pc, #164]	; (84e94 <_ZN3ard9HmiThreadC1Et+0xe8>)
   84dee:	4798      	blx	r3
   84df0:	687b      	ldr	r3, [r7, #4]
   84df2:	3330      	adds	r3, #48	; 0x30
   84df4:	2200      	movs	r2, #0
   84df6:	2131      	movs	r1, #49	; 0x31
   84df8:	4618      	mov	r0, r3
   84dfa:	4b26      	ldr	r3, [pc, #152]	; (84e94 <_ZN3ard9HmiThreadC1Et+0xe8>)
   84dfc:	4798      	blx	r3
   84dfe:	687b      	ldr	r3, [r7, #4]
   84e00:	333c      	adds	r3, #60	; 0x3c
   84e02:	2200      	movs	r2, #0
   84e04:	2132      	movs	r1, #50	; 0x32
   84e06:	4618      	mov	r0, r3
   84e08:	4b22      	ldr	r3, [pc, #136]	; (84e94 <_ZN3ard9HmiThreadC1Et+0xe8>)
   84e0a:	4798      	blx	r3
   84e0c:	687b      	ldr	r3, [r7, #4]
   84e0e:	3348      	adds	r3, #72	; 0x48
   84e10:	2201      	movs	r2, #1
   84e12:	2148      	movs	r1, #72	; 0x48
   84e14:	4618      	mov	r0, r3
   84e16:	4b1f      	ldr	r3, [pc, #124]	; (84e94 <_ZN3ard9HmiThreadC1Et+0xe8>)
   84e18:	4798      	blx	r3
   84e1a:	687b      	ldr	r3, [r7, #4]
   84e1c:	3354      	adds	r3, #84	; 0x54
   84e1e:	2201      	movs	r2, #1
   84e20:	2149      	movs	r1, #73	; 0x49
   84e22:	4618      	mov	r0, r3
   84e24:	4b1b      	ldr	r3, [pc, #108]	; (84e94 <_ZN3ard9HmiThreadC1Et+0xe8>)
   84e26:	4798      	blx	r3
   84e28:	687b      	ldr	r3, [r7, #4]
   84e2a:	3360      	adds	r3, #96	; 0x60
   84e2c:	2200      	movs	r2, #0
   84e2e:	210d      	movs	r1, #13
   84e30:	4618      	mov	r0, r3
   84e32:	4b18      	ldr	r3, [pc, #96]	; (84e94 <_ZN3ard9HmiThreadC1Et+0xe8>)
   84e34:	4798      	blx	r3
   84e36:	687b      	ldr	r3, [r7, #4]
   84e38:	f103 006c 	add.w	r0, r3, #108	; 0x6c
   84e3c:	2332      	movs	r3, #50	; 0x32
   84e3e:	2232      	movs	r2, #50	; 0x32
   84e40:	2116      	movs	r1, #22
   84e42:	4c15      	ldr	r4, [pc, #84]	; (84e98 <_ZN3ard9HmiThreadC1Et+0xec>)
   84e44:	47a0      	blx	r4
   84e46:	687b      	ldr	r3, [r7, #4]
   84e48:	f103 008c 	add.w	r0, r3, #140	; 0x8c
   84e4c:	2332      	movs	r3, #50	; 0x32
   84e4e:	2232      	movs	r2, #50	; 0x32
   84e50:	2117      	movs	r1, #23
   84e52:	4c11      	ldr	r4, [pc, #68]	; (84e98 <_ZN3ard9HmiThreadC1Et+0xec>)
   84e54:	47a0      	blx	r4
   84e56:	687b      	ldr	r3, [r7, #4]
   84e58:	f103 00ac 	add.w	r0, r3, #172	; 0xac
   84e5c:	2332      	movs	r3, #50	; 0x32
   84e5e:	2232      	movs	r2, #50	; 0x32
   84e60:	2118      	movs	r1, #24
   84e62:	4c0d      	ldr	r4, [pc, #52]	; (84e98 <_ZN3ard9HmiThreadC1Et+0xec>)
   84e64:	47a0      	blx	r4
   84e66:	687b      	ldr	r3, [r7, #4]
   84e68:	f103 00cc 	add.w	r0, r3, #204	; 0xcc
   84e6c:	2332      	movs	r3, #50	; 0x32
   84e6e:	2232      	movs	r2, #50	; 0x32
   84e70:	2119      	movs	r1, #25
   84e72:	4c09      	ldr	r4, [pc, #36]	; (84e98 <_ZN3ard9HmiThreadC1Et+0xec>)
   84e74:	47a0      	blx	r4
   84e76:	687b      	ldr	r3, [r7, #4]
   84e78:	887a      	ldrh	r2, [r7, #2]
   84e7a:	f8a3 20ec 	strh.w	r2, [r3, #236]	; 0xec
{

}
   84e7e:	687b      	ldr	r3, [r7, #4]
   84e80:	4618      	mov	r0, r3
   84e82:	370c      	adds	r7, #12
   84e84:	46bd      	mov	sp, r7
   84e86:	bd90      	pop	{r4, r7, pc}
   84e88:	00084d8d 	.word	0x00084d8d
   84e8c:	0009a5ac 	.word	0x0009a5ac
   84e90:	000849bd 	.word	0x000849bd
   84e94:	00084c41 	.word	0x00084c41
   84e98:	000846ed 	.word	0x000846ed

00084e9c <_ZN3ard9HmiThread4initEv>:

void
HmiThread::init()
{
   84e9c:	b590      	push	{r4, r7, lr}
   84e9e:	b085      	sub	sp, #20
   84ea0:	af02      	add	r7, sp, #8
   84ea2:	6078      	str	r0, [r7, #4]
  //create the thread
  g_ArdOs.createPeriodicThread_Cpp("HMI", *this, STACK_HMI, PRIO_HMI, PERIOD_HMI);
   84ea4:	4b07      	ldr	r3, [pc, #28]	; (84ec4 <_ZN3ard9HmiThread4initEv+0x28>)
   84ea6:	4798      	blx	r3
   84ea8:	687a      	ldr	r2, [r7, #4]
   84eaa:	2332      	movs	r3, #50	; 0x32
   84eac:	9301      	str	r3, [sp, #4]
   84eae:	2303      	movs	r3, #3
   84eb0:	9300      	str	r3, [sp, #0]
   84eb2:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   84eb6:	4904      	ldr	r1, [pc, #16]	; (84ec8 <_ZN3ard9HmiThread4initEv+0x2c>)
   84eb8:	4c04      	ldr	r4, [pc, #16]	; (84ecc <_ZN3ard9HmiThread4initEv+0x30>)
   84eba:	47a0      	blx	r4
}
   84ebc:	bf00      	nop
   84ebe:	370c      	adds	r7, #12
   84ec0:	46bd      	mov	sp, r7
   84ec2:	bd90      	pop	{r4, r7, pc}
   84ec4:	00082fad 	.word	0x00082fad
   84ec8:	0009a5a0 	.word	0x0009a5a0
   84ecc:	000838d9 	.word	0x000838d9

00084ed0 <_ZN3ard9HmiThread3runEv>:

void
HmiThread::run()
{
   84ed0:	b580      	push	{r7, lr}
   84ed2:	b082      	sub	sp, #8
   84ed4:	af00      	add	r7, sp, #0
   84ed6:	6078      	str	r0, [r7, #4]
    ledRGB.run();
   84ed8:	687b      	ldr	r3, [r7, #4]
   84eda:	3304      	adds	r3, #4
   84edc:	4618      	mov	r0, r3
   84ede:	4b14      	ldr	r3, [pc, #80]	; (84f30 <_ZN3ard9HmiThread3runEv+0x60>)
   84ee0:	4798      	blx	r3
    led1.run();
   84ee2:	687b      	ldr	r3, [r7, #4]
   84ee4:	3318      	adds	r3, #24
   84ee6:	4618      	mov	r0, r3
   84ee8:	4b12      	ldr	r3, [pc, #72]	; (84f34 <_ZN3ard9HmiThread3runEv+0x64>)
   84eea:	4798      	blx	r3
    led2.run();
   84eec:	687b      	ldr	r3, [r7, #4]
   84eee:	3324      	adds	r3, #36	; 0x24
   84ef0:	4618      	mov	r0, r3
   84ef2:	4b10      	ldr	r3, [pc, #64]	; (84f34 <_ZN3ard9HmiThread3runEv+0x64>)
   84ef4:	4798      	blx	r3
    led3.run();
   84ef6:	687b      	ldr	r3, [r7, #4]
   84ef8:	3330      	adds	r3, #48	; 0x30
   84efa:	4618      	mov	r0, r3
   84efc:	4b0d      	ldr	r3, [pc, #52]	; (84f34 <_ZN3ard9HmiThread3runEv+0x64>)
   84efe:	4798      	blx	r3
    led4.run();
   84f00:	687b      	ldr	r3, [r7, #4]
   84f02:	333c      	adds	r3, #60	; 0x3c
   84f04:	4618      	mov	r0, r3
   84f06:	4b0b      	ldr	r3, [pc, #44]	; (84f34 <_ZN3ard9HmiThread3runEv+0x64>)
   84f08:	4798      	blx	r3
    ledDue_Rx.run();
   84f0a:	687b      	ldr	r3, [r7, #4]
   84f0c:	3348      	adds	r3, #72	; 0x48
   84f0e:	4618      	mov	r0, r3
   84f10:	4b08      	ldr	r3, [pc, #32]	; (84f34 <_ZN3ard9HmiThread3runEv+0x64>)
   84f12:	4798      	blx	r3
    ledDue_Tx.run();
   84f14:	687b      	ldr	r3, [r7, #4]
   84f16:	3354      	adds	r3, #84	; 0x54
   84f18:	4618      	mov	r0, r3
   84f1a:	4b06      	ldr	r3, [pc, #24]	; (84f34 <_ZN3ard9HmiThread3runEv+0x64>)
   84f1c:	4798      	blx	r3
    ledDue_L.run();
   84f1e:	687b      	ldr	r3, [r7, #4]
   84f20:	3360      	adds	r3, #96	; 0x60
   84f22:	4618      	mov	r0, r3
   84f24:	4b03      	ldr	r3, [pc, #12]	; (84f34 <_ZN3ard9HmiThread3runEv+0x64>)
   84f26:	4798      	blx	r3
}
   84f28:	bf00      	nop
   84f2a:	3708      	adds	r7, #8
   84f2c:	46bd      	mov	sp, r7
   84f2e:	bd80      	pop	{r7, pc}
   84f30:	00084a29 	.word	0x00084a29
   84f34:	00084cc1 	.word	0x00084cc1

00084f38 <_ZN3ard9HmiThreadD1Ev>:
   * writing non const getters. It's also a thread so that HMI can still
   * be reactive if the robot is bullshitting (you should set a quite high priority)
   *
   * The ledDue_L should not be used, the OS is using it to display errors
   */
  class HmiThread: public IThread
   84f38:	b580      	push	{r7, lr}
   84f3a:	b082      	sub	sp, #8
   84f3c:	af00      	add	r7, sp, #0
   84f3e:	6078      	str	r0, [r7, #4]
   84f40:	4a08      	ldr	r2, [pc, #32]	; (84f64 <_ZN3ard9HmiThreadD1Ev+0x2c>)
   84f42:	687b      	ldr	r3, [r7, #4]
   84f44:	601a      	str	r2, [r3, #0]
   84f46:	687b      	ldr	r3, [r7, #4]
   84f48:	4618      	mov	r0, r3
   84f4a:	4b07      	ldr	r3, [pc, #28]	; (84f68 <_ZN3ard9HmiThreadD1Ev+0x30>)
   84f4c:	4798      	blx	r3
   84f4e:	2300      	movs	r3, #0
   84f50:	2b00      	cmp	r3, #0
   84f52:	d002      	beq.n	84f5a <_ZN3ard9HmiThreadD1Ev+0x22>
   84f54:	6878      	ldr	r0, [r7, #4]
   84f56:	4b05      	ldr	r3, [pc, #20]	; (84f6c <_ZN3ard9HmiThreadD1Ev+0x34>)
   84f58:	4798      	blx	r3
   84f5a:	687b      	ldr	r3, [r7, #4]
   84f5c:	4618      	mov	r0, r3
   84f5e:	3708      	adds	r7, #8
   84f60:	46bd      	mov	sp, r7
   84f62:	bd80      	pop	{r7, pc}
   84f64:	0009a5ac 	.word	0x0009a5ac
   84f68:	00084969 	.word	0x00084969
   84f6c:	0008788d 	.word	0x0008788d

00084f70 <_ZN3ard9HmiThreadD0Ev>:
   84f70:	b580      	push	{r7, lr}
   84f72:	b082      	sub	sp, #8
   84f74:	af00      	add	r7, sp, #0
   84f76:	6078      	str	r0, [r7, #4]
   84f78:	6878      	ldr	r0, [r7, #4]
   84f7a:	4b05      	ldr	r3, [pc, #20]	; (84f90 <_ZN3ard9HmiThreadD0Ev+0x20>)
   84f7c:	4798      	blx	r3
   84f7e:	6878      	ldr	r0, [r7, #4]
   84f80:	4b04      	ldr	r3, [pc, #16]	; (84f94 <_ZN3ard9HmiThreadD0Ev+0x24>)
   84f82:	4798      	blx	r3
   84f84:	687b      	ldr	r3, [r7, #4]
   84f86:	4618      	mov	r0, r3
   84f88:	3708      	adds	r7, #8
   84f8a:	46bd      	mov	sp, r7
   84f8c:	bd80      	pop	{r7, pc}
   84f8e:	bf00      	nop
   84f90:	00084f39 	.word	0x00084f39
   84f94:	0008788d 	.word	0x0008788d

00084f98 <_ZN3ard7ILoggerD1Ev>:
   * Functionnal interface to ease unit tests
   */
  class ILogger
  {
  public:
    virtual ~ILogger(){};
   84f98:	b580      	push	{r7, lr}
   84f9a:	b082      	sub	sp, #8
   84f9c:	af00      	add	r7, sp, #0
   84f9e:	6078      	str	r0, [r7, #4]
   84fa0:	4a06      	ldr	r2, [pc, #24]	; (84fbc <_ZN3ard7ILoggerD1Ev+0x24>)
   84fa2:	687b      	ldr	r3, [r7, #4]
   84fa4:	601a      	str	r2, [r3, #0]
   84fa6:	2300      	movs	r3, #0
   84fa8:	2b00      	cmp	r3, #0
   84faa:	d002      	beq.n	84fb2 <_ZN3ard7ILoggerD1Ev+0x1a>
   84fac:	6878      	ldr	r0, [r7, #4]
   84fae:	4b04      	ldr	r3, [pc, #16]	; (84fc0 <_ZN3ard7ILoggerD1Ev+0x28>)
   84fb0:	4798      	blx	r3
   84fb2:	687b      	ldr	r3, [r7, #4]
   84fb4:	4618      	mov	r0, r3
   84fb6:	3708      	adds	r7, #8
   84fb8:	46bd      	mov	sp, r7
   84fba:	bd80      	pop	{r7, pc}
   84fbc:	0009a790 	.word	0x0009a790
   84fc0:	0008788d 	.word	0x0008788d

00084fc4 <_ZN3ard7ILoggerD0Ev>:
   84fc4:	b580      	push	{r7, lr}
   84fc6:	b082      	sub	sp, #8
   84fc8:	af00      	add	r7, sp, #0
   84fca:	6078      	str	r0, [r7, #4]
   84fcc:	6878      	ldr	r0, [r7, #4]
   84fce:	4b05      	ldr	r3, [pc, #20]	; (84fe4 <_ZN3ard7ILoggerD0Ev+0x20>)
   84fd0:	4798      	blx	r3
   84fd2:	6878      	ldr	r0, [r7, #4]
   84fd4:	4b04      	ldr	r3, [pc, #16]	; (84fe8 <_ZN3ard7ILoggerD0Ev+0x24>)
   84fd6:	4798      	blx	r3
   84fd8:	687b      	ldr	r3, [r7, #4]
   84fda:	4618      	mov	r0, r3
   84fdc:	3708      	adds	r7, #8
   84fde:	46bd      	mov	sp, r7
   84fe0:	bd80      	pop	{r7, pc}
   84fe2:	bf00      	nop
   84fe4:	00084f99 	.word	0x00084f99
   84fe8:	0008788d 	.word	0x0008788d

00084fec <_ZN3ard9LogThread6LogMsgD1Ev>:
    //configure if logs are sent to the serial bus (activated by default)
    bool configSdCardLog;

  private:
    //fifo item
    struct LogMsg
   84fec:	b580      	push	{r7, lr}
   84fee:	b082      	sub	sp, #8
   84ff0:	af00      	add	r7, sp, #0
   84ff2:	6078      	str	r0, [r7, #4]
   84ff4:	687b      	ldr	r3, [r7, #4]
   84ff6:	3308      	adds	r3, #8
   84ff8:	4618      	mov	r0, r3
   84ffa:	4b03      	ldr	r3, [pc, #12]	; (85008 <_ZN3ard9LogThread6LogMsgD1Ev+0x1c>)
   84ffc:	4798      	blx	r3
   84ffe:	687b      	ldr	r3, [r7, #4]
   85000:	4618      	mov	r0, r3
   85002:	3708      	adds	r7, #8
   85004:	46bd      	mov	sp, r7
   85006:	bd80      	pop	{r7, pc}
   85008:	00089145 	.word	0x00089145

0008500c <_ZN3ard9LogThreadD1Ev>:
   */
  class LogThread : public IThread, public ILogger
  {
  public:
    virtual
    ~LogThread ()
   8500c:	b590      	push	{r4, r7, lr}
   8500e:	b083      	sub	sp, #12
   85010:	af00      	add	r7, sp, #0
   85012:	6078      	str	r0, [r7, #4]
    {
   85014:	4a15      	ldr	r2, [pc, #84]	; (8506c <_ZN3ard9LogThreadD1Ev+0x60>)
   85016:	687b      	ldr	r3, [r7, #4]
   85018:	601a      	str	r2, [r3, #0]
   8501a:	4a15      	ldr	r2, [pc, #84]	; (85070 <_ZN3ard9LogThreadD1Ev+0x64>)
   8501c:	687b      	ldr	r3, [r7, #4]
   8501e:	605a      	str	r2, [r3, #4]
   85020:	687b      	ldr	r3, [r7, #4]
   85022:	3314      	adds	r3, #20
   85024:	2b00      	cmp	r3, #0
   85026:	d00c      	beq.n	85042 <_ZN3ard9LogThreadD1Ev+0x36>
   85028:	687b      	ldr	r3, [r7, #4]
   8502a:	3314      	adds	r3, #20
   8502c:	f503 74c8 	add.w	r4, r3, #400	; 0x190
   85030:	687b      	ldr	r3, [r7, #4]
   85032:	3314      	adds	r3, #20
   85034:	429c      	cmp	r4, r3
   85036:	d004      	beq.n	85042 <_ZN3ard9LogThreadD1Ev+0x36>
   85038:	3c14      	subs	r4, #20
   8503a:	4620      	mov	r0, r4
   8503c:	4b0d      	ldr	r3, [pc, #52]	; (85074 <_ZN3ard9LogThreadD1Ev+0x68>)
   8503e:	4798      	blx	r3
   85040:	e7f6      	b.n	85030 <_ZN3ard9LogThreadD1Ev+0x24>
   85042:	687b      	ldr	r3, [r7, #4]
   85044:	3304      	adds	r3, #4
   85046:	4618      	mov	r0, r3
   85048:	4b0b      	ldr	r3, [pc, #44]	; (85078 <_ZN3ard9LogThreadD1Ev+0x6c>)
   8504a:	4798      	blx	r3
   8504c:	687b      	ldr	r3, [r7, #4]
   8504e:	4618      	mov	r0, r3
   85050:	4b0a      	ldr	r3, [pc, #40]	; (8507c <_ZN3ard9LogThreadD1Ev+0x70>)
   85052:	4798      	blx	r3
    }
   85054:	2300      	movs	r3, #0
   85056:	2b00      	cmp	r3, #0
   85058:	d002      	beq.n	85060 <_ZN3ard9LogThreadD1Ev+0x54>
   8505a:	6878      	ldr	r0, [r7, #4]
   8505c:	4b08      	ldr	r3, [pc, #32]	; (85080 <_ZN3ard9LogThreadD1Ev+0x74>)
   8505e:	4798      	blx	r3
   85060:	687b      	ldr	r3, [r7, #4]
   85062:	4618      	mov	r0, r3
   85064:	370c      	adds	r7, #12
   85066:	46bd      	mov	sp, r7
   85068:	bd90      	pop	{r4, r7, pc}
   8506a:	bf00      	nop
   8506c:	0009a760 	.word	0x0009a760
   85070:	0009a77c 	.word	0x0009a77c
   85074:	00084fed 	.word	0x00084fed
   85078:	00084f99 	.word	0x00084f99
   8507c:	00084969 	.word	0x00084969
   85080:	0008788d 	.word	0x0008788d

00085084 <_ZThn4_N3ard9LogThreadD1Ev>:
   */
  class LogThread : public IThread, public ILogger
  {
  public:
    virtual
    ~LogThread ()
   85084:	f1a0 0004 	sub.w	r0, r0, #4
   85088:	e7c0      	b.n	8500c <_ZN3ard9LogThreadD1Ev>
   8508a:	bf00      	nop

0008508c <_ZN3ard9LogThreadD0Ev>:
   8508c:	b580      	push	{r7, lr}
   8508e:	b082      	sub	sp, #8
   85090:	af00      	add	r7, sp, #0
   85092:	6078      	str	r0, [r7, #4]
    {
    }
   85094:	6878      	ldr	r0, [r7, #4]
   85096:	4b05      	ldr	r3, [pc, #20]	; (850ac <_ZN3ard9LogThreadD0Ev+0x20>)
   85098:	4798      	blx	r3
   8509a:	6878      	ldr	r0, [r7, #4]
   8509c:	4b04      	ldr	r3, [pc, #16]	; (850b0 <_ZN3ard9LogThreadD0Ev+0x24>)
   8509e:	4798      	blx	r3
   850a0:	687b      	ldr	r3, [r7, #4]
   850a2:	4618      	mov	r0, r3
   850a4:	3708      	adds	r7, #8
   850a6:	46bd      	mov	sp, r7
   850a8:	bd80      	pop	{r7, pc}
   850aa:	bf00      	nop
   850ac:	0008500d 	.word	0x0008500d
   850b0:	0008788d 	.word	0x0008788d

000850b4 <_ZThn4_N3ard9LogThreadD0Ev>:
   */
  class LogThread : public IThread, public ILogger
  {
  public:
    virtual
    ~LogThread ()
   850b4:	f1a0 0004 	sub.w	r0, r0, #4
   850b8:	e7e8      	b.n	8508c <_ZN3ard9LogThreadD0Ev>
   850ba:	bf00      	nop

000850bc <_ZN3ard7ILoggerC1Ev>:
  } eLogLevel;

  /**
   * Functionnal interface to ease unit tests
   */
  class ILogger
   850bc:	b480      	push	{r7}
   850be:	b083      	sub	sp, #12
   850c0:	af00      	add	r7, sp, #0
   850c2:	6078      	str	r0, [r7, #4]
   850c4:	4a04      	ldr	r2, [pc, #16]	; (850d8 <_ZN3ard7ILoggerC1Ev+0x1c>)
   850c6:	687b      	ldr	r3, [r7, #4]
   850c8:	601a      	str	r2, [r3, #0]
   850ca:	687b      	ldr	r3, [r7, #4]
   850cc:	4618      	mov	r0, r3
   850ce:	370c      	adds	r7, #12
   850d0:	46bd      	mov	sp, r7
   850d2:	bc80      	pop	{r7}
   850d4:	4770      	bx	lr
   850d6:	bf00      	nop
   850d8:	0009a790 	.word	0x0009a790

000850dc <_ZN3ard9LogThread6LogMsgC1Ev>:
    //configure if logs are sent to the serial bus (activated by default)
    bool configSdCardLog;

  private:
    //fifo item
    struct LogMsg
   850dc:	b580      	push	{r7, lr}
   850de:	b082      	sub	sp, #8
   850e0:	af00      	add	r7, sp, #0
   850e2:	6078      	str	r0, [r7, #4]
   850e4:	687b      	ldr	r3, [r7, #4]
   850e6:	3308      	adds	r3, #8
   850e8:	4904      	ldr	r1, [pc, #16]	; (850fc <_ZN3ard9LogThread6LogMsgC1Ev+0x20>)
   850ea:	4618      	mov	r0, r3
   850ec:	4b04      	ldr	r3, [pc, #16]	; (85100 <_ZN3ard9LogThread6LogMsgC1Ev+0x24>)
   850ee:	4798      	blx	r3
   850f0:	687b      	ldr	r3, [r7, #4]
   850f2:	4618      	mov	r0, r3
   850f4:	3708      	adds	r7, #8
   850f6:	46bd      	mov	sp, r7
   850f8:	bd80      	pop	{r7, pc}
   850fa:	bf00      	nop
   850fc:	0009a5d4 	.word	0x0009a5d4
   85100:	00089009 	.word	0x00089009

00085104 <_ZN3ard9LogThreadC1Ev>:
using namespace ard;

//singleton instanciation
LogThread LogThread::instance = LogThread ();

LogThread::LogThread () :
   85104:	b5b0      	push	{r4, r5, r7, lr}
   85106:	b082      	sub	sp, #8
   85108:	af00      	add	r7, sp, #0
   8510a:	6078      	str	r0, [r7, #4]
    configSerialLog (true), configSdCardLog (false), semDataPresent (NULL), mutex (
    NULL), fifoHead (0), fifoTail (0), fifoCount (0), missedLogs (0), sdCardPresent (
    false)
   8510c:	687b      	ldr	r3, [r7, #4]
   8510e:	4618      	mov	r0, r3
   85110:	4b26      	ldr	r3, [pc, #152]	; (851ac <_ZN3ard9LogThreadC1Ev+0xa8>)
   85112:	4798      	blx	r3
   85114:	687b      	ldr	r3, [r7, #4]
   85116:	3304      	adds	r3, #4
   85118:	4618      	mov	r0, r3
   8511a:	4b25      	ldr	r3, [pc, #148]	; (851b0 <_ZN3ard9LogThreadC1Ev+0xac>)
   8511c:	4798      	blx	r3
   8511e:	4a25      	ldr	r2, [pc, #148]	; (851b4 <_ZN3ard9LogThreadC1Ev+0xb0>)
   85120:	687b      	ldr	r3, [r7, #4]
   85122:	601a      	str	r2, [r3, #0]
   85124:	4a24      	ldr	r2, [pc, #144]	; (851b8 <_ZN3ard9LogThreadC1Ev+0xb4>)
   85126:	687b      	ldr	r3, [r7, #4]
   85128:	605a      	str	r2, [r3, #4]
   8512a:	687b      	ldr	r3, [r7, #4]
   8512c:	2201      	movs	r2, #1
   8512e:	721a      	strb	r2, [r3, #8]
   85130:	687b      	ldr	r3, [r7, #4]
   85132:	2200      	movs	r2, #0
   85134:	725a      	strb	r2, [r3, #9]
   85136:	687b      	ldr	r3, [r7, #4]
   85138:	2200      	movs	r2, #0
   8513a:	60da      	str	r2, [r3, #12]
   8513c:	687b      	ldr	r3, [r7, #4]
   8513e:	2200      	movs	r2, #0
   85140:	611a      	str	r2, [r3, #16]
   85142:	687b      	ldr	r3, [r7, #4]
   85144:	3314      	adds	r3, #20
   85146:	2413      	movs	r4, #19
   85148:	461d      	mov	r5, r3
   8514a:	f1b4 3fff 	cmp.w	r4, #4294967295
   8514e:	d005      	beq.n	8515c <_ZN3ard9LogThreadC1Ev+0x58>
   85150:	4628      	mov	r0, r5
   85152:	4b1a      	ldr	r3, [pc, #104]	; (851bc <_ZN3ard9LogThreadC1Ev+0xb8>)
   85154:	4798      	blx	r3
   85156:	3514      	adds	r5, #20
   85158:	3c01      	subs	r4, #1
   8515a:	e7f6      	b.n	8514a <_ZN3ard9LogThreadC1Ev+0x46>
   8515c:	687b      	ldr	r3, [r7, #4]
   8515e:	2200      	movs	r2, #0
   85160:	f8a3 21a4 	strh.w	r2, [r3, #420]	; 0x1a4
   85164:	687b      	ldr	r3, [r7, #4]
   85166:	2200      	movs	r2, #0
   85168:	f8a3 21a6 	strh.w	r2, [r3, #422]	; 0x1a6
   8516c:	687b      	ldr	r3, [r7, #4]
   8516e:	2200      	movs	r2, #0
   85170:	f8a3 21a8 	strh.w	r2, [r3, #424]	; 0x1a8
   85174:	687b      	ldr	r3, [r7, #4]
   85176:	2200      	movs	r2, #0
   85178:	f883 21aa 	strb.w	r2, [r3, #426]	; 0x1aa
   8517c:	687b      	ldr	r3, [r7, #4]
   8517e:	2200      	movs	r2, #0
   85180:	f883 21ab 	strb.w	r2, [r3, #427]	; 0x1ab
   85184:	687b      	ldr	r3, [r7, #4]
   85186:	f503 73d6 	add.w	r3, r3, #428	; 0x1ac
   8518a:	4618      	mov	r0, r3
   8518c:	4b0c      	ldr	r3, [pc, #48]	; (851c0 <_ZN3ard9LogThreadC1Ev+0xbc>)
   8518e:	4798      	blx	r3
{
  INIT_TABLE_TO_ZERO(fifoArray);
   85190:	687b      	ldr	r3, [r7, #4]
   85192:	3314      	adds	r3, #20
   85194:	f44f 72c8 	mov.w	r2, #400	; 0x190
   85198:	2100      	movs	r1, #0
   8519a:	4618      	mov	r0, r3
   8519c:	4b09      	ldr	r3, [pc, #36]	; (851c4 <_ZN3ard9LogThreadC1Ev+0xc0>)
   8519e:	4798      	blx	r3
}
   851a0:	687b      	ldr	r3, [r7, #4]
   851a2:	4618      	mov	r0, r3
   851a4:	3708      	adds	r7, #8
   851a6:	46bd      	mov	sp, r7
   851a8:	bdb0      	pop	{r4, r5, r7, pc}
   851aa:	bf00      	nop
   851ac:	00084d8d 	.word	0x00084d8d
   851b0:	000850bd 	.word	0x000850bd
   851b4:	0009a760 	.word	0x0009a760
   851b8:	0009a77c 	.word	0x0009a77c
   851bc:	000850dd 	.word	0x000850dd
   851c0:	0008a48d 	.word	0x0008a48d
   851c4:	00093cc5 	.word	0x00093cc5

000851c8 <_ZN3ard9LogThread4initEv>:

void
LogThread::init ()
{
   851c8:	b590      	push	{r4, r7, lr}
   851ca:	b085      	sub	sp, #20
   851cc:	af02      	add	r7, sp, #8
   851ce:	6078      	str	r0, [r7, #4]
  //create the thread
  g_ArdOs.createThread_Cpp("Log", *this, STACK_LOG, PRIO_LOG);
   851d0:	4b14      	ldr	r3, [pc, #80]	; (85224 <_ZN3ard9LogThread4initEv+0x5c>)
   851d2:	4798      	blx	r3
   851d4:	687a      	ldr	r2, [r7, #4]
   851d6:	2302      	movs	r3, #2
   851d8:	9300      	str	r3, [sp, #0]
   851da:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   851de:	4912      	ldr	r1, [pc, #72]	; (85228 <_ZN3ard9LogThread4initEv+0x60>)
   851e0:	4c12      	ldr	r4, [pc, #72]	; (8522c <_ZN3ard9LogThread4initEv+0x64>)
   851e2:	47a0      	blx	r4

  // initialize fifoData semaphore to no data available
  semDataPresent = g_ArdOs.Semaphore_create(FIFO_SIZE, 0);
   851e4:	4b0f      	ldr	r3, [pc, #60]	; (85224 <_ZN3ard9LogThread4initEv+0x5c>)
   851e6:	4798      	blx	r3
   851e8:	4603      	mov	r3, r0
   851ea:	2200      	movs	r2, #0
   851ec:	2114      	movs	r1, #20
   851ee:	4618      	mov	r0, r3
   851f0:	4b0f      	ldr	r3, [pc, #60]	; (85230 <_ZN3ard9LogThread4initEv+0x68>)
   851f2:	4798      	blx	r3
   851f4:	4602      	mov	r2, r0
   851f6:	687b      	ldr	r3, [r7, #4]
   851f8:	60da      	str	r2, [r3, #12]

  //create the mutex
  mutex = g_ArdOs.Mutex_create();
   851fa:	4b0a      	ldr	r3, [pc, #40]	; (85224 <_ZN3ard9LogThread4initEv+0x5c>)
   851fc:	4798      	blx	r3
   851fe:	4603      	mov	r3, r0
   85200:	4618      	mov	r0, r3
   85202:	4b0c      	ldr	r3, [pc, #48]	; (85234 <_ZN3ard9LogThread4initEv+0x6c>)
   85204:	4798      	blx	r3
   85206:	4602      	mov	r2, r0
   85208:	687b      	ldr	r3, [r7, #4]
   8520a:	611a      	str	r2, [r3, #16]

  if( configSdCardLog )
   8520c:	687b      	ldr	r3, [r7, #4]
   8520e:	7a5b      	ldrb	r3, [r3, #9]
   85210:	2b00      	cmp	r3, #0
   85212:	d002      	beq.n	8521a <_ZN3ard9LogThread4initEv+0x52>
    {
      //setup the SDcard driver and open the log file
      initSDcard ();
   85214:	6878      	ldr	r0, [r7, #4]
   85216:	4b08      	ldr	r3, [pc, #32]	; (85238 <_ZN3ard9LogThread4initEv+0x70>)
   85218:	4798      	blx	r3
    }
}
   8521a:	bf00      	nop
   8521c:	370c      	adds	r7, #12
   8521e:	46bd      	mov	sp, r7
   85220:	bd90      	pop	{r4, r7, pc}
   85222:	bf00      	nop
   85224:	00082fad 	.word	0x00082fad
   85228:	0009a5d8 	.word	0x0009a5d8
   8522c:	000838a9 	.word	0x000838a9
   85230:	000841f9 	.word	0x000841f9
   85234:	00083f21 	.word	0x00083f21
   85238:	0008523d 	.word	0x0008523d

0008523c <_ZN3ard9LogThread10initSDcardEv>:

void
LogThread::initSDcard ()
{
   8523c:	b590      	push	{r4, r7, lr}
   8523e:	b08d      	sub	sp, #52	; 0x34
   85240:	af00      	add	r7, sp, #0
   85242:	6078      	str	r0, [r7, #4]
  g_ArdOs.dprintln ("[LogThread] Initializing SD card...");
   85244:	4b27      	ldr	r3, [pc, #156]	; (852e4 <_ZN3ard9LogThread10initSDcardEv+0xa8>)
   85246:	4798      	blx	r3
   85248:	4604      	mov	r4, r0
   8524a:	f107 030c 	add.w	r3, r7, #12
   8524e:	4926      	ldr	r1, [pc, #152]	; (852e8 <_ZN3ard9LogThread10initSDcardEv+0xac>)
   85250:	4618      	mov	r0, r3
   85252:	4b26      	ldr	r3, [pc, #152]	; (852ec <_ZN3ard9LogThread10initSDcardEv+0xb0>)
   85254:	4798      	blx	r3
   85256:	f107 030c 	add.w	r3, r7, #12
   8525a:	4619      	mov	r1, r3
   8525c:	4620      	mov	r0, r4
   8525e:	4b24      	ldr	r3, [pc, #144]	; (852f0 <_ZN3ard9LogThread10initSDcardEv+0xb4>)
   85260:	4798      	blx	r3
   85262:	f107 030c 	add.w	r3, r7, #12
   85266:	4618      	mov	r0, r3
   85268:	4b22      	ldr	r3, [pc, #136]	; (852f4 <_ZN3ard9LogThread10initSDcardEv+0xb8>)
   8526a:	4798      	blx	r3
  // see if the card is present and can be initialized:
  if (!SD.begin (CS_SDCARD))
   8526c:	2120      	movs	r1, #32
   8526e:	4822      	ldr	r0, [pc, #136]	; (852f8 <_ZN3ard9LogThread10initSDcardEv+0xbc>)
   85270:	4b22      	ldr	r3, [pc, #136]	; (852fc <_ZN3ard9LogThread10initSDcardEv+0xc0>)
   85272:	4798      	blx	r3
   85274:	4603      	mov	r3, r0
   85276:	f083 0301 	eor.w	r3, r3, #1
   8527a:	b2db      	uxtb	r3, r3
   8527c:	2b00      	cmp	r3, #0
   8527e:	d014      	beq.n	852aa <_ZN3ard9LogThread10initSDcardEv+0x6e>
    {
      g_ArdOs.dprintln (
   85280:	4b18      	ldr	r3, [pc, #96]	; (852e4 <_ZN3ard9LogThread10initSDcardEv+0xa8>)
   85282:	4798      	blx	r3
   85284:	4604      	mov	r4, r0
   85286:	f107 0318 	add.w	r3, r7, #24
   8528a:	491d      	ldr	r1, [pc, #116]	; (85300 <_ZN3ard9LogThread10initSDcardEv+0xc4>)
   8528c:	4618      	mov	r0, r3
   8528e:	4b17      	ldr	r3, [pc, #92]	; (852ec <_ZN3ard9LogThread10initSDcardEv+0xb0>)
   85290:	4798      	blx	r3
	  "[LogThread] SD card init FAILED, or not present, log persistency disabled.");
   85292:	f107 0318 	add.w	r3, r7, #24
   85296:	4619      	mov	r1, r3
   85298:	4620      	mov	r0, r4
   8529a:	4b15      	ldr	r3, [pc, #84]	; (852f0 <_ZN3ard9LogThread10initSDcardEv+0xb4>)
   8529c:	4798      	blx	r3
{
  g_ArdOs.dprintln ("[LogThread] Initializing SD card...");
  // see if the card is present and can be initialized:
  if (!SD.begin (CS_SDCARD))
    {
      g_ArdOs.dprintln (
   8529e:	f107 0318 	add.w	r3, r7, #24
   852a2:	4618      	mov	r0, r3
   852a4:	4b13      	ldr	r3, [pc, #76]	; (852f4 <_ZN3ard9LogThread10initSDcardEv+0xb8>)
   852a6:	4798      	blx	r3
  else
    {
      sdCardPresent = true;
      g_ArdOs.dprintln ("[LogThread] SD card init SUCCESS.");
    }
}
   852a8:	e017      	b.n	852da <_ZN3ard9LogThread10initSDcardEv+0x9e>
      g_ArdOs.dprintln (
	  "[LogThread] SD card init FAILED, or not present, log persistency disabled.");
    }
  else
    {
      sdCardPresent = true;
   852aa:	687b      	ldr	r3, [r7, #4]
   852ac:	2201      	movs	r2, #1
   852ae:	f883 21ab 	strb.w	r2, [r3, #427]	; 0x1ab
      g_ArdOs.dprintln ("[LogThread] SD card init SUCCESS.");
   852b2:	4b0c      	ldr	r3, [pc, #48]	; (852e4 <_ZN3ard9LogThread10initSDcardEv+0xa8>)
   852b4:	4798      	blx	r3
   852b6:	4604      	mov	r4, r0
   852b8:	f107 0324 	add.w	r3, r7, #36	; 0x24
   852bc:	4911      	ldr	r1, [pc, #68]	; (85304 <_ZN3ard9LogThread10initSDcardEv+0xc8>)
   852be:	4618      	mov	r0, r3
   852c0:	4b0a      	ldr	r3, [pc, #40]	; (852ec <_ZN3ard9LogThread10initSDcardEv+0xb0>)
   852c2:	4798      	blx	r3
   852c4:	f107 0324 	add.w	r3, r7, #36	; 0x24
   852c8:	4619      	mov	r1, r3
   852ca:	4620      	mov	r0, r4
   852cc:	4b08      	ldr	r3, [pc, #32]	; (852f0 <_ZN3ard9LogThread10initSDcardEv+0xb4>)
   852ce:	4798      	blx	r3
   852d0:	f107 0324 	add.w	r3, r7, #36	; 0x24
   852d4:	4618      	mov	r0, r3
   852d6:	4b07      	ldr	r3, [pc, #28]	; (852f4 <_ZN3ard9LogThread10initSDcardEv+0xb8>)
   852d8:	4798      	blx	r3
    }
}
   852da:	bf00      	nop
   852dc:	3734      	adds	r7, #52	; 0x34
   852de:	46bd      	mov	sp, r7
   852e0:	bd90      	pop	{r4, r7, pc}
   852e2:	bf00      	nop
   852e4:	00082fad 	.word	0x00082fad
   852e8:	0009a5dc 	.word	0x0009a5dc
   852ec:	00089009 	.word	0x00089009
   852f0:	00083845 	.word	0x00083845
   852f4:	00089145 	.word	0x00089145
   852f8:	200718a8 	.word	0x200718a8
   852fc:	0008a889 	.word	0x0008a889
   85300:	0009a600 	.word	0x0009a600
   85304:	0009a64c 	.word	0x0009a64c

00085308 <_ZN3ard9LogThread3runEv>:

void
LogThread::run ()
{
   85308:	b590      	push	{r4, r7, lr}
   8530a:	b087      	sub	sp, #28
   8530c:	af00      	add	r7, sp, #0
   8530e:	6078      	str	r0, [r7, #4]
#ifdef ARD_DEBUG
  g_ArdOs.dprintln (" --- DEBUG --- (see ARD_DEBUG in ArdOs.h) ");
   85310:	4b15      	ldr	r3, [pc, #84]	; (85368 <_ZN3ard9LogThread3runEv+0x60>)
   85312:	4798      	blx	r3
   85314:	4604      	mov	r4, r0
   85316:	f107 030c 	add.w	r3, r7, #12
   8531a:	4914      	ldr	r1, [pc, #80]	; (8536c <_ZN3ard9LogThread3runEv+0x64>)
   8531c:	4618      	mov	r0, r3
   8531e:	4b14      	ldr	r3, [pc, #80]	; (85370 <_ZN3ard9LogThread3runEv+0x68>)
   85320:	4798      	blx	r3
   85322:	f107 030c 	add.w	r3, r7, #12
   85326:	4619      	mov	r1, r3
   85328:	4620      	mov	r0, r4
   8532a:	4b12      	ldr	r3, [pc, #72]	; (85374 <_ZN3ard9LogThread3runEv+0x6c>)
   8532c:	4798      	blx	r3
   8532e:	f107 030c 	add.w	r3, r7, #12
   85332:	4618      	mov	r0, r3
   85334:	4b10      	ldr	r3, [pc, #64]	; (85378 <_ZN3ard9LogThread3runEv+0x70>)
   85336:	4798      	blx	r3
#endif

  while (1)
    {
      //If the logger is disabled, wait until it is enable again
      if (!configSerialLog && !configSerialLog)
   85338:	687b      	ldr	r3, [r7, #4]
   8533a:	7a1b      	ldrb	r3, [r3, #8]
   8533c:	f083 0301 	eor.w	r3, r3, #1
   85340:	b2db      	uxtb	r3, r3
   85342:	2b00      	cmp	r3, #0
   85344:	d00b      	beq.n	8535e <_ZN3ard9LogThread3runEv+0x56>
   85346:	687b      	ldr	r3, [r7, #4]
   85348:	7a1b      	ldrb	r3, [r3, #8]
   8534a:	f083 0301 	eor.w	r3, r3, #1
   8534e:	b2db      	uxtb	r3, r3
   85350:	2b00      	cmp	r3, #0
   85352:	d004      	beq.n	8535e <_ZN3ard9LogThread3runEv+0x56>
	{
	  vTaskDelay (1000);
   85354:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   85358:	4b08      	ldr	r3, [pc, #32]	; (8537c <_ZN3ard9LogThread3runEv+0x74>)
   8535a:	4798      	blx	r3
   8535c:	e002      	b.n	85364 <_ZN3ard9LogThread3runEv+0x5c>
	}
      //Else take the next item in the fifo (or wait until one is here)
      else
	{
	  unpileFifo ();
   8535e:	6878      	ldr	r0, [r7, #4]
   85360:	4b07      	ldr	r3, [pc, #28]	; (85380 <_ZN3ard9LogThread3runEv+0x78>)
   85362:	4798      	blx	r3
  g_ArdOs.dprintln (" --- DEBUG --- (see ARD_DEBUG in ArdOs.h) ");
#else
  g_ArdOs.dprintln ("Tips : In order to see debug logs, define ARD_DEBUG in ArdOs.h.");
#endif

  while (1)
   85364:	e7e8      	b.n	85338 <_ZN3ard9LogThread3runEv+0x30>
   85366:	bf00      	nop
   85368:	00082fad 	.word	0x00082fad
   8536c:	0009a670 	.word	0x0009a670
   85370:	00089009 	.word	0x00089009
   85374:	00083845 	.word	0x00083845
   85378:	00089145 	.word	0x00089145
   8537c:	0008df01 	.word	0x0008df01
   85380:	00085541 	.word	0x00085541

00085384 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String>:
    }
}

void
LogThread::log (eLogLevel logLevel, String const& log)
{
   85384:	b580      	push	{r7, lr}
   85386:	b086      	sub	sp, #24
   85388:	af00      	add	r7, sp, #0
   8538a:	60f8      	str	r0, [r7, #12]
   8538c:	460b      	mov	r3, r1
   8538e:	607a      	str	r2, [r7, #4]
   85390:	72fb      	strb	r3, [r7, #11]
  if(logLevel == DEBUG)
  return;
#endif

  //take the time of log before any action
  TimeMs now = millis ();
   85392:	4b3b      	ldr	r3, [pc, #236]	; (85480 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0xfc>)
   85394:	4798      	blx	r3
   85396:	6178      	str	r0, [r7, #20]

  g_ArdOs.Mutex_lock(mutex);
   85398:	4b3a      	ldr	r3, [pc, #232]	; (85484 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0x100>)
   8539a:	4798      	blx	r3
   8539c:	4602      	mov	r2, r0
   8539e:	68fb      	ldr	r3, [r7, #12]
   853a0:	691b      	ldr	r3, [r3, #16]
   853a2:	4619      	mov	r1, r3
   853a4:	4610      	mov	r0, r2
   853a6:	4b38      	ldr	r3, [pc, #224]	; (85488 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0x104>)
   853a8:	4798      	blx	r3

  // get a buffer in the fifo to fill the message
  if (fifoCount == FIFO_SIZE)
   853aa:	68fb      	ldr	r3, [r7, #12]
   853ac:	f8b3 31a8 	ldrh.w	r3, [r3, #424]	; 0x1a8
   853b0:	2b14      	cmp	r3, #20
   853b2:	d10d      	bne.n	853d0 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0x4c>
    {
      // fifo full - indicate missed point (unless there already many missed logs)
      if (missedLogs < 255)
   853b4:	68fb      	ldr	r3, [r7, #12]
   853b6:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
   853ba:	2bff      	cmp	r3, #255	; 0xff
   853bc:	d05c      	beq.n	85478 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0xf4>
	missedLogs++;
   853be:	68fb      	ldr	r3, [r7, #12]
   853c0:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
   853c4:	3301      	adds	r3, #1
   853c6:	b2da      	uxtb	r2, r3
   853c8:	68fb      	ldr	r3, [r7, #12]
   853ca:	f883 21aa 	strb.w	r2, [r3, #426]	; 0x1aa
      return;
   853ce:	e053      	b.n	85478 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0xf4>
    }

  // fill the buffer
  fifoArray[fifoHead].date = now;
   853d0:	68fb      	ldr	r3, [r7, #12]
   853d2:	f8b3 31a4 	ldrh.w	r3, [r3, #420]	; 0x1a4
   853d6:	4619      	mov	r1, r3
   853d8:	68fa      	ldr	r2, [r7, #12]
   853da:	460b      	mov	r3, r1
   853dc:	009b      	lsls	r3, r3, #2
   853de:	440b      	add	r3, r1
   853e0:	009b      	lsls	r3, r3, #2
   853e2:	4413      	add	r3, r2
   853e4:	3314      	adds	r3, #20
   853e6:	697a      	ldr	r2, [r7, #20]
   853e8:	601a      	str	r2, [r3, #0]
  fifoArray[fifoHead].level = logLevel;
   853ea:	68fb      	ldr	r3, [r7, #12]
   853ec:	f8b3 31a4 	ldrh.w	r3, [r3, #420]	; 0x1a4
   853f0:	4619      	mov	r1, r3
   853f2:	68fa      	ldr	r2, [r7, #12]
   853f4:	460b      	mov	r3, r1
   853f6:	009b      	lsls	r3, r3, #2
   853f8:	440b      	add	r3, r1
   853fa:	009b      	lsls	r3, r3, #2
   853fc:	4413      	add	r3, r2
   853fe:	3318      	adds	r3, #24
   85400:	7afa      	ldrb	r2, [r7, #11]
   85402:	701a      	strb	r2, [r3, #0]
  fifoArray[fifoHead].text = log;
   85404:	68fb      	ldr	r3, [r7, #12]
   85406:	f8b3 31a4 	ldrh.w	r3, [r3, #420]	; 0x1a4
   8540a:	461a      	mov	r2, r3
   8540c:	4613      	mov	r3, r2
   8540e:	009b      	lsls	r3, r3, #2
   85410:	4413      	add	r3, r2
   85412:	009b      	lsls	r3, r3, #2
   85414:	3318      	adds	r3, #24
   85416:	68fa      	ldr	r2, [r7, #12]
   85418:	4413      	add	r3, r2
   8541a:	3304      	adds	r3, #4
   8541c:	6879      	ldr	r1, [r7, #4]
   8541e:	4618      	mov	r0, r3
   85420:	4b1a      	ldr	r3, [pc, #104]	; (8548c <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0x108>)
   85422:	4798      	blx	r3
  ++fifoCount;
   85424:	68fb      	ldr	r3, [r7, #12]
   85426:	f8b3 31a8 	ldrh.w	r3, [r3, #424]	; 0x1a8
   8542a:	3301      	adds	r3, #1
   8542c:	b29a      	uxth	r2, r3
   8542e:	68fb      	ldr	r3, [r7, #12]
   85430:	f8a3 21a8 	strh.w	r2, [r3, #424]	; 0x1a8

  // advance FIFO index
  fifoHead = fifoHead < (FIFO_SIZE - 1) ? fifoHead + 1 : 0;
   85434:	68fb      	ldr	r3, [r7, #12]
   85436:	f8b3 31a4 	ldrh.w	r3, [r3, #420]	; 0x1a4
   8543a:	2b12      	cmp	r3, #18
   8543c:	d805      	bhi.n	8544a <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0xc6>
   8543e:	68fb      	ldr	r3, [r7, #12]
   85440:	f8b3 31a4 	ldrh.w	r3, [r3, #420]	; 0x1a4
   85444:	3301      	adds	r3, #1
   85446:	b29a      	uxth	r2, r3
   85448:	e000      	b.n	8544c <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0xc8>
   8544a:	2200      	movs	r2, #0
   8544c:	68fb      	ldr	r3, [r7, #12]
   8544e:	f8a3 21a4 	strh.w	r2, [r3, #420]	; 0x1a4

  // signal a new data is in the fifo
  g_ArdOs.Semaphore_give(semDataPresent);
   85452:	4b0c      	ldr	r3, [pc, #48]	; (85484 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0x100>)
   85454:	4798      	blx	r3
   85456:	4602      	mov	r2, r0
   85458:	68fb      	ldr	r3, [r7, #12]
   8545a:	68db      	ldr	r3, [r3, #12]
   8545c:	4619      	mov	r1, r3
   8545e:	4610      	mov	r0, r2
   85460:	4b0b      	ldr	r3, [pc, #44]	; (85490 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0x10c>)
   85462:	4798      	blx	r3

  g_ArdOs.Mutex_unlock(mutex);
   85464:	4b07      	ldr	r3, [pc, #28]	; (85484 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0x100>)
   85466:	4798      	blx	r3
   85468:	4602      	mov	r2, r0
   8546a:	68fb      	ldr	r3, [r7, #12]
   8546c:	691b      	ldr	r3, [r3, #16]
   8546e:	4619      	mov	r1, r3
   85470:	4610      	mov	r0, r2
   85472:	4b08      	ldr	r3, [pc, #32]	; (85494 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0x110>)
   85474:	4798      	blx	r3
   85476:	e000      	b.n	8547a <_ZN3ard9LogThread3logENS_9eLogLevelERK6String+0xf6>
  if (fifoCount == FIFO_SIZE)
    {
      // fifo full - indicate missed point (unless there already many missed logs)
      if (missedLogs < 255)
	missedLogs++;
      return;
   85478:	bf00      	nop

  // signal a new data is in the fifo
  g_ArdOs.Semaphore_give(semDataPresent);

  g_ArdOs.Mutex_unlock(mutex);
}
   8547a:	3718      	adds	r7, #24
   8547c:	46bd      	mov	sp, r7
   8547e:	bd80      	pop	{r7, pc}
   85480:	00081bb1 	.word	0x00081bb1
   85484:	00082fad 	.word	0x00082fad
   85488:	00084069 	.word	0x00084069
   8548c:	000892b9 	.word	0x000892b9
   85490:	00084349 	.word	0x00084349
   85494:	00084131 	.word	0x00084131

00085498 <_ZThn4_N3ard9LogThread3logENS_9eLogLevelERK6String>:
    void
    run () override;

    //Implements ILogger
    void
    log (eLogLevel logLevel, String const& log) override;
   85498:	f1a0 0004 	sub.w	r0, r0, #4
   8549c:	f7ff bf72 	b.w	85384 <_ZN3ard9LogThread3logENS_9eLogLevelERK6String>

000854a0 <_ZN5PrintaSEOS_>:
#define DEC 10
#define HEX 16
#define OCT 8
#define BIN 2

class Print
   854a0:	b480      	push	{r7}
   854a2:	b083      	sub	sp, #12
   854a4:	af00      	add	r7, sp, #0
   854a6:	6078      	str	r0, [r7, #4]
   854a8:	6039      	str	r1, [r7, #0]
   854aa:	683b      	ldr	r3, [r7, #0]
   854ac:	685a      	ldr	r2, [r3, #4]
   854ae:	687b      	ldr	r3, [r7, #4]
   854b0:	605a      	str	r2, [r3, #4]
   854b2:	687b      	ldr	r3, [r7, #4]
   854b4:	4618      	mov	r0, r3
   854b6:	370c      	adds	r7, #12
   854b8:	46bd      	mov	sp, r7
   854ba:	bc80      	pop	{r7}
   854bc:	4770      	bx	lr
   854be:	bf00      	nop

000854c0 <_ZN6StreamaSEOS_>:
    SKIP_WHITESPACE // Only tabs, spaces, line feeds & carriage returns are skipped.
};

#define NO_IGNORE_CHAR  '\x01' // a char not found in a valid ASCII numeric field

class Stream : public Print
   854c0:	b580      	push	{r7, lr}
   854c2:	b082      	sub	sp, #8
   854c4:	af00      	add	r7, sp, #0
   854c6:	6078      	str	r0, [r7, #4]
   854c8:	6039      	str	r1, [r7, #0]
   854ca:	687b      	ldr	r3, [r7, #4]
   854cc:	683a      	ldr	r2, [r7, #0]
   854ce:	4611      	mov	r1, r2
   854d0:	4618      	mov	r0, r3
   854d2:	4b07      	ldr	r3, [pc, #28]	; (854f0 <_ZN6StreamaSEOS_+0x30>)
   854d4:	4798      	blx	r3
   854d6:	683b      	ldr	r3, [r7, #0]
   854d8:	689a      	ldr	r2, [r3, #8]
   854da:	687b      	ldr	r3, [r7, #4]
   854dc:	609a      	str	r2, [r3, #8]
   854de:	683b      	ldr	r3, [r7, #0]
   854e0:	68da      	ldr	r2, [r3, #12]
   854e2:	687b      	ldr	r3, [r7, #4]
   854e4:	60da      	str	r2, [r3, #12]
   854e6:	687b      	ldr	r3, [r7, #4]
   854e8:	4618      	mov	r0, r3
   854ea:	3708      	adds	r7, #8
   854ec:	46bd      	mov	sp, r7
   854ee:	bd80      	pop	{r7, pc}
   854f0:	000854a1 	.word	0x000854a1

000854f4 <_ZN5SDLib4FileaSEOS0_>:
#define FILE_READ O_READ
#define FILE_WRITE (O_READ | O_WRITE | O_CREAT)

namespace SDLib {

class File : public Stream {
   854f4:	b580      	push	{r7, lr}
   854f6:	b082      	sub	sp, #8
   854f8:	af00      	add	r7, sp, #0
   854fa:	6078      	str	r0, [r7, #4]
   854fc:	6039      	str	r1, [r7, #0]
   854fe:	687b      	ldr	r3, [r7, #4]
   85500:	683a      	ldr	r2, [r7, #0]
   85502:	4611      	mov	r1, r2
   85504:	4618      	mov	r0, r3
   85506:	4b0d      	ldr	r3, [pc, #52]	; (8553c <_ZN5SDLib4FileaSEOS0_+0x48>)
   85508:	4798      	blx	r3
   8550a:	687b      	ldr	r3, [r7, #4]
   8550c:	f103 0110 	add.w	r1, r3, #16
   85510:	220c      	movs	r2, #12
   85512:	683b      	ldr	r3, [r7, #0]
   85514:	3310      	adds	r3, #16
   85516:	f1b2 3fff 	cmp.w	r2, #4294967295
   8551a:	d005      	beq.n	85528 <_ZN5SDLib4FileaSEOS0_+0x34>
   8551c:	7818      	ldrb	r0, [r3, #0]
   8551e:	7008      	strb	r0, [r1, #0]
   85520:	3101      	adds	r1, #1
   85522:	3301      	adds	r3, #1
   85524:	3a01      	subs	r2, #1
   85526:	e7f6      	b.n	85516 <_ZN5SDLib4FileaSEOS0_+0x22>
   85528:	683b      	ldr	r3, [r7, #0]
   8552a:	6a1a      	ldr	r2, [r3, #32]
   8552c:	687b      	ldr	r3, [r7, #4]
   8552e:	621a      	str	r2, [r3, #32]
   85530:	687b      	ldr	r3, [r7, #4]
   85532:	4618      	mov	r0, r3
   85534:	3708      	adds	r7, #8
   85536:	46bd      	mov	sp, r7
   85538:	bd80      	pop	{r7, pc}
   8553a:	bf00      	nop
   8553c:	000854c1 	.word	0x000854c1

00085540 <_ZN3ard9LogThread10unpileFifoEv>:

void
LogThread::unpileFifo ()
{
   85540:	b5b0      	push	{r4, r5, r7, lr}
   85542:	b0a0      	sub	sp, #128	; 0x80
   85544:	af00      	add	r7, sp, #0
   85546:	6078      	str	r0, [r7, #4]
  if (missedLogs)
   85548:	687b      	ldr	r3, [r7, #4]
   8554a:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
   8554e:	2b00      	cmp	r3, #0
   85550:	d059      	beq.n	85606 <_ZN3ard9LogThread10unpileFifoEv+0xc6>
    {
      if (missedLogs == 255)
   85552:	687b      	ldr	r3, [r7, #4]
   85554:	f893 31aa 	ldrb.w	r3, [r3, #426]	; 0x1aa
   85558:	2bff      	cmp	r3, #255	; 0xff
   8555a:	d114      	bne.n	85586 <_ZN3ard9LogThread10unpileFifoEv+0x46>
	g_ArdOs.dprintln ("[FATAL] More than 255 logs have been lost.");
   8555c:	4b91      	ldr	r3, [pc, #580]	; (857a4 <_ZN3ard9LogThread10unpileFifoEv+0x264>)
   8555e:	4798      	blx	r3
   85560:	4604      	mov	r4, r0
   85562:	f107 0308 	add.w	r3, r7, #8
   85566:	4990      	ldr	r1, [pc, #576]	; (857a8 <_ZN3ard9LogThread10unpileFifoEv+0x268>)
   85568:	4618      	mov	r0, r3
   8556a:	4b90      	ldr	r3, [pc, #576]	; (857ac <_ZN3ard9LogThread10unpileFifoEv+0x26c>)
   8556c:	4798      	blx	r3
   8556e:	f107 0308 	add.w	r3, r7, #8
   85572:	4619      	mov	r1, r3
   85574:	4620      	mov	r0, r4
   85576:	4b8e      	ldr	r3, [pc, #568]	; (857b0 <_ZN3ard9LogThread10unpileFifoEv+0x270>)
   85578:	4798      	blx	r3
   8557a:	f107 0308 	add.w	r3, r7, #8
   8557e:	4618      	mov	r0, r3
   85580:	4b8c      	ldr	r3, [pc, #560]	; (857b4 <_ZN3ard9LogThread10unpileFifoEv+0x274>)
   85582:	4798      	blx	r3
   85584:	e03b      	b.n	855fe <_ZN3ard9LogThread10unpileFifoEv+0xbe>
	else
	g_ArdOs.dprintln (
   85586:	4b87      	ldr	r3, [pc, #540]	; (857a4 <_ZN3ard9LogThread10unpileFifoEv+0x264>)
   85588:	4798      	blx	r3
   8558a:	4604      	mov	r4, r0
	    String ("[FATAL] ") + missedLogs + " logs have been lost.");
   8558c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   85590:	4989      	ldr	r1, [pc, #548]	; (857b8 <_ZN3ard9LogThread10unpileFifoEv+0x278>)
   85592:	4618      	mov	r0, r3
   85594:	4b85      	ldr	r3, [pc, #532]	; (857ac <_ZN3ard9LogThread10unpileFifoEv+0x26c>)
   85596:	4798      	blx	r3
   85598:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   8559c:	f107 0320 	add.w	r3, r7, #32
   855a0:	4611      	mov	r1, r2
   855a2:	4618      	mov	r0, r3
   855a4:	4b85      	ldr	r3, [pc, #532]	; (857bc <_ZN3ard9LogThread10unpileFifoEv+0x27c>)
   855a6:	4798      	blx	r3
   855a8:	687b      	ldr	r3, [r7, #4]
   855aa:	f893 21aa 	ldrb.w	r2, [r3, #426]	; 0x1aa
   855ae:	f107 0320 	add.w	r3, r7, #32
   855b2:	4611      	mov	r1, r2
   855b4:	4618      	mov	r0, r3
   855b6:	4b82      	ldr	r3, [pc, #520]	; (857c0 <_ZN3ard9LogThread10unpileFifoEv+0x280>)
   855b8:	4798      	blx	r3
   855ba:	4603      	mov	r3, r0
   855bc:	4981      	ldr	r1, [pc, #516]	; (857c4 <_ZN3ard9LogThread10unpileFifoEv+0x284>)
   855be:	4618      	mov	r0, r3
   855c0:	4b81      	ldr	r3, [pc, #516]	; (857c8 <_ZN3ard9LogThread10unpileFifoEv+0x288>)
   855c2:	4798      	blx	r3
   855c4:	4603      	mov	r3, r0
  if (missedLogs)
    {
      if (missedLogs == 255)
	g_ArdOs.dprintln ("[FATAL] More than 255 logs have been lost.");
	else
	g_ArdOs.dprintln (
   855c6:	461a      	mov	r2, r3
   855c8:	f107 0314 	add.w	r3, r7, #20
   855cc:	4611      	mov	r1, r2
   855ce:	4618      	mov	r0, r3
   855d0:	4b7e      	ldr	r3, [pc, #504]	; (857cc <_ZN3ard9LogThread10unpileFifoEv+0x28c>)
   855d2:	4798      	blx	r3
	    String ("[FATAL] ") + missedLogs + " logs have been lost.");
   855d4:	f107 0314 	add.w	r3, r7, #20
   855d8:	4619      	mov	r1, r3
   855da:	4620      	mov	r0, r4
   855dc:	4b74      	ldr	r3, [pc, #464]	; (857b0 <_ZN3ard9LogThread10unpileFifoEv+0x270>)
   855de:	4798      	blx	r3
  if (missedLogs)
    {
      if (missedLogs == 255)
	g_ArdOs.dprintln ("[FATAL] More than 255 logs have been lost.");
	else
	g_ArdOs.dprintln (
   855e0:	f107 0314 	add.w	r3, r7, #20
   855e4:	4618      	mov	r0, r3
   855e6:	4b73      	ldr	r3, [pc, #460]	; (857b4 <_ZN3ard9LogThread10unpileFifoEv+0x274>)
   855e8:	4798      	blx	r3
	    String ("[FATAL] ") + missedLogs + " logs have been lost.");
   855ea:	f107 0320 	add.w	r3, r7, #32
   855ee:	4618      	mov	r0, r3
   855f0:	4b77      	ldr	r3, [pc, #476]	; (857d0 <_ZN3ard9LogThread10unpileFifoEv+0x290>)
   855f2:	4798      	blx	r3
   855f4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   855f8:	4618      	mov	r0, r3
   855fa:	4b6e      	ldr	r3, [pc, #440]	; (857b4 <_ZN3ard9LogThread10unpileFifoEv+0x274>)
   855fc:	4798      	blx	r3
	missedLogs = 0;
   855fe:	687b      	ldr	r3, [r7, #4]
   85600:	2200      	movs	r2, #0
   85602:	f883 21aa 	strb.w	r2, [r3, #426]	; 0x1aa
      }

    // wait for next data record
    g_ArdOs.Semaphore_take(semDataPresent);
   85606:	4b67      	ldr	r3, [pc, #412]	; (857a4 <_ZN3ard9LogThread10unpileFifoEv+0x264>)
   85608:	4798      	blx	r3
   8560a:	4602      	mov	r2, r0
   8560c:	687b      	ldr	r3, [r7, #4]
   8560e:	68db      	ldr	r3, [r3, #12]
   85610:	4619      	mov	r1, r3
   85612:	4610      	mov	r0, r2
   85614:	4b6f      	ldr	r3, [pc, #444]	; (857d4 <_ZN3ard9LogThread10unpileFifoEv+0x294>)
   85616:	4798      	blx	r3

    if (configSerialLog)
   85618:	687b      	ldr	r3, [r7, #4]
   8561a:	7a1b      	ldrb	r3, [r3, #8]
   8561c:	2b00      	cmp	r3, #0
   8561e:	d01f      	beq.n	85660 <_ZN3ard9LogThread10unpileFifoEv+0x120>
      {
	g_ArdOs.dprintln (formatLogMsg (fifoArray[fifoTail]));
   85620:	4b60      	ldr	r3, [pc, #384]	; (857a4 <_ZN3ard9LogThread10unpileFifoEv+0x264>)
   85622:	4798      	blx	r3
   85624:	4604      	mov	r4, r0
   85626:	687b      	ldr	r3, [r7, #4]
   85628:	f8b3 31a6 	ldrh.w	r3, [r3, #422]	; 0x1a6
   8562c:	461a      	mov	r2, r3
   8562e:	4613      	mov	r3, r2
   85630:	009b      	lsls	r3, r3, #2
   85632:	4413      	add	r3, r2
   85634:	009b      	lsls	r3, r3, #2
   85636:	3310      	adds	r3, #16
   85638:	687a      	ldr	r2, [r7, #4]
   8563a:	4413      	add	r3, r2
   8563c:	1d1a      	adds	r2, r3, #4
   8563e:	f107 0338 	add.w	r3, r7, #56	; 0x38
   85642:	6879      	ldr	r1, [r7, #4]
   85644:	4618      	mov	r0, r3
   85646:	4b64      	ldr	r3, [pc, #400]	; (857d8 <_ZN3ard9LogThread10unpileFifoEv+0x298>)
   85648:	4798      	blx	r3
   8564a:	f107 0338 	add.w	r3, r7, #56	; 0x38
   8564e:	4619      	mov	r1, r3
   85650:	4620      	mov	r0, r4
   85652:	4b57      	ldr	r3, [pc, #348]	; (857b0 <_ZN3ard9LogThread10unpileFifoEv+0x270>)
   85654:	4798      	blx	r3
   85656:	f107 0338 	add.w	r3, r7, #56	; 0x38
   8565a:	4618      	mov	r0, r3
   8565c:	4b55      	ldr	r3, [pc, #340]	; (857b4 <_ZN3ard9LogThread10unpileFifoEv+0x274>)
   8565e:	4798      	blx	r3
      }

    if (configSdCardLog && sdCardPresent)
   85660:	687b      	ldr	r3, [r7, #4]
   85662:	7a5b      	ldrb	r3, [r3, #9]
   85664:	2b00      	cmp	r3, #0
   85666:	d06f      	beq.n	85748 <_ZN3ard9LogThread10unpileFifoEv+0x208>
   85668:	687b      	ldr	r3, [r7, #4]
   8566a:	f893 31ab 	ldrb.w	r3, [r3, #427]	; 0x1ab
   8566e:	2b00      	cmp	r3, #0
   85670:	d06a      	beq.n	85748 <_ZN3ard9LogThread10unpileFifoEv+0x208>
      {
	//If file is not opened yet ... open it !
	if (!logFile)
   85672:	687b      	ldr	r3, [r7, #4]
   85674:	f503 73d6 	add.w	r3, r3, #428	; 0x1ac
   85678:	4618      	mov	r0, r3
   8567a:	4b58      	ldr	r3, [pc, #352]	; (857dc <_ZN3ard9LogThread10unpileFifoEv+0x29c>)
   8567c:	4798      	blx	r3
   8567e:	4603      	mov	r3, r0
   85680:	f083 0301 	eor.w	r3, r3, #1
   85684:	b2db      	uxtb	r3, r3
   85686:	2b00      	cmp	r3, #0
   85688:	d033      	beq.n	856f2 <_ZN3ard9LogThread10unpileFifoEv+0x1b2>
	  {
	    // open the file. note that only one file can be open at a time,
	    // so you have to close this one before opening another
	    // (maybe it's not true anymore in recent lib version...)
	    logFile = SD.open ("log.txt", FILE_WRITE);
   8568a:	687b      	ldr	r3, [r7, #4]
   8568c:	f503 75d6 	add.w	r5, r3, #428	; 0x1ac
   85690:	f107 0044 	add.w	r0, r7, #68	; 0x44
   85694:	2313      	movs	r3, #19
   85696:	4a52      	ldr	r2, [pc, #328]	; (857e0 <_ZN3ard9LogThread10unpileFifoEv+0x2a0>)
   85698:	4952      	ldr	r1, [pc, #328]	; (857e4 <_ZN3ard9LogThread10unpileFifoEv+0x2a4>)
   8569a:	4c53      	ldr	r4, [pc, #332]	; (857e8 <_ZN3ard9LogThread10unpileFifoEv+0x2a8>)
   8569c:	47a0      	blx	r4
   8569e:	f107 0344 	add.w	r3, r7, #68	; 0x44
   856a2:	4619      	mov	r1, r3
   856a4:	4628      	mov	r0, r5
   856a6:	4b51      	ldr	r3, [pc, #324]	; (857ec <_ZN3ard9LogThread10unpileFifoEv+0x2ac>)
   856a8:	4798      	blx	r3

	    //if the file is not opened, consider that the sdcard is not present
	    if (!logFile)
   856aa:	687b      	ldr	r3, [r7, #4]
   856ac:	f503 73d6 	add.w	r3, r3, #428	; 0x1ac
   856b0:	4618      	mov	r0, r3
   856b2:	4b4a      	ldr	r3, [pc, #296]	; (857dc <_ZN3ard9LogThread10unpileFifoEv+0x29c>)
   856b4:	4798      	blx	r3
   856b6:	4603      	mov	r3, r0
   856b8:	f083 0301 	eor.w	r3, r3, #1
   856bc:	b2db      	uxtb	r3, r3
   856be:	2b00      	cmp	r3, #0
   856c0:	d017      	beq.n	856f2 <_ZN3ard9LogThread10unpileFifoEv+0x1b2>
	      {
		g_ArdOs.dprintln (
   856c2:	4b38      	ldr	r3, [pc, #224]	; (857a4 <_ZN3ard9LogThread10unpileFifoEv+0x264>)
   856c4:	4798      	blx	r3
   856c6:	4604      	mov	r4, r0
   856c8:	f107 0368 	add.w	r3, r7, #104	; 0x68
   856cc:	4948      	ldr	r1, [pc, #288]	; (857f0 <_ZN3ard9LogThread10unpileFifoEv+0x2b0>)
   856ce:	4618      	mov	r0, r3
   856d0:	4b36      	ldr	r3, [pc, #216]	; (857ac <_ZN3ard9LogThread10unpileFifoEv+0x26c>)
   856d2:	4798      	blx	r3
		    "[FATAL] Failed to open log file, SDcard logging feature disabled.");
   856d4:	f107 0368 	add.w	r3, r7, #104	; 0x68
   856d8:	4619      	mov	r1, r3
   856da:	4620      	mov	r0, r4
   856dc:	4b34      	ldr	r3, [pc, #208]	; (857b0 <_ZN3ard9LogThread10unpileFifoEv+0x270>)
   856de:	4798      	blx	r3
	    logFile = SD.open ("log.txt", FILE_WRITE);

	    //if the file is not opened, consider that the sdcard is not present
	    if (!logFile)
	      {
		g_ArdOs.dprintln (
   856e0:	f107 0368 	add.w	r3, r7, #104	; 0x68
   856e4:	4618      	mov	r0, r3
   856e6:	4b33      	ldr	r3, [pc, #204]	; (857b4 <_ZN3ard9LogThread10unpileFifoEv+0x274>)
   856e8:	4798      	blx	r3
		    "[FATAL] Failed to open log file, SDcard logging feature disabled.");
		sdCardPresent = false;
   856ea:	687b      	ldr	r3, [r7, #4]
   856ec:	2200      	movs	r2, #0
   856ee:	f883 21ab 	strb.w	r2, [r3, #427]	; 0x1ab
	      }
	  }

	//Write to the file
	logFile.println (formatLogMsg (fifoArray[fifoTail]));
   856f2:	687b      	ldr	r3, [r7, #4]
   856f4:	f503 74d6 	add.w	r4, r3, #428	; 0x1ac
   856f8:	687b      	ldr	r3, [r7, #4]
   856fa:	f8b3 31a6 	ldrh.w	r3, [r3, #422]	; 0x1a6
   856fe:	461a      	mov	r2, r3
   85700:	4613      	mov	r3, r2
   85702:	009b      	lsls	r3, r3, #2
   85704:	4413      	add	r3, r2
   85706:	009b      	lsls	r3, r3, #2
   85708:	3310      	adds	r3, #16
   8570a:	687a      	ldr	r2, [r7, #4]
   8570c:	4413      	add	r3, r2
   8570e:	1d1a      	adds	r2, r3, #4
   85710:	f107 0374 	add.w	r3, r7, #116	; 0x74
   85714:	6879      	ldr	r1, [r7, #4]
   85716:	4618      	mov	r0, r3
   85718:	4b2f      	ldr	r3, [pc, #188]	; (857d8 <_ZN3ard9LogThread10unpileFifoEv+0x298>)
   8571a:	4798      	blx	r3
   8571c:	f107 0374 	add.w	r3, r7, #116	; 0x74
   85720:	4619      	mov	r1, r3
   85722:	4620      	mov	r0, r4
   85724:	4b33      	ldr	r3, [pc, #204]	; (857f4 <_ZN3ard9LogThread10unpileFifoEv+0x2b4>)
   85726:	4798      	blx	r3
   85728:	f107 0374 	add.w	r3, r7, #116	; 0x74
   8572c:	4618      	mov	r0, r3
   8572e:	4b21      	ldr	r3, [pc, #132]	; (857b4 <_ZN3ard9LogThread10unpileFifoEv+0x274>)
   85730:	4798      	blx	r3

	//When there is no pending log, close the file to prevent loosing data and corrupting the filesystem.
	//1 because the counter is not decremented yet
	if (fifoCount <= 1)
   85732:	687b      	ldr	r3, [r7, #4]
   85734:	f8b3 31a8 	ldrh.w	r3, [r3, #424]	; 0x1a8
   85738:	2b01      	cmp	r3, #1
   8573a:	d805      	bhi.n	85748 <_ZN3ard9LogThread10unpileFifoEv+0x208>
	  {
	    logFile.close ();
   8573c:	687b      	ldr	r3, [r7, #4]
   8573e:	f503 73d6 	add.w	r3, r3, #428	; 0x1ac
   85742:	4618      	mov	r0, r3
   85744:	4b2c      	ldr	r3, [pc, #176]	; (857f8 <_ZN3ard9LogThread10unpileFifoEv+0x2b8>)
   85746:	4798      	blx	r3
	  }
      }

    g_ArdOs.Mutex_lock(mutex);
   85748:	4b16      	ldr	r3, [pc, #88]	; (857a4 <_ZN3ard9LogThread10unpileFifoEv+0x264>)
   8574a:	4798      	blx	r3
   8574c:	4602      	mov	r2, r0
   8574e:	687b      	ldr	r3, [r7, #4]
   85750:	691b      	ldr	r3, [r3, #16]
   85752:	4619      	mov	r1, r3
   85754:	4610      	mov	r0, r2
   85756:	4b29      	ldr	r3, [pc, #164]	; (857fc <_ZN3ard9LogThread10unpileFifoEv+0x2bc>)
   85758:	4798      	blx	r3
    // release record
    --fifoCount;
   8575a:	687b      	ldr	r3, [r7, #4]
   8575c:	f8b3 31a8 	ldrh.w	r3, [r3, #424]	; 0x1a8
   85760:	3b01      	subs	r3, #1
   85762:	b29a      	uxth	r2, r3
   85764:	687b      	ldr	r3, [r7, #4]
   85766:	f8a3 21a8 	strh.w	r2, [r3, #424]	; 0x1a8
    // advance FIFO index
    fifoTail = fifoTail < (FIFO_SIZE - 1) ? fifoTail + 1 : 0;
   8576a:	687b      	ldr	r3, [r7, #4]
   8576c:	f8b3 31a6 	ldrh.w	r3, [r3, #422]	; 0x1a6
   85770:	2b12      	cmp	r3, #18
   85772:	d805      	bhi.n	85780 <_ZN3ard9LogThread10unpileFifoEv+0x240>
   85774:	687b      	ldr	r3, [r7, #4]
   85776:	f8b3 31a6 	ldrh.w	r3, [r3, #422]	; 0x1a6
   8577a:	3301      	adds	r3, #1
   8577c:	b29a      	uxth	r2, r3
   8577e:	e000      	b.n	85782 <_ZN3ard9LogThread10unpileFifoEv+0x242>
   85780:	2200      	movs	r2, #0
   85782:	687b      	ldr	r3, [r7, #4]
   85784:	f8a3 21a6 	strh.w	r2, [r3, #422]	; 0x1a6
    g_ArdOs.Mutex_unlock(mutex);
   85788:	4b06      	ldr	r3, [pc, #24]	; (857a4 <_ZN3ard9LogThread10unpileFifoEv+0x264>)
   8578a:	4798      	blx	r3
   8578c:	4602      	mov	r2, r0
   8578e:	687b      	ldr	r3, [r7, #4]
   85790:	691b      	ldr	r3, [r3, #16]
   85792:	4619      	mov	r1, r3
   85794:	4610      	mov	r0, r2
   85796:	4b1a      	ldr	r3, [pc, #104]	; (85800 <_ZN3ard9LogThread10unpileFifoEv+0x2c0>)
   85798:	4798      	blx	r3
  }
   8579a:	bf00      	nop
   8579c:	3780      	adds	r7, #128	; 0x80
   8579e:	46bd      	mov	sp, r7
   857a0:	bdb0      	pop	{r4, r5, r7, pc}
   857a2:	bf00      	nop
   857a4:	00082fad 	.word	0x00082fad
   857a8:	0009a69c 	.word	0x0009a69c
   857ac:	00089009 	.word	0x00089009
   857b0:	00083845 	.word	0x00083845
   857b4:	00089145 	.word	0x00089145
   857b8:	0009a6c8 	.word	0x0009a6c8
   857bc:	00082f89 	.word	0x00082f89
   857c0:	00089575 	.word	0x00089575
   857c4:	0009a6d4 	.word	0x0009a6d4
   857c8:	0008951d 	.word	0x0008951d
   857cc:	00089049 	.word	0x00089049
   857d0:	00082fe9 	.word	0x00082fe9
   857d4:	00084411 	.word	0x00084411
   857d8:	00085805 	.word	0x00085805
   857dc:	0008a6e9 	.word	0x0008a6e9
   857e0:	0009a6ec 	.word	0x0009a6ec
   857e4:	200718a8 	.word	0x200718a8
   857e8:	0008aac9 	.word	0x0008aac9
   857ec:	000854f5 	.word	0x000854f5
   857f0:	0009a6f4 	.word	0x0009a6f4
   857f4:	000879f9 	.word	0x000879f9
   857f8:	0008a6ad 	.word	0x0008a6ad
   857fc:	00084069 	.word	0x00084069
   85800:	00084131 	.word	0x00084131

00085804 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE>:

String
LogThread::formatLogMsg (LogMsg const& msg)
{
   85804:	b580      	push	{r7, lr}
   85806:	b08e      	sub	sp, #56	; 0x38
   85808:	af00      	add	r7, sp, #0
   8580a:	60f8      	str	r0, [r7, #12]
   8580c:	60b9      	str	r1, [r7, #8]
   8580e:	607a      	str	r2, [r7, #4]
  String level;
   85810:	f107 0314 	add.w	r3, r7, #20
   85814:	4930      	ldr	r1, [pc, #192]	; (858d8 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xd4>)
   85816:	4618      	mov	r0, r3
   85818:	4b30      	ldr	r3, [pc, #192]	; (858dc <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xd8>)
   8581a:	4798      	blx	r3
  switch (msg.level)
   8581c:	687b      	ldr	r3, [r7, #4]
   8581e:	791b      	ldrb	r3, [r3, #4]
   85820:	2b00      	cmp	r3, #0
   85822:	d002      	beq.n	8582a <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0x26>
   85824:	2b01      	cmp	r3, #1
   85826:	d007      	beq.n	85838 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0x34>
   85828:	e00d      	b.n	85846 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0x42>
    {
    case DEBUG:
      level = "DEBUG";
   8582a:	f107 0314 	add.w	r3, r7, #20
   8582e:	492c      	ldr	r1, [pc, #176]	; (858e0 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xdc>)
   85830:	4618      	mov	r0, r3
   85832:	4b2c      	ldr	r3, [pc, #176]	; (858e4 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xe0>)
   85834:	4798      	blx	r3
      break;
   85836:	e00d      	b.n	85854 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0x50>
    case INFO:
      level = "INFO";
   85838:	f107 0314 	add.w	r3, r7, #20
   8583c:	492a      	ldr	r1, [pc, #168]	; (858e8 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xe4>)
   8583e:	4618      	mov	r0, r3
   85840:	4b28      	ldr	r3, [pc, #160]	; (858e4 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xe0>)
   85842:	4798      	blx	r3
      break;
   85844:	e006      	b.n	85854 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0x50>
    default:
    case ERROR:
      level = "ERROR";
   85846:	f107 0314 	add.w	r3, r7, #20
   8584a:	4928      	ldr	r1, [pc, #160]	; (858ec <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xe8>)
   8584c:	4618      	mov	r0, r3
   8584e:	4b25      	ldr	r3, [pc, #148]	; (858e4 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xe0>)
   85850:	4798      	blx	r3
      break;
   85852:	bf00      	nop
    }

  return String (msg.date) + " [" + level + "] " + msg.text;
   85854:	687b      	ldr	r3, [r7, #4]
   85856:	6819      	ldr	r1, [r3, #0]
   85858:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   8585c:	220a      	movs	r2, #10
   8585e:	4618      	mov	r0, r3
   85860:	4b23      	ldr	r3, [pc, #140]	; (858f0 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xec>)
   85862:	4798      	blx	r3
   85864:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   85868:	f107 0320 	add.w	r3, r7, #32
   8586c:	4611      	mov	r1, r2
   8586e:	4618      	mov	r0, r3
   85870:	4b20      	ldr	r3, [pc, #128]	; (858f4 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xf0>)
   85872:	4798      	blx	r3
   85874:	f107 0320 	add.w	r3, r7, #32
   85878:	491f      	ldr	r1, [pc, #124]	; (858f8 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xf4>)
   8587a:	4618      	mov	r0, r3
   8587c:	4b1f      	ldr	r3, [pc, #124]	; (858fc <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xf8>)
   8587e:	4798      	blx	r3
   85880:	4602      	mov	r2, r0
   85882:	f107 0314 	add.w	r3, r7, #20
   85886:	4619      	mov	r1, r3
   85888:	4610      	mov	r0, r2
   8588a:	4b1d      	ldr	r3, [pc, #116]	; (85900 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xfc>)
   8588c:	4798      	blx	r3
   8588e:	4603      	mov	r3, r0
   85890:	491c      	ldr	r1, [pc, #112]	; (85904 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0x100>)
   85892:	4618      	mov	r0, r3
   85894:	4b19      	ldr	r3, [pc, #100]	; (858fc <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xf8>)
   85896:	4798      	blx	r3
   85898:	4602      	mov	r2, r0
   8589a:	687b      	ldr	r3, [r7, #4]
   8589c:	3308      	adds	r3, #8
   8589e:	4619      	mov	r1, r3
   858a0:	4610      	mov	r0, r2
   858a2:	4b17      	ldr	r3, [pc, #92]	; (85900 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0xfc>)
   858a4:	4798      	blx	r3
   858a6:	4603      	mov	r3, r0
   858a8:	4619      	mov	r1, r3
   858aa:	68f8      	ldr	r0, [r7, #12]
   858ac:	4b16      	ldr	r3, [pc, #88]	; (85908 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0x104>)
   858ae:	4798      	blx	r3
   858b0:	f107 0320 	add.w	r3, r7, #32
   858b4:	4618      	mov	r0, r3
   858b6:	4b15      	ldr	r3, [pc, #84]	; (8590c <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0x108>)
   858b8:	4798      	blx	r3
   858ba:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   858be:	4618      	mov	r0, r3
   858c0:	4b13      	ldr	r3, [pc, #76]	; (85910 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0x10c>)
   858c2:	4798      	blx	r3
  }

String
LogThread::formatLogMsg (LogMsg const& msg)
{
  String level;
   858c4:	f107 0314 	add.w	r3, r7, #20
   858c8:	4618      	mov	r0, r3
   858ca:	4b11      	ldr	r3, [pc, #68]	; (85910 <_ZN3ard9LogThread12formatLogMsgERKNS0_6LogMsgE+0x10c>)
   858cc:	4798      	blx	r3
    case ERROR:
      level = "ERROR";
      break;
    }

  return String (msg.date) + " [" + level + "] " + msg.text;
   858ce:	bf00      	nop
}
   858d0:	68f8      	ldr	r0, [r7, #12]
   858d2:	3738      	adds	r7, #56	; 0x38
   858d4:	46bd      	mov	sp, r7
   858d6:	bd80      	pop	{r7, pc}
   858d8:	0009a5d4 	.word	0x0009a5d4
   858dc:	00089009 	.word	0x00089009
   858e0:	0009a738 	.word	0x0009a738
   858e4:	00089301 	.word	0x00089301
   858e8:	0009a740 	.word	0x0009a740
   858ec:	0009a748 	.word	0x0009a748
   858f0:	00089101 	.word	0x00089101
   858f4:	00082f89 	.word	0x00082f89
   858f8:	0009a750 	.word	0x0009a750
   858fc:	0008951d 	.word	0x0008951d
   85900:	000894d5 	.word	0x000894d5
   85904:	0009a754 	.word	0x0009a754
   85908:	00089049 	.word	0x00089049
   8590c:	00082fe9 	.word	0x00082fe9
   85910:	00089145 	.word	0x00089145

00085914 <_Z41__static_initialization_and_destruction_0ii>:
   85914:	b580      	push	{r7, lr}
   85916:	b082      	sub	sp, #8
   85918:	af00      	add	r7, sp, #0
   8591a:	6078      	str	r0, [r7, #4]
   8591c:	6039      	str	r1, [r7, #0]
   8591e:	687b      	ldr	r3, [r7, #4]
   85920:	2b01      	cmp	r3, #1
   85922:	d10c      	bne.n	8593e <_Z41__static_initialization_and_destruction_0ii+0x2a>
   85924:	683b      	ldr	r3, [r7, #0]
   85926:	f64f 72ff 	movw	r2, #65535	; 0xffff
   8592a:	4293      	cmp	r3, r2
   8592c:	d107      	bne.n	8593e <_Z41__static_initialization_and_destruction_0ii+0x2a>
#include "BSP.h"

using namespace ard;

//singleton instanciation
LogThread LogThread::instance = LogThread ();
   8592e:	4806      	ldr	r0, [pc, #24]	; (85948 <_Z41__static_initialization_and_destruction_0ii+0x34>)
   85930:	4b06      	ldr	r3, [pc, #24]	; (8594c <_Z41__static_initialization_and_destruction_0ii+0x38>)
   85932:	4798      	blx	r3
   85934:	4a06      	ldr	r2, [pc, #24]	; (85950 <_Z41__static_initialization_and_destruction_0ii+0x3c>)
   85936:	4907      	ldr	r1, [pc, #28]	; (85954 <_Z41__static_initialization_and_destruction_0ii+0x40>)
   85938:	4803      	ldr	r0, [pc, #12]	; (85948 <_Z41__static_initialization_and_destruction_0ii+0x34>)
   8593a:	4b07      	ldr	r3, [pc, #28]	; (85958 <_Z41__static_initialization_and_destruction_0ii+0x44>)
   8593c:	4798      	blx	r3
      level = "ERROR";
      break;
    }

  return String (msg.date) + " [" + level + "] " + msg.text;
}
   8593e:	bf00      	nop
   85940:	3708      	adds	r7, #8
   85942:	46bd      	mov	sp, r7
   85944:	bd80      	pop	{r7, pc}
   85946:	bf00      	nop
   85948:	20071450 	.word	0x20071450
   8594c:	00085105 	.word	0x00085105
   85950:	20070064 	.word	0x20070064
   85954:	0008500d 	.word	0x0008500d
   85958:	000909cd 	.word	0x000909cd

0008595c <_GLOBAL__sub_I__ZN3ard9LogThread8instanceE>:
   8595c:	b580      	push	{r7, lr}
   8595e:	af00      	add	r7, sp, #0
   85960:	f64f 71ff 	movw	r1, #65535	; 0xffff
   85964:	2001      	movs	r0, #1
   85966:	4b01      	ldr	r3, [pc, #4]	; (8596c <_GLOBAL__sub_I__ZN3ard9LogThread8instanceE+0x10>)
   85968:	4798      	blx	r3
   8596a:	bd80      	pop	{r7, pc}
   8596c:	00085915 	.word	0x00085915

00085970 <_ZN15StringSumHelperC1EPKc>:
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
   85970:	b580      	push	{r7, lr}
   85972:	b082      	sub	sp, #8
   85974:	af00      	add	r7, sp, #0
   85976:	6078      	str	r0, [r7, #4]
   85978:	6039      	str	r1, [r7, #0]
   8597a:	687b      	ldr	r3, [r7, #4]
   8597c:	6839      	ldr	r1, [r7, #0]
   8597e:	4618      	mov	r0, r3
   85980:	4b03      	ldr	r3, [pc, #12]	; (85990 <_ZN15StringSumHelperC1EPKc+0x20>)
   85982:	4798      	blx	r3
   85984:	687b      	ldr	r3, [r7, #4]
   85986:	4618      	mov	r0, r3
   85988:	3708      	adds	r7, #8
   8598a:	46bd      	mov	sp, r7
   8598c:	bd80      	pop	{r7, pc}
   8598e:	bf00      	nop
   85990:	00089009 	.word	0x00089009

00085994 <_ZN3ard19IMiniPeriodicThreadD1Ev>:
    init () = 0;

    virtual void
    update (TimeMs sinceLastCall) = 0;

    virtual ~IMiniPeriodicThread(){};
   85994:	b580      	push	{r7, lr}
   85996:	b082      	sub	sp, #8
   85998:	af00      	add	r7, sp, #0
   8599a:	6078      	str	r0, [r7, #4]
   8599c:	4a06      	ldr	r2, [pc, #24]	; (859b8 <_ZN3ard19IMiniPeriodicThreadD1Ev+0x24>)
   8599e:	687b      	ldr	r3, [r7, #4]
   859a0:	601a      	str	r2, [r3, #0]
   859a2:	2300      	movs	r3, #0
   859a4:	2b00      	cmp	r3, #0
   859a6:	d002      	beq.n	859ae <_ZN3ard19IMiniPeriodicThreadD1Ev+0x1a>
   859a8:	6878      	ldr	r0, [r7, #4]
   859aa:	4b04      	ldr	r3, [pc, #16]	; (859bc <_ZN3ard19IMiniPeriodicThreadD1Ev+0x28>)
   859ac:	4798      	blx	r3
   859ae:	687b      	ldr	r3, [r7, #4]
   859b0:	4618      	mov	r0, r3
   859b2:	3708      	adds	r7, #8
   859b4:	46bd      	mov	sp, r7
   859b6:	bd80      	pop	{r7, pc}
   859b8:	0009aa38 	.word	0x0009aa38
   859bc:	0008788d 	.word	0x0008788d

000859c0 <_ZN3ard19IMiniPeriodicThreadD0Ev>:
   859c0:	b580      	push	{r7, lr}
   859c2:	b082      	sub	sp, #8
   859c4:	af00      	add	r7, sp, #0
   859c6:	6078      	str	r0, [r7, #4]
   859c8:	6878      	ldr	r0, [r7, #4]
   859ca:	4b05      	ldr	r3, [pc, #20]	; (859e0 <_ZN3ard19IMiniPeriodicThreadD0Ev+0x20>)
   859cc:	4798      	blx	r3
   859ce:	6878      	ldr	r0, [r7, #4]
   859d0:	4b04      	ldr	r3, [pc, #16]	; (859e4 <_ZN3ard19IMiniPeriodicThreadD0Ev+0x24>)
   859d2:	4798      	blx	r3
   859d4:	687b      	ldr	r3, [r7, #4]
   859d6:	4618      	mov	r0, r3
   859d8:	3708      	adds	r7, #8
   859da:	46bd      	mov	sp, r7
   859dc:	bd80      	pop	{r7, pc}
   859de:	bf00      	nop
   859e0:	00085995 	.word	0x00085995
   859e4:	0008788d 	.word	0x0008788d

000859e8 <_ZN3ard9LogThread11getInstanceEv>:
    }
    ;

    //retrieve the singleton instance (you should prefer the use of the g_ArdOs maccro)
    static LogThread&
    getInstance ()
   859e8:	b480      	push	{r7}
   859ea:	af00      	add	r7, sp, #0
    {
      return instance;
   859ec:	4b02      	ldr	r3, [pc, #8]	; (859f8 <_ZN3ard9LogThread11getInstanceEv+0x10>)
    }
   859ee:	4618      	mov	r0, r3
   859f0:	46bd      	mov	sp, r7
   859f2:	bc80      	pop	{r7}
   859f4:	4770      	bx	lr
   859f6:	bf00      	nop
   859f8:	20071450 	.word	0x20071450

000859fc <_ZN3ard5PointD1Ev>:
  {
  public:
    float x;
    float y;

    virtual ~Point(){};
   859fc:	b580      	push	{r7, lr}
   859fe:	b082      	sub	sp, #8
   85a00:	af00      	add	r7, sp, #0
   85a02:	6078      	str	r0, [r7, #4]
   85a04:	4a06      	ldr	r2, [pc, #24]	; (85a20 <_ZN3ard5PointD1Ev+0x24>)
   85a06:	687b      	ldr	r3, [r7, #4]
   85a08:	601a      	str	r2, [r3, #0]
   85a0a:	2300      	movs	r3, #0
   85a0c:	2b00      	cmp	r3, #0
   85a0e:	d002      	beq.n	85a16 <_ZN3ard5PointD1Ev+0x1a>
   85a10:	6878      	ldr	r0, [r7, #4]
   85a12:	4b04      	ldr	r3, [pc, #16]	; (85a24 <_ZN3ard5PointD1Ev+0x28>)
   85a14:	4798      	blx	r3
   85a16:	687b      	ldr	r3, [r7, #4]
   85a18:	4618      	mov	r0, r3
   85a1a:	3708      	adds	r7, #8
   85a1c:	46bd      	mov	sp, r7
   85a1e:	bd80      	pop	{r7, pc}
   85a20:	0009aef4 	.word	0x0009aef4
   85a24:	0008788d 	.word	0x0008788d

00085a28 <_ZN3ard5PointD0Ev>:
   85a28:	b580      	push	{r7, lr}
   85a2a:	b082      	sub	sp, #8
   85a2c:	af00      	add	r7, sp, #0
   85a2e:	6078      	str	r0, [r7, #4]
   85a30:	6878      	ldr	r0, [r7, #4]
   85a32:	4b05      	ldr	r3, [pc, #20]	; (85a48 <_ZN3ard5PointD0Ev+0x20>)
   85a34:	4798      	blx	r3
   85a36:	6878      	ldr	r0, [r7, #4]
   85a38:	4b04      	ldr	r3, [pc, #16]	; (85a4c <_ZN3ard5PointD0Ev+0x24>)
   85a3a:	4798      	blx	r3
   85a3c:	687b      	ldr	r3, [r7, #4]
   85a3e:	4618      	mov	r0, r3
   85a40:	3708      	adds	r7, #8
   85a42:	46bd      	mov	sp, r7
   85a44:	bd80      	pop	{r7, pc}
   85a46:	bf00      	nop
   85a48:	000859fd 	.word	0x000859fd
   85a4c:	0008788d 	.word	0x0008788d

00085a50 <_ZN3ard5PointC1ERKS0_>:
{
  float
  moduloPiPi (float a);

  //Represent a geometric point in a 2D space
  class Point
   85a50:	b480      	push	{r7}
   85a52:	b083      	sub	sp, #12
   85a54:	af00      	add	r7, sp, #0
   85a56:	6078      	str	r0, [r7, #4]
   85a58:	6039      	str	r1, [r7, #0]
   85a5a:	4a08      	ldr	r2, [pc, #32]	; (85a7c <_ZN3ard5PointC1ERKS0_+0x2c>)
   85a5c:	687b      	ldr	r3, [r7, #4]
   85a5e:	601a      	str	r2, [r3, #0]
   85a60:	683b      	ldr	r3, [r7, #0]
   85a62:	685a      	ldr	r2, [r3, #4]
   85a64:	687b      	ldr	r3, [r7, #4]
   85a66:	605a      	str	r2, [r3, #4]
   85a68:	683b      	ldr	r3, [r7, #0]
   85a6a:	689a      	ldr	r2, [r3, #8]
   85a6c:	687b      	ldr	r3, [r7, #4]
   85a6e:	609a      	str	r2, [r3, #8]
   85a70:	687b      	ldr	r3, [r7, #4]
   85a72:	4618      	mov	r0, r3
   85a74:	370c      	adds	r7, #12
   85a76:	46bd      	mov	sp, r7
   85a78:	bc80      	pop	{r7}
   85a7a:	4770      	bx	lr
   85a7c:	0009aef4 	.word	0x0009aef4

00085a80 <_ZN3ard19IMiniPeriodicThreadC1Ev>:
  };

  /**
   * Use IMiniThread when you aggregate several components in one periodic thread
   */
  class IMiniPeriodicThread
   85a80:	b480      	push	{r7}
   85a82:	b083      	sub	sp, #12
   85a84:	af00      	add	r7, sp, #0
   85a86:	6078      	str	r0, [r7, #4]
   85a88:	4a04      	ldr	r2, [pc, #16]	; (85a9c <_ZN3ard19IMiniPeriodicThreadC1Ev+0x1c>)
   85a8a:	687b      	ldr	r3, [r7, #4]
   85a8c:	601a      	str	r2, [r3, #0]
   85a8e:	687b      	ldr	r3, [r7, #4]
   85a90:	4618      	mov	r0, r3
   85a92:	370c      	adds	r7, #12
   85a94:	46bd      	mov	sp, r7
   85a96:	bc80      	pop	{r7}
   85a98:	4770      	bx	lr
   85a9a:	bf00      	nop
   85a9c:	0009aa38 	.word	0x0009aa38

00085aa0 <_ZN3ard10NavigationC1Ev>:
#include "K_constants.h"
#include "BSP.h"

using namespace ard;

Navigation::Navigation () :
   85aa0:	b590      	push	{r4, r7, lr}
   85aa2:	b087      	sub	sp, #28
   85aa4:	af04      	add	r7, sp, #16
   85aa6:	6078      	str	r0, [r7, #4]
								    50), omronFrontRight (
	OMRON2, 50, 50), omronRearLeft (OMRON3, 50, 50), omronRearRight (OMRON4,
									 50,
									 50), m_color (
	eColor::UNDEF), m_speed (SPEED_MAX), m_speed_virage (SPEED_MAX_VIR), m_mutex (
    NULL), m_targetReached (NULL)
   85aa8:	687b      	ldr	r3, [r7, #4]
   85aaa:	4618      	mov	r0, r3
   85aac:	4b3a      	ldr	r3, [pc, #232]	; (85b98 <_ZN3ard10NavigationC1Ev+0xf8>)
   85aae:	4798      	blx	r3
   85ab0:	4a3a      	ldr	r2, [pc, #232]	; (85b9c <_ZN3ard10NavigationC1Ev+0xfc>)
   85ab2:	687b      	ldr	r3, [r7, #4]
   85ab4:	601a      	str	r2, [r3, #0]
   85ab6:	687b      	ldr	r3, [r7, #4]
   85ab8:	3304      	adds	r3, #4
   85aba:	4618      	mov	r0, r3
   85abc:	4b38      	ldr	r3, [pc, #224]	; (85ba0 <_ZN3ard10NavigationC1Ev+0x100>)
   85abe:	4798      	blx	r3
   85ac0:	687b      	ldr	r3, [r7, #4]
   85ac2:	2200      	movs	r2, #0
   85ac4:	615a      	str	r2, [r3, #20]
   85ac6:	687b      	ldr	r3, [r7, #4]
   85ac8:	3318      	adds	r3, #24
   85aca:	4618      	mov	r0, r3
   85acc:	4b34      	ldr	r3, [pc, #208]	; (85ba0 <_ZN3ard10NavigationC1Ev+0x100>)
   85ace:	4798      	blx	r3
   85ad0:	687b      	ldr	r3, [r7, #4]
   85ad2:	2200      	movs	r2, #0
   85ad4:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
   85ad8:	687b      	ldr	r3, [r7, #4]
   85ada:	2200      	movs	r2, #0
   85adc:	62da      	str	r2, [r3, #44]	; 0x2c
   85ade:	687b      	ldr	r3, [r7, #4]
   85ae0:	f04f 0200 	mov.w	r2, #0
   85ae4:	631a      	str	r2, [r3, #48]	; 0x30
   85ae6:	687b      	ldr	r3, [r7, #4]
   85ae8:	f04f 0200 	mov.w	r2, #0
   85aec:	635a      	str	r2, [r3, #52]	; 0x34
   85aee:	687b      	ldr	r3, [r7, #4]
   85af0:	f103 0038 	add.w	r0, r3, #56	; 0x38
   85af4:	2301      	movs	r3, #1
   85af6:	9302      	str	r3, [sp, #8]
   85af8:	2305      	movs	r3, #5
   85afa:	9301      	str	r3, [sp, #4]
   85afc:	2304      	movs	r3, #4
   85afe:	9300      	str	r3, [sp, #0]
   85b00:	2322      	movs	r3, #34	; 0x22
   85b02:	2223      	movs	r2, #35	; 0x23
   85b04:	2101      	movs	r1, #1
   85b06:	4c27      	ldr	r4, [pc, #156]	; (85ba4 <_ZN3ard10NavigationC1Ev+0x104>)
   85b08:	47a0      	blx	r4
   85b0a:	687b      	ldr	r3, [r7, #4]
   85b0c:	f103 008c 	add.w	r0, r3, #140	; 0x8c
   85b10:	2301      	movs	r3, #1
   85b12:	9302      	str	r3, [sp, #8]
   85b14:	2305      	movs	r3, #5
   85b16:	9301      	str	r3, [sp, #4]
   85b18:	2304      	movs	r3, #4
   85b1a:	9300      	str	r3, [sp, #0]
   85b1c:	2324      	movs	r3, #36	; 0x24
   85b1e:	2225      	movs	r2, #37	; 0x25
   85b20:	2101      	movs	r1, #1
   85b22:	4c20      	ldr	r4, [pc, #128]	; (85ba4 <_ZN3ard10NavigationC1Ev+0x104>)
   85b24:	47a0      	blx	r4
   85b26:	687b      	ldr	r3, [r7, #4]
   85b28:	f103 00e0 	add.w	r0, r3, #224	; 0xe0
   85b2c:	2332      	movs	r3, #50	; 0x32
   85b2e:	2232      	movs	r2, #50	; 0x32
   85b30:	211f      	movs	r1, #31
   85b32:	4c1d      	ldr	r4, [pc, #116]	; (85ba8 <_ZN3ard10NavigationC1Ev+0x108>)
   85b34:	47a0      	blx	r4
   85b36:	687b      	ldr	r3, [r7, #4]
   85b38:	f503 7080 	add.w	r0, r3, #256	; 0x100
   85b3c:	2332      	movs	r3, #50	; 0x32
   85b3e:	2232      	movs	r2, #50	; 0x32
   85b40:	211a      	movs	r1, #26
   85b42:	4c19      	ldr	r4, [pc, #100]	; (85ba8 <_ZN3ard10NavigationC1Ev+0x108>)
   85b44:	47a0      	blx	r4
   85b46:	687b      	ldr	r3, [r7, #4]
   85b48:	f503 7090 	add.w	r0, r3, #288	; 0x120
   85b4c:	2332      	movs	r3, #50	; 0x32
   85b4e:	2232      	movs	r2, #50	; 0x32
   85b50:	211b      	movs	r1, #27
   85b52:	4c15      	ldr	r4, [pc, #84]	; (85ba8 <_ZN3ard10NavigationC1Ev+0x108>)
   85b54:	47a0      	blx	r4
   85b56:	687b      	ldr	r3, [r7, #4]
   85b58:	f503 70a0 	add.w	r0, r3, #320	; 0x140
   85b5c:	2332      	movs	r3, #50	; 0x32
   85b5e:	2232      	movs	r2, #50	; 0x32
   85b60:	211c      	movs	r1, #28
   85b62:	4c11      	ldr	r4, [pc, #68]	; (85ba8 <_ZN3ard10NavigationC1Ev+0x108>)
   85b64:	47a0      	blx	r4
   85b66:	687b      	ldr	r3, [r7, #4]
   85b68:	2200      	movs	r2, #0
   85b6a:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
   85b6e:	687b      	ldr	r3, [r7, #4]
   85b70:	4a0e      	ldr	r2, [pc, #56]	; (85bac <_ZN3ard10NavigationC1Ev+0x10c>)
   85b72:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164
   85b76:	687b      	ldr	r3, [r7, #4]
   85b78:	4a0d      	ldr	r2, [pc, #52]	; (85bb0 <_ZN3ard10NavigationC1Ev+0x110>)
   85b7a:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
   85b7e:	687b      	ldr	r3, [r7, #4]
   85b80:	2200      	movs	r2, #0
   85b82:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c
   85b86:	687b      	ldr	r3, [r7, #4]
   85b88:	2200      	movs	r2, #0
   85b8a:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
{
}
   85b8e:	687b      	ldr	r3, [r7, #4]
   85b90:	4618      	mov	r0, r3
   85b92:	370c      	adds	r7, #12
   85b94:	46bd      	mov	sp, r7
   85b96:	bd90      	pop	{r4, r7, pc}
   85b98:	00085a81 	.word	0x00085a81
   85b9c:	0009aa20 	.word	0x0009aa20
   85ba0:	0008fab1 	.word	0x0008fab1
   85ba4:	00089a9d 	.word	0x00089a9d
   85ba8:	000846ed 	.word	0x000846ed
   85bac:	45bb8000 	.word	0x45bb8000
   85bb0:	44fa0000 	.word	0x44fa0000

00085bb4 <_ZN3ard10Navigation4initEv>:

void
Navigation::init ()
{
   85bb4:	b580      	push	{r7, lr}
   85bb6:	b082      	sub	sp, #8
   85bb8:	af00      	add	r7, sp, #0
   85bba:	6078      	str	r0, [r7, #4]
  m_mutex = g_ArdOs.Mutex_create();
   85bbc:	4b11      	ldr	r3, [pc, #68]	; (85c04 <_ZN3ard10Navigation4initEv+0x50>)
   85bbe:	4798      	blx	r3
   85bc0:	4603      	mov	r3, r0
   85bc2:	4618      	mov	r0, r3
   85bc4:	4b10      	ldr	r3, [pc, #64]	; (85c08 <_ZN3ard10Navigation4initEv+0x54>)
   85bc6:	4798      	blx	r3
   85bc8:	4602      	mov	r2, r0
   85bca:	687b      	ldr	r3, [r7, #4]
   85bcc:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c
  m_targetReached = g_ArdOs.Signal_create();
   85bd0:	4b0c      	ldr	r3, [pc, #48]	; (85c04 <_ZN3ard10Navigation4initEv+0x50>)
   85bd2:	4798      	blx	r3
   85bd4:	4603      	mov	r3, r0
   85bd6:	4618      	mov	r0, r3
   85bd8:	4b0c      	ldr	r3, [pc, #48]	; (85c0c <_ZN3ard10Navigation4initEv+0x58>)
   85bda:	4798      	blx	r3
   85bdc:	4602      	mov	r2, r0
   85bde:	687b      	ldr	r3, [r7, #4]
   85be0:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
  stepperG.setAcceleration(ACC_MAX);
   85be4:	687b      	ldr	r3, [r7, #4]
   85be6:	3338      	adds	r3, #56	; 0x38
   85be8:	4909      	ldr	r1, [pc, #36]	; (85c10 <_ZN3ard10Navigation4initEv+0x5c>)
   85bea:	4618      	mov	r0, r3
   85bec:	4b09      	ldr	r3, [pc, #36]	; (85c14 <_ZN3ard10Navigation4initEv+0x60>)
   85bee:	4798      	blx	r3
  stepperD.setAcceleration(ACC_MAX);
   85bf0:	687b      	ldr	r3, [r7, #4]
   85bf2:	338c      	adds	r3, #140	; 0x8c
   85bf4:	4906      	ldr	r1, [pc, #24]	; (85c10 <_ZN3ard10Navigation4initEv+0x5c>)
   85bf6:	4618      	mov	r0, r3
   85bf8:	4b06      	ldr	r3, [pc, #24]	; (85c14 <_ZN3ard10Navigation4initEv+0x60>)
   85bfa:	4798      	blx	r3
}
   85bfc:	bf00      	nop
   85bfe:	3708      	adds	r7, #8
   85c00:	46bd      	mov	sp, r7
   85c02:	bd80      	pop	{r7, pc}
   85c04:	00082fad 	.word	0x00082fad
   85c08:	00083f21 	.word	0x00083f21
   85c0c:	00083c45 	.word	0x00083c45
   85c10:	466a6000 	.word	0x466a6000
   85c14:	00089c61 	.word	0x00089c61

00085c18 <_ZN3ard10Navigation6updateEm>:
 * Container thread interface
 ---------------------------------*/

void
Navigation::update (TimeMs sinceLastCall)
{
   85c18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   85c1c:	b0a7      	sub	sp, #156	; 0x9c
   85c1e:	af00      	add	r7, sp, #0
   85c20:	6078      	str	r0, [r7, #4]
   85c22:	6039      	str	r1, [r7, #0]
  static eNavState lastState = m_state;
   85c24:	4ba4      	ldr	r3, [pc, #656]	; (85eb8 <_ZN3ard10Navigation6updateEm+0x2a0>)
   85c26:	681b      	ldr	r3, [r3, #0]
   85c28:	f003 0301 	and.w	r3, r3, #1
   85c2c:	2b00      	cmp	r3, #0
   85c2e:	d106      	bne.n	85c3e <_ZN3ard10Navigation6updateEm+0x26>
   85c30:	687b      	ldr	r3, [r7, #4]
   85c32:	695b      	ldr	r3, [r3, #20]
   85c34:	4aa1      	ldr	r2, [pc, #644]	; (85ebc <_ZN3ard10Navigation6updateEm+0x2a4>)
   85c36:	6013      	str	r3, [r2, #0]
   85c38:	4b9f      	ldr	r3, [pc, #636]	; (85eb8 <_ZN3ard10Navigation6updateEm+0x2a0>)
   85c3a:	2201      	movs	r2, #1
   85c3c:	601a      	str	r2, [r3, #0]
  if( m_state != lastState )
   85c3e:	687b      	ldr	r3, [r7, #4]
   85c40:	695a      	ldr	r2, [r3, #20]
   85c42:	4b9e      	ldr	r3, [pc, #632]	; (85ebc <_ZN3ard10Navigation6updateEm+0x2a4>)
   85c44:	681b      	ldr	r3, [r3, #0]
   85c46:	429a      	cmp	r2, r3
   85c48:	d047      	beq.n	85cda <_ZN3ard10Navigation6updateEm+0xc2>
    {
        LOG(DEBUG, "NAV : state changed from  " + stateToString (lastState) + " to " + stateToString (m_state));
   85c4a:	4b9d      	ldr	r3, [pc, #628]	; (85ec0 <_ZN3ard10Navigation6updateEm+0x2a8>)
   85c4c:	4798      	blx	r3
   85c4e:	4605      	mov	r5, r0
   85c50:	682b      	ldr	r3, [r5, #0]
   85c52:	3310      	adds	r3, #16
   85c54:	681c      	ldr	r4, [r3, #0]
   85c56:	f107 0308 	add.w	r3, r7, #8
   85c5a:	499a      	ldr	r1, [pc, #616]	; (85ec4 <_ZN3ard10Navigation6updateEm+0x2ac>)
   85c5c:	4618      	mov	r0, r3
   85c5e:	4b9a      	ldr	r3, [pc, #616]	; (85ec8 <_ZN3ard10Navigation6updateEm+0x2b0>)
   85c60:	4798      	blx	r3
   85c62:	4b96      	ldr	r3, [pc, #600]	; (85ebc <_ZN3ard10Navigation6updateEm+0x2a4>)
   85c64:	681a      	ldr	r2, [r3, #0]
   85c66:	f107 0314 	add.w	r3, r7, #20
   85c6a:	6879      	ldr	r1, [r7, #4]
   85c6c:	4618      	mov	r0, r3
   85c6e:	4b97      	ldr	r3, [pc, #604]	; (85ecc <_ZN3ard10Navigation6updateEm+0x2b4>)
   85c70:	4798      	blx	r3
   85c72:	f107 0214 	add.w	r2, r7, #20
   85c76:	f107 0308 	add.w	r3, r7, #8
   85c7a:	4611      	mov	r1, r2
   85c7c:	4618      	mov	r0, r3
   85c7e:	4b94      	ldr	r3, [pc, #592]	; (85ed0 <_ZN3ard10Navigation6updateEm+0x2b8>)
   85c80:	4798      	blx	r3
   85c82:	4603      	mov	r3, r0
   85c84:	4993      	ldr	r1, [pc, #588]	; (85ed4 <_ZN3ard10Navigation6updateEm+0x2bc>)
   85c86:	4618      	mov	r0, r3
   85c88:	4b93      	ldr	r3, [pc, #588]	; (85ed8 <_ZN3ard10Navigation6updateEm+0x2c0>)
   85c8a:	4798      	blx	r3
   85c8c:	4606      	mov	r6, r0
   85c8e:	687b      	ldr	r3, [r7, #4]
   85c90:	695a      	ldr	r2, [r3, #20]
   85c92:	f107 0320 	add.w	r3, r7, #32
   85c96:	6879      	ldr	r1, [r7, #4]
   85c98:	4618      	mov	r0, r3
   85c9a:	4b8c      	ldr	r3, [pc, #560]	; (85ecc <_ZN3ard10Navigation6updateEm+0x2b4>)
   85c9c:	4798      	blx	r3
   85c9e:	f107 0320 	add.w	r3, r7, #32
   85ca2:	4619      	mov	r1, r3
   85ca4:	4630      	mov	r0, r6
   85ca6:	4b8a      	ldr	r3, [pc, #552]	; (85ed0 <_ZN3ard10Navigation6updateEm+0x2b8>)
   85ca8:	4798      	blx	r3
   85caa:	4603      	mov	r3, r0
   85cac:	461a      	mov	r2, r3
   85cae:	2100      	movs	r1, #0
   85cb0:	4628      	mov	r0, r5
   85cb2:	47a0      	blx	r4
   85cb4:	f107 0320 	add.w	r3, r7, #32
   85cb8:	4618      	mov	r0, r3
   85cba:	4b88      	ldr	r3, [pc, #544]	; (85edc <_ZN3ard10Navigation6updateEm+0x2c4>)
   85cbc:	4798      	blx	r3
   85cbe:	f107 0314 	add.w	r3, r7, #20
   85cc2:	4618      	mov	r0, r3
   85cc4:	4b85      	ldr	r3, [pc, #532]	; (85edc <_ZN3ard10Navigation6updateEm+0x2c4>)
   85cc6:	4798      	blx	r3
   85cc8:	f107 0308 	add.w	r3, r7, #8
   85ccc:	4618      	mov	r0, r3
   85cce:	4b84      	ldr	r3, [pc, #528]	; (85ee0 <_ZN3ard10Navigation6updateEm+0x2c8>)
   85cd0:	4798      	blx	r3
        lastState = m_state;
   85cd2:	687b      	ldr	r3, [r7, #4]
   85cd4:	695b      	ldr	r3, [r3, #20]
   85cd6:	4a79      	ldr	r2, [pc, #484]	; (85ebc <_ZN3ard10Navigation6updateEm+0x2a4>)
   85cd8:	6013      	str	r3, [r2, #0]
    }

  //Take a mutex to prevent localisation and target to be changed during a cycle
  g_ArdOs.Mutex_lock(m_mutex);
   85cda:	4b82      	ldr	r3, [pc, #520]	; (85ee4 <_ZN3ard10Navigation6updateEm+0x2cc>)
   85cdc:	4798      	blx	r3
   85cde:	4602      	mov	r2, r0
   85ce0:	687b      	ldr	r3, [r7, #4]
   85ce2:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
   85ce6:	4619      	mov	r1, r3
   85ce8:	4610      	mov	r0, r2
   85cea:	4b7f      	ldr	r3, [pc, #508]	; (85ee8 <_ZN3ard10Navigation6updateEm+0x2d0>)
   85cec:	4798      	blx	r3

  switch (m_state)
   85cee:	687b      	ldr	r3, [r7, #4]
   85cf0:	695b      	ldr	r3, [r3, #20]
   85cf2:	3b01      	subs	r3, #1
   85cf4:	2b03      	cmp	r3, #3
   85cf6:	d80b      	bhi.n	85d10 <_ZN3ard10Navigation6updateEm+0xf8>
   85cf8:	a201      	add	r2, pc, #4	; (adr r2, 85d00 <_ZN3ard10Navigation6updateEm+0xe8>)
   85cfa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   85cfe:	bf00      	nop
   85d00:	00085f2d 	.word	0x00085f2d
   85d04:	00085ff7 	.word	0x00085ff7
   85d08:	00086231 	.word	0x00086231
   85d0c:	00086295 	.word	0x00086295
    {
    default:
    case eNavState::IDLE:
      {
	switch (m_order)
   85d10:	687b      	ldr	r3, [r7, #4]
   85d12:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   85d14:	3b01      	subs	r3, #1
   85d16:	2b01      	cmp	r3, #1
   85d18:	f200 80c6 	bhi.w	85ea8 <_ZN3ard10Navigation6updateEm+0x290>
	    }

	  case eNavOrder::GOTO:
	  case eNavOrder::GOTO_CAP:
	    {
	      LOG(INFO,
   85d1c:	4b68      	ldr	r3, [pc, #416]	; (85ec0 <_ZN3ard10Navigation6updateEm+0x2a8>)
   85d1e:	4798      	blx	r3
   85d20:	4605      	mov	r5, r0
   85d22:	682b      	ldr	r3, [r5, #0]
   85d24:	3310      	adds	r3, #16
   85d26:	681c      	ldr	r4, [r3, #0]
   85d28:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   85d2c:	496f      	ldr	r1, [pc, #444]	; (85eec <_ZN3ard10Navigation6updateEm+0x2d4>)
   85d2e:	4618      	mov	r0, r3
   85d30:	4b65      	ldr	r3, [pc, #404]	; (85ec8 <_ZN3ard10Navigation6updateEm+0x2b0>)
   85d32:	4798      	blx	r3
   85d34:	687b      	ldr	r3, [r7, #4]
   85d36:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   85d38:	f107 0338 	add.w	r3, r7, #56	; 0x38
   85d3c:	6879      	ldr	r1, [r7, #4]
   85d3e:	4618      	mov	r0, r3
   85d40:	4b6b      	ldr	r3, [pc, #428]	; (85ef0 <_ZN3ard10Navigation6updateEm+0x2d8>)
   85d42:	4798      	blx	r3
   85d44:	f107 0238 	add.w	r2, r7, #56	; 0x38
   85d48:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   85d4c:	4611      	mov	r1, r2
   85d4e:	4618      	mov	r0, r3
   85d50:	4b5f      	ldr	r3, [pc, #380]	; (85ed0 <_ZN3ard10Navigation6updateEm+0x2b8>)
   85d52:	4798      	blx	r3
   85d54:	4603      	mov	r3, r0
   85d56:	4967      	ldr	r1, [pc, #412]	; (85ef4 <_ZN3ard10Navigation6updateEm+0x2dc>)
   85d58:	4618      	mov	r0, r3
   85d5a:	4b5f      	ldr	r3, [pc, #380]	; (85ed8 <_ZN3ard10Navigation6updateEm+0x2c0>)
   85d5c:	4798      	blx	r3
   85d5e:	4602      	mov	r2, r0
   85d60:	687b      	ldr	r3, [r7, #4]
   85d62:	69db      	ldr	r3, [r3, #28]
   85d64:	4619      	mov	r1, r3
   85d66:	4610      	mov	r0, r2
   85d68:	4b63      	ldr	r3, [pc, #396]	; (85ef8 <_ZN3ard10Navigation6updateEm+0x2e0>)
   85d6a:	4798      	blx	r3
   85d6c:	4603      	mov	r3, r0
   85d6e:	4963      	ldr	r1, [pc, #396]	; (85efc <_ZN3ard10Navigation6updateEm+0x2e4>)
   85d70:	4618      	mov	r0, r3
   85d72:	4b59      	ldr	r3, [pc, #356]	; (85ed8 <_ZN3ard10Navigation6updateEm+0x2c0>)
   85d74:	4798      	blx	r3
   85d76:	4602      	mov	r2, r0
   85d78:	687b      	ldr	r3, [r7, #4]
   85d7a:	6a1b      	ldr	r3, [r3, #32]
   85d7c:	4619      	mov	r1, r3
   85d7e:	4610      	mov	r0, r2
   85d80:	4b5d      	ldr	r3, [pc, #372]	; (85ef8 <_ZN3ard10Navigation6updateEm+0x2e0>)
   85d82:	4798      	blx	r3
   85d84:	4603      	mov	r3, r0
   85d86:	495d      	ldr	r1, [pc, #372]	; (85efc <_ZN3ard10Navigation6updateEm+0x2e4>)
   85d88:	4618      	mov	r0, r3
   85d8a:	4b53      	ldr	r3, [pc, #332]	; (85ed8 <_ZN3ard10Navigation6updateEm+0x2c0>)
   85d8c:	4798      	blx	r3
   85d8e:	4602      	mov	r2, r0
   85d90:	687b      	ldr	r3, [r7, #4]
   85d92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   85d94:	4619      	mov	r1, r3
   85d96:	4610      	mov	r0, r2
   85d98:	4b57      	ldr	r3, [pc, #348]	; (85ef8 <_ZN3ard10Navigation6updateEm+0x2e0>)
   85d9a:	4798      	blx	r3
   85d9c:	4603      	mov	r3, r0
   85d9e:	4958      	ldr	r1, [pc, #352]	; (85f00 <_ZN3ard10Navigation6updateEm+0x2e8>)
   85da0:	4618      	mov	r0, r3
   85da2:	4b4d      	ldr	r3, [pc, #308]	; (85ed8 <_ZN3ard10Navigation6updateEm+0x2c0>)
   85da4:	4798      	blx	r3
   85da6:	4606      	mov	r6, r0
   85da8:	687b      	ldr	r3, [r7, #4]
   85daa:	f993 2028 	ldrsb.w	r2, [r3, #40]	; 0x28
   85dae:	f107 0344 	add.w	r3, r7, #68	; 0x44
   85db2:	6879      	ldr	r1, [r7, #4]
   85db4:	4618      	mov	r0, r3
   85db6:	4b53      	ldr	r3, [pc, #332]	; (85f04 <_ZN3ard10Navigation6updateEm+0x2ec>)
   85db8:	4798      	blx	r3
   85dba:	f107 0344 	add.w	r3, r7, #68	; 0x44
   85dbe:	4619      	mov	r1, r3
   85dc0:	4630      	mov	r0, r6
   85dc2:	4b43      	ldr	r3, [pc, #268]	; (85ed0 <_ZN3ard10Navigation6updateEm+0x2b8>)
   85dc4:	4798      	blx	r3
   85dc6:	4603      	mov	r3, r0
   85dc8:	494f      	ldr	r1, [pc, #316]	; (85f08 <_ZN3ard10Navigation6updateEm+0x2f0>)
   85dca:	4618      	mov	r0, r3
   85dcc:	4b42      	ldr	r3, [pc, #264]	; (85ed8 <_ZN3ard10Navigation6updateEm+0x2c0>)
   85dce:	4798      	blx	r3
   85dd0:	4603      	mov	r3, r0
		  "NAV : new order " + orderToString (m_order) + "(" + m_target.x
		  + ", " + m_target.y + ", " + m_target.h + ") "
		  + sensToString (m_sensTarget) + ".");
   85dd2:	461a      	mov	r2, r3
   85dd4:	2101      	movs	r1, #1
   85dd6:	4628      	mov	r0, r5
   85dd8:	47a0      	blx	r4
	    }

	  case eNavOrder::GOTO:
	  case eNavOrder::GOTO_CAP:
	    {
	      LOG(INFO,
   85dda:	f107 0344 	add.w	r3, r7, #68	; 0x44
   85dde:	4618      	mov	r0, r3
   85de0:	4b3e      	ldr	r3, [pc, #248]	; (85edc <_ZN3ard10Navigation6updateEm+0x2c4>)
   85de2:	4798      	blx	r3
   85de4:	f107 0338 	add.w	r3, r7, #56	; 0x38
   85de8:	4618      	mov	r0, r3
   85dea:	4b3c      	ldr	r3, [pc, #240]	; (85edc <_ZN3ard10Navigation6updateEm+0x2c4>)
   85dec:	4798      	blx	r3
   85dee:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   85df2:	4618      	mov	r0, r3
   85df4:	4b3a      	ldr	r3, [pc, #232]	; (85ee0 <_ZN3ard10Navigation6updateEm+0x2c8>)
   85df6:	4798      	blx	r3
		  "NAV : new order " + orderToString (m_order) + "(" + m_target.x
		  + ", " + m_target.y + ", " + m_target.h + ") "
		  + sensToString (m_sensTarget) + ".");
	      if (m_sensTarget == SENS_AR)
   85df8:	687b      	ldr	r3, [r7, #4]
   85dfa:	f993 3028 	ldrsb.w	r3, [r3, #40]	; 0x28
   85dfe:	f1b3 3fff 	cmp.w	r3, #4294967295
   85e02:	d12e      	bne.n	85e62 <_ZN3ard10Navigation6updateEm+0x24a>
	      m_angleToTarget = moduloPiPi (m_pose.angleTo (m_target) + M_PI);
   85e04:	687b      	ldr	r3, [r7, #4]
   85e06:	1d1c      	adds	r4, r3, #4
   85e08:	687b      	ldr	r3, [r7, #4]
   85e0a:	f103 0218 	add.w	r2, r3, #24
   85e0e:	f107 0350 	add.w	r3, r7, #80	; 0x50
   85e12:	4611      	mov	r1, r2
   85e14:	4618      	mov	r0, r3
   85e16:	4b3d      	ldr	r3, [pc, #244]	; (85f0c <_ZN3ard10Navigation6updateEm+0x2f4>)
   85e18:	4798      	blx	r3
   85e1a:	f107 0350 	add.w	r3, r7, #80	; 0x50
   85e1e:	4619      	mov	r1, r3
   85e20:	4620      	mov	r0, r4
   85e22:	4b3b      	ldr	r3, [pc, #236]	; (85f10 <_ZN3ard10Navigation6updateEm+0x2f8>)
   85e24:	4798      	blx	r3
   85e26:	4602      	mov	r2, r0
   85e28:	4b3a      	ldr	r3, [pc, #232]	; (85f14 <_ZN3ard10Navigation6updateEm+0x2fc>)
   85e2a:	4610      	mov	r0, r2
   85e2c:	4798      	blx	r3
   85e2e:	4c3a      	ldr	r4, [pc, #232]	; (85f18 <_ZN3ard10Navigation6updateEm+0x300>)
   85e30:	a31f      	add	r3, pc, #124	; (adr r3, 85eb0 <_ZN3ard10Navigation6updateEm+0x298>)
   85e32:	e9d3 2300 	ldrd	r2, r3, [r3]
   85e36:	47a0      	blx	r4
   85e38:	4603      	mov	r3, r0
   85e3a:	460c      	mov	r4, r1
   85e3c:	4619      	mov	r1, r3
   85e3e:	4622      	mov	r2, r4
   85e40:	4b36      	ldr	r3, [pc, #216]	; (85f1c <_ZN3ard10Navigation6updateEm+0x304>)
   85e42:	4608      	mov	r0, r1
   85e44:	4611      	mov	r1, r2
   85e46:	4798      	blx	r3
   85e48:	4603      	mov	r3, r0
   85e4a:	4618      	mov	r0, r3
   85e4c:	4b34      	ldr	r3, [pc, #208]	; (85f20 <_ZN3ard10Navigation6updateEm+0x308>)
   85e4e:	4798      	blx	r3
   85e50:	4602      	mov	r2, r0
   85e52:	687b      	ldr	r3, [r7, #4]
   85e54:	631a      	str	r2, [r3, #48]	; 0x30
   85e56:	f107 0350 	add.w	r3, r7, #80	; 0x50
   85e5a:	4618      	mov	r0, r3
   85e5c:	4b31      	ldr	r3, [pc, #196]	; (85f24 <_ZN3ard10Navigation6updateEm+0x30c>)
   85e5e:	4798      	blx	r3
   85e60:	e018      	b.n	85e94 <_ZN3ard10Navigation6updateEm+0x27c>
	      else
	      m_angleToTarget = m_pose.angleTo (m_target);
   85e62:	687b      	ldr	r3, [r7, #4]
   85e64:	1d1c      	adds	r4, r3, #4
   85e66:	687b      	ldr	r3, [r7, #4]
   85e68:	f103 0218 	add.w	r2, r3, #24
   85e6c:	f107 035c 	add.w	r3, r7, #92	; 0x5c
   85e70:	4611      	mov	r1, r2
   85e72:	4618      	mov	r0, r3
   85e74:	4b25      	ldr	r3, [pc, #148]	; (85f0c <_ZN3ard10Navigation6updateEm+0x2f4>)
   85e76:	4798      	blx	r3
   85e78:	f107 035c 	add.w	r3, r7, #92	; 0x5c
   85e7c:	4619      	mov	r1, r3
   85e7e:	4620      	mov	r0, r4
   85e80:	4b23      	ldr	r3, [pc, #140]	; (85f10 <_ZN3ard10Navigation6updateEm+0x2f8>)
   85e82:	4798      	blx	r3
   85e84:	4602      	mov	r2, r0
   85e86:	687b      	ldr	r3, [r7, #4]
   85e88:	631a      	str	r2, [r3, #48]	; 0x30
   85e8a:	f107 035c 	add.w	r3, r7, #92	; 0x5c
   85e8e:	4618      	mov	r0, r3
   85e90:	4b24      	ldr	r3, [pc, #144]	; (85f24 <_ZN3ard10Navigation6updateEm+0x30c>)
   85e92:	4798      	blx	r3
	      turn (m_angleToTarget);
   85e94:	687b      	ldr	r3, [r7, #4]
   85e96:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   85e98:	4619      	mov	r1, r3
   85e9a:	6878      	ldr	r0, [r7, #4]
   85e9c:	4b22      	ldr	r3, [pc, #136]	; (85f28 <_ZN3ard10Navigation6updateEm+0x310>)
   85e9e:	4798      	blx	r3
	      m_state = eNavState::FACING_DEST;
   85ea0:	687b      	ldr	r3, [r7, #4]
   85ea2:	2201      	movs	r2, #1
   85ea4:	615a      	str	r2, [r3, #20]
	      break;
   85ea6:	e000      	b.n	85eaa <_ZN3ard10Navigation6updateEm+0x292>
	switch (m_order)
	  {
	  default:
	  case eNavOrder::NOTHING:
	    {
	      break;
   85ea8:	bf00      	nop
	      turn (m_angleToTarget);
	      m_state = eNavState::FACING_DEST;
	      break;
	    }
	}
      break;
   85eaa:	e21b      	b.n	862e4 <_ZN3ard10Navigation6updateEm+0x6cc>
   85eac:	f3af 8000 	nop.w
   85eb0:	54442d18 	.word	0x54442d18
   85eb4:	400921fb 	.word	0x400921fb
   85eb8:	20071620 	.word	0x20071620
   85ebc:	20071624 	.word	0x20071624
   85ec0:	000859e9 	.word	0x000859e9
   85ec4:	0009a79c 	.word	0x0009a79c
   85ec8:	00085971 	.word	0x00085971
   85ecc:	00086a1d 	.word	0x00086a1d
   85ed0:	000894d5 	.word	0x000894d5
   85ed4:	0009a7b8 	.word	0x0009a7b8
   85ed8:	0008951d 	.word	0x0008951d
   85edc:	00089145 	.word	0x00089145
   85ee0:	00082fe9 	.word	0x00082fe9
   85ee4:	00082fad 	.word	0x00082fad
   85ee8:	00084069 	.word	0x00084069
   85eec:	0009a7c0 	.word	0x0009a7c0
   85ef0:	000869d1 	.word	0x000869d1
   85ef4:	0009a7d4 	.word	0x0009a7d4
   85ef8:	00089645 	.word	0x00089645
   85efc:	0009a7d8 	.word	0x0009a7d8
   85f00:	0009a7dc 	.word	0x0009a7dc
   85f04:	00086981 	.word	0x00086981
   85f08:	0009a7e0 	.word	0x0009a7e0
   85f0c:	00085a51 	.word	0x00085a51
   85f10:	0008f8e1 	.word	0x0008f8e1
   85f14:	000926d5 	.word	0x000926d5
   85f18:	00092419 	.word	0x00092419
   85f1c:	00092d6d 	.word	0x00092d6d
   85f20:	0008f6d9 	.word	0x0008f6d9
   85f24:	000859fd 	.word	0x000859fd
   85f28:	00086819 	.word	0x00086819
    }

  case eNavState::FACING_DEST:
    {
      if (subOrderFinished ())
   85f2c:	6878      	ldr	r0, [r7, #4]
   85f2e:	4b86      	ldr	r3, [pc, #536]	; (86148 <_ZN3ard10Navigation6updateEm+0x530>)
   85f30:	4798      	blx	r3
   85f32:	4603      	mov	r3, r0
   85f34:	2b00      	cmp	r3, #0
   85f36:	f000 81ce 	beq.w	862d6 <_ZN3ard10Navigation6updateEm+0x6be>
	{
	  // Update odom
	  m_pose.h += m_angleToTarget;
   85f3a:	687b      	ldr	r3, [r7, #4]
   85f3c:	691a      	ldr	r2, [r3, #16]
   85f3e:	687b      	ldr	r3, [r7, #4]
   85f40:	6b19      	ldr	r1, [r3, #48]	; 0x30
   85f42:	4b82      	ldr	r3, [pc, #520]	; (8614c <_ZN3ard10Navigation6updateEm+0x534>)
   85f44:	4610      	mov	r0, r2
   85f46:	4798      	blx	r3
   85f48:	4603      	mov	r3, r0
   85f4a:	461a      	mov	r2, r3
   85f4c:	687b      	ldr	r3, [r7, #4]
   85f4e:	611a      	str	r2, [r3, #16]
	  m_pose.h = moduloPiPi (m_pose.h);
   85f50:	687b      	ldr	r3, [r7, #4]
   85f52:	691b      	ldr	r3, [r3, #16]
   85f54:	4618      	mov	r0, r3
   85f56:	4b7e      	ldr	r3, [pc, #504]	; (86150 <_ZN3ard10Navigation6updateEm+0x538>)
   85f58:	4798      	blx	r3
   85f5a:	4602      	mov	r2, r0
   85f5c:	687b      	ldr	r3, [r7, #4]
   85f5e:	611a      	str	r2, [r3, #16]

	  //Request straight line
	  m_distanceToTarget = m_sensTarget * m_pose.distanceTo (m_target);
   85f60:	687b      	ldr	r3, [r7, #4]
   85f62:	f993 2028 	ldrsb.w	r2, [r3, #40]	; 0x28
   85f66:	4b7b      	ldr	r3, [pc, #492]	; (86154 <_ZN3ard10Navigation6updateEm+0x53c>)
   85f68:	4610      	mov	r0, r2
   85f6a:	4798      	blx	r3
   85f6c:	4605      	mov	r5, r0
   85f6e:	687b      	ldr	r3, [r7, #4]
   85f70:	1d1c      	adds	r4, r3, #4
   85f72:	687b      	ldr	r3, [r7, #4]
   85f74:	f103 0218 	add.w	r2, r3, #24
   85f78:	f107 0368 	add.w	r3, r7, #104	; 0x68
   85f7c:	4611      	mov	r1, r2
   85f7e:	4618      	mov	r0, r3
   85f80:	4b75      	ldr	r3, [pc, #468]	; (86158 <_ZN3ard10Navigation6updateEm+0x540>)
   85f82:	4798      	blx	r3
   85f84:	f107 0368 	add.w	r3, r7, #104	; 0x68
   85f88:	4619      	mov	r1, r3
   85f8a:	4620      	mov	r0, r4
   85f8c:	4b73      	ldr	r3, [pc, #460]	; (8615c <_ZN3ard10Navigation6updateEm+0x544>)
   85f8e:	4798      	blx	r3
   85f90:	4602      	mov	r2, r0
   85f92:	4b73      	ldr	r3, [pc, #460]	; (86160 <_ZN3ard10Navigation6updateEm+0x548>)
   85f94:	4611      	mov	r1, r2
   85f96:	4628      	mov	r0, r5
   85f98:	4798      	blx	r3
   85f9a:	4603      	mov	r3, r0
   85f9c:	461a      	mov	r2, r3
   85f9e:	687b      	ldr	r3, [r7, #4]
   85fa0:	635a      	str	r2, [r3, #52]	; 0x34
   85fa2:	f107 0368 	add.w	r3, r7, #104	; 0x68
   85fa6:	4618      	mov	r0, r3
   85fa8:	4b6e      	ldr	r3, [pc, #440]	; (86164 <_ZN3ard10Navigation6updateEm+0x54c>)
   85faa:	4798      	blx	r3
	  straight (m_distanceToTarget);
   85fac:	687b      	ldr	r3, [r7, #4]
   85fae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   85fb0:	4619      	mov	r1, r3
   85fb2:	6878      	ldr	r0, [r7, #4]
   85fb4:	4b6c      	ldr	r3, [pc, #432]	; (86168 <_ZN3ard10Navigation6updateEm+0x550>)
   85fb6:	4798      	blx	r3

	  //Change state
	  m_angleToTarget = 0;
   85fb8:	687b      	ldr	r3, [r7, #4]
   85fba:	f04f 0200 	mov.w	r2, #0
   85fbe:	631a      	str	r2, [r3, #48]	; 0x30
	  m_state = eNavState::GOING_TO_TARGET;
   85fc0:	687b      	ldr	r3, [r7, #4]
   85fc2:	2202      	movs	r2, #2
   85fc4:	615a      	str	r2, [r3, #20]
	  LOG(DEBUG, "NAV : facing destination, beginning line.");
   85fc6:	4b69      	ldr	r3, [pc, #420]	; (8616c <_ZN3ard10Navigation6updateEm+0x554>)
   85fc8:	4798      	blx	r3
   85fca:	4605      	mov	r5, r0
   85fcc:	682b      	ldr	r3, [r5, #0]
   85fce:	3310      	adds	r3, #16
   85fd0:	681c      	ldr	r4, [r3, #0]
   85fd2:	f107 0374 	add.w	r3, r7, #116	; 0x74
   85fd6:	4966      	ldr	r1, [pc, #408]	; (86170 <_ZN3ard10Navigation6updateEm+0x558>)
   85fd8:	4618      	mov	r0, r3
   85fda:	4b66      	ldr	r3, [pc, #408]	; (86174 <_ZN3ard10Navigation6updateEm+0x55c>)
   85fdc:	4798      	blx	r3
   85fde:	f107 0374 	add.w	r3, r7, #116	; 0x74
   85fe2:	461a      	mov	r2, r3
   85fe4:	2100      	movs	r1, #0
   85fe6:	4628      	mov	r0, r5
   85fe8:	47a0      	blx	r4
   85fea:	f107 0374 	add.w	r3, r7, #116	; 0x74
   85fee:	4618      	mov	r0, r3
   85ff0:	4b61      	ldr	r3, [pc, #388]	; (86178 <_ZN3ard10Navigation6updateEm+0x560>)
   85ff2:	4798      	blx	r3
	}
      break;
   85ff4:	e16f      	b.n	862d6 <_ZN3ard10Navigation6updateEm+0x6be>
    }

  case eNavState::GOING_TO_TARGET:
    {
      if (subOrderFinished ())
   85ff6:	6878      	ldr	r0, [r7, #4]
   85ff8:	4b53      	ldr	r3, [pc, #332]	; (86148 <_ZN3ard10Navigation6updateEm+0x530>)
   85ffa:	4798      	blx	r3
   85ffc:	4603      	mov	r3, r0
   85ffe:	2b00      	cmp	r3, #0
   86000:	f000 816b 	beq.w	862da <_ZN3ard10Navigation6updateEm+0x6c2>
	{
	  //Update odom
	  m_pose.x += m_distanceToTarget * cos (m_pose.h);
   86004:	687b      	ldr	r3, [r7, #4]
   86006:	689a      	ldr	r2, [r3, #8]
   86008:	4b5c      	ldr	r3, [pc, #368]	; (8617c <_ZN3ard10Navigation6updateEm+0x564>)
   8600a:	4610      	mov	r0, r2
   8600c:	4798      	blx	r3
   8600e:	4605      	mov	r5, r0
   86010:	460e      	mov	r6, r1
   86012:	687b      	ldr	r3, [r7, #4]
   86014:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   86016:	4b59      	ldr	r3, [pc, #356]	; (8617c <_ZN3ard10Navigation6updateEm+0x564>)
   86018:	4610      	mov	r0, r2
   8601a:	4798      	blx	r3
   8601c:	4680      	mov	r8, r0
   8601e:	4689      	mov	r9, r1
   86020:	687b      	ldr	r3, [r7, #4]
   86022:	691a      	ldr	r2, [r3, #16]
   86024:	4b55      	ldr	r3, [pc, #340]	; (8617c <_ZN3ard10Navigation6updateEm+0x564>)
   86026:	4610      	mov	r0, r2
   86028:	4798      	blx	r3
   8602a:	4603      	mov	r3, r0
   8602c:	460c      	mov	r4, r1
   8602e:	4618      	mov	r0, r3
   86030:	4621      	mov	r1, r4
   86032:	4b53      	ldr	r3, [pc, #332]	; (86180 <_ZN3ard10Navigation6updateEm+0x568>)
   86034:	4798      	blx	r3
   86036:	4602      	mov	r2, r0
   86038:	460b      	mov	r3, r1
   8603a:	4c52      	ldr	r4, [pc, #328]	; (86184 <_ZN3ard10Navigation6updateEm+0x56c>)
   8603c:	4640      	mov	r0, r8
   8603e:	4649      	mov	r1, r9
   86040:	47a0      	blx	r4
   86042:	4603      	mov	r3, r0
   86044:	460c      	mov	r4, r1
   86046:	461a      	mov	r2, r3
   86048:	4623      	mov	r3, r4
   8604a:	4c4f      	ldr	r4, [pc, #316]	; (86188 <_ZN3ard10Navigation6updateEm+0x570>)
   8604c:	4628      	mov	r0, r5
   8604e:	4631      	mov	r1, r6
   86050:	47a0      	blx	r4
   86052:	4603      	mov	r3, r0
   86054:	460c      	mov	r4, r1
   86056:	4619      	mov	r1, r3
   86058:	4622      	mov	r2, r4
   8605a:	4b4c      	ldr	r3, [pc, #304]	; (8618c <_ZN3ard10Navigation6updateEm+0x574>)
   8605c:	4608      	mov	r0, r1
   8605e:	4611      	mov	r1, r2
   86060:	4798      	blx	r3
   86062:	4602      	mov	r2, r0
   86064:	687b      	ldr	r3, [r7, #4]
   86066:	609a      	str	r2, [r3, #8]
	  m_pose.y += m_distanceToTarget * sin (m_pose.h);
   86068:	687b      	ldr	r3, [r7, #4]
   8606a:	68da      	ldr	r2, [r3, #12]
   8606c:	4b43      	ldr	r3, [pc, #268]	; (8617c <_ZN3ard10Navigation6updateEm+0x564>)
   8606e:	4610      	mov	r0, r2
   86070:	4798      	blx	r3
   86072:	4605      	mov	r5, r0
   86074:	460e      	mov	r6, r1
   86076:	687b      	ldr	r3, [r7, #4]
   86078:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   8607a:	4b40      	ldr	r3, [pc, #256]	; (8617c <_ZN3ard10Navigation6updateEm+0x564>)
   8607c:	4610      	mov	r0, r2
   8607e:	4798      	blx	r3
   86080:	4680      	mov	r8, r0
   86082:	4689      	mov	r9, r1
   86084:	687b      	ldr	r3, [r7, #4]
   86086:	691a      	ldr	r2, [r3, #16]
   86088:	4b3c      	ldr	r3, [pc, #240]	; (8617c <_ZN3ard10Navigation6updateEm+0x564>)
   8608a:	4610      	mov	r0, r2
   8608c:	4798      	blx	r3
   8608e:	4603      	mov	r3, r0
   86090:	460c      	mov	r4, r1
   86092:	4618      	mov	r0, r3
   86094:	4621      	mov	r1, r4
   86096:	4b3e      	ldr	r3, [pc, #248]	; (86190 <_ZN3ard10Navigation6updateEm+0x578>)
   86098:	4798      	blx	r3
   8609a:	4602      	mov	r2, r0
   8609c:	460b      	mov	r3, r1
   8609e:	4c39      	ldr	r4, [pc, #228]	; (86184 <_ZN3ard10Navigation6updateEm+0x56c>)
   860a0:	4640      	mov	r0, r8
   860a2:	4649      	mov	r1, r9
   860a4:	47a0      	blx	r4
   860a6:	4603      	mov	r3, r0
   860a8:	460c      	mov	r4, r1
   860aa:	461a      	mov	r2, r3
   860ac:	4623      	mov	r3, r4
   860ae:	4c36      	ldr	r4, [pc, #216]	; (86188 <_ZN3ard10Navigation6updateEm+0x570>)
   860b0:	4628      	mov	r0, r5
   860b2:	4631      	mov	r1, r6
   860b4:	47a0      	blx	r4
   860b6:	4603      	mov	r3, r0
   860b8:	460c      	mov	r4, r1
   860ba:	4619      	mov	r1, r3
   860bc:	4622      	mov	r2, r4
   860be:	4b33      	ldr	r3, [pc, #204]	; (8618c <_ZN3ard10Navigation6updateEm+0x574>)
   860c0:	4608      	mov	r0, r1
   860c2:	4611      	mov	r1, r2
   860c4:	4798      	blx	r3
   860c6:	4602      	mov	r2, r0
   860c8:	687b      	ldr	r3, [r7, #4]
   860ca:	60da      	str	r2, [r3, #12]

	  //Request rotation to final heading
	  if (m_order == eNavOrder::GOTO_CAP)
   860cc:	687b      	ldr	r3, [r7, #4]
   860ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   860d0:	2b02      	cmp	r3, #2
   860d2:	f040 80a5 	bne.w	86220 <_ZN3ard10Navigation6updateEm+0x608>
	    {
	      if (m_target.h - m_pose.h < -M_PI)
   860d6:	687b      	ldr	r3, [r7, #4]
   860d8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   860da:	687b      	ldr	r3, [r7, #4]
   860dc:	6919      	ldr	r1, [r3, #16]
   860de:	4b2d      	ldr	r3, [pc, #180]	; (86194 <_ZN3ard10Navigation6updateEm+0x57c>)
   860e0:	4610      	mov	r0, r2
   860e2:	4798      	blx	r3
   860e4:	4603      	mov	r3, r0
   860e6:	461a      	mov	r2, r3
   860e8:	4b24      	ldr	r3, [pc, #144]	; (8617c <_ZN3ard10Navigation6updateEm+0x564>)
   860ea:	4610      	mov	r0, r2
   860ec:	4798      	blx	r3
   860ee:	4c2a      	ldr	r4, [pc, #168]	; (86198 <_ZN3ard10Navigation6updateEm+0x580>)
   860f0:	a311      	add	r3, pc, #68	; (adr r3, 86138 <_ZN3ard10Navigation6updateEm+0x520>)
   860f2:	e9d3 2300 	ldrd	r2, r3, [r3]
   860f6:	47a0      	blx	r4
   860f8:	4603      	mov	r3, r0
   860fa:	2b00      	cmp	r3, #0
   860fc:	d04e      	beq.n	8619c <_ZN3ard10Navigation6updateEm+0x584>
	      m_angleToTarget = m_target.h - m_pose.h + 2 * M_PI;
   860fe:	687b      	ldr	r3, [r7, #4]
   86100:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   86102:	687b      	ldr	r3, [r7, #4]
   86104:	6919      	ldr	r1, [r3, #16]
   86106:	4b23      	ldr	r3, [pc, #140]	; (86194 <_ZN3ard10Navigation6updateEm+0x57c>)
   86108:	4610      	mov	r0, r2
   8610a:	4798      	blx	r3
   8610c:	4603      	mov	r3, r0
   8610e:	461a      	mov	r2, r3
   86110:	4b1a      	ldr	r3, [pc, #104]	; (8617c <_ZN3ard10Navigation6updateEm+0x564>)
   86112:	4610      	mov	r0, r2
   86114:	4798      	blx	r3
   86116:	4c1c      	ldr	r4, [pc, #112]	; (86188 <_ZN3ard10Navigation6updateEm+0x570>)
   86118:	a309      	add	r3, pc, #36	; (adr r3, 86140 <_ZN3ard10Navigation6updateEm+0x528>)
   8611a:	e9d3 2300 	ldrd	r2, r3, [r3]
   8611e:	47a0      	blx	r4
   86120:	4603      	mov	r3, r0
   86122:	460c      	mov	r4, r1
   86124:	4619      	mov	r1, r3
   86126:	4622      	mov	r2, r4
   86128:	4b18      	ldr	r3, [pc, #96]	; (8618c <_ZN3ard10Navigation6updateEm+0x574>)
   8612a:	4608      	mov	r0, r1
   8612c:	4611      	mov	r1, r2
   8612e:	4798      	blx	r3
   86130:	4602      	mov	r2, r0
   86132:	687b      	ldr	r3, [r7, #4]
   86134:	631a      	str	r2, [r3, #48]	; 0x30
   86136:	e06d      	b.n	86214 <_ZN3ard10Navigation6updateEm+0x5fc>
   86138:	54442d18 	.word	0x54442d18
   8613c:	c00921fb 	.word	0xc00921fb
   86140:	54442d18 	.word	0x54442d18
   86144:	401921fb 	.word	0x401921fb
   86148:	00086945 	.word	0x00086945
   8614c:	00092e19 	.word	0x00092e19
   86150:	0008f6d9 	.word	0x0008f6d9
   86154:	00092f81 	.word	0x00092f81
   86158:	00085a51 	.word	0x00085a51
   8615c:	0008f951 	.word	0x0008f951
   86160:	00093029 	.word	0x00093029
   86164:	000859fd 	.word	0x000859fd
   86168:	00086741 	.word	0x00086741
   8616c:	000859e9 	.word	0x000859e9
   86170:	0009a7e4 	.word	0x0009a7e4
   86174:	00089009 	.word	0x00089009
   86178:	00089145 	.word	0x00089145
   8617c:	000926d5 	.word	0x000926d5
   86180:	000909d9 	.word	0x000909d9
   86184:	0009277d 	.word	0x0009277d
   86188:	00092419 	.word	0x00092419
   8618c:	00092d6d 	.word	0x00092d6d
   86190:	00090a69 	.word	0x00090a69
   86194:	00092e15 	.word	0x00092e15
   86198:	00092c61 	.word	0x00092c61
	      else if (m_target.h - m_pose.h > M_PI)
   8619c:	687b      	ldr	r3, [r7, #4]
   8619e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   861a0:	687b      	ldr	r3, [r7, #4]
   861a2:	6919      	ldr	r1, [r3, #16]
   861a4:	4b5c      	ldr	r3, [pc, #368]	; (86318 <_ZN3ard10Navigation6updateEm+0x700>)
   861a6:	4610      	mov	r0, r2
   861a8:	4798      	blx	r3
   861aa:	4603      	mov	r3, r0
   861ac:	461a      	mov	r2, r3
   861ae:	4b5b      	ldr	r3, [pc, #364]	; (8631c <_ZN3ard10Navigation6updateEm+0x704>)
   861b0:	4610      	mov	r0, r2
   861b2:	4798      	blx	r3
   861b4:	4c5a      	ldr	r4, [pc, #360]	; (86320 <_ZN3ard10Navigation6updateEm+0x708>)
   861b6:	a354      	add	r3, pc, #336	; (adr r3, 86308 <_ZN3ard10Navigation6updateEm+0x6f0>)
   861b8:	e9d3 2300 	ldrd	r2, r3, [r3]
   861bc:	47a0      	blx	r4
   861be:	4603      	mov	r3, r0
   861c0:	2b00      	cmp	r3, #0
   861c2:	d01c      	beq.n	861fe <_ZN3ard10Navigation6updateEm+0x5e6>
	      m_angleToTarget = m_target.h - m_pose.h - 2 * M_PI;
   861c4:	687b      	ldr	r3, [r7, #4]
   861c6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   861c8:	687b      	ldr	r3, [r7, #4]
   861ca:	6919      	ldr	r1, [r3, #16]
   861cc:	4b52      	ldr	r3, [pc, #328]	; (86318 <_ZN3ard10Navigation6updateEm+0x700>)
   861ce:	4610      	mov	r0, r2
   861d0:	4798      	blx	r3
   861d2:	4603      	mov	r3, r0
   861d4:	461a      	mov	r2, r3
   861d6:	4b51      	ldr	r3, [pc, #324]	; (8631c <_ZN3ard10Navigation6updateEm+0x704>)
   861d8:	4610      	mov	r0, r2
   861da:	4798      	blx	r3
   861dc:	4c51      	ldr	r4, [pc, #324]	; (86324 <_ZN3ard10Navigation6updateEm+0x70c>)
   861de:	a34c      	add	r3, pc, #304	; (adr r3, 86310 <_ZN3ard10Navigation6updateEm+0x6f8>)
   861e0:	e9d3 2300 	ldrd	r2, r3, [r3]
   861e4:	47a0      	blx	r4
   861e6:	4603      	mov	r3, r0
   861e8:	460c      	mov	r4, r1
   861ea:	4619      	mov	r1, r3
   861ec:	4622      	mov	r2, r4
   861ee:	4b4e      	ldr	r3, [pc, #312]	; (86328 <_ZN3ard10Navigation6updateEm+0x710>)
   861f0:	4608      	mov	r0, r1
   861f2:	4611      	mov	r1, r2
   861f4:	4798      	blx	r3
   861f6:	4602      	mov	r2, r0
   861f8:	687b      	ldr	r3, [r7, #4]
   861fa:	631a      	str	r2, [r3, #48]	; 0x30
   861fc:	e00a      	b.n	86214 <_ZN3ard10Navigation6updateEm+0x5fc>
	      else
	      m_angleToTarget = m_target.h - m_pose.h;
   861fe:	687b      	ldr	r3, [r7, #4]
   86200:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   86202:	687b      	ldr	r3, [r7, #4]
   86204:	6919      	ldr	r1, [r3, #16]
   86206:	4b44      	ldr	r3, [pc, #272]	; (86318 <_ZN3ard10Navigation6updateEm+0x700>)
   86208:	4610      	mov	r0, r2
   8620a:	4798      	blx	r3
   8620c:	4603      	mov	r3, r0
   8620e:	461a      	mov	r2, r3
   86210:	687b      	ldr	r3, [r7, #4]
   86212:	631a      	str	r2, [r3, #48]	; 0x30
	      turn (m_angleToTarget);
   86214:	687b      	ldr	r3, [r7, #4]
   86216:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   86218:	4619      	mov	r1, r3
   8621a:	6878      	ldr	r0, [r7, #4]
   8621c:	4b43      	ldr	r3, [pc, #268]	; (8632c <_ZN3ard10Navigation6updateEm+0x714>)
   8621e:	4798      	blx	r3
	    }

	  //Change state
	  m_distanceToTarget = 0;
   86220:	687b      	ldr	r3, [r7, #4]
   86222:	f04f 0200 	mov.w	r2, #0
   86226:	635a      	str	r2, [r3, #52]	; 0x34
	  m_state = eNavState::TURNING_AT_TARGET;
   86228:	687b      	ldr	r3, [r7, #4]
   8622a:	2203      	movs	r2, #3
   8622c:	615a      	str	r2, [r3, #20]
	}
      break;
   8622e:	e054      	b.n	862da <_ZN3ard10Navigation6updateEm+0x6c2>
    }

  case eNavState::TURNING_AT_TARGET:
    {
      if (subOrderFinished ())
   86230:	6878      	ldr	r0, [r7, #4]
   86232:	4b3f      	ldr	r3, [pc, #252]	; (86330 <_ZN3ard10Navigation6updateEm+0x718>)
   86234:	4798      	blx	r3
   86236:	4603      	mov	r3, r0
   86238:	2b00      	cmp	r3, #0
   8623a:	d050      	beq.n	862de <_ZN3ard10Navigation6updateEm+0x6c6>
	{
	  m_angleToTarget = 0;
   8623c:	687b      	ldr	r3, [r7, #4]
   8623e:	f04f 0200 	mov.w	r2, #0
   86242:	631a      	str	r2, [r3, #48]	; 0x30
	  m_state = eNavState::IDLE;
   86244:	687b      	ldr	r3, [r7, #4]
   86246:	2200      	movs	r2, #0
   86248:	615a      	str	r2, [r3, #20]
	  m_order = eNavOrder::NOTHING;
   8624a:	687b      	ldr	r3, [r7, #4]
   8624c:	2200      	movs	r2, #0
   8624e:	62da      	str	r2, [r3, #44]	; 0x2c
	  g_ArdOs.Signal_set(m_targetReached);
   86250:	4b38      	ldr	r3, [pc, #224]	; (86334 <_ZN3ard10Navigation6updateEm+0x71c>)
   86252:	4798      	blx	r3
   86254:	4602      	mov	r2, r0
   86256:	687b      	ldr	r3, [r7, #4]
   86258:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
   8625c:	4619      	mov	r1, r3
   8625e:	4610      	mov	r0, r2
   86260:	4b35      	ldr	r3, [pc, #212]	; (86338 <_ZN3ard10Navigation6updateEm+0x720>)
   86262:	4798      	blx	r3
	  LOG(INFO, "NAV : order finished.");
   86264:	4b35      	ldr	r3, [pc, #212]	; (8633c <_ZN3ard10Navigation6updateEm+0x724>)
   86266:	4798      	blx	r3
   86268:	4605      	mov	r5, r0
   8626a:	682b      	ldr	r3, [r5, #0]
   8626c:	3310      	adds	r3, #16
   8626e:	681c      	ldr	r4, [r3, #0]
   86270:	f107 0380 	add.w	r3, r7, #128	; 0x80
   86274:	4932      	ldr	r1, [pc, #200]	; (86340 <_ZN3ard10Navigation6updateEm+0x728>)
   86276:	4618      	mov	r0, r3
   86278:	4b32      	ldr	r3, [pc, #200]	; (86344 <_ZN3ard10Navigation6updateEm+0x72c>)
   8627a:	4798      	blx	r3
   8627c:	f107 0380 	add.w	r3, r7, #128	; 0x80
   86280:	461a      	mov	r2, r3
   86282:	2101      	movs	r1, #1
   86284:	4628      	mov	r0, r5
   86286:	47a0      	blx	r4
   86288:	f107 0380 	add.w	r3, r7, #128	; 0x80
   8628c:	4618      	mov	r0, r3
   8628e:	4b2e      	ldr	r3, [pc, #184]	; (86348 <_ZN3ard10Navigation6updateEm+0x730>)
   86290:	4798      	blx	r3
	}
      break;
   86292:	e024      	b.n	862de <_ZN3ard10Navigation6updateEm+0x6c6>
    }

  //TODO attention si on s'arrete avec ca, on ne compte pas le deplacement car c'est normalement fait a la fin
  case eNavState::INTERRUPTING_ORDER:
    {
      if (subOrderFinished ())
   86294:	6878      	ldr	r0, [r7, #4]
   86296:	4b26      	ldr	r3, [pc, #152]	; (86330 <_ZN3ard10Navigation6updateEm+0x718>)
   86298:	4798      	blx	r3
   8629a:	4603      	mov	r3, r0
   8629c:	2b00      	cmp	r3, #0
   8629e:	d020      	beq.n	862e2 <_ZN3ard10Navigation6updateEm+0x6ca>
	{
	  m_state = eNavState::IDLE;
   862a0:	687b      	ldr	r3, [r7, #4]
   862a2:	2200      	movs	r2, #0
   862a4:	615a      	str	r2, [r3, #20]
	  LOG(INFO, "NAV : order interrupted.");
   862a6:	4b25      	ldr	r3, [pc, #148]	; (8633c <_ZN3ard10Navigation6updateEm+0x724>)
   862a8:	4798      	blx	r3
   862aa:	4605      	mov	r5, r0
   862ac:	682b      	ldr	r3, [r5, #0]
   862ae:	3310      	adds	r3, #16
   862b0:	681c      	ldr	r4, [r3, #0]
   862b2:	f107 038c 	add.w	r3, r7, #140	; 0x8c
   862b6:	4925      	ldr	r1, [pc, #148]	; (8634c <_ZN3ard10Navigation6updateEm+0x734>)
   862b8:	4618      	mov	r0, r3
   862ba:	4b22      	ldr	r3, [pc, #136]	; (86344 <_ZN3ard10Navigation6updateEm+0x72c>)
   862bc:	4798      	blx	r3
   862be:	f107 038c 	add.w	r3, r7, #140	; 0x8c
   862c2:	461a      	mov	r2, r3
   862c4:	2101      	movs	r1, #1
   862c6:	4628      	mov	r0, r5
   862c8:	47a0      	blx	r4
   862ca:	f107 038c 	add.w	r3, r7, #140	; 0x8c
   862ce:	4618      	mov	r0, r3
   862d0:	4b1d      	ldr	r3, [pc, #116]	; (86348 <_ZN3ard10Navigation6updateEm+0x730>)
   862d2:	4798      	blx	r3
	}
      break;
   862d4:	e005      	b.n	862e2 <_ZN3ard10Navigation6updateEm+0x6ca>
	  //Change state
	  m_angleToTarget = 0;
	  m_state = eNavState::GOING_TO_TARGET;
	  LOG(DEBUG, "NAV : facing destination, beginning line.");
	}
      break;
   862d6:	bf00      	nop
   862d8:	e004      	b.n	862e4 <_ZN3ard10Navigation6updateEm+0x6cc>

	  //Change state
	  m_distanceToTarget = 0;
	  m_state = eNavState::TURNING_AT_TARGET;
	}
      break;
   862da:	bf00      	nop
   862dc:	e002      	b.n	862e4 <_ZN3ard10Navigation6updateEm+0x6cc>
	  m_state = eNavState::IDLE;
	  m_order = eNavOrder::NOTHING;
	  g_ArdOs.Signal_set(m_targetReached);
	  LOG(INFO, "NAV : order finished.");
	}
      break;
   862de:	bf00      	nop
   862e0:	e000      	b.n	862e4 <_ZN3ard10Navigation6updateEm+0x6cc>
      if (subOrderFinished ())
	{
	  m_state = eNavState::IDLE;
	  LOG(INFO, "NAV : order interrupted.");
	}
      break;
   862e2:	bf00      	nop
    }
}

  g_ArdOs.Mutex_unlock(m_mutex);
   862e4:	4b13      	ldr	r3, [pc, #76]	; (86334 <_ZN3ard10Navigation6updateEm+0x71c>)
   862e6:	4798      	blx	r3
   862e8:	4602      	mov	r2, r0
   862ea:	687b      	ldr	r3, [r7, #4]
   862ec:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
   862f0:	4619      	mov	r1, r3
   862f2:	4610      	mov	r0, r2
   862f4:	4b16      	ldr	r3, [pc, #88]	; (86350 <_ZN3ard10Navigation6updateEm+0x738>)
   862f6:	4798      	blx	r3
}
   862f8:	bf00      	nop
   862fa:	379c      	adds	r7, #156	; 0x9c
   862fc:	46bd      	mov	sp, r7
   862fe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   86302:	bf00      	nop
   86304:	f3af 8000 	nop.w
   86308:	54442d18 	.word	0x54442d18
   8630c:	400921fb 	.word	0x400921fb
   86310:	54442d18 	.word	0x54442d18
   86314:	401921fb 	.word	0x401921fb
   86318:	00092e15 	.word	0x00092e15
   8631c:	000926d5 	.word	0x000926d5
   86320:	00092c9d 	.word	0x00092c9d
   86324:	00092415 	.word	0x00092415
   86328:	00092d6d 	.word	0x00092d6d
   8632c:	00086819 	.word	0x00086819
   86330:	00086945 	.word	0x00086945
   86334:	00082fad 	.word	0x00082fad
   86338:	00083d91 	.word	0x00083d91
   8633c:	000859e9 	.word	0x000859e9
   86340:	0009a810 	.word	0x0009a810
   86344:	00089009 	.word	0x00089009
   86348:	00089145 	.word	0x00089145
   8634c:	0009a828 	.word	0x0009a828
   86350:	00084131 	.word	0x00084131

00086354 <_ZN3ard10Navigation19updateFromInterruptEv>:

void
Navigation::updateFromInterrupt ()
{
   86354:	b580      	push	{r7, lr}
   86356:	b082      	sub	sp, #8
   86358:	af00      	add	r7, sp, #0
   8635a:	6078      	str	r0, [r7, #4]
  stepperG.run ();
   8635c:	687b      	ldr	r3, [r7, #4]
   8635e:	3338      	adds	r3, #56	; 0x38
   86360:	4618      	mov	r0, r3
   86362:	4b05      	ldr	r3, [pc, #20]	; (86378 <_ZN3ard10Navigation19updateFromInterruptEv+0x24>)
   86364:	4798      	blx	r3
  stepperD.run ();
   86366:	687b      	ldr	r3, [r7, #4]
   86368:	338c      	adds	r3, #140	; 0x8c
   8636a:	4618      	mov	r0, r3
   8636c:	4b02      	ldr	r3, [pc, #8]	; (86378 <_ZN3ard10Navigation19updateFromInterruptEv+0x24>)
   8636e:	4798      	blx	r3
  //TODO compute_odom ?
}
   86370:	bf00      	nop
   86372:	3708      	adds	r7, #8
   86374:	46bd      	mov	sp, r7
   86376:	bd80      	pop	{r7, pc}
   86378:	00089a45 	.word	0x00089a45

0008637c <_ZN3ard5PointaSERKS0_>:
   8637c:	b480      	push	{r7}
   8637e:	b083      	sub	sp, #12
   86380:	af00      	add	r7, sp, #0
   86382:	6078      	str	r0, [r7, #4]
   86384:	6039      	str	r1, [r7, #0]
   86386:	683b      	ldr	r3, [r7, #0]
   86388:	685a      	ldr	r2, [r3, #4]
   8638a:	687b      	ldr	r3, [r7, #4]
   8638c:	605a      	str	r2, [r3, #4]
   8638e:	683b      	ldr	r3, [r7, #0]
   86390:	689a      	ldr	r2, [r3, #8]
   86392:	687b      	ldr	r3, [r7, #4]
   86394:	609a      	str	r2, [r3, #8]
   86396:	687b      	ldr	r3, [r7, #4]
   86398:	4618      	mov	r0, r3
   8639a:	370c      	adds	r7, #12
   8639c:	46bd      	mov	sp, r7
   8639e:	bc80      	pop	{r7}
   863a0:	4770      	bx	lr
   863a2:	bf00      	nop

000863a4 <_ZN3ard8PointCapaSEOS0_>:
    String
    virtual toString ();
  };

  //Represent a pose in a 2D space : Point + heading
  class PointCap : public Point
   863a4:	b580      	push	{r7, lr}
   863a6:	b082      	sub	sp, #8
   863a8:	af00      	add	r7, sp, #0
   863aa:	6078      	str	r0, [r7, #4]
   863ac:	6039      	str	r1, [r7, #0]
   863ae:	687b      	ldr	r3, [r7, #4]
   863b0:	683a      	ldr	r2, [r7, #0]
   863b2:	4611      	mov	r1, r2
   863b4:	4618      	mov	r0, r3
   863b6:	4b05      	ldr	r3, [pc, #20]	; (863cc <_ZN3ard8PointCapaSEOS0_+0x28>)
   863b8:	4798      	blx	r3
   863ba:	683b      	ldr	r3, [r7, #0]
   863bc:	68da      	ldr	r2, [r3, #12]
   863be:	687b      	ldr	r3, [r7, #4]
   863c0:	60da      	str	r2, [r3, #12]
   863c2:	687b      	ldr	r3, [r7, #4]
   863c4:	4618      	mov	r0, r3
   863c6:	3708      	adds	r7, #8
   863c8:	46bd      	mov	sp, r7
   863ca:	bd80      	pop	{r7, pc}
   863cc:	0008637d 	.word	0x0008637d

000863d0 <_ZN3ard10Navigation11setPositionENS_8PointCapE>:
 * User (= strategy) interface
 ---------------------------------*/

void
Navigation::setPosition (PointCap newPose)
{
   863d0:	b5b0      	push	{r4, r5, r7, lr}
   863d2:	b08c      	sub	sp, #48	; 0x30
   863d4:	af00      	add	r7, sp, #0
   863d6:	6078      	str	r0, [r7, #4]
   863d8:	6039      	str	r1, [r7, #0]
  m_pose = newPose.toAmbiPose (m_color);
   863da:	687b      	ldr	r3, [r7, #4]
   863dc:	1d1c      	adds	r4, r3, #4
   863de:	687b      	ldr	r3, [r7, #4]
   863e0:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
   863e4:	f107 0308 	add.w	r3, r7, #8
   863e8:	6839      	ldr	r1, [r7, #0]
   863ea:	4618      	mov	r0, r3
   863ec:	4b1c      	ldr	r3, [pc, #112]	; (86460 <_ZN3ard10Navigation11setPositionENS_8PointCapE+0x90>)
   863ee:	4798      	blx	r3
   863f0:	f107 0308 	add.w	r3, r7, #8
   863f4:	4619      	mov	r1, r3
   863f6:	4620      	mov	r0, r4
   863f8:	4b1a      	ldr	r3, [pc, #104]	; (86464 <_ZN3ard10Navigation11setPositionENS_8PointCapE+0x94>)
   863fa:	4798      	blx	r3
   863fc:	f107 0308 	add.w	r3, r7, #8
   86400:	4618      	mov	r0, r3
   86402:	4b19      	ldr	r3, [pc, #100]	; (86468 <_ZN3ard10Navigation11setPositionENS_8PointCapE+0x98>)
   86404:	4798      	blx	r3
  LOG(INFO, "NAV : position set to :" + newPose.toString ());
   86406:	4b19      	ldr	r3, [pc, #100]	; (8646c <_ZN3ard10Navigation11setPositionENS_8PointCapE+0x9c>)
   86408:	4798      	blx	r3
   8640a:	4605      	mov	r5, r0
   8640c:	682b      	ldr	r3, [r5, #0]
   8640e:	3310      	adds	r3, #16
   86410:	681c      	ldr	r4, [r3, #0]
   86412:	f107 0318 	add.w	r3, r7, #24
   86416:	4916      	ldr	r1, [pc, #88]	; (86470 <_ZN3ard10Navigation11setPositionENS_8PointCapE+0xa0>)
   86418:	4618      	mov	r0, r3
   8641a:	4b16      	ldr	r3, [pc, #88]	; (86474 <_ZN3ard10Navigation11setPositionENS_8PointCapE+0xa4>)
   8641c:	4798      	blx	r3
   8641e:	f107 0324 	add.w	r3, r7, #36	; 0x24
   86422:	6839      	ldr	r1, [r7, #0]
   86424:	4618      	mov	r0, r3
   86426:	4b14      	ldr	r3, [pc, #80]	; (86478 <_ZN3ard10Navigation11setPositionENS_8PointCapE+0xa8>)
   86428:	4798      	blx	r3
   8642a:	f107 0224 	add.w	r2, r7, #36	; 0x24
   8642e:	f107 0318 	add.w	r3, r7, #24
   86432:	4611      	mov	r1, r2
   86434:	4618      	mov	r0, r3
   86436:	4b11      	ldr	r3, [pc, #68]	; (8647c <_ZN3ard10Navigation11setPositionENS_8PointCapE+0xac>)
   86438:	4798      	blx	r3
   8643a:	4603      	mov	r3, r0
   8643c:	461a      	mov	r2, r3
   8643e:	2101      	movs	r1, #1
   86440:	4628      	mov	r0, r5
   86442:	47a0      	blx	r4
   86444:	f107 0324 	add.w	r3, r7, #36	; 0x24
   86448:	4618      	mov	r0, r3
   8644a:	4b0d      	ldr	r3, [pc, #52]	; (86480 <_ZN3ard10Navigation11setPositionENS_8PointCapE+0xb0>)
   8644c:	4798      	blx	r3
   8644e:	f107 0318 	add.w	r3, r7, #24
   86452:	4618      	mov	r0, r3
   86454:	4b0b      	ldr	r3, [pc, #44]	; (86484 <_ZN3ard10Navigation11setPositionENS_8PointCapE+0xb4>)
   86456:	4798      	blx	r3
}
   86458:	bf00      	nop
   8645a:	3730      	adds	r7, #48	; 0x30
   8645c:	46bd      	mov	sp, r7
   8645e:	bdb0      	pop	{r4, r5, r7, pc}
   86460:	0008fb59 	.word	0x0008fb59
   86464:	000863a5 	.word	0x000863a5
   86468:	00086b11 	.word	0x00086b11
   8646c:	000859e9 	.word	0x000859e9
   86470:	0009a844 	.word	0x0009a844
   86474:	00085971 	.word	0x00085971
   86478:	0008fbf1 	.word	0x0008fbf1
   8647c:	000894d5 	.word	0x000894d5
   86480:	00089145 	.word	0x00089145
   86484:	00082fe9 	.word	0x00082fe9

00086488 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE>:

void
Navigation::goTo (Point target, sens_t sens)
{
   86488:	b5b0      	push	{r4, r5, r7, lr}
   8648a:	b08e      	sub	sp, #56	; 0x38
   8648c:	af00      	add	r7, sp, #0
   8648e:	60f8      	str	r0, [r7, #12]
   86490:	60b9      	str	r1, [r7, #8]
   86492:	4613      	mov	r3, r2
   86494:	71fb      	strb	r3, [r7, #7]
  g_ArdOs.Mutex_lock(m_mutex);
   86496:	4b3a      	ldr	r3, [pc, #232]	; (86580 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0xf8>)
   86498:	4798      	blx	r3
   8649a:	4602      	mov	r2, r0
   8649c:	68fb      	ldr	r3, [r7, #12]
   8649e:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
   864a2:	4619      	mov	r1, r3
   864a4:	4610      	mov	r0, r2
   864a6:	4b37      	ldr	r3, [pc, #220]	; (86584 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0xfc>)
   864a8:	4798      	blx	r3
  //If an order is present, wait
  if (m_state != eNavState::IDLE)
   864aa:	68fb      	ldr	r3, [r7, #12]
   864ac:	695b      	ldr	r3, [r3, #20]
   864ae:	2b00      	cmp	r3, #0
   864b0:	d02d      	beq.n	8650e <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x86>
    {
      LOG(INFO, "NAV : new order pending until current order is finished");
   864b2:	4b35      	ldr	r3, [pc, #212]	; (86588 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x100>)
   864b4:	4798      	blx	r3
   864b6:	4605      	mov	r5, r0
   864b8:	682b      	ldr	r3, [r5, #0]
   864ba:	3310      	adds	r3, #16
   864bc:	681c      	ldr	r4, [r3, #0]
   864be:	f107 0310 	add.w	r3, r7, #16
   864c2:	4932      	ldr	r1, [pc, #200]	; (8658c <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x104>)
   864c4:	4618      	mov	r0, r3
   864c6:	4b32      	ldr	r3, [pc, #200]	; (86590 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x108>)
   864c8:	4798      	blx	r3
   864ca:	f107 0310 	add.w	r3, r7, #16
   864ce:	461a      	mov	r2, r3
   864d0:	2101      	movs	r1, #1
   864d2:	4628      	mov	r0, r5
   864d4:	47a0      	blx	r4
   864d6:	f107 0310 	add.w	r3, r7, #16
   864da:	4618      	mov	r0, r3
   864dc:	4b2d      	ldr	r3, [pc, #180]	; (86594 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x10c>)
   864de:	4798      	blx	r3
      g_ArdOs.Mutex_unlock(m_mutex);
   864e0:	4b27      	ldr	r3, [pc, #156]	; (86580 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0xf8>)
   864e2:	4798      	blx	r3
   864e4:	4602      	mov	r2, r0
   864e6:	68fb      	ldr	r3, [r7, #12]
   864e8:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
   864ec:	4619      	mov	r1, r3
   864ee:	4610      	mov	r0, r2
   864f0:	4b29      	ldr	r3, [pc, #164]	; (86598 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x110>)
   864f2:	4798      	blx	r3
      wait ();
   864f4:	68f8      	ldr	r0, [r7, #12]
   864f6:	4b29      	ldr	r3, [pc, #164]	; (8659c <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x114>)
   864f8:	4798      	blx	r3
      g_ArdOs.Mutex_lock(m_mutex);
   864fa:	4b21      	ldr	r3, [pc, #132]	; (86580 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0xf8>)
   864fc:	4798      	blx	r3
   864fe:	4602      	mov	r2, r0
   86500:	68fb      	ldr	r3, [r7, #12]
   86502:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
   86506:	4619      	mov	r1, r3
   86508:	4610      	mov	r0, r2
   8650a:	4b1e      	ldr	r3, [pc, #120]	; (86584 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0xfc>)
   8650c:	4798      	blx	r3
    }

  m_order = eNavOrder::GOTO;
   8650e:	68fb      	ldr	r3, [r7, #12]
   86510:	2201      	movs	r2, #1
   86512:	62da      	str	r2, [r3, #44]	; 0x2c
  m_target = target.toAmbiPose (m_color);
   86514:	68fb      	ldr	r3, [r7, #12]
   86516:	f103 0418 	add.w	r4, r3, #24
   8651a:	68fb      	ldr	r3, [r7, #12]
   8651c:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
   86520:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   86524:	68b9      	ldr	r1, [r7, #8]
   86526:	4618      	mov	r0, r3
   86528:	4b1d      	ldr	r3, [pc, #116]	; (865a0 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x118>)
   8652a:	4798      	blx	r3
   8652c:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   86530:	f107 031c 	add.w	r3, r7, #28
   86534:	4611      	mov	r1, r2
   86536:	4618      	mov	r0, r3
   86538:	4b1a      	ldr	r3, [pc, #104]	; (865a4 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x11c>)
   8653a:	4798      	blx	r3
   8653c:	f107 031c 	add.w	r3, r7, #28
   86540:	4619      	mov	r1, r3
   86542:	4620      	mov	r0, r4
   86544:	4b18      	ldr	r3, [pc, #96]	; (865a8 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x120>)
   86546:	4798      	blx	r3
   86548:	f107 031c 	add.w	r3, r7, #28
   8654c:	4618      	mov	r0, r3
   8654e:	4b17      	ldr	r3, [pc, #92]	; (865ac <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x124>)
   86550:	4798      	blx	r3
   86552:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   86556:	4618      	mov	r0, r3
   86558:	4b15      	ldr	r3, [pc, #84]	; (865b0 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x128>)
   8655a:	4798      	blx	r3
  m_sensTarget = sens;
   8655c:	68fb      	ldr	r3, [r7, #12]
   8655e:	79fa      	ldrb	r2, [r7, #7]
   86560:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28

  g_ArdOs.Mutex_unlock(m_mutex);
   86564:	4b06      	ldr	r3, [pc, #24]	; (86580 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0xf8>)
   86566:	4798      	blx	r3
   86568:	4602      	mov	r2, r0
   8656a:	68fb      	ldr	r3, [r7, #12]
   8656c:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
   86570:	4619      	mov	r1, r3
   86572:	4610      	mov	r0, r2
   86574:	4b08      	ldr	r3, [pc, #32]	; (86598 <_ZN3ard10Navigation4goToENS_5PointENS_6sens_tE+0x110>)
   86576:	4798      	blx	r3
}
   86578:	bf00      	nop
   8657a:	3738      	adds	r7, #56	; 0x38
   8657c:	46bd      	mov	sp, r7
   8657e:	bdb0      	pop	{r4, r5, r7, pc}
   86580:	00082fad 	.word	0x00082fad
   86584:	00084069 	.word	0x00084069
   86588:	000859e9 	.word	0x000859e9
   8658c:	0009a85c 	.word	0x0009a85c
   86590:	00089009 	.word	0x00089009
   86594:	00089145 	.word	0x00089145
   86598:	00084131 	.word	0x00084131
   8659c:	000865b5 	.word	0x000865b5
   865a0:	0008f7f1 	.word	0x0008f7f1
   865a4:	0008fae1 	.word	0x0008fae1
   865a8:	000863a5 	.word	0x000863a5
   865ac:	00086b11 	.word	0x00086b11
   865b0:	000859fd 	.word	0x000859fd

000865b4 <_ZN3ard10Navigation4waitEv>:
  g_ArdOs.Mutex_unlock(m_mutex);
}

void
Navigation::wait ()
{
   865b4:	b580      	push	{r7, lr}
   865b6:	b082      	sub	sp, #8
   865b8:	af00      	add	r7, sp, #0
   865ba:	6078      	str	r0, [r7, #4]
  //obvisouly don't put a mutex, it's a blocking call ... !
  g_ArdOs.Signal_wait(m_targetReached);
   865bc:	4b06      	ldr	r3, [pc, #24]	; (865d8 <_ZN3ard10Navigation4waitEv+0x24>)
   865be:	4798      	blx	r3
   865c0:	4602      	mov	r2, r0
   865c2:	687b      	ldr	r3, [r7, #4]
   865c4:	f8d3 3170 	ldr.w	r3, [r3, #368]	; 0x170
   865c8:	4619      	mov	r1, r3
   865ca:	4610      	mov	r0, r2
   865cc:	4b03      	ldr	r3, [pc, #12]	; (865dc <_ZN3ard10Navigation4waitEv+0x28>)
   865ce:	4798      	blx	r3
}
   865d0:	bf00      	nop
   865d2:	3708      	adds	r7, #8
   865d4:	46bd      	mov	sp, r7
   865d6:	bd80      	pop	{r7, pc}
   865d8:	00082fad 	.word	0x00082fad
   865dc:	00083e59 	.word	0x00083e59

000865e0 <_ZN3ard10Navigation8setColorE6eColor>:
 * Nav configuration
 ---------------------------------*/

void
Navigation::setColor (eColor c)
{
   865e0:	b5b0      	push	{r4, r5, r7, lr}
   865e2:	b092      	sub	sp, #72	; 0x48
   865e4:	af00      	add	r7, sp, #0
   865e6:	6078      	str	r0, [r7, #4]
   865e8:	6039      	str	r1, [r7, #0]
  ardAssert(c != eColor::UNDEF, "NAV : color should not be set to undefined.");
   865ea:	683b      	ldr	r3, [r7, #0]
   865ec:	2b00      	cmp	r3, #0
   865ee:	d137      	bne.n	86660 <_ZN3ard10Navigation8setColorE6eColor+0x80>
   865f0:	4b42      	ldr	r3, [pc, #264]	; (866fc <_ZN3ard10Navigation8setColorE6eColor+0x11c>)
   865f2:	4798      	blx	r3
   865f4:	4604      	mov	r4, r0
   865f6:	f107 0324 	add.w	r3, r7, #36	; 0x24
   865fa:	4941      	ldr	r1, [pc, #260]	; (86700 <_ZN3ard10Navigation8setColorE6eColor+0x120>)
   865fc:	4618      	mov	r0, r3
   865fe:	4b41      	ldr	r3, [pc, #260]	; (86704 <_ZN3ard10Navigation8setColorE6eColor+0x124>)
   86600:	4798      	blx	r3
   86602:	f107 0224 	add.w	r2, r7, #36	; 0x24
   86606:	f107 0318 	add.w	r3, r7, #24
   8660a:	4611      	mov	r1, r2
   8660c:	4618      	mov	r0, r3
   8660e:	4b3e      	ldr	r3, [pc, #248]	; (86708 <_ZN3ard10Navigation8setColorE6eColor+0x128>)
   86610:	4798      	blx	r3
   86612:	f107 0318 	add.w	r3, r7, #24
   86616:	493d      	ldr	r1, [pc, #244]	; (8670c <_ZN3ard10Navigation8setColorE6eColor+0x12c>)
   86618:	4618      	mov	r0, r3
   8661a:	4b3d      	ldr	r3, [pc, #244]	; (86710 <_ZN3ard10Navigation8setColorE6eColor+0x130>)
   8661c:	4798      	blx	r3
   8661e:	4603      	mov	r3, r0
   86620:	461a      	mov	r2, r3
   86622:	f107 030c 	add.w	r3, r7, #12
   86626:	4611      	mov	r1, r2
   86628:	4618      	mov	r0, r3
   8662a:	4b3a      	ldr	r3, [pc, #232]	; (86714 <_ZN3ard10Navigation8setColorE6eColor+0x134>)
   8662c:	4798      	blx	r3
   8662e:	f107 030c 	add.w	r3, r7, #12
   86632:	4619      	mov	r1, r3
   86634:	4620      	mov	r0, r4
   86636:	4b38      	ldr	r3, [pc, #224]	; (86718 <_ZN3ard10Navigation8setColorE6eColor+0x138>)
   86638:	4798      	blx	r3
   8663a:	f107 030c 	add.w	r3, r7, #12
   8663e:	4618      	mov	r0, r3
   86640:	4b36      	ldr	r3, [pc, #216]	; (8671c <_ZN3ard10Navigation8setColorE6eColor+0x13c>)
   86642:	4798      	blx	r3
   86644:	f107 0318 	add.w	r3, r7, #24
   86648:	4618      	mov	r0, r3
   8664a:	4b35      	ldr	r3, [pc, #212]	; (86720 <_ZN3ard10Navigation8setColorE6eColor+0x140>)
   8664c:	4798      	blx	r3
   8664e:	f107 0324 	add.w	r3, r7, #36	; 0x24
   86652:	4618      	mov	r0, r3
   86654:	4b31      	ldr	r3, [pc, #196]	; (8671c <_ZN3ard10Navigation8setColorE6eColor+0x13c>)
   86656:	4798      	blx	r3
   86658:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   8665c:	4b31      	ldr	r3, [pc, #196]	; (86724 <_ZN3ard10Navigation8setColorE6eColor+0x144>)
   8665e:	4798      	blx	r3
  g_ArdOs.Mutex_lock(m_mutex);
   86660:	4b26      	ldr	r3, [pc, #152]	; (866fc <_ZN3ard10Navigation8setColorE6eColor+0x11c>)
   86662:	4798      	blx	r3
   86664:	4602      	mov	r2, r0
   86666:	687b      	ldr	r3, [r7, #4]
   86668:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
   8666c:	4619      	mov	r1, r3
   8666e:	4610      	mov	r0, r2
   86670:	4b2d      	ldr	r3, [pc, #180]	; (86728 <_ZN3ard10Navigation8setColorE6eColor+0x148>)
   86672:	4798      	blx	r3
  m_color = c;
   86674:	687b      	ldr	r3, [r7, #4]
   86676:	683a      	ldr	r2, [r7, #0]
   86678:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
  g_ArdOs.Mutex_unlock(m_mutex);
   8667c:	4b1f      	ldr	r3, [pc, #124]	; (866fc <_ZN3ard10Navigation8setColorE6eColor+0x11c>)
   8667e:	4798      	blx	r3
   86680:	4602      	mov	r2, r0
   86682:	687b      	ldr	r3, [r7, #4]
   86684:	f8d3 316c 	ldr.w	r3, [r3, #364]	; 0x16c
   86688:	4619      	mov	r1, r3
   8668a:	4610      	mov	r0, r2
   8668c:	4b27      	ldr	r3, [pc, #156]	; (8672c <_ZN3ard10Navigation8setColorE6eColor+0x14c>)
   8668e:	4798      	blx	r3
  if (c == eColor::PREF)
   86690:	683b      	ldr	r3, [r7, #0]
   86692:	2b01      	cmp	r3, #1
   86694:	d117      	bne.n	866c6 <_ZN3ard10Navigation8setColorE6eColor+0xe6>
    LOG(INFO, "NAV : Color set to : PREF");
   86696:	4b26      	ldr	r3, [pc, #152]	; (86730 <_ZN3ard10Navigation8setColorE6eColor+0x150>)
   86698:	4798      	blx	r3
   8669a:	4605      	mov	r5, r0
   8669c:	682b      	ldr	r3, [r5, #0]
   8669e:	3310      	adds	r3, #16
   866a0:	681c      	ldr	r4, [r3, #0]
   866a2:	f107 0330 	add.w	r3, r7, #48	; 0x30
   866a6:	4923      	ldr	r1, [pc, #140]	; (86734 <_ZN3ard10Navigation8setColorE6eColor+0x154>)
   866a8:	4618      	mov	r0, r3
   866aa:	4b16      	ldr	r3, [pc, #88]	; (86704 <_ZN3ard10Navigation8setColorE6eColor+0x124>)
   866ac:	4798      	blx	r3
   866ae:	f107 0330 	add.w	r3, r7, #48	; 0x30
   866b2:	461a      	mov	r2, r3
   866b4:	2101      	movs	r1, #1
   866b6:	4628      	mov	r0, r5
   866b8:	47a0      	blx	r4
   866ba:	f107 0330 	add.w	r3, r7, #48	; 0x30
   866be:	4618      	mov	r0, r3
   866c0:	4b16      	ldr	r3, [pc, #88]	; (8671c <_ZN3ard10Navigation8setColorE6eColor+0x13c>)
   866c2:	4798      	blx	r3
  else
    LOG(INFO, "NAV : Color set to : SYM");
}
   866c4:	e016      	b.n	866f4 <_ZN3ard10Navigation8setColorE6eColor+0x114>
  m_color = c;
  g_ArdOs.Mutex_unlock(m_mutex);
  if (c == eColor::PREF)
    LOG(INFO, "NAV : Color set to : PREF");
  else
    LOG(INFO, "NAV : Color set to : SYM");
   866c6:	4b1a      	ldr	r3, [pc, #104]	; (86730 <_ZN3ard10Navigation8setColorE6eColor+0x150>)
   866c8:	4798      	blx	r3
   866ca:	4605      	mov	r5, r0
   866cc:	682b      	ldr	r3, [r5, #0]
   866ce:	3310      	adds	r3, #16
   866d0:	681c      	ldr	r4, [r3, #0]
   866d2:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   866d6:	4918      	ldr	r1, [pc, #96]	; (86738 <_ZN3ard10Navigation8setColorE6eColor+0x158>)
   866d8:	4618      	mov	r0, r3
   866da:	4b0a      	ldr	r3, [pc, #40]	; (86704 <_ZN3ard10Navigation8setColorE6eColor+0x124>)
   866dc:	4798      	blx	r3
   866de:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   866e2:	461a      	mov	r2, r3
   866e4:	2101      	movs	r1, #1
   866e6:	4628      	mov	r0, r5
   866e8:	47a0      	blx	r4
   866ea:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   866ee:	4618      	mov	r0, r3
   866f0:	4b0a      	ldr	r3, [pc, #40]	; (8671c <_ZN3ard10Navigation8setColorE6eColor+0x13c>)
   866f2:	4798      	blx	r3
}
   866f4:	bf00      	nop
   866f6:	3748      	adds	r7, #72	; 0x48
   866f8:	46bd      	mov	sp, r7
   866fa:	bdb0      	pop	{r4, r5, r7, pc}
   866fc:	00082fad 	.word	0x00082fad
   86700:	0009a894 	.word	0x0009a894
   86704:	00089009 	.word	0x00089009
   86708:	00082f89 	.word	0x00082f89
   8670c:	0009a8b4 	.word	0x0009a8b4
   86710:	0008951d 	.word	0x0008951d
   86714:	00089049 	.word	0x00089049
   86718:	00083845 	.word	0x00083845
   8671c:	00089145 	.word	0x00089145
   86720:	00082fe9 	.word	0x00082fe9
   86724:	00081c7d 	.word	0x00081c7d
   86728:	00084069 	.word	0x00084069
   8672c:	00084131 	.word	0x00084131
   86730:	000859e9 	.word	0x000859e9
   86734:	0009a8e0 	.word	0x0009a8e0
   86738:	0009a8fc 	.word	0x0009a8fc
   8673c:	00000000 	.word	0x00000000

00086740 <_ZN3ard10Navigation8straightEf>:
//  Serial.println (m_t);
}

void
Navigation::straight (float mm)
{
   86740:	b5b0      	push	{r4, r5, r7, lr}
   86742:	b082      	sub	sp, #8
   86744:	af00      	add	r7, sp, #0
   86746:	6078      	str	r0, [r7, #4]
   86748:	6039      	str	r1, [r7, #0]
  stepperG.setCurrentPosition (0);
   8674a:	687b      	ldr	r3, [r7, #4]
   8674c:	3338      	adds	r3, #56	; 0x38
   8674e:	2100      	movs	r1, #0
   86750:	4618      	mov	r0, r3
   86752:	4b2b      	ldr	r3, [pc, #172]	; (86800 <_ZN3ard10Navigation8straightEf+0xc0>)
   86754:	4798      	blx	r3
  stepperD.setCurrentPosition (0);
   86756:	687b      	ldr	r3, [r7, #4]
   86758:	338c      	adds	r3, #140	; 0x8c
   8675a:	2100      	movs	r1, #0
   8675c:	4618      	mov	r0, r3
   8675e:	4b28      	ldr	r3, [pc, #160]	; (86800 <_ZN3ard10Navigation8straightEf+0xc0>)
   86760:	4798      	blx	r3
  stepperG.setMaxSpeed (m_speed);
   86762:	687b      	ldr	r3, [r7, #4]
   86764:	f103 0238 	add.w	r2, r3, #56	; 0x38
   86768:	687b      	ldr	r3, [r7, #4]
   8676a:	f8d3 3164 	ldr.w	r3, [r3, #356]	; 0x164
   8676e:	4619      	mov	r1, r3
   86770:	4610      	mov	r0, r2
   86772:	4b24      	ldr	r3, [pc, #144]	; (86804 <_ZN3ard10Navigation8straightEf+0xc4>)
   86774:	4798      	blx	r3
  stepperD.setMaxSpeed (m_speed);
   86776:	687b      	ldr	r3, [r7, #4]
   86778:	f103 028c 	add.w	r2, r3, #140	; 0x8c
   8677c:	687b      	ldr	r3, [r7, #4]
   8677e:	f8d3 3164 	ldr.w	r3, [r3, #356]	; 0x164
   86782:	4619      	mov	r1, r3
   86784:	4610      	mov	r0, r2
   86786:	4b1f      	ldr	r3, [pc, #124]	; (86804 <_ZN3ard10Navigation8straightEf+0xc4>)
   86788:	4798      	blx	r3
  stepperG.moveTo (-mm * GAIN_STEP_MM);
   8678a:	687b      	ldr	r3, [r7, #4]
   8678c:	f103 0538 	add.w	r5, r3, #56	; 0x38
   86790:	683b      	ldr	r3, [r7, #0]
   86792:	f083 4200 	eor.w	r2, r3, #2147483648	; 0x80000000
   86796:	4b1c      	ldr	r3, [pc, #112]	; (86808 <_ZN3ard10Navigation8straightEf+0xc8>)
   86798:	4610      	mov	r0, r2
   8679a:	4798      	blx	r3
   8679c:	4c1b      	ldr	r4, [pc, #108]	; (8680c <_ZN3ard10Navigation8straightEf+0xcc>)
   8679e:	a316      	add	r3, pc, #88	; (adr r3, 867f8 <_ZN3ard10Navigation8straightEf+0xb8>)
   867a0:	e9d3 2300 	ldrd	r2, r3, [r3]
   867a4:	47a0      	blx	r4
   867a6:	4603      	mov	r3, r0
   867a8:	460c      	mov	r4, r1
   867aa:	4619      	mov	r1, r3
   867ac:	4622      	mov	r2, r4
   867ae:	4b18      	ldr	r3, [pc, #96]	; (86810 <_ZN3ard10Navigation8straightEf+0xd0>)
   867b0:	4608      	mov	r0, r1
   867b2:	4611      	mov	r1, r2
   867b4:	4798      	blx	r3
   867b6:	4603      	mov	r3, r0
   867b8:	4619      	mov	r1, r3
   867ba:	4628      	mov	r0, r5
   867bc:	4b15      	ldr	r3, [pc, #84]	; (86814 <_ZN3ard10Navigation8straightEf+0xd4>)
   867be:	4798      	blx	r3
  stepperD.moveTo (mm * GAIN_STEP_MM);
   867c0:	687b      	ldr	r3, [r7, #4]
   867c2:	f103 058c 	add.w	r5, r3, #140	; 0x8c
   867c6:	4b10      	ldr	r3, [pc, #64]	; (86808 <_ZN3ard10Navigation8straightEf+0xc8>)
   867c8:	6838      	ldr	r0, [r7, #0]
   867ca:	4798      	blx	r3
   867cc:	4c0f      	ldr	r4, [pc, #60]	; (8680c <_ZN3ard10Navigation8straightEf+0xcc>)
   867ce:	a30a      	add	r3, pc, #40	; (adr r3, 867f8 <_ZN3ard10Navigation8straightEf+0xb8>)
   867d0:	e9d3 2300 	ldrd	r2, r3, [r3]
   867d4:	47a0      	blx	r4
   867d6:	4603      	mov	r3, r0
   867d8:	460c      	mov	r4, r1
   867da:	4619      	mov	r1, r3
   867dc:	4622      	mov	r2, r4
   867de:	4b0c      	ldr	r3, [pc, #48]	; (86810 <_ZN3ard10Navigation8straightEf+0xd0>)
   867e0:	4608      	mov	r0, r1
   867e2:	4611      	mov	r1, r2
   867e4:	4798      	blx	r3
   867e6:	4603      	mov	r3, r0
   867e8:	4619      	mov	r1, r3
   867ea:	4628      	mov	r0, r5
   867ec:	4b09      	ldr	r3, [pc, #36]	; (86814 <_ZN3ard10Navigation8straightEf+0xd4>)
   867ee:	4798      	blx	r3
}
   867f0:	bf00      	nop
   867f2:	3708      	adds	r7, #8
   867f4:	46bd      	mov	sp, r7
   867f6:	bdb0      	pop	{r4, r5, r7, pc}
   867f8:	72b020c5 	.word	0x72b020c5
   867fc:	4020d168 	.word	0x4020d168
   86800:	00089779 	.word	0x00089779
   86804:	00089b95 	.word	0x00089b95
   86808:	000926d5 	.word	0x000926d5
   8680c:	0009277d 	.word	0x0009277d
   86810:	00092cdd 	.word	0x00092cdd
   86814:	00089689 	.word	0x00089689

00086818 <_ZN3ard10Navigation4turnEf>:

void
Navigation::turn (float angle)
{
   86818:	b5b0      	push	{r4, r5, r7, lr}
   8681a:	b082      	sub	sp, #8
   8681c:	af00      	add	r7, sp, #0
   8681e:	6078      	str	r0, [r7, #4]
   86820:	6039      	str	r1, [r7, #0]
  stepperG.setCurrentPosition (0);
   86822:	687b      	ldr	r3, [r7, #4]
   86824:	3338      	adds	r3, #56	; 0x38
   86826:	2100      	movs	r1, #0
   86828:	4618      	mov	r0, r3
   8682a:	4b3f      	ldr	r3, [pc, #252]	; (86928 <_ZN3ard10Navigation4turnEf+0x110>)
   8682c:	4798      	blx	r3
  stepperD.setCurrentPosition (0);
   8682e:	687b      	ldr	r3, [r7, #4]
   86830:	338c      	adds	r3, #140	; 0x8c
   86832:	2100      	movs	r1, #0
   86834:	4618      	mov	r0, r3
   86836:	4b3c      	ldr	r3, [pc, #240]	; (86928 <_ZN3ard10Navigation4turnEf+0x110>)
   86838:	4798      	blx	r3
  stepperG.setMaxSpeed (m_speed_virage);
   8683a:	687b      	ldr	r3, [r7, #4]
   8683c:	f103 0238 	add.w	r2, r3, #56	; 0x38
   86840:	687b      	ldr	r3, [r7, #4]
   86842:	f8d3 3168 	ldr.w	r3, [r3, #360]	; 0x168
   86846:	4619      	mov	r1, r3
   86848:	4610      	mov	r0, r2
   8684a:	4b38      	ldr	r3, [pc, #224]	; (8692c <_ZN3ard10Navigation4turnEf+0x114>)
   8684c:	4798      	blx	r3
  stepperD.setMaxSpeed (m_speed_virage);
   8684e:	687b      	ldr	r3, [r7, #4]
   86850:	f103 028c 	add.w	r2, r3, #140	; 0x8c
   86854:	687b      	ldr	r3, [r7, #4]
   86856:	f8d3 3168 	ldr.w	r3, [r3, #360]	; 0x168
   8685a:	4619      	mov	r1, r3
   8685c:	4610      	mov	r0, r2
   8685e:	4b33      	ldr	r3, [pc, #204]	; (8692c <_ZN3ard10Navigation4turnEf+0x114>)
   86860:	4798      	blx	r3
  stepperG.moveTo (angle * VOIE / 2 * GAIN_STEP_MM);
   86862:	687b      	ldr	r3, [r7, #4]
   86864:	f103 0538 	add.w	r5, r3, #56	; 0x38
   86868:	4b31      	ldr	r3, [pc, #196]	; (86930 <_ZN3ard10Navigation4turnEf+0x118>)
   8686a:	6838      	ldr	r0, [r7, #0]
   8686c:	4798      	blx	r3
   8686e:	4c31      	ldr	r4, [pc, #196]	; (86934 <_ZN3ard10Navigation4turnEf+0x11c>)
   86870:	a329      	add	r3, pc, #164	; (adr r3, 86918 <_ZN3ard10Navigation4turnEf+0x100>)
   86872:	e9d3 2300 	ldrd	r2, r3, [r3]
   86876:	47a0      	blx	r4
   86878:	4603      	mov	r3, r0
   8687a:	460c      	mov	r4, r1
   8687c:	4618      	mov	r0, r3
   8687e:	4621      	mov	r1, r4
   86880:	4c2d      	ldr	r4, [pc, #180]	; (86938 <_ZN3ard10Navigation4turnEf+0x120>)
   86882:	f04f 0200 	mov.w	r2, #0
   86886:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   8688a:	47a0      	blx	r4
   8688c:	4603      	mov	r3, r0
   8688e:	460c      	mov	r4, r1
   86890:	4618      	mov	r0, r3
   86892:	4621      	mov	r1, r4
   86894:	4c27      	ldr	r4, [pc, #156]	; (86934 <_ZN3ard10Navigation4turnEf+0x11c>)
   86896:	a322      	add	r3, pc, #136	; (adr r3, 86920 <_ZN3ard10Navigation4turnEf+0x108>)
   86898:	e9d3 2300 	ldrd	r2, r3, [r3]
   8689c:	47a0      	blx	r4
   8689e:	4603      	mov	r3, r0
   868a0:	460c      	mov	r4, r1
   868a2:	4619      	mov	r1, r3
   868a4:	4622      	mov	r2, r4
   868a6:	4b25      	ldr	r3, [pc, #148]	; (8693c <_ZN3ard10Navigation4turnEf+0x124>)
   868a8:	4608      	mov	r0, r1
   868aa:	4611      	mov	r1, r2
   868ac:	4798      	blx	r3
   868ae:	4603      	mov	r3, r0
   868b0:	4619      	mov	r1, r3
   868b2:	4628      	mov	r0, r5
   868b4:	4b22      	ldr	r3, [pc, #136]	; (86940 <_ZN3ard10Navigation4turnEf+0x128>)
   868b6:	4798      	blx	r3
  stepperD.moveTo (angle * VOIE / 2 * GAIN_STEP_MM);
   868b8:	687b      	ldr	r3, [r7, #4]
   868ba:	f103 058c 	add.w	r5, r3, #140	; 0x8c
   868be:	4b1c      	ldr	r3, [pc, #112]	; (86930 <_ZN3ard10Navigation4turnEf+0x118>)
   868c0:	6838      	ldr	r0, [r7, #0]
   868c2:	4798      	blx	r3
   868c4:	4c1b      	ldr	r4, [pc, #108]	; (86934 <_ZN3ard10Navigation4turnEf+0x11c>)
   868c6:	a314      	add	r3, pc, #80	; (adr r3, 86918 <_ZN3ard10Navigation4turnEf+0x100>)
   868c8:	e9d3 2300 	ldrd	r2, r3, [r3]
   868cc:	47a0      	blx	r4
   868ce:	4603      	mov	r3, r0
   868d0:	460c      	mov	r4, r1
   868d2:	4618      	mov	r0, r3
   868d4:	4621      	mov	r1, r4
   868d6:	4c18      	ldr	r4, [pc, #96]	; (86938 <_ZN3ard10Navigation4turnEf+0x120>)
   868d8:	f04f 0200 	mov.w	r2, #0
   868dc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   868e0:	47a0      	blx	r4
   868e2:	4603      	mov	r3, r0
   868e4:	460c      	mov	r4, r1
   868e6:	4618      	mov	r0, r3
   868e8:	4621      	mov	r1, r4
   868ea:	4c12      	ldr	r4, [pc, #72]	; (86934 <_ZN3ard10Navigation4turnEf+0x11c>)
   868ec:	a30c      	add	r3, pc, #48	; (adr r3, 86920 <_ZN3ard10Navigation4turnEf+0x108>)
   868ee:	e9d3 2300 	ldrd	r2, r3, [r3]
   868f2:	47a0      	blx	r4
   868f4:	4603      	mov	r3, r0
   868f6:	460c      	mov	r4, r1
   868f8:	4619      	mov	r1, r3
   868fa:	4622      	mov	r2, r4
   868fc:	4b0f      	ldr	r3, [pc, #60]	; (8693c <_ZN3ard10Navigation4turnEf+0x124>)
   868fe:	4608      	mov	r0, r1
   86900:	4611      	mov	r1, r2
   86902:	4798      	blx	r3
   86904:	4603      	mov	r3, r0
   86906:	4619      	mov	r1, r3
   86908:	4628      	mov	r0, r5
   8690a:	4b0d      	ldr	r3, [pc, #52]	; (86940 <_ZN3ard10Navigation4turnEf+0x128>)
   8690c:	4798      	blx	r3
}
   8690e:	bf00      	nop
   86910:	3708      	adds	r7, #8
   86912:	46bd      	mov	sp, r7
   86914:	bdb0      	pop	{r4, r5, r7, pc}
   86916:	bf00      	nop
   86918:	51eb851f 	.word	0x51eb851f
   8691c:	405a2eb8 	.word	0x405a2eb8
   86920:	72b020c5 	.word	0x72b020c5
   86924:	4020d168 	.word	0x4020d168
   86928:	00089779 	.word	0x00089779
   8692c:	00089b95 	.word	0x00089b95
   86930:	000926d5 	.word	0x000926d5
   86934:	0009277d 	.word	0x0009277d
   86938:	000929d1 	.word	0x000929d1
   8693c:	00092cdd 	.word	0x00092cdd
   86940:	00089689 	.word	0x00089689

00086944 <_ZN3ard10Navigation16subOrderFinishedEv>:
/**
 * return true if the trajectory is finished
 */
bool
Navigation::subOrderFinished ()
{
   86944:	b580      	push	{r7, lr}
   86946:	b082      	sub	sp, #8
   86948:	af00      	add	r7, sp, #0
   8694a:	6078      	str	r0, [r7, #4]
  return (stepperG.distanceToGo () == 0 || stepperD.distanceToGo () == 0);
   8694c:	687b      	ldr	r3, [r7, #4]
   8694e:	3338      	adds	r3, #56	; 0x38
   86950:	4618      	mov	r0, r3
   86952:	4b0a      	ldr	r3, [pc, #40]	; (8697c <_ZN3ard10Navigation16subOrderFinishedEv+0x38>)
   86954:	4798      	blx	r3
   86956:	4603      	mov	r3, r0
   86958:	2b00      	cmp	r3, #0
   8695a:	d007      	beq.n	8696c <_ZN3ard10Navigation16subOrderFinishedEv+0x28>
   8695c:	687b      	ldr	r3, [r7, #4]
   8695e:	338c      	adds	r3, #140	; 0x8c
   86960:	4618      	mov	r0, r3
   86962:	4b06      	ldr	r3, [pc, #24]	; (8697c <_ZN3ard10Navigation16subOrderFinishedEv+0x38>)
   86964:	4798      	blx	r3
   86966:	4603      	mov	r3, r0
   86968:	2b00      	cmp	r3, #0
   8696a:	d101      	bne.n	86970 <_ZN3ard10Navigation16subOrderFinishedEv+0x2c>
   8696c:	2301      	movs	r3, #1
   8696e:	e000      	b.n	86972 <_ZN3ard10Navigation16subOrderFinishedEv+0x2e>
   86970:	2300      	movs	r3, #0
}
   86972:	4618      	mov	r0, r3
   86974:	3708      	adds	r7, #8
   86976:	46bd      	mov	sp, r7
   86978:	bd80      	pop	{r7, pc}
   8697a:	bf00      	nop
   8697c:	0008975d 	.word	0x0008975d

00086980 <_ZN3ard10Navigation12sensToStringENS_6sens_tE>:

String
Navigation::sensToString (sens_t sens)
{
   86980:	b580      	push	{r7, lr}
   86982:	b084      	sub	sp, #16
   86984:	af00      	add	r7, sp, #0
   86986:	60f8      	str	r0, [r7, #12]
   86988:	60b9      	str	r1, [r7, #8]
   8698a:	4613      	mov	r3, r2
   8698c:	71fb      	strb	r3, [r7, #7]
  switch (sens)
   8698e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   86992:	f1b3 3fff 	cmp.w	r3, #4294967295
   86996:	d00b      	beq.n	869b0 <_ZN3ard10Navigation12sensToStringENS_6sens_tE+0x30>
   86998:	2b01      	cmp	r3, #1
   8699a:	d004      	beq.n	869a6 <_ZN3ard10Navigation12sensToStringENS_6sens_tE+0x26>
    {
    default:
    ENUM2STR(SENS_UNDEFINED)
   8699c:	4908      	ldr	r1, [pc, #32]	; (869c0 <_ZN3ard10Navigation12sensToStringENS_6sens_tE+0x40>)
   8699e:	68f8      	ldr	r0, [r7, #12]
   869a0:	4b08      	ldr	r3, [pc, #32]	; (869c4 <_ZN3ard10Navigation12sensToStringENS_6sens_tE+0x44>)
   869a2:	4798      	blx	r3
   869a4:	e008      	b.n	869b8 <_ZN3ard10Navigation12sensToStringENS_6sens_tE+0x38>
;      ENUM2STR(SENS_AV);
   869a6:	4908      	ldr	r1, [pc, #32]	; (869c8 <_ZN3ard10Navigation12sensToStringENS_6sens_tE+0x48>)
   869a8:	68f8      	ldr	r0, [r7, #12]
   869aa:	4b06      	ldr	r3, [pc, #24]	; (869c4 <_ZN3ard10Navigation12sensToStringENS_6sens_tE+0x44>)
   869ac:	4798      	blx	r3
   869ae:	e003      	b.n	869b8 <_ZN3ard10Navigation12sensToStringENS_6sens_tE+0x38>
      ENUM2STR(SENS_AR);
   869b0:	4906      	ldr	r1, [pc, #24]	; (869cc <_ZN3ard10Navigation12sensToStringENS_6sens_tE+0x4c>)
   869b2:	68f8      	ldr	r0, [r7, #12]
   869b4:	4b03      	ldr	r3, [pc, #12]	; (869c4 <_ZN3ard10Navigation12sensToStringENS_6sens_tE+0x44>)
   869b6:	4798      	blx	r3
    }
}
   869b8:	68f8      	ldr	r0, [r7, #12]
   869ba:	3710      	adds	r7, #16
   869bc:	46bd      	mov	sp, r7
   869be:	bd80      	pop	{r7, pc}
   869c0:	0009a93c 	.word	0x0009a93c
   869c4:	00089009 	.word	0x00089009
   869c8:	0009a94c 	.word	0x0009a94c
   869cc:	0009a954 	.word	0x0009a954

000869d0 <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE>:

String
Navigation::orderToString (eNavOrder order)
{
   869d0:	b580      	push	{r7, lr}
   869d2:	b084      	sub	sp, #16
   869d4:	af00      	add	r7, sp, #0
   869d6:	60f8      	str	r0, [r7, #12]
   869d8:	60b9      	str	r1, [r7, #8]
   869da:	607a      	str	r2, [r7, #4]
  switch (order)
   869dc:	687b      	ldr	r3, [r7, #4]
   869de:	2b01      	cmp	r3, #1
   869e0:	d006      	beq.n	869f0 <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE+0x20>
   869e2:	2b02      	cmp	r3, #2
   869e4:	d009      	beq.n	869fa <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE+0x2a>
    {
    default:
    ENUM2STR(eNavOrder::NOTHING)
   869e6:	4909      	ldr	r1, [pc, #36]	; (86a0c <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE+0x3c>)
   869e8:	68f8      	ldr	r0, [r7, #12]
   869ea:	4b09      	ldr	r3, [pc, #36]	; (86a10 <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE+0x40>)
   869ec:	4798      	blx	r3
   869ee:	e008      	b.n	86a02 <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE+0x32>
;      ENUM2STR(eNavOrder::GOTO);
   869f0:	4908      	ldr	r1, [pc, #32]	; (86a14 <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE+0x44>)
   869f2:	68f8      	ldr	r0, [r7, #12]
   869f4:	4b06      	ldr	r3, [pc, #24]	; (86a10 <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE+0x40>)
   869f6:	4798      	blx	r3
   869f8:	e003      	b.n	86a02 <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE+0x32>
      ENUM2STR(eNavOrder::GOTO_CAP);
   869fa:	4907      	ldr	r1, [pc, #28]	; (86a18 <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE+0x48>)
   869fc:	68f8      	ldr	r0, [r7, #12]
   869fe:	4b04      	ldr	r3, [pc, #16]	; (86a10 <_ZN3ard10Navigation13orderToStringENS0_9eNavOrderE+0x40>)
   86a00:	4798      	blx	r3
    }
}
   86a02:	68f8      	ldr	r0, [r7, #12]
   86a04:	3710      	adds	r7, #16
   86a06:	46bd      	mov	sp, r7
   86a08:	bd80      	pop	{r7, pc}
   86a0a:	bf00      	nop
   86a0c:	0009a95c 	.word	0x0009a95c
   86a10:	00089009 	.word	0x00089009
   86a14:	0009a970 	.word	0x0009a970
   86a18:	0009a980 	.word	0x0009a980

00086a1c <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE>:

String
Navigation::stateToString (eNavState state)
{
   86a1c:	b580      	push	{r7, lr}
   86a1e:	b084      	sub	sp, #16
   86a20:	af00      	add	r7, sp, #0
   86a22:	60f8      	str	r0, [r7, #12]
   86a24:	60b9      	str	r1, [r7, #8]
   86a26:	607a      	str	r2, [r7, #4]
  switch (state)
   86a28:	687b      	ldr	r3, [r7, #4]
   86a2a:	3b01      	subs	r3, #1
   86a2c:	2b03      	cmp	r3, #3
   86a2e:	d80b      	bhi.n	86a48 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x2c>
   86a30:	a201      	add	r2, pc, #4	; (adr r2, 86a38 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x1c>)
   86a32:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   86a36:	bf00      	nop
   86a38:	00086a53 	.word	0x00086a53
   86a3c:	00086a5d 	.word	0x00086a5d
   86a40:	00086a67 	.word	0x00086a67
   86a44:	00086a71 	.word	0x00086a71
    {
    default:
    ENUM2STR(eNavState::IDLE)
   86a48:	490d      	ldr	r1, [pc, #52]	; (86a80 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x64>)
   86a4a:	68f8      	ldr	r0, [r7, #12]
   86a4c:	4b0d      	ldr	r3, [pc, #52]	; (86a84 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x68>)
   86a4e:	4798      	blx	r3
   86a50:	e012      	b.n	86a78 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x5c>
;      ENUM2STR(eNavState::FACING_DEST);
   86a52:	490d      	ldr	r1, [pc, #52]	; (86a88 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x6c>)
   86a54:	68f8      	ldr	r0, [r7, #12]
   86a56:	4b0b      	ldr	r3, [pc, #44]	; (86a84 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x68>)
   86a58:	4798      	blx	r3
   86a5a:	e00d      	b.n	86a78 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x5c>
      ENUM2STR(eNavState::GOING_TO_TARGET);
   86a5c:	490b      	ldr	r1, [pc, #44]	; (86a8c <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x70>)
   86a5e:	68f8      	ldr	r0, [r7, #12]
   86a60:	4b08      	ldr	r3, [pc, #32]	; (86a84 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x68>)
   86a62:	4798      	blx	r3
   86a64:	e008      	b.n	86a78 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x5c>
      ENUM2STR(eNavState::TURNING_AT_TARGET);
   86a66:	490a      	ldr	r1, [pc, #40]	; (86a90 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x74>)
   86a68:	68f8      	ldr	r0, [r7, #12]
   86a6a:	4b06      	ldr	r3, [pc, #24]	; (86a84 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x68>)
   86a6c:	4798      	blx	r3
   86a6e:	e003      	b.n	86a78 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x5c>
      ENUM2STR(eNavState::INTERRUPTING_ORDER);
   86a70:	4908      	ldr	r1, [pc, #32]	; (86a94 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x78>)
   86a72:	68f8      	ldr	r0, [r7, #12]
   86a74:	4b03      	ldr	r3, [pc, #12]	; (86a84 <_ZN3ard10Navigation13stateToStringENS0_9eNavStateE+0x68>)
   86a76:	4798      	blx	r3
    }
}
   86a78:	68f8      	ldr	r0, [r7, #12]
   86a7a:	3710      	adds	r7, #16
   86a7c:	46bd      	mov	sp, r7
   86a7e:	bd80      	pop	{r7, pc}
   86a80:	0009a994 	.word	0x0009a994
   86a84:	00089009 	.word	0x00089009
   86a88:	0009a9a4 	.word	0x0009a9a4
   86a8c:	0009a9bc 	.word	0x0009a9bc
   86a90:	0009a9d8 	.word	0x0009a9d8
   86a94:	0009a9f8 	.word	0x0009a9f8

00086a98 <_ZN3ard10NavigationD1Ev>:
   * This class manage the robot position and movements.
   * It is expected to be embedded in a periodic thread
   * Hence, the strategy will access it from another thread
   * Thus, introducing thread safety issue (so a mutex is present)
   */
  class Navigation : public IMiniPeriodicThread
   86a98:	b580      	push	{r7, lr}
   86a9a:	b082      	sub	sp, #8
   86a9c:	af00      	add	r7, sp, #0
   86a9e:	6078      	str	r0, [r7, #4]
   86aa0:	4a0d      	ldr	r2, [pc, #52]	; (86ad8 <_ZN3ard10NavigationD1Ev+0x40>)
   86aa2:	687b      	ldr	r3, [r7, #4]
   86aa4:	601a      	str	r2, [r3, #0]
   86aa6:	687b      	ldr	r3, [r7, #4]
   86aa8:	3318      	adds	r3, #24
   86aaa:	4618      	mov	r0, r3
   86aac:	4b0b      	ldr	r3, [pc, #44]	; (86adc <_ZN3ard10NavigationD1Ev+0x44>)
   86aae:	4798      	blx	r3
   86ab0:	687b      	ldr	r3, [r7, #4]
   86ab2:	3304      	adds	r3, #4
   86ab4:	4618      	mov	r0, r3
   86ab6:	4b09      	ldr	r3, [pc, #36]	; (86adc <_ZN3ard10NavigationD1Ev+0x44>)
   86ab8:	4798      	blx	r3
   86aba:	687b      	ldr	r3, [r7, #4]
   86abc:	4618      	mov	r0, r3
   86abe:	4b08      	ldr	r3, [pc, #32]	; (86ae0 <_ZN3ard10NavigationD1Ev+0x48>)
   86ac0:	4798      	blx	r3
   86ac2:	2300      	movs	r3, #0
   86ac4:	2b00      	cmp	r3, #0
   86ac6:	d002      	beq.n	86ace <_ZN3ard10NavigationD1Ev+0x36>
   86ac8:	6878      	ldr	r0, [r7, #4]
   86aca:	4b06      	ldr	r3, [pc, #24]	; (86ae4 <_ZN3ard10NavigationD1Ev+0x4c>)
   86acc:	4798      	blx	r3
   86ace:	687b      	ldr	r3, [r7, #4]
   86ad0:	4618      	mov	r0, r3
   86ad2:	3708      	adds	r7, #8
   86ad4:	46bd      	mov	sp, r7
   86ad6:	bd80      	pop	{r7, pc}
   86ad8:	0009aa20 	.word	0x0009aa20
   86adc:	00086b11 	.word	0x00086b11
   86ae0:	00085995 	.word	0x00085995
   86ae4:	0008788d 	.word	0x0008788d

00086ae8 <_ZN3ard10NavigationD0Ev>:
   86ae8:	b580      	push	{r7, lr}
   86aea:	b082      	sub	sp, #8
   86aec:	af00      	add	r7, sp, #0
   86aee:	6078      	str	r0, [r7, #4]
   86af0:	6878      	ldr	r0, [r7, #4]
   86af2:	4b05      	ldr	r3, [pc, #20]	; (86b08 <_ZN3ard10NavigationD0Ev+0x20>)
   86af4:	4798      	blx	r3
   86af6:	6878      	ldr	r0, [r7, #4]
   86af8:	4b04      	ldr	r3, [pc, #16]	; (86b0c <_ZN3ard10NavigationD0Ev+0x24>)
   86afa:	4798      	blx	r3
   86afc:	687b      	ldr	r3, [r7, #4]
   86afe:	4618      	mov	r0, r3
   86b00:	3708      	adds	r7, #8
   86b02:	46bd      	mov	sp, r7
   86b04:	bd80      	pop	{r7, pc}
   86b06:	bf00      	nop
   86b08:	00086a99 	.word	0x00086a99
   86b0c:	0008788d 	.word	0x0008788d

00086b10 <_ZN3ard8PointCapD1Ev>:
   86b10:	b580      	push	{r7, lr}
   86b12:	b082      	sub	sp, #8
   86b14:	af00      	add	r7, sp, #0
   86b16:	6078      	str	r0, [r7, #4]
   86b18:	4a08      	ldr	r2, [pc, #32]	; (86b3c <_ZN3ard8PointCapD1Ev+0x2c>)
   86b1a:	687b      	ldr	r3, [r7, #4]
   86b1c:	601a      	str	r2, [r3, #0]
   86b1e:	687b      	ldr	r3, [r7, #4]
   86b20:	4618      	mov	r0, r3
   86b22:	4b07      	ldr	r3, [pc, #28]	; (86b40 <_ZN3ard8PointCapD1Ev+0x30>)
   86b24:	4798      	blx	r3
   86b26:	2300      	movs	r3, #0
   86b28:	2b00      	cmp	r3, #0
   86b2a:	d002      	beq.n	86b32 <_ZN3ard8PointCapD1Ev+0x22>
   86b2c:	6878      	ldr	r0, [r7, #4]
   86b2e:	4b05      	ldr	r3, [pc, #20]	; (86b44 <_ZN3ard8PointCapD1Ev+0x34>)
   86b30:	4798      	blx	r3
   86b32:	687b      	ldr	r3, [r7, #4]
   86b34:	4618      	mov	r0, r3
   86b36:	3708      	adds	r7, #8
   86b38:	46bd      	mov	sp, r7
   86b3a:	bd80      	pop	{r7, pc}
   86b3c:	0009aee0 	.word	0x0009aee0
   86b40:	000859fd 	.word	0x000859fd
   86b44:	0008788d 	.word	0x0008788d

00086b48 <_ZN3ard8PointCapD0Ev>:
   86b48:	b580      	push	{r7, lr}
   86b4a:	b082      	sub	sp, #8
   86b4c:	af00      	add	r7, sp, #0
   86b4e:	6078      	str	r0, [r7, #4]
   86b50:	6878      	ldr	r0, [r7, #4]
   86b52:	4b05      	ldr	r3, [pc, #20]	; (86b68 <_ZN3ard8PointCapD0Ev+0x20>)
   86b54:	4798      	blx	r3
   86b56:	6878      	ldr	r0, [r7, #4]
   86b58:	4b04      	ldr	r3, [pc, #16]	; (86b6c <_ZN3ard8PointCapD0Ev+0x24>)
   86b5a:	4798      	blx	r3
   86b5c:	687b      	ldr	r3, [r7, #4]
   86b5e:	4618      	mov	r0, r3
   86b60:	3708      	adds	r7, #8
   86b62:	46bd      	mov	sp, r7
   86b64:	bd80      	pop	{r7, pc}
   86b66:	bf00      	nop
   86b68:	00086b11 	.word	0x00086b11
   86b6c:	0008788d 	.word	0x0008788d

00086b70 <_ZN3ard12TeleopThreadD1Ev>:
  class TeleopThread : public IThread
  {
  public:
    TeleopThread ();
    virtual
    ~TeleopThread ()
   86b70:	b580      	push	{r7, lr}
   86b72:	b082      	sub	sp, #8
   86b74:	af00      	add	r7, sp, #0
   86b76:	6078      	str	r0, [r7, #4]
    {
   86b78:	4a08      	ldr	r2, [pc, #32]	; (86b9c <_ZN3ard12TeleopThreadD1Ev+0x2c>)
   86b7a:	687b      	ldr	r3, [r7, #4]
   86b7c:	601a      	str	r2, [r3, #0]
   86b7e:	687b      	ldr	r3, [r7, #4]
   86b80:	4618      	mov	r0, r3
   86b82:	4b07      	ldr	r3, [pc, #28]	; (86ba0 <_ZN3ard12TeleopThreadD1Ev+0x30>)
   86b84:	4798      	blx	r3
    }
   86b86:	2300      	movs	r3, #0
   86b88:	2b00      	cmp	r3, #0
   86b8a:	d002      	beq.n	86b92 <_ZN3ard12TeleopThreadD1Ev+0x22>
   86b8c:	6878      	ldr	r0, [r7, #4]
   86b8e:	4b05      	ldr	r3, [pc, #20]	; (86ba4 <_ZN3ard12TeleopThreadD1Ev+0x34>)
   86b90:	4798      	blx	r3
   86b92:	687b      	ldr	r3, [r7, #4]
   86b94:	4618      	mov	r0, r3
   86b96:	3708      	adds	r7, #8
   86b98:	46bd      	mov	sp, r7
   86b9a:	bd80      	pop	{r7, pc}
   86b9c:	0009aa58 	.word	0x0009aa58
   86ba0:	00084969 	.word	0x00084969
   86ba4:	0008788d 	.word	0x0008788d

00086ba8 <_ZN3ard12TeleopThreadD0Ev>:
  class TeleopThread : public IThread
  {
  public:
    TeleopThread ();
    virtual
    ~TeleopThread ()
   86ba8:	b580      	push	{r7, lr}
   86baa:	b082      	sub	sp, #8
   86bac:	af00      	add	r7, sp, #0
   86bae:	6078      	str	r0, [r7, #4]
    {
    }
   86bb0:	6878      	ldr	r0, [r7, #4]
   86bb2:	4b05      	ldr	r3, [pc, #20]	; (86bc8 <_ZN3ard12TeleopThreadD0Ev+0x20>)
   86bb4:	4798      	blx	r3
   86bb6:	6878      	ldr	r0, [r7, #4]
   86bb8:	4b04      	ldr	r3, [pc, #16]	; (86bcc <_ZN3ard12TeleopThreadD0Ev+0x24>)
   86bba:	4798      	blx	r3
   86bbc:	687b      	ldr	r3, [r7, #4]
   86bbe:	4618      	mov	r0, r3
   86bc0:	3708      	adds	r7, #8
   86bc2:	46bd      	mov	sp, r7
   86bc4:	bd80      	pop	{r7, pc}
   86bc6:	bf00      	nop
   86bc8:	00086b71 	.word	0x00086b71
   86bcc:	0008788d 	.word	0x0008788d

00086bd0 <_ZN3ard12TeleopThreadC1Ev>:
#include "TeleopThread.h"

namespace ard
{

  TeleopThread::TeleopThread ()
   86bd0:	b580      	push	{r7, lr}
   86bd2:	b082      	sub	sp, #8
   86bd4:	af00      	add	r7, sp, #0
   86bd6:	6078      	str	r0, [r7, #4]
   86bd8:	687b      	ldr	r3, [r7, #4]
   86bda:	4618      	mov	r0, r3
   86bdc:	4b04      	ldr	r3, [pc, #16]	; (86bf0 <_ZN3ard12TeleopThreadC1Ev+0x20>)
   86bde:	4798      	blx	r3
   86be0:	4a04      	ldr	r2, [pc, #16]	; (86bf4 <_ZN3ard12TeleopThreadC1Ev+0x24>)
   86be2:	687b      	ldr	r3, [r7, #4]
   86be4:	601a      	str	r2, [r3, #0]
  {
  }
   86be6:	687b      	ldr	r3, [r7, #4]
   86be8:	4618      	mov	r0, r3
   86bea:	3708      	adds	r7, #8
   86bec:	46bd      	mov	sp, r7
   86bee:	bd80      	pop	{r7, pc}
   86bf0:	00084d8d 	.word	0x00084d8d
   86bf4:	0009aa58 	.word	0x0009aa58

00086bf8 <_ZN3ard12TeleopThread4initEv>:

  void
  TeleopThread::init ()
  {
   86bf8:	b590      	push	{r4, r7, lr}
   86bfa:	b085      	sub	sp, #20
   86bfc:	af02      	add	r7, sp, #8
   86bfe:	6078      	str	r0, [r7, #4]
    //create the thread
    g_ArdOs.createThread_Cpp("Teleop", *this, STACK_LOG, PRIO_LOG);
   86c00:	4b06      	ldr	r3, [pc, #24]	; (86c1c <_ZN3ard12TeleopThread4initEv+0x24>)
   86c02:	4798      	blx	r3
   86c04:	687a      	ldr	r2, [r7, #4]
   86c06:	2302      	movs	r3, #2
   86c08:	9300      	str	r3, [sp, #0]
   86c0a:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   86c0e:	4904      	ldr	r1, [pc, #16]	; (86c20 <_ZN3ard12TeleopThread4initEv+0x28>)
   86c10:	4c04      	ldr	r4, [pc, #16]	; (86c24 <_ZN3ard12TeleopThread4initEv+0x2c>)
   86c12:	47a0      	blx	r4
  }
   86c14:	bf00      	nop
   86c16:	370c      	adds	r7, #12
   86c18:	46bd      	mov	sp, r7
   86c1a:	bd90      	pop	{r4, r7, pc}
   86c1c:	00082fad 	.word	0x00082fad
   86c20:	0009aa48 	.word	0x0009aa48
   86c24:	000838a9 	.word	0x000838a9

00086c28 <_ZN3ard12TeleopThread3runEv>:

  void
  TeleopThread::run ()
  {
   86c28:	b580      	push	{r7, lr}
   86c2a:	b082      	sub	sp, #8
   86c2c:	af00      	add	r7, sp, #0
   86c2e:	6078      	str	r0, [r7, #4]
    while (1)
      {
	while (Serial.available ())
   86c30:	480c      	ldr	r0, [pc, #48]	; (86c64 <_ZN3ard12TeleopThread3runEv+0x3c>)
   86c32:	4b0d      	ldr	r3, [pc, #52]	; (86c68 <_ZN3ard12TeleopThread3runEv+0x40>)
   86c34:	4798      	blx	r3
   86c36:	4603      	mov	r3, r0
   86c38:	2b00      	cmp	r3, #0
   86c3a:	bf14      	ite	ne
   86c3c:	2301      	movne	r3, #1
   86c3e:	2300      	moveq	r3, #0
   86c40:	b2db      	uxtb	r3, r3
   86c42:	2b00      	cmp	r3, #0
   86c44:	d009      	beq.n	86c5a <_ZN3ard12TeleopThread3runEv+0x32>
	  {
	    Serial.read ();
   86c46:	4807      	ldr	r0, [pc, #28]	; (86c64 <_ZN3ard12TeleopThread3runEv+0x3c>)
   86c48:	4b08      	ldr	r3, [pc, #32]	; (86c6c <_ZN3ard12TeleopThread3runEv+0x44>)
   86c4a:	4798      	blx	r3
	    //TODO do something
	    g_ArdOs.displayStats();
   86c4c:	4b08      	ldr	r3, [pc, #32]	; (86c70 <_ZN3ard12TeleopThread3runEv+0x48>)
   86c4e:	4798      	blx	r3
   86c50:	4603      	mov	r3, r0
   86c52:	4618      	mov	r0, r3
   86c54:	4b07      	ldr	r3, [pc, #28]	; (86c74 <_ZN3ard12TeleopThread3runEv+0x4c>)
   86c56:	4798      	blx	r3
  void
  TeleopThread::run ()
  {
    while (1)
      {
	while (Serial.available ())
   86c58:	e7ea      	b.n	86c30 <_ZN3ard12TeleopThread3runEv+0x8>
	    Serial.read ();
	    //TODO do something
	    g_ArdOs.displayStats();
	}

      vTaskDelay(1);
   86c5a:	2001      	movs	r0, #1
   86c5c:	4b06      	ldr	r3, [pc, #24]	; (86c78 <_ZN3ard12TeleopThread3runEv+0x50>)
   86c5e:	4798      	blx	r3
  }

  void
  TeleopThread::run ()
  {
    while (1)
   86c60:	e7e6      	b.n	86c30 <_ZN3ard12TeleopThread3runEv+0x8>
   86c62:	bf00      	nop
   86c64:	20070dd8 	.word	0x20070dd8
   86c68:	0008071d 	.word	0x0008071d
   86c6c:	00080791 	.word	0x00080791
   86c70:	00082fad 	.word	0x00082fad
   86c74:	00083485 	.word	0x00083485
   86c78:	0008df01 	.word	0x0008df01

00086c7c <_ZN3ard7IThread5delayEm>:

    virtual void
    run () = 0;

    //Put thread in sleep mode during delay ms.
    void delay(DelayMs delay)
   86c7c:	b580      	push	{r7, lr}
   86c7e:	b082      	sub	sp, #8
   86c80:	af00      	add	r7, sp, #0
   86c82:	6078      	str	r0, [r7, #4]
   86c84:	6039      	str	r1, [r7, #0]
    {
      vTaskDelay(delay);
   86c86:	6838      	ldr	r0, [r7, #0]
   86c88:	4b02      	ldr	r3, [pc, #8]	; (86c94 <_ZN3ard7IThread5delayEm+0x18>)
   86c8a:	4798      	blx	r3
    }
   86c8c:	bf00      	nop
   86c8e:	3708      	adds	r7, #8
   86c90:	46bd      	mov	sp, r7
   86c92:	bd80      	pop	{r7, pc}
   86c94:	0008df01 	.word	0x0008df01

00086c98 <_ZN3ard14ActuatorThread4initEv>:

using namespace ard;

void
ActuatorThread::init ()
{
   86c98:	b590      	push	{r4, r7, lr}
   86c9a:	b087      	sub	sp, #28
   86c9c:	af02      	add	r7, sp, #8
   86c9e:	6078      	str	r0, [r7, #4]
  //create the thread
  g_ArdOs.createPeriodicThread_Cpp("Actuators", *this, STACK_ACTUATORS, PRIO_ACTUATORS, PERIOD_ACTUATORS);
   86ca0:	4b14      	ldr	r3, [pc, #80]	; (86cf4 <_ZN3ard14ActuatorThread4initEv+0x5c>)
   86ca2:	4798      	blx	r3
   86ca4:	687a      	ldr	r2, [r7, #4]
   86ca6:	2364      	movs	r3, #100	; 0x64
   86ca8:	9301      	str	r3, [sp, #4]
   86caa:	2305      	movs	r3, #5
   86cac:	9300      	str	r3, [sp, #0]
   86cae:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   86cb2:	4911      	ldr	r1, [pc, #68]	; (86cf8 <_ZN3ard14ActuatorThread4initEv+0x60>)
   86cb4:	4c11      	ldr	r4, [pc, #68]	; (86cfc <_ZN3ard14ActuatorThread4initEv+0x64>)
   86cb6:	47a0      	blx	r4

  for(int i = 0 ; i < nextRank ; ++i)
   86cb8:	2300      	movs	r3, #0
   86cba:	60fb      	str	r3, [r7, #12]
   86cbc:	687b      	ldr	r3, [r7, #4]
   86cbe:	7a1b      	ldrb	r3, [r3, #8]
   86cc0:	461a      	mov	r2, r3
   86cc2:	68fb      	ldr	r3, [r7, #12]
   86cc4:	429a      	cmp	r2, r3
   86cc6:	dd11      	ble.n	86cec <_ZN3ard14ActuatorThread4initEv+0x54>
    {
      threadlets[i]->init();
   86cc8:	687a      	ldr	r2, [r7, #4]
   86cca:	68fb      	ldr	r3, [r7, #12]
   86ccc:	009b      	lsls	r3, r3, #2
   86cce:	4413      	add	r3, r2
   86cd0:	685b      	ldr	r3, [r3, #4]
   86cd2:	681b      	ldr	r3, [r3, #0]
   86cd4:	681a      	ldr	r2, [r3, #0]
   86cd6:	6879      	ldr	r1, [r7, #4]
   86cd8:	68fb      	ldr	r3, [r7, #12]
   86cda:	009b      	lsls	r3, r3, #2
   86cdc:	440b      	add	r3, r1
   86cde:	685b      	ldr	r3, [r3, #4]
   86ce0:	4618      	mov	r0, r3
   86ce2:	4790      	blx	r2
ActuatorThread::init ()
{
  //create the thread
  g_ArdOs.createPeriodicThread_Cpp("Actuators", *this, STACK_ACTUATORS, PRIO_ACTUATORS, PERIOD_ACTUATORS);

  for(int i = 0 ; i < nextRank ; ++i)
   86ce4:	68fb      	ldr	r3, [r7, #12]
   86ce6:	3301      	adds	r3, #1
   86ce8:	60fb      	str	r3, [r7, #12]
   86cea:	e7e7      	b.n	86cbc <_ZN3ard14ActuatorThread4initEv+0x24>
    {
      threadlets[i]->init();
    }
}
   86cec:	bf00      	nop
   86cee:	3714      	adds	r7, #20
   86cf0:	46bd      	mov	sp, r7
   86cf2:	bd90      	pop	{r4, r7, pc}
   86cf4:	00082fad 	.word	0x00082fad
   86cf8:	0009aa68 	.word	0x0009aa68
   86cfc:	000838d9 	.word	0x000838d9

00086d00 <_ZN3ard14ActuatorThread3runEv>:

void
ActuatorThread::run ()
{
   86d00:	b580      	push	{r7, lr}
   86d02:	b084      	sub	sp, #16
   86d04:	af00      	add	r7, sp, #0
   86d06:	6078      	str	r0, [r7, #4]
// Uncomment for oscilloscope debug and tests
//    static int8_t toggle = 0;
//    toggle = 1 - toggle;
//    digitalWrite(DEBUG_2, toggle);

  for(int i = 0 ; i < nextRank ; ++i)
   86d08:	2300      	movs	r3, #0
   86d0a:	60fb      	str	r3, [r7, #12]
   86d0c:	687b      	ldr	r3, [r7, #4]
   86d0e:	7a1b      	ldrb	r3, [r3, #8]
   86d10:	461a      	mov	r2, r3
   86d12:	68fb      	ldr	r3, [r7, #12]
   86d14:	429a      	cmp	r2, r3
   86d16:	dd13      	ble.n	86d40 <_ZN3ard14ActuatorThread3runEv+0x40>
    {
      threadlets[i]->update(PERIOD_ACTUATORS);
   86d18:	687a      	ldr	r2, [r7, #4]
   86d1a:	68fb      	ldr	r3, [r7, #12]
   86d1c:	009b      	lsls	r3, r3, #2
   86d1e:	4413      	add	r3, r2
   86d20:	685b      	ldr	r3, [r3, #4]
   86d22:	681b      	ldr	r3, [r3, #0]
   86d24:	3304      	adds	r3, #4
   86d26:	681a      	ldr	r2, [r3, #0]
   86d28:	6879      	ldr	r1, [r7, #4]
   86d2a:	68fb      	ldr	r3, [r7, #12]
   86d2c:	009b      	lsls	r3, r3, #2
   86d2e:	440b      	add	r3, r1
   86d30:	685b      	ldr	r3, [r3, #4]
   86d32:	2164      	movs	r1, #100	; 0x64
   86d34:	4618      	mov	r0, r3
   86d36:	4790      	blx	r2
// Uncomment for oscilloscope debug and tests
//    static int8_t toggle = 0;
//    toggle = 1 - toggle;
//    digitalWrite(DEBUG_2, toggle);

  for(int i = 0 ; i < nextRank ; ++i)
   86d38:	68fb      	ldr	r3, [r7, #12]
   86d3a:	3301      	adds	r3, #1
   86d3c:	60fb      	str	r3, [r7, #12]
   86d3e:	e7e5      	b.n	86d0c <_ZN3ard14ActuatorThread3runEv+0xc>
    {
      threadlets[i]->update(PERIOD_ACTUATORS);
    }
}
   86d40:	bf00      	nop
   86d42:	3710      	adds	r7, #16
   86d44:	46bd      	mov	sp, r7
   86d46:	bd80      	pop	{r7, pc}

00086d48 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE>:

void
ActuatorThread::addMiniThread(IMiniPeriodicThread* threadlet )
{
   86d48:	b590      	push	{r4, r7, lr}
   86d4a:	b08d      	sub	sp, #52	; 0x34
   86d4c:	af00      	add	r7, sp, #0
   86d4e:	6078      	str	r0, [r7, #4]
   86d50:	6039      	str	r1, [r7, #0]
  ardAssert(nextRank < NB_MAX_MINI_THREADS, "Actuators : too many mini threads");
   86d52:	687b      	ldr	r3, [r7, #4]
   86d54:	7a1b      	ldrb	r3, [r3, #8]
   86d56:	2b00      	cmp	r3, #0
   86d58:	d039      	beq.n	86dce <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0x86>
   86d5a:	4b25      	ldr	r3, [pc, #148]	; (86df0 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xa8>)
   86d5c:	4798      	blx	r3
   86d5e:	4604      	mov	r4, r0
   86d60:	f107 0324 	add.w	r3, r7, #36	; 0x24
   86d64:	4923      	ldr	r1, [pc, #140]	; (86df4 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xac>)
   86d66:	4618      	mov	r0, r3
   86d68:	4b23      	ldr	r3, [pc, #140]	; (86df8 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xb0>)
   86d6a:	4798      	blx	r3
   86d6c:	f107 0224 	add.w	r2, r7, #36	; 0x24
   86d70:	f107 0318 	add.w	r3, r7, #24
   86d74:	4611      	mov	r1, r2
   86d76:	4618      	mov	r0, r3
   86d78:	4b20      	ldr	r3, [pc, #128]	; (86dfc <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xb4>)
   86d7a:	4798      	blx	r3
   86d7c:	f107 0318 	add.w	r3, r7, #24
   86d80:	491f      	ldr	r1, [pc, #124]	; (86e00 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xb8>)
   86d82:	4618      	mov	r0, r3
   86d84:	4b1f      	ldr	r3, [pc, #124]	; (86e04 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xbc>)
   86d86:	4798      	blx	r3
   86d88:	4603      	mov	r3, r0
   86d8a:	461a      	mov	r2, r3
   86d8c:	f107 030c 	add.w	r3, r7, #12
   86d90:	4611      	mov	r1, r2
   86d92:	4618      	mov	r0, r3
   86d94:	4b1c      	ldr	r3, [pc, #112]	; (86e08 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xc0>)
   86d96:	4798      	blx	r3
   86d98:	f107 030c 	add.w	r3, r7, #12
   86d9c:	4619      	mov	r1, r3
   86d9e:	4620      	mov	r0, r4
   86da0:	4b1a      	ldr	r3, [pc, #104]	; (86e0c <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xc4>)
   86da2:	4798      	blx	r3
   86da4:	f107 030c 	add.w	r3, r7, #12
   86da8:	4618      	mov	r0, r3
   86daa:	4b19      	ldr	r3, [pc, #100]	; (86e10 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xc8>)
   86dac:	4798      	blx	r3
   86dae:	f107 0318 	add.w	r3, r7, #24
   86db2:	4618      	mov	r0, r3
   86db4:	4b17      	ldr	r3, [pc, #92]	; (86e14 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xcc>)
   86db6:	4798      	blx	r3
   86db8:	f107 0324 	add.w	r3, r7, #36	; 0x24
   86dbc:	4618      	mov	r0, r3
   86dbe:	4b14      	ldr	r3, [pc, #80]	; (86e10 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xc8>)
   86dc0:	4798      	blx	r3
   86dc2:	687b      	ldr	r3, [r7, #4]
   86dc4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   86dc8:	4618      	mov	r0, r3
   86dca:	4b13      	ldr	r3, [pc, #76]	; (86e18 <_ZN3ard14ActuatorThread13addMiniThreadEPNS_19IMiniPeriodicThreadE+0xd0>)
   86dcc:	4798      	blx	r3
  threadlets[nextRank] = threadlet;
   86dce:	687b      	ldr	r3, [r7, #4]
   86dd0:	7a1b      	ldrb	r3, [r3, #8]
   86dd2:	687a      	ldr	r2, [r7, #4]
   86dd4:	009b      	lsls	r3, r3, #2
   86dd6:	4413      	add	r3, r2
   86dd8:	683a      	ldr	r2, [r7, #0]
   86dda:	605a      	str	r2, [r3, #4]
  nextRank++;
   86ddc:	687b      	ldr	r3, [r7, #4]
   86dde:	7a1b      	ldrb	r3, [r3, #8]
   86de0:	3301      	adds	r3, #1
   86de2:	b2da      	uxtb	r2, r3
   86de4:	687b      	ldr	r3, [r7, #4]
   86de6:	721a      	strb	r2, [r3, #8]
}
   86de8:	bf00      	nop
   86dea:	3734      	adds	r7, #52	; 0x34
   86dec:	46bd      	mov	sp, r7
   86dee:	bd90      	pop	{r4, r7, pc}
   86df0:	00082fad 	.word	0x00082fad
   86df4:	0009aa74 	.word	0x0009aa74
   86df8:	00089009 	.word	0x00089009
   86dfc:	00082f89 	.word	0x00082f89
   86e00:	0009aa84 	.word	0x0009aa84
   86e04:	0008951d 	.word	0x0008951d
   86e08:	00089049 	.word	0x00089049
   86e0c:	00083845 	.word	0x00083845
   86e10:	00089145 	.word	0x00089145
   86e14:	00082fe9 	.word	0x00082fe9
   86e18:	00086c7d 	.word	0x00086c7d

00086e1c <_ZN3ard14ActuatorThreadD1Ev>:
  class ActuatorThread : public IThread
  {
  public:
    ActuatorThread () = default;
    virtual
    ~ActuatorThread () = default;
   86e1c:	b580      	push	{r7, lr}
   86e1e:	b082      	sub	sp, #8
   86e20:	af00      	add	r7, sp, #0
   86e22:	6078      	str	r0, [r7, #4]
   86e24:	4a08      	ldr	r2, [pc, #32]	; (86e48 <_ZN3ard14ActuatorThreadD1Ev+0x2c>)
   86e26:	687b      	ldr	r3, [r7, #4]
   86e28:	601a      	str	r2, [r3, #0]
   86e2a:	687b      	ldr	r3, [r7, #4]
   86e2c:	4618      	mov	r0, r3
   86e2e:	4b07      	ldr	r3, [pc, #28]	; (86e4c <_ZN3ard14ActuatorThreadD1Ev+0x30>)
   86e30:	4798      	blx	r3
   86e32:	2300      	movs	r3, #0
   86e34:	2b00      	cmp	r3, #0
   86e36:	d002      	beq.n	86e3e <_ZN3ard14ActuatorThreadD1Ev+0x22>
   86e38:	6878      	ldr	r0, [r7, #4]
   86e3a:	4b05      	ldr	r3, [pc, #20]	; (86e50 <_ZN3ard14ActuatorThreadD1Ev+0x34>)
   86e3c:	4798      	blx	r3
   86e3e:	687b      	ldr	r3, [r7, #4]
   86e40:	4618      	mov	r0, r3
   86e42:	3708      	adds	r7, #8
   86e44:	46bd      	mov	sp, r7
   86e46:	bd80      	pop	{r7, pc}
   86e48:	0009aab0 	.word	0x0009aab0
   86e4c:	00084969 	.word	0x00084969
   86e50:	0008788d 	.word	0x0008788d

00086e54 <_ZN3ard14ActuatorThreadD0Ev>:
   86e54:	b580      	push	{r7, lr}
   86e56:	b082      	sub	sp, #8
   86e58:	af00      	add	r7, sp, #0
   86e5a:	6078      	str	r0, [r7, #4]
   86e5c:	6878      	ldr	r0, [r7, #4]
   86e5e:	4b05      	ldr	r3, [pc, #20]	; (86e74 <_ZN3ard14ActuatorThreadD0Ev+0x20>)
   86e60:	4798      	blx	r3
   86e62:	6878      	ldr	r0, [r7, #4]
   86e64:	4b04      	ldr	r3, [pc, #16]	; (86e78 <_ZN3ard14ActuatorThreadD0Ev+0x24>)
   86e66:	4798      	blx	r3
   86e68:	687b      	ldr	r3, [r7, #4]
   86e6a:	4618      	mov	r0, r3
   86e6c:	3708      	adds	r7, #8
   86e6e:	46bd      	mov	sp, r7
   86e70:	bd80      	pop	{r7, pc}
   86e72:	bf00      	nop
   86e74:	00086e1d 	.word	0x00086e1d
   86e78:	0008788d 	.word	0x0008788d

00086e7c <_ZNK3ard13FilteredInput4readEv>:

    /**
     * Read the filtered value
     */
    eGpioLevel
    read () const
   86e7c:	b480      	push	{r7}
   86e7e:	b083      	sub	sp, #12
   86e80:	af00      	add	r7, sp, #0
   86e82:	6078      	str	r0, [r7, #4]
    {
      return filteredLevel;
   86e84:	687b      	ldr	r3, [r7, #4]
   86e86:	785b      	ldrb	r3, [r3, #1]
    }
   86e88:	4618      	mov	r0, r3
   86e8a:	370c      	adds	r7, #12
   86e8c:	46bd      	mov	sp, r7
   86e8e:	bc80      	pop	{r7}
   86e90:	4770      	bx	lr
   86e92:	bf00      	nop

00086e94 <_ZNK3ard13FilteredInput7readRawEv>:

    /**
     * Read the raw value (unfiltered
     */
    eGpioLevel
    readRaw () const
   86e94:	b580      	push	{r7, lr}
   86e96:	b082      	sub	sp, #8
   86e98:	af00      	add	r7, sp, #0
   86e9a:	6078      	str	r0, [r7, #4]
    {
      return digitalRead (pin) ? GPIO_HIGH : GPIO_LOW;
   86e9c:	687b      	ldr	r3, [r7, #4]
   86e9e:	781b      	ldrb	r3, [r3, #0]
   86ea0:	4618      	mov	r0, r3
   86ea2:	4b06      	ldr	r3, [pc, #24]	; (86ebc <_ZNK3ard13FilteredInput7readRawEv+0x28>)
   86ea4:	4798      	blx	r3
   86ea6:	4603      	mov	r3, r0
   86ea8:	2b00      	cmp	r3, #0
   86eaa:	d001      	beq.n	86eb0 <_ZNK3ard13FilteredInput7readRawEv+0x1c>
   86eac:	2301      	movs	r3, #1
   86eae:	e000      	b.n	86eb2 <_ZNK3ard13FilteredInput7readRawEv+0x1e>
   86eb0:	2300      	movs	r3, #0
    }
   86eb2:	4618      	mov	r0, r3
   86eb4:	3708      	adds	r7, #8
   86eb6:	46bd      	mov	sp, r7
   86eb8:	bd80      	pop	{r7, pc}
   86eba:	bf00      	nop
   86ebc:	00082031 	.word	0x00082031

00086ec0 <_ZN3ard10Navigation11setPositionEfff>:
     * on the value configured with setColor()
     */
    void
    setPosition (PointCap newPose);
    void
    setPosition(float x, float y, float h){setPosition(PointCap(x,y,h));};
   86ec0:	b590      	push	{r4, r7, lr}
   86ec2:	b089      	sub	sp, #36	; 0x24
   86ec4:	af00      	add	r7, sp, #0
   86ec6:	60f8      	str	r0, [r7, #12]
   86ec8:	60b9      	str	r1, [r7, #8]
   86eca:	607a      	str	r2, [r7, #4]
   86ecc:	603b      	str	r3, [r7, #0]
   86ece:	f107 0010 	add.w	r0, r7, #16
   86ed2:	683b      	ldr	r3, [r7, #0]
   86ed4:	687a      	ldr	r2, [r7, #4]
   86ed6:	68b9      	ldr	r1, [r7, #8]
   86ed8:	4c08      	ldr	r4, [pc, #32]	; (86efc <_ZN3ard10Navigation11setPositionEfff+0x3c>)
   86eda:	47a0      	blx	r4
   86edc:	f107 0310 	add.w	r3, r7, #16
   86ee0:	4619      	mov	r1, r3
   86ee2:	68f8      	ldr	r0, [r7, #12]
   86ee4:	4b06      	ldr	r3, [pc, #24]	; (86f00 <_ZN3ard10Navigation11setPositionEfff+0x40>)
   86ee6:	4798      	blx	r3
   86ee8:	f107 0310 	add.w	r3, r7, #16
   86eec:	4618      	mov	r0, r3
   86eee:	4b05      	ldr	r3, [pc, #20]	; (86f04 <_ZN3ard10Navigation11setPositionEfff+0x44>)
   86ef0:	4798      	blx	r3
   86ef2:	bf00      	nop
   86ef4:	3724      	adds	r7, #36	; 0x24
   86ef6:	46bd      	mov	sp, r7
   86ef8:	bd90      	pop	{r4, r7, pc}
   86efa:	bf00      	nop
   86efc:	0008fb1d 	.word	0x0008fb1d
   86f00:	000863d1 	.word	0x000863d1
   86f04:	00086b11 	.word	0x00086b11

00086f08 <_ZN3ard10Navigation4goToEffNS_6sens_tE>:
     In order to wait until the order is complete, use the wait()/targetReached() functions
     */
    void
    goTo (Point target, sens_t sens = SENS_AV);
    void
    goTo (float x, float y, sens_t sens = SENS_AV){goTo(Point(x,y), sens);};
   86f08:	b580      	push	{r7, lr}
   86f0a:	b088      	sub	sp, #32
   86f0c:	af00      	add	r7, sp, #0
   86f0e:	60f8      	str	r0, [r7, #12]
   86f10:	60b9      	str	r1, [r7, #8]
   86f12:	607a      	str	r2, [r7, #4]
   86f14:	70fb      	strb	r3, [r7, #3]
   86f16:	f107 0314 	add.w	r3, r7, #20
   86f1a:	687a      	ldr	r2, [r7, #4]
   86f1c:	68b9      	ldr	r1, [r7, #8]
   86f1e:	4618      	mov	r0, r3
   86f20:	4b09      	ldr	r3, [pc, #36]	; (86f48 <_ZN3ard10Navigation4goToEffNS_6sens_tE+0x40>)
   86f22:	4798      	blx	r3
   86f24:	f997 2003 	ldrsb.w	r2, [r7, #3]
   86f28:	f107 0314 	add.w	r3, r7, #20
   86f2c:	4619      	mov	r1, r3
   86f2e:	68f8      	ldr	r0, [r7, #12]
   86f30:	4b06      	ldr	r3, [pc, #24]	; (86f4c <_ZN3ard10Navigation4goToEffNS_6sens_tE+0x44>)
   86f32:	4798      	blx	r3
   86f34:	f107 0314 	add.w	r3, r7, #20
   86f38:	4618      	mov	r0, r3
   86f3a:	4b05      	ldr	r3, [pc, #20]	; (86f50 <_ZN3ard10Navigation4goToEffNS_6sens_tE+0x48>)
   86f3c:	4798      	blx	r3
   86f3e:	bf00      	nop
   86f40:	3720      	adds	r7, #32
   86f42:	46bd      	mov	sp, r7
   86f44:	bd80      	pop	{r7, pc}
   86f46:	bf00      	nop
   86f48:	0008f7c1 	.word	0x0008f7c1
   86f4c:	00086489 	.word	0x00086489
   86f50:	000859fd 	.word	0x000859fd

00086f54 <_ZN3ard10Navigation16getOmronState_FLEv>:
    void
    setSpeed (float speed);
    void
    setSpeedVir (float s);

    eGpioLevel getOmronState_FL(){return omronFrontLeft.readRaw();};
   86f54:	b580      	push	{r7, lr}
   86f56:	b082      	sub	sp, #8
   86f58:	af00      	add	r7, sp, #0
   86f5a:	6078      	str	r0, [r7, #4]
   86f5c:	687b      	ldr	r3, [r7, #4]
   86f5e:	33e0      	adds	r3, #224	; 0xe0
   86f60:	4618      	mov	r0, r3
   86f62:	4b03      	ldr	r3, [pc, #12]	; (86f70 <_ZN3ard10Navigation16getOmronState_FLEv+0x1c>)
   86f64:	4798      	blx	r3
   86f66:	4603      	mov	r3, r0
   86f68:	4618      	mov	r0, r3
   86f6a:	3708      	adds	r7, #8
   86f6c:	46bd      	mov	sp, r7
   86f6e:	bd80      	pop	{r7, pc}
   86f70:	00086e95 	.word	0x00086e95

00086f74 <_ZN3ard10Navigation16getOmronState_FREv>:
    eGpioLevel getOmronState_FR(){return omronFrontRight.readRaw();};
   86f74:	b580      	push	{r7, lr}
   86f76:	b082      	sub	sp, #8
   86f78:	af00      	add	r7, sp, #0
   86f7a:	6078      	str	r0, [r7, #4]
   86f7c:	687b      	ldr	r3, [r7, #4]
   86f7e:	f503 7380 	add.w	r3, r3, #256	; 0x100
   86f82:	4618      	mov	r0, r3
   86f84:	4b03      	ldr	r3, [pc, #12]	; (86f94 <_ZN3ard10Navigation16getOmronState_FREv+0x20>)
   86f86:	4798      	blx	r3
   86f88:	4603      	mov	r3, r0
   86f8a:	4618      	mov	r0, r3
   86f8c:	3708      	adds	r7, #8
   86f8e:	46bd      	mov	sp, r7
   86f90:	bd80      	pop	{r7, pc}
   86f92:	bf00      	nop
   86f94:	00086e95 	.word	0x00086e95

00086f98 <_ZN3ard10Navigation16getOmronState_RLEv>:
    eGpioLevel getOmronState_RL(){return omronRearLeft.readRaw();};
   86f98:	b580      	push	{r7, lr}
   86f9a:	b082      	sub	sp, #8
   86f9c:	af00      	add	r7, sp, #0
   86f9e:	6078      	str	r0, [r7, #4]
   86fa0:	687b      	ldr	r3, [r7, #4]
   86fa2:	f503 7390 	add.w	r3, r3, #288	; 0x120
   86fa6:	4618      	mov	r0, r3
   86fa8:	4b03      	ldr	r3, [pc, #12]	; (86fb8 <_ZN3ard10Navigation16getOmronState_RLEv+0x20>)
   86faa:	4798      	blx	r3
   86fac:	4603      	mov	r3, r0
   86fae:	4618      	mov	r0, r3
   86fb0:	3708      	adds	r7, #8
   86fb2:	46bd      	mov	sp, r7
   86fb4:	bd80      	pop	{r7, pc}
   86fb6:	bf00      	nop
   86fb8:	00086e95 	.word	0x00086e95

00086fbc <_ZN3ard10Navigation16getOmronState_RREv>:
    eGpioLevel getOmronState_RR(){return omronRearRight.readRaw();};
   86fbc:	b580      	push	{r7, lr}
   86fbe:	b082      	sub	sp, #8
   86fc0:	af00      	add	r7, sp, #0
   86fc2:	6078      	str	r0, [r7, #4]
   86fc4:	687b      	ldr	r3, [r7, #4]
   86fc6:	f503 73a0 	add.w	r3, r3, #320	; 0x140
   86fca:	4618      	mov	r0, r3
   86fcc:	4b03      	ldr	r3, [pc, #12]	; (86fdc <_ZN3ard10Navigation16getOmronState_RREv+0x20>)
   86fce:	4798      	blx	r3
   86fd0:	4603      	mov	r3, r0
   86fd2:	4618      	mov	r0, r3
   86fd4:	3708      	adds	r7, #8
   86fd6:	46bd      	mov	sp, r7
   86fd8:	bd80      	pop	{r7, pc}
   86fda:	bf00      	nop
   86fdc:	00086e95 	.word	0x00086e95

00086fe0 <_ZN3ard9Robot201711getInstanceEv>:
  class Robot2017
  {
  public:
    //retrieve the singleton instance (you should prefer the use of the g_ArdOs maccro)
    static Robot2017&
    getInstance ()
   86fe0:	b480      	push	{r7}
   86fe2:	af00      	add	r7, sp, #0
    {
      return instance;
   86fe4:	4b02      	ldr	r3, [pc, #8]	; (86ff0 <_ZN3ard9Robot201711getInstanceEv+0x10>)
    }
   86fe6:	4618      	mov	r0, r3
   86fe8:	46bd      	mov	sp, r7
   86fea:	bc80      	pop	{r7}
   86fec:	4770      	bx	lr
   86fee:	bf00      	nop
   86ff0:	200709d8 	.word	0x200709d8

00086ff4 <_ZN3ard14StrategyThread4initEv>:

using namespace ard;

void
StrategyThread::init ()
{
   86ff4:	b590      	push	{r4, r7, lr}
   86ff6:	b085      	sub	sp, #20
   86ff8:	af02      	add	r7, sp, #8
   86ffa:	6078      	str	r0, [r7, #4]
  //create the thread
  g_ArdOs.createThread_Cpp("Strategy", *this, STACK_STRATEGY, PRIO_STRATEGY);
   86ffc:	4b06      	ldr	r3, [pc, #24]	; (87018 <_ZN3ard14StrategyThread4initEv+0x24>)
   86ffe:	4798      	blx	r3
   87000:	687a      	ldr	r2, [r7, #4]
   87002:	2304      	movs	r3, #4
   87004:	9300      	str	r3, [sp, #0]
   87006:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   8700a:	4904      	ldr	r1, [pc, #16]	; (8701c <_ZN3ard14StrategyThread4initEv+0x28>)
   8700c:	4c04      	ldr	r4, [pc, #16]	; (87020 <_ZN3ard14StrategyThread4initEv+0x2c>)
   8700e:	47a0      	blx	r4
}
   87010:	bf00      	nop
   87012:	370c      	adds	r7, #12
   87014:	46bd      	mov	sp, r7
   87016:	bd90      	pop	{r4, r7, pc}
   87018:	00082fad 	.word	0x00082fad
   8701c:	0009aac0 	.word	0x0009aac0
   87020:	000838a9 	.word	0x000838a9

00087024 <_ZN3ard14StrategyThread3runEv>:

void
StrategyThread::run ()
{
   87024:	b5b0      	push	{r4, r5, r7, lr}
   87026:	b086      	sub	sp, #24
   87028:	af00      	add	r7, sp, #0
   8702a:	6078      	str	r0, [r7, #4]
  LOG(INFO, "STRAT : Waiting start withdraw.");
   8702c:	4b1f      	ldr	r3, [pc, #124]	; (870ac <_ZN3ard14StrategyThread3runEv+0x88>)
   8702e:	4798      	blx	r3
   87030:	4605      	mov	r5, r0
   87032:	682b      	ldr	r3, [r5, #0]
   87034:	3310      	adds	r3, #16
   87036:	681c      	ldr	r4, [r3, #0]
   87038:	f107 030c 	add.w	r3, r7, #12
   8703c:	491c      	ldr	r1, [pc, #112]	; (870b0 <_ZN3ard14StrategyThread3runEv+0x8c>)
   8703e:	4618      	mov	r0, r3
   87040:	4b1c      	ldr	r3, [pc, #112]	; (870b4 <_ZN3ard14StrategyThread3runEv+0x90>)
   87042:	4798      	blx	r3
   87044:	f107 030c 	add.w	r3, r7, #12
   87048:	461a      	mov	r2, r3
   8704a:	2101      	movs	r1, #1
   8704c:	4628      	mov	r0, r5
   8704e:	47a0      	blx	r4
   87050:	f107 030c 	add.w	r3, r7, #12
   87054:	4618      	mov	r0, r3
   87056:	4b18      	ldr	r3, [pc, #96]	; (870b8 <_ZN3ard14StrategyThread3runEv+0x94>)
   87058:	4798      	blx	r3
//  ROBOT.hmi.start.wait(FALLING_EDGE);
  readUserInputs();
   8705a:	6878      	ldr	r0, [r7, #4]
   8705c:	4b17      	ldr	r3, [pc, #92]	; (870bc <_ZN3ard14StrategyThread3runEv+0x98>)
   8705e:	4798      	blx	r3

  switch (strategyId) {
   87060:	687b      	ldr	r3, [r7, #4]
   87062:	791b      	ldrb	r3, [r3, #4]
   87064:	2b03      	cmp	r3, #3
   87066:	d81b      	bhi.n	870a0 <_ZN3ard14StrategyThread3runEv+0x7c>
   87068:	a201      	add	r2, pc, #4	; (adr r2, 87070 <_ZN3ard14StrategyThread3runEv+0x4c>)
   8706a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   8706e:	bf00      	nop
   87070:	00087081 	.word	0x00087081
   87074:	00087089 	.word	0x00087089
   87078:	00087091 	.word	0x00087091
   8707c:	00087099 	.word	0x00087099
    case 0:
      Strategy_Alpha();
   87080:	6878      	ldr	r0, [r7, #4]
   87082:	4b0f      	ldr	r3, [pc, #60]	; (870c0 <_ZN3ard14StrategyThread3runEv+0x9c>)
   87084:	4798      	blx	r3
      break;
   87086:	e00c      	b.n	870a2 <_ZN3ard14StrategyThread3runEv+0x7e>
    case 1:
      Strategy_LedTest();
   87088:	6878      	ldr	r0, [r7, #4]
   8708a:	4b0e      	ldr	r3, [pc, #56]	; (870c4 <_ZN3ard14StrategyThread3runEv+0xa0>)
   8708c:	4798      	blx	r3
      break;
   8708e:	e008      	b.n	870a2 <_ZN3ard14StrategyThread3runEv+0x7e>
    case 2:
      Strategy_ButtonTest();
   87090:	6878      	ldr	r0, [r7, #4]
   87092:	4b0d      	ldr	r3, [pc, #52]	; (870c8 <_ZN3ard14StrategyThread3runEv+0xa4>)
   87094:	4798      	blx	r3
      break;
   87096:	e004      	b.n	870a2 <_ZN3ard14StrategyThread3runEv+0x7e>
    case 3:
      Strategy_OmronTest();
   87098:	6878      	ldr	r0, [r7, #4]
   8709a:	4b0c      	ldr	r3, [pc, #48]	; (870cc <_ZN3ard14StrategyThread3runEv+0xa8>)
   8709c:	4798      	blx	r3
      break;
   8709e:	e000      	b.n	870a2 <_ZN3ard14StrategyThread3runEv+0x7e>
    default:
      break;
   870a0:	bf00      	nop
  }
}
   870a2:	bf00      	nop
   870a4:	3718      	adds	r7, #24
   870a6:	46bd      	mov	sp, r7
   870a8:	bdb0      	pop	{r4, r5, r7, pc}
   870aa:	bf00      	nop
   870ac:	000859e9 	.word	0x000859e9
   870b0:	0009aacc 	.word	0x0009aacc
   870b4:	00089009 	.word	0x00089009
   870b8:	00089145 	.word	0x00089145
   870bc:	00087639 	.word	0x00087639
   870c0:	000870d1 	.word	0x000870d1
   870c4:	0008722d 	.word	0x0008722d
   870c8:	00087375 	.word	0x00087375
   870cc:	000874cd 	.word	0x000874cd

000870d0 <_ZN3ard14StrategyThread14Strategy_AlphaEv>:

void
StrategyThread::Strategy_Alpha ()
{
   870d0:	b5b0      	push	{r4, r5, r7, lr}
   870d2:	b08e      	sub	sp, #56	; 0x38
   870d4:	af00      	add	r7, sp, #0
   870d6:	6078      	str	r0, [r7, #4]
  LOG(INFO, "STRAT : Strategy_Alpha.");
   870d8:	4b48      	ldr	r3, [pc, #288]	; (871fc <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x12c>)
   870da:	4798      	blx	r3
   870dc:	4605      	mov	r5, r0
   870de:	682b      	ldr	r3, [r5, #0]
   870e0:	3310      	adds	r3, #16
   870e2:	681c      	ldr	r4, [r3, #0]
   870e4:	f107 0308 	add.w	r3, r7, #8
   870e8:	4945      	ldr	r1, [pc, #276]	; (87200 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x130>)
   870ea:	4618      	mov	r0, r3
   870ec:	4b45      	ldr	r3, [pc, #276]	; (87204 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x134>)
   870ee:	4798      	blx	r3
   870f0:	f107 0308 	add.w	r3, r7, #8
   870f4:	461a      	mov	r2, r3
   870f6:	2101      	movs	r1, #1
   870f8:	4628      	mov	r0, r5
   870fa:	47a0      	blx	r4
   870fc:	f107 0308 	add.w	r3, r7, #8
   87100:	4618      	mov	r0, r3
   87102:	4b41      	ldr	r3, [pc, #260]	; (87208 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x138>)
   87104:	4798      	blx	r3

  //Set robot to default position
  ROBOT.nav.setPosition(0,0,0);
   87106:	4b41      	ldr	r3, [pc, #260]	; (8720c <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x13c>)
   87108:	4798      	blx	r3
   8710a:	4603      	mov	r3, r0
   8710c:	f503 7086 	add.w	r0, r3, #268	; 0x10c
   87110:	f04f 0300 	mov.w	r3, #0
   87114:	f04f 0200 	mov.w	r2, #0
   87118:	f04f 0100 	mov.w	r1, #0
   8711c:	4c3c      	ldr	r4, [pc, #240]	; (87210 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x140>)
   8711e:	47a0      	blx	r4
  ROBOT.nav.goTo(300, 0, SENS_AV);
   87120:	4b3a      	ldr	r3, [pc, #232]	; (8720c <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x13c>)
   87122:	4798      	blx	r3
   87124:	4603      	mov	r3, r0
   87126:	f503 7086 	add.w	r0, r3, #268	; 0x10c
   8712a:	2301      	movs	r3, #1
   8712c:	f04f 0200 	mov.w	r2, #0
   87130:	4938      	ldr	r1, [pc, #224]	; (87214 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x144>)
   87132:	4c39      	ldr	r4, [pc, #228]	; (87218 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x148>)
   87134:	47a0      	blx	r4
  LOG(INFO,"STRAT : Move order sent, waiting...");
   87136:	4b31      	ldr	r3, [pc, #196]	; (871fc <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x12c>)
   87138:	4798      	blx	r3
   8713a:	4605      	mov	r5, r0
   8713c:	682b      	ldr	r3, [r5, #0]
   8713e:	3310      	adds	r3, #16
   87140:	681c      	ldr	r4, [r3, #0]
   87142:	f107 0314 	add.w	r3, r7, #20
   87146:	4935      	ldr	r1, [pc, #212]	; (8721c <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x14c>)
   87148:	4618      	mov	r0, r3
   8714a:	4b2e      	ldr	r3, [pc, #184]	; (87204 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x134>)
   8714c:	4798      	blx	r3
   8714e:	f107 0314 	add.w	r3, r7, #20
   87152:	461a      	mov	r2, r3
   87154:	2101      	movs	r1, #1
   87156:	4628      	mov	r0, r5
   87158:	47a0      	blx	r4
   8715a:	f107 0314 	add.w	r3, r7, #20
   8715e:	4618      	mov	r0, r3
   87160:	4b29      	ldr	r3, [pc, #164]	; (87208 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x138>)
   87162:	4798      	blx	r3
  ROBOT.nav.wait();
   87164:	4b29      	ldr	r3, [pc, #164]	; (8720c <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x13c>)
   87166:	4798      	blx	r3
   87168:	4603      	mov	r3, r0
   8716a:	f503 7386 	add.w	r3, r3, #268	; 0x10c
   8716e:	4618      	mov	r0, r3
   87170:	4b2b      	ldr	r3, [pc, #172]	; (87220 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x150>)
   87172:	4798      	blx	r3
  LOG(INFO,"STRAT : Return to start pos, waiting...");
   87174:	4b21      	ldr	r3, [pc, #132]	; (871fc <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x12c>)
   87176:	4798      	blx	r3
   87178:	4605      	mov	r5, r0
   8717a:	682b      	ldr	r3, [r5, #0]
   8717c:	3310      	adds	r3, #16
   8717e:	681c      	ldr	r4, [r3, #0]
   87180:	f107 0320 	add.w	r3, r7, #32
   87184:	4927      	ldr	r1, [pc, #156]	; (87224 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x154>)
   87186:	4618      	mov	r0, r3
   87188:	4b1e      	ldr	r3, [pc, #120]	; (87204 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x134>)
   8718a:	4798      	blx	r3
   8718c:	f107 0320 	add.w	r3, r7, #32
   87190:	461a      	mov	r2, r3
   87192:	2101      	movs	r1, #1
   87194:	4628      	mov	r0, r5
   87196:	47a0      	blx	r4
   87198:	f107 0320 	add.w	r3, r7, #32
   8719c:	4618      	mov	r0, r3
   8719e:	4b1a      	ldr	r3, [pc, #104]	; (87208 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x138>)
   871a0:	4798      	blx	r3
  ROBOT.nav.goTo(0, 0, SENS_AV);
   871a2:	4b1a      	ldr	r3, [pc, #104]	; (8720c <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x13c>)
   871a4:	4798      	blx	r3
   871a6:	4603      	mov	r3, r0
   871a8:	f503 7086 	add.w	r0, r3, #268	; 0x10c
   871ac:	2301      	movs	r3, #1
   871ae:	f04f 0200 	mov.w	r2, #0
   871b2:	f04f 0100 	mov.w	r1, #0
   871b6:	4c18      	ldr	r4, [pc, #96]	; (87218 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x148>)
   871b8:	47a0      	blx	r4
  ROBOT.nav.wait();
   871ba:	4b14      	ldr	r3, [pc, #80]	; (8720c <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x13c>)
   871bc:	4798      	blx	r3
   871be:	4603      	mov	r3, r0
   871c0:	f503 7386 	add.w	r3, r3, #268	; 0x10c
   871c4:	4618      	mov	r0, r3
   871c6:	4b16      	ldr	r3, [pc, #88]	; (87220 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x150>)
   871c8:	4798      	blx	r3
  LOG(INFO,"STRAT : Finished.");
   871ca:	4b0c      	ldr	r3, [pc, #48]	; (871fc <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x12c>)
   871cc:	4798      	blx	r3
   871ce:	4605      	mov	r5, r0
   871d0:	682b      	ldr	r3, [r5, #0]
   871d2:	3310      	adds	r3, #16
   871d4:	681c      	ldr	r4, [r3, #0]
   871d6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   871da:	4913      	ldr	r1, [pc, #76]	; (87228 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x158>)
   871dc:	4618      	mov	r0, r3
   871de:	4b09      	ldr	r3, [pc, #36]	; (87204 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x134>)
   871e0:	4798      	blx	r3
   871e2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   871e6:	461a      	mov	r2, r3
   871e8:	2101      	movs	r1, #1
   871ea:	4628      	mov	r0, r5
   871ec:	47a0      	blx	r4
   871ee:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   871f2:	4618      	mov	r0, r3
   871f4:	4b04      	ldr	r3, [pc, #16]	; (87208 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x138>)
   871f6:	4798      	blx	r3
  while(1);
   871f8:	e7fe      	b.n	871f8 <_ZN3ard14StrategyThread14Strategy_AlphaEv+0x128>
   871fa:	bf00      	nop
   871fc:	000859e9 	.word	0x000859e9
   87200:	0009aaec 	.word	0x0009aaec
   87204:	00089009 	.word	0x00089009
   87208:	00089145 	.word	0x00089145
   8720c:	00086fe1 	.word	0x00086fe1
   87210:	00086ec1 	.word	0x00086ec1
   87214:	43960000 	.word	0x43960000
   87218:	00086f09 	.word	0x00086f09
   8721c:	0009ab04 	.word	0x0009ab04
   87220:	000865b5 	.word	0x000865b5
   87224:	0009ab28 	.word	0x0009ab28
   87228:	0009ab50 	.word	0x0009ab50

0008722c <_ZN3ard14StrategyThread16Strategy_LedTestEv>:
}

void
StrategyThread::Strategy_LedTest ()
{
   8722c:	b5b0      	push	{r4, r5, r7, lr}
   8722e:	b086      	sub	sp, #24
   87230:	af00      	add	r7, sp, #0
   87232:	6078      	str	r0, [r7, #4]
  int WAIT = 200;
   87234:	23c8      	movs	r3, #200	; 0xc8
   87236:	617b      	str	r3, [r7, #20]
  LOG(INFO, "STRAT : Strategy_LedTest.");
   87238:	4b45      	ldr	r3, [pc, #276]	; (87350 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x124>)
   8723a:	4798      	blx	r3
   8723c:	4605      	mov	r5, r0
   8723e:	682b      	ldr	r3, [r5, #0]
   87240:	3310      	adds	r3, #16
   87242:	681c      	ldr	r4, [r3, #0]
   87244:	f107 0308 	add.w	r3, r7, #8
   87248:	4942      	ldr	r1, [pc, #264]	; (87354 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x128>)
   8724a:	4618      	mov	r0, r3
   8724c:	4b42      	ldr	r3, [pc, #264]	; (87358 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x12c>)
   8724e:	4798      	blx	r3
   87250:	f107 0308 	add.w	r3, r7, #8
   87254:	461a      	mov	r2, r3
   87256:	2101      	movs	r1, #1
   87258:	4628      	mov	r0, r5
   8725a:	47a0      	blx	r4
   8725c:	f107 0308 	add.w	r3, r7, #8
   87260:	4618      	mov	r0, r3
   87262:	4b3e      	ldr	r3, [pc, #248]	; (8735c <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x130>)
   87264:	4798      	blx	r3

  while (1)
    {
      ROBOT.hmi.ledRGB.set (RED, ON);
   87266:	4b3e      	ldr	r3, [pc, #248]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   87268:	4798      	blx	r3
   8726a:	4603      	mov	r3, r0
   8726c:	3304      	adds	r3, #4
   8726e:	2201      	movs	r2, #1
   87270:	2100      	movs	r1, #0
   87272:	4618      	mov	r0, r3
   87274:	4b3b      	ldr	r3, [pc, #236]	; (87364 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x138>)
   87276:	4798      	blx	r3
      ROBOT.hmi.led4.off ();
   87278:	4b39      	ldr	r3, [pc, #228]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   8727a:	4798      	blx	r3
   8727c:	4603      	mov	r3, r0
   8727e:	333c      	adds	r3, #60	; 0x3c
   87280:	4618      	mov	r0, r3
   87282:	4b39      	ldr	r3, [pc, #228]	; (87368 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x13c>)
   87284:	4798      	blx	r3
      ROBOT.hmi.led1.on ();
   87286:	4b36      	ldr	r3, [pc, #216]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   87288:	4798      	blx	r3
   8728a:	4603      	mov	r3, r0
   8728c:	3318      	adds	r3, #24
   8728e:	4618      	mov	r0, r3
   87290:	4b36      	ldr	r3, [pc, #216]	; (8736c <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x140>)
   87292:	4798      	blx	r3
      delay (WAIT);
   87294:	687b      	ldr	r3, [r7, #4]
   87296:	697a      	ldr	r2, [r7, #20]
   87298:	4611      	mov	r1, r2
   8729a:	4618      	mov	r0, r3
   8729c:	4b34      	ldr	r3, [pc, #208]	; (87370 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x144>)
   8729e:	4798      	blx	r3
      ROBOT.hmi.ledRGB.set (GREEN, ON);
   872a0:	4b2f      	ldr	r3, [pc, #188]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   872a2:	4798      	blx	r3
   872a4:	4603      	mov	r3, r0
   872a6:	3304      	adds	r3, #4
   872a8:	2201      	movs	r2, #1
   872aa:	2101      	movs	r1, #1
   872ac:	4618      	mov	r0, r3
   872ae:	4b2d      	ldr	r3, [pc, #180]	; (87364 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x138>)
   872b0:	4798      	blx	r3
      ROBOT.hmi.led1.off ();
   872b2:	4b2b      	ldr	r3, [pc, #172]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   872b4:	4798      	blx	r3
   872b6:	4603      	mov	r3, r0
   872b8:	3318      	adds	r3, #24
   872ba:	4618      	mov	r0, r3
   872bc:	4b2a      	ldr	r3, [pc, #168]	; (87368 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x13c>)
   872be:	4798      	blx	r3
      ROBOT.hmi.led2.on ();
   872c0:	4b27      	ldr	r3, [pc, #156]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   872c2:	4798      	blx	r3
   872c4:	4603      	mov	r3, r0
   872c6:	3324      	adds	r3, #36	; 0x24
   872c8:	4618      	mov	r0, r3
   872ca:	4b28      	ldr	r3, [pc, #160]	; (8736c <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x140>)
   872cc:	4798      	blx	r3
      delay (WAIT);
   872ce:	687b      	ldr	r3, [r7, #4]
   872d0:	697a      	ldr	r2, [r7, #20]
   872d2:	4611      	mov	r1, r2
   872d4:	4618      	mov	r0, r3
   872d6:	4b26      	ldr	r3, [pc, #152]	; (87370 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x144>)
   872d8:	4798      	blx	r3
      ROBOT.hmi.ledRGB.set (BLUE, ON);
   872da:	4b21      	ldr	r3, [pc, #132]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   872dc:	4798      	blx	r3
   872de:	4603      	mov	r3, r0
   872e0:	3304      	adds	r3, #4
   872e2:	2201      	movs	r2, #1
   872e4:	2102      	movs	r1, #2
   872e6:	4618      	mov	r0, r3
   872e8:	4b1e      	ldr	r3, [pc, #120]	; (87364 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x138>)
   872ea:	4798      	blx	r3
      ROBOT.hmi.led2.off ();
   872ec:	4b1c      	ldr	r3, [pc, #112]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   872ee:	4798      	blx	r3
   872f0:	4603      	mov	r3, r0
   872f2:	3324      	adds	r3, #36	; 0x24
   872f4:	4618      	mov	r0, r3
   872f6:	4b1c      	ldr	r3, [pc, #112]	; (87368 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x13c>)
   872f8:	4798      	blx	r3
      ROBOT.hmi.led3.on ();
   872fa:	4b19      	ldr	r3, [pc, #100]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   872fc:	4798      	blx	r3
   872fe:	4603      	mov	r3, r0
   87300:	3330      	adds	r3, #48	; 0x30
   87302:	4618      	mov	r0, r3
   87304:	4b19      	ldr	r3, [pc, #100]	; (8736c <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x140>)
   87306:	4798      	blx	r3
      delay (WAIT);
   87308:	687b      	ldr	r3, [r7, #4]
   8730a:	697a      	ldr	r2, [r7, #20]
   8730c:	4611      	mov	r1, r2
   8730e:	4618      	mov	r0, r3
   87310:	4b17      	ldr	r3, [pc, #92]	; (87370 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x144>)
   87312:	4798      	blx	r3
      ROBOT.hmi.ledRGB.set (WHITE, ON);
   87314:	4b12      	ldr	r3, [pc, #72]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   87316:	4798      	blx	r3
   87318:	4603      	mov	r3, r0
   8731a:	3304      	adds	r3, #4
   8731c:	2201      	movs	r2, #1
   8731e:	2106      	movs	r1, #6
   87320:	4618      	mov	r0, r3
   87322:	4b10      	ldr	r3, [pc, #64]	; (87364 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x138>)
   87324:	4798      	blx	r3
      ROBOT.hmi.led3.off ();
   87326:	4b0e      	ldr	r3, [pc, #56]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   87328:	4798      	blx	r3
   8732a:	4603      	mov	r3, r0
   8732c:	3330      	adds	r3, #48	; 0x30
   8732e:	4618      	mov	r0, r3
   87330:	4b0d      	ldr	r3, [pc, #52]	; (87368 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x13c>)
   87332:	4798      	blx	r3
      ROBOT.hmi.led4.on ();
   87334:	4b0a      	ldr	r3, [pc, #40]	; (87360 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x134>)
   87336:	4798      	blx	r3
   87338:	4603      	mov	r3, r0
   8733a:	333c      	adds	r3, #60	; 0x3c
   8733c:	4618      	mov	r0, r3
   8733e:	4b0b      	ldr	r3, [pc, #44]	; (8736c <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x140>)
   87340:	4798      	blx	r3
      delay (WAIT);
   87342:	687b      	ldr	r3, [r7, #4]
   87344:	697a      	ldr	r2, [r7, #20]
   87346:	4611      	mov	r1, r2
   87348:	4618      	mov	r0, r3
   8734a:	4b09      	ldr	r3, [pc, #36]	; (87370 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x144>)
   8734c:	4798      	blx	r3
StrategyThread::Strategy_LedTest ()
{
  int WAIT = 200;
  LOG(INFO, "STRAT : Strategy_LedTest.");

  while (1)
   8734e:	e78a      	b.n	87266 <_ZN3ard14StrategyThread16Strategy_LedTestEv+0x3a>
   87350:	000859e9 	.word	0x000859e9
   87354:	0009ab64 	.word	0x0009ab64
   87358:	00089009 	.word	0x00089009
   8735c:	00089145 	.word	0x00089145
   87360:	00086fe1 	.word	0x00086fe1
   87364:	00084a01 	.word	0x00084a01
   87368:	00084ca9 	.word	0x00084ca9
   8736c:	00084c79 	.word	0x00084c79
   87370:	00086c7d 	.word	0x00086c7d

00087374 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv>:
}


void
StrategyThread::Strategy_ButtonTest ()
{
   87374:	b5b0      	push	{r4, r5, r7, lr}
   87376:	b086      	sub	sp, #24
   87378:	af00      	add	r7, sp, #0
   8737a:	6078      	str	r0, [r7, #4]
  LOG(INFO, "STRAT : Strategy_ButtonTest.");
   8737c:	4b4a      	ldr	r3, [pc, #296]	; (874a8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x134>)
   8737e:	4798      	blx	r3
   87380:	4605      	mov	r5, r0
   87382:	682b      	ldr	r3, [r5, #0]
   87384:	3310      	adds	r3, #16
   87386:	681c      	ldr	r4, [r3, #0]
   87388:	f107 030c 	add.w	r3, r7, #12
   8738c:	4947      	ldr	r1, [pc, #284]	; (874ac <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x138>)
   8738e:	4618      	mov	r0, r3
   87390:	4b47      	ldr	r3, [pc, #284]	; (874b0 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x13c>)
   87392:	4798      	blx	r3
   87394:	f107 030c 	add.w	r3, r7, #12
   87398:	461a      	mov	r2, r3
   8739a:	2101      	movs	r1, #1
   8739c:	4628      	mov	r0, r5
   8739e:	47a0      	blx	r4
   873a0:	f107 030c 	add.w	r3, r7, #12
   873a4:	4618      	mov	r0, r3
   873a6:	4b43      	ldr	r3, [pc, #268]	; (874b4 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x140>)
   873a8:	4798      	blx	r3
  while (1)
    {
      if (ROBOT.hmi.matchColor.read ())
   873aa:	4b43      	ldr	r3, [pc, #268]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   873ac:	4798      	blx	r3
   873ae:	4603      	mov	r3, r0
   873b0:	338c      	adds	r3, #140	; 0x8c
   873b2:	4618      	mov	r0, r3
   873b4:	4b41      	ldr	r3, [pc, #260]	; (874bc <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x148>)
   873b6:	4798      	blx	r3
   873b8:	4603      	mov	r3, r0
   873ba:	2b00      	cmp	r3, #0
   873bc:	bf14      	ite	ne
   873be:	2301      	movne	r3, #1
   873c0:	2300      	moveq	r3, #0
   873c2:	b2db      	uxtb	r3, r3
   873c4:	2b00      	cmp	r3, #0
   873c6:	d007      	beq.n	873d8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x64>
	{
	  ROBOT.hmi.led1.on ();
   873c8:	4b3b      	ldr	r3, [pc, #236]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   873ca:	4798      	blx	r3
   873cc:	4603      	mov	r3, r0
   873ce:	3318      	adds	r3, #24
   873d0:	4618      	mov	r0, r3
   873d2:	4b3b      	ldr	r3, [pc, #236]	; (874c0 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x14c>)
   873d4:	4798      	blx	r3
   873d6:	e006      	b.n	873e6 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x72>
	}
      else
	{
	  ROBOT.hmi.led1.off ();
   873d8:	4b37      	ldr	r3, [pc, #220]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   873da:	4798      	blx	r3
   873dc:	4603      	mov	r3, r0
   873de:	3318      	adds	r3, #24
   873e0:	4618      	mov	r0, r3
   873e2:	4b38      	ldr	r3, [pc, #224]	; (874c4 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x150>)
   873e4:	4798      	blx	r3
	}

      if (ROBOT.hmi.user1.read ())
   873e6:	4b34      	ldr	r3, [pc, #208]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   873e8:	4798      	blx	r3
   873ea:	4603      	mov	r3, r0
   873ec:	33ac      	adds	r3, #172	; 0xac
   873ee:	4618      	mov	r0, r3
   873f0:	4b32      	ldr	r3, [pc, #200]	; (874bc <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x148>)
   873f2:	4798      	blx	r3
   873f4:	4603      	mov	r3, r0
   873f6:	2b00      	cmp	r3, #0
   873f8:	bf14      	ite	ne
   873fa:	2301      	movne	r3, #1
   873fc:	2300      	moveq	r3, #0
   873fe:	b2db      	uxtb	r3, r3
   87400:	2b00      	cmp	r3, #0
   87402:	d007      	beq.n	87414 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0xa0>
	{
	  ROBOT.hmi.led2.on ();
   87404:	4b2c      	ldr	r3, [pc, #176]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   87406:	4798      	blx	r3
   87408:	4603      	mov	r3, r0
   8740a:	3324      	adds	r3, #36	; 0x24
   8740c:	4618      	mov	r0, r3
   8740e:	4b2c      	ldr	r3, [pc, #176]	; (874c0 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x14c>)
   87410:	4798      	blx	r3
   87412:	e006      	b.n	87422 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0xae>
	}
      else
	{
	  ROBOT.hmi.led2.off ();
   87414:	4b28      	ldr	r3, [pc, #160]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   87416:	4798      	blx	r3
   87418:	4603      	mov	r3, r0
   8741a:	3324      	adds	r3, #36	; 0x24
   8741c:	4618      	mov	r0, r3
   8741e:	4b29      	ldr	r3, [pc, #164]	; (874c4 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x150>)
   87420:	4798      	blx	r3
	}

      if (ROBOT.hmi.user2.read ())
   87422:	4b25      	ldr	r3, [pc, #148]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   87424:	4798      	blx	r3
   87426:	4603      	mov	r3, r0
   87428:	33cc      	adds	r3, #204	; 0xcc
   8742a:	4618      	mov	r0, r3
   8742c:	4b23      	ldr	r3, [pc, #140]	; (874bc <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x148>)
   8742e:	4798      	blx	r3
   87430:	4603      	mov	r3, r0
   87432:	2b00      	cmp	r3, #0
   87434:	bf14      	ite	ne
   87436:	2301      	movne	r3, #1
   87438:	2300      	moveq	r3, #0
   8743a:	b2db      	uxtb	r3, r3
   8743c:	2b00      	cmp	r3, #0
   8743e:	d007      	beq.n	87450 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0xdc>
	{
	  ROBOT.hmi.led3.on ();
   87440:	4b1d      	ldr	r3, [pc, #116]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   87442:	4798      	blx	r3
   87444:	4603      	mov	r3, r0
   87446:	3330      	adds	r3, #48	; 0x30
   87448:	4618      	mov	r0, r3
   8744a:	4b1d      	ldr	r3, [pc, #116]	; (874c0 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x14c>)
   8744c:	4798      	blx	r3
   8744e:	e006      	b.n	8745e <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0xea>
	}
      else
	{
	  ROBOT.hmi.led3.off ();
   87450:	4b19      	ldr	r3, [pc, #100]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   87452:	4798      	blx	r3
   87454:	4603      	mov	r3, r0
   87456:	3330      	adds	r3, #48	; 0x30
   87458:	4618      	mov	r0, r3
   8745a:	4b1a      	ldr	r3, [pc, #104]	; (874c4 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x150>)
   8745c:	4798      	blx	r3
	}

      if (ROBOT.hmi.start.read ())
   8745e:	4b16      	ldr	r3, [pc, #88]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   87460:	4798      	blx	r3
   87462:	4603      	mov	r3, r0
   87464:	336c      	adds	r3, #108	; 0x6c
   87466:	4618      	mov	r0, r3
   87468:	4b14      	ldr	r3, [pc, #80]	; (874bc <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x148>)
   8746a:	4798      	blx	r3
   8746c:	4603      	mov	r3, r0
   8746e:	2b00      	cmp	r3, #0
   87470:	bf14      	ite	ne
   87472:	2301      	movne	r3, #1
   87474:	2300      	moveq	r3, #0
   87476:	b2db      	uxtb	r3, r3
   87478:	2b00      	cmp	r3, #0
   8747a:	d007      	beq.n	8748c <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x118>
	{
	  ROBOT.hmi.led4.on ();
   8747c:	4b0e      	ldr	r3, [pc, #56]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   8747e:	4798      	blx	r3
   87480:	4603      	mov	r3, r0
   87482:	333c      	adds	r3, #60	; 0x3c
   87484:	4618      	mov	r0, r3
   87486:	4b0e      	ldr	r3, [pc, #56]	; (874c0 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x14c>)
   87488:	4798      	blx	r3
   8748a:	e006      	b.n	8749a <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x126>
	}
      else
	{
	  ROBOT.hmi.led4.off ();
   8748c:	4b0a      	ldr	r3, [pc, #40]	; (874b8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x144>)
   8748e:	4798      	blx	r3
   87490:	4603      	mov	r3, r0
   87492:	333c      	adds	r3, #60	; 0x3c
   87494:	4618      	mov	r0, r3
   87496:	4b0b      	ldr	r3, [pc, #44]	; (874c4 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x150>)
   87498:	4798      	blx	r3
	}

      delay (50);
   8749a:	687b      	ldr	r3, [r7, #4]
   8749c:	2132      	movs	r1, #50	; 0x32
   8749e:	4618      	mov	r0, r3
   874a0:	4b09      	ldr	r3, [pc, #36]	; (874c8 <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x154>)
   874a2:	4798      	blx	r3

void
StrategyThread::Strategy_ButtonTest ()
{
  LOG(INFO, "STRAT : Strategy_ButtonTest.");
  while (1)
   874a4:	e781      	b.n	873aa <_ZN3ard14StrategyThread19Strategy_ButtonTestEv+0x36>
   874a6:	bf00      	nop
   874a8:	000859e9 	.word	0x000859e9
   874ac:	0009ab80 	.word	0x0009ab80
   874b0:	00089009 	.word	0x00089009
   874b4:	00089145 	.word	0x00089145
   874b8:	00086fe1 	.word	0x00086fe1
   874bc:	00086e7d 	.word	0x00086e7d
   874c0:	00084c79 	.word	0x00084c79
   874c4:	00084ca9 	.word	0x00084ca9
   874c8:	00086c7d 	.word	0x00086c7d

000874cc <_ZN3ard14StrategyThread18Strategy_OmronTestEv>:
    }
}

void
StrategyThread::Strategy_OmronTest ()
{
   874cc:	b5b0      	push	{r4, r5, r7, lr}
   874ce:	b086      	sub	sp, #24
   874d0:	af00      	add	r7, sp, #0
   874d2:	6078      	str	r0, [r7, #4]
  LOG(INFO, "STRAT : Strategy_OmronTest.");
   874d4:	4b4c      	ldr	r3, [pc, #304]	; (87608 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x13c>)
   874d6:	4798      	blx	r3
   874d8:	4605      	mov	r5, r0
   874da:	682b      	ldr	r3, [r5, #0]
   874dc:	3310      	adds	r3, #16
   874de:	681c      	ldr	r4, [r3, #0]
   874e0:	f107 030c 	add.w	r3, r7, #12
   874e4:	4949      	ldr	r1, [pc, #292]	; (8760c <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x140>)
   874e6:	4618      	mov	r0, r3
   874e8:	4b49      	ldr	r3, [pc, #292]	; (87610 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x144>)
   874ea:	4798      	blx	r3
   874ec:	f107 030c 	add.w	r3, r7, #12
   874f0:	461a      	mov	r2, r3
   874f2:	2101      	movs	r1, #1
   874f4:	4628      	mov	r0, r5
   874f6:	47a0      	blx	r4
   874f8:	f107 030c 	add.w	r3, r7, #12
   874fc:	4618      	mov	r0, r3
   874fe:	4b45      	ldr	r3, [pc, #276]	; (87614 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x148>)
   87500:	4798      	blx	r3

  while (1)
    {
      if (ROBOT.nav.getOmronState_FL ())
   87502:	4b45      	ldr	r3, [pc, #276]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   87504:	4798      	blx	r3
   87506:	4603      	mov	r3, r0
   87508:	f503 7386 	add.w	r3, r3, #268	; 0x10c
   8750c:	4618      	mov	r0, r3
   8750e:	4b43      	ldr	r3, [pc, #268]	; (8761c <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x150>)
   87510:	4798      	blx	r3
   87512:	4603      	mov	r3, r0
   87514:	2b00      	cmp	r3, #0
   87516:	bf14      	ite	ne
   87518:	2301      	movne	r3, #1
   8751a:	2300      	moveq	r3, #0
   8751c:	b2db      	uxtb	r3, r3
   8751e:	2b00      	cmp	r3, #0
   87520:	d007      	beq.n	87532 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x66>
	ROBOT.hmi.led1.on ();
   87522:	4b3d      	ldr	r3, [pc, #244]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   87524:	4798      	blx	r3
   87526:	4603      	mov	r3, r0
   87528:	3318      	adds	r3, #24
   8752a:	4618      	mov	r0, r3
   8752c:	4b3c      	ldr	r3, [pc, #240]	; (87620 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x154>)
   8752e:	4798      	blx	r3
   87530:	e006      	b.n	87540 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x74>
      else
	ROBOT.hmi.led1.off ();
   87532:	4b39      	ldr	r3, [pc, #228]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   87534:	4798      	blx	r3
   87536:	4603      	mov	r3, r0
   87538:	3318      	adds	r3, #24
   8753a:	4618      	mov	r0, r3
   8753c:	4b39      	ldr	r3, [pc, #228]	; (87624 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x158>)
   8753e:	4798      	blx	r3

      if (ROBOT.nav.getOmronState_FR ())
   87540:	4b35      	ldr	r3, [pc, #212]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   87542:	4798      	blx	r3
   87544:	4603      	mov	r3, r0
   87546:	f503 7386 	add.w	r3, r3, #268	; 0x10c
   8754a:	4618      	mov	r0, r3
   8754c:	4b36      	ldr	r3, [pc, #216]	; (87628 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x15c>)
   8754e:	4798      	blx	r3
   87550:	4603      	mov	r3, r0
   87552:	2b00      	cmp	r3, #0
   87554:	bf14      	ite	ne
   87556:	2301      	movne	r3, #1
   87558:	2300      	moveq	r3, #0
   8755a:	b2db      	uxtb	r3, r3
   8755c:	2b00      	cmp	r3, #0
   8755e:	d007      	beq.n	87570 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0xa4>
	ROBOT.hmi.led2.on ();
   87560:	4b2d      	ldr	r3, [pc, #180]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   87562:	4798      	blx	r3
   87564:	4603      	mov	r3, r0
   87566:	3324      	adds	r3, #36	; 0x24
   87568:	4618      	mov	r0, r3
   8756a:	4b2d      	ldr	r3, [pc, #180]	; (87620 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x154>)
   8756c:	4798      	blx	r3
   8756e:	e006      	b.n	8757e <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0xb2>
      else
	ROBOT.hmi.led2.off ();
   87570:	4b29      	ldr	r3, [pc, #164]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   87572:	4798      	blx	r3
   87574:	4603      	mov	r3, r0
   87576:	3324      	adds	r3, #36	; 0x24
   87578:	4618      	mov	r0, r3
   8757a:	4b2a      	ldr	r3, [pc, #168]	; (87624 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x158>)
   8757c:	4798      	blx	r3

      if (ROBOT.nav.getOmronState_RL ())
   8757e:	4b26      	ldr	r3, [pc, #152]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   87580:	4798      	blx	r3
   87582:	4603      	mov	r3, r0
   87584:	f503 7386 	add.w	r3, r3, #268	; 0x10c
   87588:	4618      	mov	r0, r3
   8758a:	4b28      	ldr	r3, [pc, #160]	; (8762c <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x160>)
   8758c:	4798      	blx	r3
   8758e:	4603      	mov	r3, r0
   87590:	2b00      	cmp	r3, #0
   87592:	bf14      	ite	ne
   87594:	2301      	movne	r3, #1
   87596:	2300      	moveq	r3, #0
   87598:	b2db      	uxtb	r3, r3
   8759a:	2b00      	cmp	r3, #0
   8759c:	d007      	beq.n	875ae <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0xe2>
	ROBOT.hmi.led3.on ();
   8759e:	4b1e      	ldr	r3, [pc, #120]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   875a0:	4798      	blx	r3
   875a2:	4603      	mov	r3, r0
   875a4:	3330      	adds	r3, #48	; 0x30
   875a6:	4618      	mov	r0, r3
   875a8:	4b1d      	ldr	r3, [pc, #116]	; (87620 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x154>)
   875aa:	4798      	blx	r3
   875ac:	e006      	b.n	875bc <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0xf0>
      else
	ROBOT.hmi.led3.off ();
   875ae:	4b1a      	ldr	r3, [pc, #104]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   875b0:	4798      	blx	r3
   875b2:	4603      	mov	r3, r0
   875b4:	3330      	adds	r3, #48	; 0x30
   875b6:	4618      	mov	r0, r3
   875b8:	4b1a      	ldr	r3, [pc, #104]	; (87624 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x158>)
   875ba:	4798      	blx	r3

      if (ROBOT.nav.getOmronState_RR ())
   875bc:	4b16      	ldr	r3, [pc, #88]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   875be:	4798      	blx	r3
   875c0:	4603      	mov	r3, r0
   875c2:	f503 7386 	add.w	r3, r3, #268	; 0x10c
   875c6:	4618      	mov	r0, r3
   875c8:	4b19      	ldr	r3, [pc, #100]	; (87630 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x164>)
   875ca:	4798      	blx	r3
   875cc:	4603      	mov	r3, r0
   875ce:	2b00      	cmp	r3, #0
   875d0:	bf14      	ite	ne
   875d2:	2301      	movne	r3, #1
   875d4:	2300      	moveq	r3, #0
   875d6:	b2db      	uxtb	r3, r3
   875d8:	2b00      	cmp	r3, #0
   875da:	d007      	beq.n	875ec <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x120>
	ROBOT.hmi.led4.on ();
   875dc:	4b0e      	ldr	r3, [pc, #56]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   875de:	4798      	blx	r3
   875e0:	4603      	mov	r3, r0
   875e2:	333c      	adds	r3, #60	; 0x3c
   875e4:	4618      	mov	r0, r3
   875e6:	4b0e      	ldr	r3, [pc, #56]	; (87620 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x154>)
   875e8:	4798      	blx	r3
   875ea:	e006      	b.n	875fa <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x12e>
      else
	ROBOT.hmi.led4.off ();
   875ec:	4b0a      	ldr	r3, [pc, #40]	; (87618 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x14c>)
   875ee:	4798      	blx	r3
   875f0:	4603      	mov	r3, r0
   875f2:	333c      	adds	r3, #60	; 0x3c
   875f4:	4618      	mov	r0, r3
   875f6:	4b0b      	ldr	r3, [pc, #44]	; (87624 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x158>)
   875f8:	4798      	blx	r3

      delay (50);
   875fa:	687b      	ldr	r3, [r7, #4]
   875fc:	2132      	movs	r1, #50	; 0x32
   875fe:	4618      	mov	r0, r3
   87600:	4b0c      	ldr	r3, [pc, #48]	; (87634 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x168>)
   87602:	4798      	blx	r3
void
StrategyThread::Strategy_OmronTest ()
{
  LOG(INFO, "STRAT : Strategy_OmronTest.");

  while (1)
   87604:	e77d      	b.n	87502 <_ZN3ard14StrategyThread18Strategy_OmronTestEv+0x36>
   87606:	bf00      	nop
   87608:	000859e9 	.word	0x000859e9
   8760c:	0009aba0 	.word	0x0009aba0
   87610:	00089009 	.word	0x00089009
   87614:	00089145 	.word	0x00089145
   87618:	00086fe1 	.word	0x00086fe1
   8761c:	00086f55 	.word	0x00086f55
   87620:	00084c79 	.word	0x00084c79
   87624:	00084ca9 	.word	0x00084ca9
   87628:	00086f75 	.word	0x00086f75
   8762c:	00086f99 	.word	0x00086f99
   87630:	00086fbd 	.word	0x00086fbd
   87634:	00086c7d 	.word	0x00086c7d

00087638 <_ZN3ard14StrategyThread14readUserInputsEv>:
      delay (50);
    }
}

void StrategyThread::readUserInputs()
{
   87638:	b5b0      	push	{r4, r5, r7, lr}
   8763a:	b08e      	sub	sp, #56	; 0x38
   8763c:	af00      	add	r7, sp, #0
   8763e:	6078      	str	r0, [r7, #4]
  //Read color input
  if( ROBOT.hmi.start.read() == GPIO_HIGH )
   87640:	4b53      	ldr	r3, [pc, #332]	; (87790 <_ZN3ard14StrategyThread14readUserInputsEv+0x158>)
   87642:	4798      	blx	r3
   87644:	4603      	mov	r3, r0
   87646:	336c      	adds	r3, #108	; 0x6c
   87648:	4618      	mov	r0, r3
   8764a:	4b52      	ldr	r3, [pc, #328]	; (87794 <_ZN3ard14StrategyThread14readUserInputsEv+0x15c>)
   8764c:	4798      	blx	r3
   8764e:	4603      	mov	r3, r0
   87650:	2b01      	cmp	r3, #1
   87652:	bf0c      	ite	eq
   87654:	2301      	moveq	r3, #1
   87656:	2300      	movne	r3, #0
   87658:	b2db      	uxtb	r3, r3
   8765a:	2b00      	cmp	r3, #0
   8765c:	d029      	beq.n	876b2 <_ZN3ard14StrategyThread14readUserInputsEv+0x7a>
    {
    ROBOT.nav.setColor (eColor::PREF);
   8765e:	4b4c      	ldr	r3, [pc, #304]	; (87790 <_ZN3ard14StrategyThread14readUserInputsEv+0x158>)
   87660:	4798      	blx	r3
   87662:	4603      	mov	r3, r0
   87664:	f503 7386 	add.w	r3, r3, #268	; 0x10c
   87668:	2101      	movs	r1, #1
   8766a:	4618      	mov	r0, r3
   8766c:	4b4a      	ldr	r3, [pc, #296]	; (87798 <_ZN3ard14StrategyThread14readUserInputsEv+0x160>)
   8766e:	4798      	blx	r3
    ROBOT.hmi.ledRGB.set(YELLOW, ON);
   87670:	4b47      	ldr	r3, [pc, #284]	; (87790 <_ZN3ard14StrategyThread14readUserInputsEv+0x158>)
   87672:	4798      	blx	r3
   87674:	4603      	mov	r3, r0
   87676:	3304      	adds	r3, #4
   87678:	2201      	movs	r2, #1
   8767a:	2103      	movs	r1, #3
   8767c:	4618      	mov	r0, r3
   8767e:	4b47      	ldr	r3, [pc, #284]	; (8779c <_ZN3ard14StrategyThread14readUserInputsEv+0x164>)
   87680:	4798      	blx	r3
    LOG(INFO, "User has selected PREF (Yellow) color");
   87682:	4b47      	ldr	r3, [pc, #284]	; (877a0 <_ZN3ard14StrategyThread14readUserInputsEv+0x168>)
   87684:	4798      	blx	r3
   87686:	4605      	mov	r5, r0
   87688:	682b      	ldr	r3, [r5, #0]
   8768a:	3310      	adds	r3, #16
   8768c:	681c      	ldr	r4, [r3, #0]
   8768e:	f107 0308 	add.w	r3, r7, #8
   87692:	4944      	ldr	r1, [pc, #272]	; (877a4 <_ZN3ard14StrategyThread14readUserInputsEv+0x16c>)
   87694:	4618      	mov	r0, r3
   87696:	4b44      	ldr	r3, [pc, #272]	; (877a8 <_ZN3ard14StrategyThread14readUserInputsEv+0x170>)
   87698:	4798      	blx	r3
   8769a:	f107 0308 	add.w	r3, r7, #8
   8769e:	461a      	mov	r2, r3
   876a0:	2101      	movs	r1, #1
   876a2:	4628      	mov	r0, r5
   876a4:	47a0      	blx	r4
   876a6:	f107 0308 	add.w	r3, r7, #8
   876aa:	4618      	mov	r0, r3
   876ac:	4b3f      	ldr	r3, [pc, #252]	; (877ac <_ZN3ard14StrategyThread14readUserInputsEv+0x174>)
   876ae:	4798      	blx	r3
   876b0:	e028      	b.n	87704 <_ZN3ard14StrategyThread14readUserInputsEv+0xcc>
    }
  else
    {
    ROBOT.nav.setColor (eColor::SYM);
   876b2:	4b37      	ldr	r3, [pc, #220]	; (87790 <_ZN3ard14StrategyThread14readUserInputsEv+0x158>)
   876b4:	4798      	blx	r3
   876b6:	4603      	mov	r3, r0
   876b8:	f503 7386 	add.w	r3, r3, #268	; 0x10c
   876bc:	2102      	movs	r1, #2
   876be:	4618      	mov	r0, r3
   876c0:	4b35      	ldr	r3, [pc, #212]	; (87798 <_ZN3ard14StrategyThread14readUserInputsEv+0x160>)
   876c2:	4798      	blx	r3
    ROBOT.hmi.ledRGB.set(BLUE, ON);
   876c4:	4b32      	ldr	r3, [pc, #200]	; (87790 <_ZN3ard14StrategyThread14readUserInputsEv+0x158>)
   876c6:	4798      	blx	r3
   876c8:	4603      	mov	r3, r0
   876ca:	3304      	adds	r3, #4
   876cc:	2201      	movs	r2, #1
   876ce:	2102      	movs	r1, #2
   876d0:	4618      	mov	r0, r3
   876d2:	4b32      	ldr	r3, [pc, #200]	; (8779c <_ZN3ard14StrategyThread14readUserInputsEv+0x164>)
   876d4:	4798      	blx	r3
    LOG(INFO, "User has selected SYM (Blue) color");
   876d6:	4b32      	ldr	r3, [pc, #200]	; (877a0 <_ZN3ard14StrategyThread14readUserInputsEv+0x168>)
   876d8:	4798      	blx	r3
   876da:	4605      	mov	r5, r0
   876dc:	682b      	ldr	r3, [r5, #0]
   876de:	3310      	adds	r3, #16
   876e0:	681c      	ldr	r4, [r3, #0]
   876e2:	f107 0314 	add.w	r3, r7, #20
   876e6:	4932      	ldr	r1, [pc, #200]	; (877b0 <_ZN3ard14StrategyThread14readUserInputsEv+0x178>)
   876e8:	4618      	mov	r0, r3
   876ea:	4b2f      	ldr	r3, [pc, #188]	; (877a8 <_ZN3ard14StrategyThread14readUserInputsEv+0x170>)
   876ec:	4798      	blx	r3
   876ee:	f107 0314 	add.w	r3, r7, #20
   876f2:	461a      	mov	r2, r3
   876f4:	2101      	movs	r1, #1
   876f6:	4628      	mov	r0, r5
   876f8:	47a0      	blx	r4
   876fa:	f107 0314 	add.w	r3, r7, #20
   876fe:	4618      	mov	r0, r3
   87700:	4b2a      	ldr	r3, [pc, #168]	; (877ac <_ZN3ard14StrategyThread14readUserInputsEv+0x174>)
   87702:	4798      	blx	r3
    }

  //Read strat config
  strategyId = ROBOT.hmi.user1.read() + (ROBOT.hmi.user2.read() << 1);
   87704:	4b22      	ldr	r3, [pc, #136]	; (87790 <_ZN3ard14StrategyThread14readUserInputsEv+0x158>)
   87706:	4798      	blx	r3
   87708:	4603      	mov	r3, r0
   8770a:	33ac      	adds	r3, #172	; 0xac
   8770c:	4618      	mov	r0, r3
   8770e:	4b21      	ldr	r3, [pc, #132]	; (87794 <_ZN3ard14StrategyThread14readUserInputsEv+0x15c>)
   87710:	4798      	blx	r3
   87712:	4603      	mov	r3, r0
   87714:	461c      	mov	r4, r3
   87716:	4b1e      	ldr	r3, [pc, #120]	; (87790 <_ZN3ard14StrategyThread14readUserInputsEv+0x158>)
   87718:	4798      	blx	r3
   8771a:	4603      	mov	r3, r0
   8771c:	33cc      	adds	r3, #204	; 0xcc
   8771e:	4618      	mov	r0, r3
   87720:	4b1c      	ldr	r3, [pc, #112]	; (87794 <_ZN3ard14StrategyThread14readUserInputsEv+0x15c>)
   87722:	4798      	blx	r3
   87724:	4603      	mov	r3, r0
   87726:	005b      	lsls	r3, r3, #1
   87728:	b2db      	uxtb	r3, r3
   8772a:	4423      	add	r3, r4
   8772c:	b2da      	uxtb	r2, r3
   8772e:	687b      	ldr	r3, [r7, #4]
   87730:	711a      	strb	r2, [r3, #4]
  LOG(INFO, "User has selected strategy " + String(strategyId));
   87732:	4b1b      	ldr	r3, [pc, #108]	; (877a0 <_ZN3ard14StrategyThread14readUserInputsEv+0x168>)
   87734:	4798      	blx	r3
   87736:	4605      	mov	r5, r0
   87738:	682b      	ldr	r3, [r5, #0]
   8773a:	3310      	adds	r3, #16
   8773c:	681c      	ldr	r4, [r3, #0]
   8773e:	f107 0320 	add.w	r3, r7, #32
   87742:	491c      	ldr	r1, [pc, #112]	; (877b4 <_ZN3ard14StrategyThread14readUserInputsEv+0x17c>)
   87744:	4618      	mov	r0, r3
   87746:	4b1c      	ldr	r3, [pc, #112]	; (877b8 <_ZN3ard14StrategyThread14readUserInputsEv+0x180>)
   87748:	4798      	blx	r3
   8774a:	687b      	ldr	r3, [r7, #4]
   8774c:	7919      	ldrb	r1, [r3, #4]
   8774e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   87752:	220a      	movs	r2, #10
   87754:	4618      	mov	r0, r3
   87756:	4b19      	ldr	r3, [pc, #100]	; (877bc <_ZN3ard14StrategyThread14readUserInputsEv+0x184>)
   87758:	4798      	blx	r3
   8775a:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   8775e:	f107 0320 	add.w	r3, r7, #32
   87762:	4611      	mov	r1, r2
   87764:	4618      	mov	r0, r3
   87766:	4b16      	ldr	r3, [pc, #88]	; (877c0 <_ZN3ard14StrategyThread14readUserInputsEv+0x188>)
   87768:	4798      	blx	r3
   8776a:	4603      	mov	r3, r0
   8776c:	461a      	mov	r2, r3
   8776e:	2101      	movs	r1, #1
   87770:	4628      	mov	r0, r5
   87772:	47a0      	blx	r4
   87774:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   87778:	4618      	mov	r0, r3
   8777a:	4b0c      	ldr	r3, [pc, #48]	; (877ac <_ZN3ard14StrategyThread14readUserInputsEv+0x174>)
   8777c:	4798      	blx	r3
   8777e:	f107 0320 	add.w	r3, r7, #32
   87782:	4618      	mov	r0, r3
   87784:	4b0f      	ldr	r3, [pc, #60]	; (877c4 <_ZN3ard14StrategyThread14readUserInputsEv+0x18c>)
   87786:	4798      	blx	r3

}
   87788:	bf00      	nop
   8778a:	3738      	adds	r7, #56	; 0x38
   8778c:	46bd      	mov	sp, r7
   8778e:	bdb0      	pop	{r4, r5, r7, pc}
   87790:	00086fe1 	.word	0x00086fe1
   87794:	00086e7d 	.word	0x00086e7d
   87798:	000865e1 	.word	0x000865e1
   8779c:	00084a01 	.word	0x00084a01
   877a0:	000859e9 	.word	0x000859e9
   877a4:	0009abbc 	.word	0x0009abbc
   877a8:	00089009 	.word	0x00089009
   877ac:	00089145 	.word	0x00089145
   877b0:	0009abe4 	.word	0x0009abe4
   877b4:	0009ac08 	.word	0x0009ac08
   877b8:	00085971 	.word	0x00085971
   877bc:	00089075 	.word	0x00089075
   877c0:	000894d5 	.word	0x000894d5
   877c4:	00082fe9 	.word	0x00082fe9

000877c8 <_ZN3ard14StrategyThreadD1Ev>:
  class StrategyThread : public IThread
  {
  public:
    StrategyThread () = default;
    virtual
    ~StrategyThread () = default;
   877c8:	b580      	push	{r7, lr}
   877ca:	b082      	sub	sp, #8
   877cc:	af00      	add	r7, sp, #0
   877ce:	6078      	str	r0, [r7, #4]
   877d0:	4a08      	ldr	r2, [pc, #32]	; (877f4 <_ZN3ard14StrategyThreadD1Ev+0x2c>)
   877d2:	687b      	ldr	r3, [r7, #4]
   877d4:	601a      	str	r2, [r3, #0]
   877d6:	687b      	ldr	r3, [r7, #4]
   877d8:	4618      	mov	r0, r3
   877da:	4b07      	ldr	r3, [pc, #28]	; (877f8 <_ZN3ard14StrategyThreadD1Ev+0x30>)
   877dc:	4798      	blx	r3
   877de:	2300      	movs	r3, #0
   877e0:	2b00      	cmp	r3, #0
   877e2:	d002      	beq.n	877ea <_ZN3ard14StrategyThreadD1Ev+0x22>
   877e4:	6878      	ldr	r0, [r7, #4]
   877e6:	4b05      	ldr	r3, [pc, #20]	; (877fc <_ZN3ard14StrategyThreadD1Ev+0x34>)
   877e8:	4798      	blx	r3
   877ea:	687b      	ldr	r3, [r7, #4]
   877ec:	4618      	mov	r0, r3
   877ee:	3708      	adds	r7, #8
   877f0:	46bd      	mov	sp, r7
   877f2:	bd80      	pop	{r7, pc}
   877f4:	0009ac2c 	.word	0x0009ac2c
   877f8:	00084969 	.word	0x00084969
   877fc:	0008788d 	.word	0x0008788d

00087800 <_ZN3ard14StrategyThreadD0Ev>:
   87800:	b580      	push	{r7, lr}
   87802:	b082      	sub	sp, #8
   87804:	af00      	add	r7, sp, #0
   87806:	6078      	str	r0, [r7, #4]
   87808:	6878      	ldr	r0, [r7, #4]
   8780a:	4b05      	ldr	r3, [pc, #20]	; (87820 <_ZN3ard14StrategyThreadD0Ev+0x20>)
   8780c:	4798      	blx	r3
   8780e:	6878      	ldr	r0, [r7, #4]
   87810:	4b04      	ldr	r3, [pc, #16]	; (87824 <_ZN3ard14StrategyThreadD0Ev+0x24>)
   87812:	4798      	blx	r3
   87814:	687b      	ldr	r3, [r7, #4]
   87816:	4618      	mov	r0, r3
   87818:	3708      	adds	r7, #8
   8781a:	46bd      	mov	sp, r7
   8781c:	bd80      	pop	{r7, pc}
   8781e:	bf00      	nop
   87820:	000877c9 	.word	0x000877c9
   87824:	0008788d 	.word	0x0008788d

00087828 <__cxa_pure_virtual>:
#include <stdlib.h>

extern "C" void __cxa_pure_virtual(void) __attribute__ ((__noreturn__));
extern "C" void __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));

void __cxa_pure_virtual(void) {
   87828:	b480      	push	{r7}
   8782a:	af00      	add	r7, sp, #0
  // We might want to write some diagnostics to uart in this case
  //std::terminate();
  while (1)
   8782c:	e7fe      	b.n	8782c <__cxa_pure_virtual+0x4>
   8782e:	bf00      	nop

00087830 <ADC_Handler>:

#ifdef __cplusplus
extern "C" {
#endif

static void __halt() {
   87830:	b480      	push	{r7}
   87832:	af00      	add	r7, sp, #0
	// Halts
	while (1)
		;
   87834:	e7fe      	b.n	87834 <ADC_Handler+0x4>
   87836:	bf00      	nop

00087838 <SVC_Handler>:
void HardFault_Handler (void) __attribute__ ((weak, alias("__halt")));
void MemManage_Handler (void) __attribute__ ((weak, alias("__halt")));
void BusFault_Handler  (void) __attribute__ ((weak, alias("__halt")));
void UsageFault_Handler(void) __attribute__ ((weak, alias("__halt")));
void DebugMon_Handler  (void) __attribute__ ((weak, alias("__halt")));
void SVC_Handler       (void) { svcHook(); }
   87838:	b580      	push	{r7, lr}
   8783a:	af00      	add	r7, sp, #0
   8783c:	4b01      	ldr	r3, [pc, #4]	; (87844 <SVC_Handler+0xc>)
   8783e:	4798      	blx	r3
   87840:	bf00      	nop
   87842:	bd80      	pop	{r7, pc}
   87844:	00090755 	.word	0x00090755

00087848 <PendSV_Handler>:
void PendSV_Handler    (void) {	pendSVHook(); }
   87848:	b580      	push	{r7, lr}
   8784a:	af00      	add	r7, sp, #0
   8784c:	4b01      	ldr	r3, [pc, #4]	; (87854 <PendSV_Handler+0xc>)
   8784e:	4798      	blx	r3
   87850:	bf00      	nop
   87852:	bd80      	pop	{r7, pc}
   87854:	00090925 	.word	0x00090925

00087858 <SysTick_Handler>:

void SysTick_Handler(void)
{
   87858:	b580      	push	{r7, lr}
   8785a:	af00      	add	r7, sp, #0
	if (sysTickHook())
   8785c:	4b05      	ldr	r3, [pc, #20]	; (87874 <SysTick_Handler+0x1c>)
   8785e:	4798      	blx	r3
   87860:	4603      	mov	r3, r0
   87862:	2b00      	cmp	r3, #0
   87864:	d104      	bne.n	87870 <SysTick_Handler+0x18>
		return;

	tickReset();
   87866:	4b04      	ldr	r3, [pc, #16]	; (87878 <SysTick_Handler+0x20>)
   87868:	4798      	blx	r3

	// Increment tick count each ms
	TimeTick_Increment();
   8786a:	4b04      	ldr	r3, [pc, #16]	; (8787c <SysTick_Handler+0x24>)
   8786c:	4798      	blx	r3
   8786e:	e000      	b.n	87872 <SysTick_Handler+0x1a>
void PendSV_Handler    (void) {	pendSVHook(); }

void SysTick_Handler(void)
{
	if (sysTickHook())
		return;
   87870:	bf00      	nop

	tickReset();

	// Increment tick count each ms
	TimeTick_Increment();
}
   87872:	bd80      	pop	{r7, pc}
   87874:	000906bd 	.word	0x000906bd
   87878:	00087a61 	.word	0x00087a61
   8787c:	0008827d 	.word	0x0008827d

00087880 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
   87880:	b480      	push	{r7}
   87882:	af00      	add	r7, sp, #0
	// Empty
}
   87884:	bf00      	nop
   87886:	46bd      	mov	sp, r7
   87888:	bc80      	pop	{r7}
   8788a:	4770      	bx	lr

0008788c <_ZdlPv>:

void *operator new[](size_t size) {
  return malloc(size);
}

void operator delete(void * ptr) {
   8788c:	b580      	push	{r7, lr}
   8788e:	b082      	sub	sp, #8
   87890:	af00      	add	r7, sp, #0
   87892:	6078      	str	r0, [r7, #4]
  free(ptr);
   87894:	6878      	ldr	r0, [r7, #4]
   87896:	4b03      	ldr	r3, [pc, #12]	; (878a4 <_ZdlPv+0x18>)
   87898:	4798      	blx	r3
}
   8789a:	bf00      	nop
   8789c:	3708      	adds	r7, #8
   8789e:	46bd      	mov	sp, r7
   878a0:	bd80      	pop	{r7, pc}
   878a2:	bf00      	nop
   878a4:	00093545 	.word	0x00093545

000878a8 <_ZNK6String6lengthEv>:
	// memory management
	// return true on success, false on failure (in which case, the string
	// is left unchanged).  reserve(0), if successful, will validate an
	// invalid string (i.e., "if (s)" will be true afterwards)
	unsigned char reserve(unsigned int size);
	inline unsigned int length(void) const {return len;}
   878a8:	b480      	push	{r7}
   878aa:	b083      	sub	sp, #12
   878ac:	af00      	add	r7, sp, #0
   878ae:	6078      	str	r0, [r7, #4]
   878b0:	687b      	ldr	r3, [r7, #4]
   878b2:	689b      	ldr	r3, [r3, #8]
   878b4:	4618      	mov	r0, r3
   878b6:	370c      	adds	r7, #12
   878b8:	46bd      	mov	sp, r7
   878ba:	bc80      	pop	{r7}
   878bc:	4770      	bx	lr
   878be:	bf00      	nop

000878c0 <_ZNK6String5c_strEv>:
	char operator [] (unsigned int index) const;
	char& operator [] (unsigned int index);
	void getBytes(unsigned char *buf, unsigned int bufsize, unsigned int index=0) const;
	void toCharArray(char *buf, unsigned int bufsize, unsigned int index=0) const
		{ getBytes((unsigned char *)buf, bufsize, index); }
	const char* c_str() const { return buffer; }
   878c0:	b480      	push	{r7}
   878c2:	b083      	sub	sp, #12
   878c4:	af00      	add	r7, sp, #0
   878c6:	6078      	str	r0, [r7, #4]
   878c8:	687b      	ldr	r3, [r7, #4]
   878ca:	681b      	ldr	r3, [r3, #0]
   878cc:	4618      	mov	r0, r3
   878ce:	370c      	adds	r7, #12
   878d0:	46bd      	mov	sp, r7
   878d2:	bc80      	pop	{r7}
   878d4:	4770      	bx	lr
   878d6:	bf00      	nop

000878d8 <_ZN5Print5writeEPKc>:
  
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
   878d8:	b590      	push	{r4, r7, lr}
   878da:	b083      	sub	sp, #12
   878dc:	af00      	add	r7, sp, #0
   878de:	6078      	str	r0, [r7, #4]
   878e0:	6039      	str	r1, [r7, #0]
      if (str == NULL) return 0;
   878e2:	683b      	ldr	r3, [r7, #0]
   878e4:	2b00      	cmp	r3, #0
   878e6:	d101      	bne.n	878ec <_ZN5Print5writeEPKc+0x14>
   878e8:	2300      	movs	r3, #0
   878ea:	e00c      	b.n	87906 <_ZN5Print5writeEPKc+0x2e>
      return write((const uint8_t *)str, strlen(str));
   878ec:	687b      	ldr	r3, [r7, #4]
   878ee:	681b      	ldr	r3, [r3, #0]
   878f0:	3304      	adds	r3, #4
   878f2:	681c      	ldr	r4, [r3, #0]
   878f4:	6838      	ldr	r0, [r7, #0]
   878f6:	4b06      	ldr	r3, [pc, #24]	; (87910 <_ZN5Print5writeEPKc+0x38>)
   878f8:	4798      	blx	r3
   878fa:	4603      	mov	r3, r0
   878fc:	461a      	mov	r2, r3
   878fe:	6839      	ldr	r1, [r7, #0]
   87900:	6878      	ldr	r0, [r7, #4]
   87902:	47a0      	blx	r4
   87904:	4603      	mov	r3, r0
    }
   87906:	4618      	mov	r0, r3
   87908:	370c      	adds	r7, #12
   8790a:	46bd      	mov	sp, r7
   8790c:	bd90      	pop	{r4, r7, pc}
   8790e:	bf00      	nop
   87910:	00094349 	.word	0x00094349

00087914 <_ZN5Print5writeEPKcj>:
    virtual size_t write(const uint8_t *buffer, size_t size);
    size_t write(const char *buffer, size_t size) {
   87914:	b580      	push	{r7, lr}
   87916:	b084      	sub	sp, #16
   87918:	af00      	add	r7, sp, #0
   8791a:	60f8      	str	r0, [r7, #12]
   8791c:	60b9      	str	r1, [r7, #8]
   8791e:	607a      	str	r2, [r7, #4]
      return write((const uint8_t *)buffer, size);
   87920:	68fb      	ldr	r3, [r7, #12]
   87922:	681b      	ldr	r3, [r3, #0]
   87924:	3304      	adds	r3, #4
   87926:	681b      	ldr	r3, [r3, #0]
   87928:	687a      	ldr	r2, [r7, #4]
   8792a:	68b9      	ldr	r1, [r7, #8]
   8792c:	68f8      	ldr	r0, [r7, #12]
   8792e:	4798      	blx	r3
   87930:	4603      	mov	r3, r0
    }
   87932:	4618      	mov	r0, r3
   87934:	3710      	adds	r7, #16
   87936:	46bd      	mov	sp, r7
   87938:	bd80      	pop	{r7, pc}
   8793a:	bf00      	nop

0008793c <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
   8793c:	b580      	push	{r7, lr}
   8793e:	b086      	sub	sp, #24
   87940:	af00      	add	r7, sp, #0
   87942:	60f8      	str	r0, [r7, #12]
   87944:	60b9      	str	r1, [r7, #8]
   87946:	607a      	str	r2, [r7, #4]
  size_t n = 0;
   87948:	2300      	movs	r3, #0
   8794a:	617b      	str	r3, [r7, #20]
  while (size--) {
   8794c:	687b      	ldr	r3, [r7, #4]
   8794e:	1e5a      	subs	r2, r3, #1
   87950:	607a      	str	r2, [r7, #4]
   87952:	2b00      	cmp	r3, #0
   87954:	bf14      	ite	ne
   87956:	2301      	movne	r3, #1
   87958:	2300      	moveq	r3, #0
   8795a:	b2db      	uxtb	r3, r3
   8795c:	2b00      	cmp	r3, #0
   8795e:	d016      	beq.n	8798e <_ZN5Print5writeEPKhj+0x52>
    if (write(*buffer++)) n++;
   87960:	68fb      	ldr	r3, [r7, #12]
   87962:	681b      	ldr	r3, [r3, #0]
   87964:	681a      	ldr	r2, [r3, #0]
   87966:	68bb      	ldr	r3, [r7, #8]
   87968:	1c59      	adds	r1, r3, #1
   8796a:	60b9      	str	r1, [r7, #8]
   8796c:	781b      	ldrb	r3, [r3, #0]
   8796e:	4619      	mov	r1, r3
   87970:	68f8      	ldr	r0, [r7, #12]
   87972:	4790      	blx	r2
   87974:	4603      	mov	r3, r0
   87976:	2b00      	cmp	r3, #0
   87978:	bf14      	ite	ne
   8797a:	2301      	movne	r3, #1
   8797c:	2300      	moveq	r3, #0
   8797e:	b2db      	uxtb	r3, r3
   87980:	2b00      	cmp	r3, #0
   87982:	d003      	beq.n	8798c <_ZN5Print5writeEPKhj+0x50>
   87984:	697b      	ldr	r3, [r7, #20]
   87986:	3301      	adds	r3, #1
   87988:	617b      	str	r3, [r7, #20]

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
   8798a:	e7df      	b.n	8794c <_ZN5Print5writeEPKhj+0x10>
    if (write(*buffer++)) n++;
    else break;
   8798c:	bf00      	nop
  }
  return n;
   8798e:	697b      	ldr	r3, [r7, #20]
}
   87990:	4618      	mov	r0, r3
   87992:	3718      	adds	r7, #24
   87994:	46bd      	mov	sp, r7
   87996:	bd80      	pop	{r7, pc}

00087998 <_ZN5Print5printERK6String>:
{
  return print(reinterpret_cast<const char *>(ifsh));
}

size_t Print::print(const String &s)
{
   87998:	b590      	push	{r4, r7, lr}
   8799a:	b083      	sub	sp, #12
   8799c:	af00      	add	r7, sp, #0
   8799e:	6078      	str	r0, [r7, #4]
   879a0:	6039      	str	r1, [r7, #0]
  return write(s.c_str(), s.length());
   879a2:	6838      	ldr	r0, [r7, #0]
   879a4:	4b08      	ldr	r3, [pc, #32]	; (879c8 <_ZN5Print5printERK6String+0x30>)
   879a6:	4798      	blx	r3
   879a8:	4604      	mov	r4, r0
   879aa:	6838      	ldr	r0, [r7, #0]
   879ac:	4b07      	ldr	r3, [pc, #28]	; (879cc <_ZN5Print5printERK6String+0x34>)
   879ae:	4798      	blx	r3
   879b0:	4603      	mov	r3, r0
   879b2:	461a      	mov	r2, r3
   879b4:	4621      	mov	r1, r4
   879b6:	6878      	ldr	r0, [r7, #4]
   879b8:	4b05      	ldr	r3, [pc, #20]	; (879d0 <_ZN5Print5printERK6String+0x38>)
   879ba:	4798      	blx	r3
   879bc:	4603      	mov	r3, r0
}
   879be:	4618      	mov	r0, r3
   879c0:	370c      	adds	r7, #12
   879c2:	46bd      	mov	sp, r7
   879c4:	bd90      	pop	{r4, r7, pc}
   879c6:	bf00      	nop
   879c8:	000878c1 	.word	0x000878c1
   879cc:	000878a9 	.word	0x000878a9
   879d0:	00087915 	.word	0x00087915

000879d4 <_ZN5Print7printlnEv>:
{
  return x.printTo(*this);
}

size_t Print::println(void)
{
   879d4:	b580      	push	{r7, lr}
   879d6:	b082      	sub	sp, #8
   879d8:	af00      	add	r7, sp, #0
   879da:	6078      	str	r0, [r7, #4]
  return write("\r\n");
   879dc:	4904      	ldr	r1, [pc, #16]	; (879f0 <_ZN5Print7printlnEv+0x1c>)
   879de:	6878      	ldr	r0, [r7, #4]
   879e0:	4b04      	ldr	r3, [pc, #16]	; (879f4 <_ZN5Print7printlnEv+0x20>)
   879e2:	4798      	blx	r3
   879e4:	4603      	mov	r3, r0
}
   879e6:	4618      	mov	r0, r3
   879e8:	3708      	adds	r7, #8
   879ea:	46bd      	mov	sp, r7
   879ec:	bd80      	pop	{r7, pc}
   879ee:	bf00      	nop
   879f0:	0009ac3c 	.word	0x0009ac3c
   879f4:	000878d9 	.word	0x000878d9

000879f8 <_ZN5Print7printlnERK6String>:

size_t Print::println(const String &s)
{
   879f8:	b580      	push	{r7, lr}
   879fa:	b084      	sub	sp, #16
   879fc:	af00      	add	r7, sp, #0
   879fe:	6078      	str	r0, [r7, #4]
   87a00:	6039      	str	r1, [r7, #0]
  size_t n = print(s);
   87a02:	6839      	ldr	r1, [r7, #0]
   87a04:	6878      	ldr	r0, [r7, #4]
   87a06:	4b07      	ldr	r3, [pc, #28]	; (87a24 <_ZN5Print7printlnERK6String+0x2c>)
   87a08:	4798      	blx	r3
   87a0a:	60f8      	str	r0, [r7, #12]
  n += println();
   87a0c:	6878      	ldr	r0, [r7, #4]
   87a0e:	4b06      	ldr	r3, [pc, #24]	; (87a28 <_ZN5Print7printlnERK6String+0x30>)
   87a10:	4798      	blx	r3
   87a12:	4602      	mov	r2, r0
   87a14:	68fb      	ldr	r3, [r7, #12]
   87a16:	4413      	add	r3, r2
   87a18:	60fb      	str	r3, [r7, #12]
  return n;
   87a1a:	68fb      	ldr	r3, [r7, #12]
}
   87a1c:	4618      	mov	r0, r3
   87a1e:	3710      	adds	r7, #16
   87a20:	46bd      	mov	sp, r7
   87a22:	bd80      	pop	{r7, pc}
   87a24:	00087999 	.word	0x00087999
   87a28:	000879d5 	.word	0x000879d5

00087a2c <initiateReset>:
	while (true);
}

static int ticks = -1;

void initiateReset(int _ticks) {
   87a2c:	b480      	push	{r7}
   87a2e:	b083      	sub	sp, #12
   87a30:	af00      	add	r7, sp, #0
   87a32:	6078      	str	r0, [r7, #4]
	ticks = _ticks;
   87a34:	4a03      	ldr	r2, [pc, #12]	; (87a44 <initiateReset+0x18>)
   87a36:	687b      	ldr	r3, [r7, #4]
   87a38:	6013      	str	r3, [r2, #0]
}
   87a3a:	bf00      	nop
   87a3c:	370c      	adds	r7, #12
   87a3e:	46bd      	mov	sp, r7
   87a40:	bc80      	pop	{r7}
   87a42:	4770      	bx	lr
   87a44:	20070100 	.word	0x20070100

00087a48 <cancelReset>:

void cancelReset() {
   87a48:	b480      	push	{r7}
   87a4a:	af00      	add	r7, sp, #0
	ticks = -1;
   87a4c:	4b03      	ldr	r3, [pc, #12]	; (87a5c <cancelReset+0x14>)
   87a4e:	f04f 32ff 	mov.w	r2, #4294967295
   87a52:	601a      	str	r2, [r3, #0]
}
   87a54:	bf00      	nop
   87a56:	46bd      	mov	sp, r7
   87a58:	bc80      	pop	{r7}
   87a5a:	4770      	bx	lr
   87a5c:	20070100 	.word	0x20070100

00087a60 <tickReset>:

void tickReset() {
   87a60:	b580      	push	{r7, lr}
   87a62:	af00      	add	r7, sp, #0
	if (ticks == -1)
   87a64:	4b09      	ldr	r3, [pc, #36]	; (87a8c <tickReset+0x2c>)
   87a66:	681b      	ldr	r3, [r3, #0]
   87a68:	f1b3 3fff 	cmp.w	r3, #4294967295
   87a6c:	d00b      	beq.n	87a86 <tickReset+0x26>
		return;
	ticks--;
   87a6e:	4b07      	ldr	r3, [pc, #28]	; (87a8c <tickReset+0x2c>)
   87a70:	681b      	ldr	r3, [r3, #0]
   87a72:	3b01      	subs	r3, #1
   87a74:	4a05      	ldr	r2, [pc, #20]	; (87a8c <tickReset+0x2c>)
   87a76:	6013      	str	r3, [r2, #0]
	if (ticks == 0)
   87a78:	4b04      	ldr	r3, [pc, #16]	; (87a8c <tickReset+0x2c>)
   87a7a:	681b      	ldr	r3, [r3, #0]
   87a7c:	2b00      	cmp	r3, #0
   87a7e:	d103      	bne.n	87a88 <tickReset+0x28>
		banzai();
   87a80:	4b03      	ldr	r3, [pc, #12]	; (87a90 <tickReset+0x30>)
   87a82:	4798      	blx	r3
   87a84:	e000      	b.n	87a88 <tickReset+0x28>
	ticks = -1;
}

void tickReset() {
	if (ticks == -1)
		return;
   87a86:	bf00      	nop
	ticks--;
	if (ticks == 0)
		banzai();
}
   87a88:	bd80      	pop	{r7, pc}
   87a8a:	bf00      	nop
   87a8c:	20070100 	.word	0x20070100
   87a90:	20070001 	.word	0x20070001

00087a94 <_ZN10RingBufferC1Ev>:
*/

#include "RingBuffer.h"
#include <string.h>

RingBuffer::RingBuffer( void )
   87a94:	b580      	push	{r7, lr}
   87a96:	b082      	sub	sp, #8
   87a98:	af00      	add	r7, sp, #0
   87a9a:	6078      	str	r0, [r7, #4]
{
    memset( (void *)_aucBuffer, 0, SERIAL_BUFFER_SIZE ) ;
   87a9c:	687b      	ldr	r3, [r7, #4]
   87a9e:	2280      	movs	r2, #128	; 0x80
   87aa0:	2100      	movs	r1, #0
   87aa2:	4618      	mov	r0, r3
   87aa4:	4b07      	ldr	r3, [pc, #28]	; (87ac4 <_ZN10RingBufferC1Ev+0x30>)
   87aa6:	4798      	blx	r3
    _iHead=0 ;
   87aa8:	687b      	ldr	r3, [r7, #4]
   87aaa:	2200      	movs	r2, #0
   87aac:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    _iTail=0 ;
   87ab0:	687b      	ldr	r3, [r7, #4]
   87ab2:	2200      	movs	r2, #0
   87ab4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
   87ab8:	687b      	ldr	r3, [r7, #4]
   87aba:	4618      	mov	r0, r3
   87abc:	3708      	adds	r7, #8
   87abe:	46bd      	mov	sp, r7
   87ac0:	bd80      	pop	{r7, pc}
   87ac2:	bf00      	nop
   87ac4:	00093cc5 	.word	0x00093cc5

00087ac8 <_ZN10RingBuffer10store_charEh>:

void RingBuffer::store_char( uint8_t c )
{
   87ac8:	b480      	push	{r7}
   87aca:	b085      	sub	sp, #20
   87acc:	af00      	add	r7, sp, #0
   87ace:	6078      	str	r0, [r7, #4]
   87ad0:	460b      	mov	r3, r1
   87ad2:	70fb      	strb	r3, [r7, #3]
  int i = (uint32_t)(_iHead + 1) % SERIAL_BUFFER_SIZE ;
   87ad4:	687b      	ldr	r3, [r7, #4]
   87ad6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   87ada:	3301      	adds	r3, #1
   87adc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   87ae0:	60fb      	str	r3, [r7, #12]

  // if we should be storing the received character into the location
  // just before the tail (meaning that the head would advance to the
  // current location of the tail), we're about to overflow the buffer
  // and so we don't write the character or advance the head.
  if ( i != _iTail )
   87ae2:	687b      	ldr	r3, [r7, #4]
   87ae4:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
   87ae8:	68fb      	ldr	r3, [r7, #12]
   87aea:	429a      	cmp	r2, r3
   87aec:	bf14      	ite	ne
   87aee:	2301      	movne	r3, #1
   87af0:	2300      	moveq	r3, #0
   87af2:	b2db      	uxtb	r3, r3
   87af4:	2b00      	cmp	r3, #0
   87af6:	d009      	beq.n	87b0c <_ZN10RingBuffer10store_charEh+0x44>
  {
    _aucBuffer[_iHead] = c ;
   87af8:	687b      	ldr	r3, [r7, #4]
   87afa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   87afe:	687a      	ldr	r2, [r7, #4]
   87b00:	78f9      	ldrb	r1, [r7, #3]
   87b02:	54d1      	strb	r1, [r2, r3]
    _iHead = i ;
   87b04:	687b      	ldr	r3, [r7, #4]
   87b06:	68fa      	ldr	r2, [r7, #12]
   87b08:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  }
}
   87b0c:	bf00      	nop
   87b0e:	3714      	adds	r7, #20
   87b10:	46bd      	mov	sp, r7
   87b12:	bc80      	pop	{r7}
   87b14:	4770      	bx	lr
   87b16:	bf00      	nop

00087b18 <adc_init>:
 *
 * \return 0 on success.
 */
uint32_t adc_init(Adc *p_adc, const uint32_t ul_mck,
		const uint32_t ul_adc_clock, const uint8_t uc_startuptime)
{
   87b18:	b4b0      	push	{r4, r5, r7}
   87b1a:	b099      	sub	sp, #100	; 0x64
   87b1c:	af00      	add	r7, sp, #0
   87b1e:	60f8      	str	r0, [r7, #12]
   87b20:	60b9      	str	r1, [r7, #8]
   87b22:	607a      	str	r2, [r7, #4]
   87b24:	70fb      	strb	r3, [r7, #3]
	uint32_t startup_table[] = { 0, 8, 16, 24, 64, 80, 96, 112, 512, 576, 640, 704, 768, 832, 896, 960 };
   87b26:	4b3b      	ldr	r3, [pc, #236]	; (87c14 <adc_init+0xfc>)
   87b28:	f107 0410 	add.w	r4, r7, #16
   87b2c:	461d      	mov	r5, r3
   87b2e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   87b30:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   87b32:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   87b34:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   87b36:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   87b38:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   87b3a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   87b3e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	uint32_t ul_prescal, ul_startup,  ul_mr_startup, ul_real_adc_clock;
	p_adc->ADC_CR = ADC_CR_SWRST;
   87b42:	68fb      	ldr	r3, [r7, #12]
   87b44:	2201      	movs	r2, #1
   87b46:	601a      	str	r2, [r3, #0]

	/* Reset Mode Register. */
	p_adc->ADC_MR = 0;
   87b48:	68fb      	ldr	r3, [r7, #12]
   87b4a:	2200      	movs	r2, #0
   87b4c:	605a      	str	r2, [r3, #4]

	/* Reset PDC transfer. */
	p_adc->ADC_PTCR = (ADC_PTCR_RXTDIS | ADC_PTCR_TXTDIS);
   87b4e:	68fb      	ldr	r3, [r7, #12]
   87b50:	f240 2202 	movw	r2, #514	; 0x202
   87b54:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
	p_adc->ADC_RCR = 0;
   87b58:	68fb      	ldr	r3, [r7, #12]
   87b5a:	2200      	movs	r2, #0
   87b5c:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	p_adc->ADC_RNCR = 0;
   87b60:	68fb      	ldr	r3, [r7, #12]
   87b62:	2200      	movs	r2, #0
   87b64:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
	if (ul_mck % (2 * ul_adc_clock)) {
   87b68:	687b      	ldr	r3, [r7, #4]
   87b6a:	005a      	lsls	r2, r3, #1
   87b6c:	68bb      	ldr	r3, [r7, #8]
   87b6e:	fbb3 f1f2 	udiv	r1, r3, r2
   87b72:	fb02 f201 	mul.w	r2, r2, r1
   87b76:	1a9b      	subs	r3, r3, r2
   87b78:	2b00      	cmp	r3, #0
   87b7a:	d006      	beq.n	87b8a <adc_init+0x72>
		// Division with reminder
		ul_prescal = ul_mck / (2 * ul_adc_clock);
   87b7c:	687b      	ldr	r3, [r7, #4]
   87b7e:	005b      	lsls	r3, r3, #1
   87b80:	68ba      	ldr	r2, [r7, #8]
   87b82:	fbb2 f3f3 	udiv	r3, r2, r3
   87b86:	65fb      	str	r3, [r7, #92]	; 0x5c
   87b88:	e006      	b.n	87b98 <adc_init+0x80>
	} else {
		// Whole division
		ul_prescal = ul_mck / (2 * ul_adc_clock) - 1;
   87b8a:	687b      	ldr	r3, [r7, #4]
   87b8c:	005b      	lsls	r3, r3, #1
   87b8e:	68ba      	ldr	r2, [r7, #8]
   87b90:	fbb2 f3f3 	udiv	r3, r2, r3
   87b94:	3b01      	subs	r3, #1
   87b96:	65fb      	str	r3, [r7, #92]	; 0x5c
	}
	ul_real_adc_clock = ul_mck / (2 * (ul_prescal + 1));
   87b98:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   87b9a:	3301      	adds	r3, #1
   87b9c:	005b      	lsls	r3, r3, #1
   87b9e:	68ba      	ldr	r2, [r7, #8]
   87ba0:	fbb2 f3f3 	udiv	r3, r2, r3
   87ba4:	657b      	str	r3, [r7, #84]	; 0x54

	// ADC clocks needed to get ul_startuptime uS
	ul_startup = (ul_real_adc_clock / 1000000) * uc_startuptime;
   87ba6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   87ba8:	4a1b      	ldr	r2, [pc, #108]	; (87c18 <adc_init+0x100>)
   87baa:	fba2 2303 	umull	r2, r3, r2, r3
   87bae:	0c9b      	lsrs	r3, r3, #18
   87bb0:	78fa      	ldrb	r2, [r7, #3]
   87bb2:	fb02 f303 	mul.w	r3, r2, r3
   87bb6:	653b      	str	r3, [r7, #80]	; 0x50

	// Find correct MR_STARTUP value from conversion table
	for (ul_mr_startup=0; ul_mr_startup<16; ul_mr_startup++) {
   87bb8:	2300      	movs	r3, #0
   87bba:	65bb      	str	r3, [r7, #88]	; 0x58
   87bbc:	e00c      	b.n	87bd8 <adc_init+0xc0>
		if (startup_table[ul_mr_startup] >= ul_startup)
   87bbe:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   87bc0:	009b      	lsls	r3, r3, #2
   87bc2:	f107 0260 	add.w	r2, r7, #96	; 0x60
   87bc6:	4413      	add	r3, r2
   87bc8:	f853 2c50 	ldr.w	r2, [r3, #-80]
   87bcc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   87bce:	429a      	cmp	r2, r3
   87bd0:	d206      	bcs.n	87be0 <adc_init+0xc8>

	// ADC clocks needed to get ul_startuptime uS
	ul_startup = (ul_real_adc_clock / 1000000) * uc_startuptime;

	// Find correct MR_STARTUP value from conversion table
	for (ul_mr_startup=0; ul_mr_startup<16; ul_mr_startup++) {
   87bd2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   87bd4:	3301      	adds	r3, #1
   87bd6:	65bb      	str	r3, [r7, #88]	; 0x58
   87bd8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   87bda:	2b0f      	cmp	r3, #15
   87bdc:	d9ef      	bls.n	87bbe <adc_init+0xa6>
   87bde:	e000      	b.n	87be2 <adc_init+0xca>
		if (startup_table[ul_mr_startup] >= ul_startup)
			break;
   87be0:	bf00      	nop
	}
	if (ul_mr_startup==16)
   87be2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   87be4:	2b10      	cmp	r3, #16
   87be6:	d102      	bne.n	87bee <adc_init+0xd6>
		return -1;
   87be8:	f04f 33ff 	mov.w	r3, #4294967295
   87bec:	e00d      	b.n	87c0a <adc_init+0xf2>
	p_adc->ADC_MR |= ADC_MR_PRESCAL(ul_prescal) |
   87bee:	68fb      	ldr	r3, [r7, #12]
   87bf0:	685a      	ldr	r2, [r3, #4]
   87bf2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   87bf4:	021b      	lsls	r3, r3, #8
   87bf6:	b299      	uxth	r1, r3
			((ul_mr_startup << ADC_MR_STARTUP_Pos) & ADC_MR_STARTUP_Msk);
   87bf8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   87bfa:	041b      	lsls	r3, r3, #16
   87bfc:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
		if (startup_table[ul_mr_startup] >= ul_startup)
			break;
	}
	if (ul_mr_startup==16)
		return -1;
	p_adc->ADC_MR |= ADC_MR_PRESCAL(ul_prescal) |
   87c00:	430b      	orrs	r3, r1
   87c02:	431a      	orrs	r2, r3
   87c04:	68fb      	ldr	r3, [r7, #12]
   87c06:	605a      	str	r2, [r3, #4]
			((ul_mr_startup << ADC_MR_STARTUP_Pos) & ADC_MR_STARTUP_Msk);
	return 0;
   87c08:	2300      	movs	r3, #0
}
   87c0a:	4618      	mov	r0, r3
   87c0c:	3764      	adds	r7, #100	; 0x64
   87c0e:	46bd      	mov	sp, r7
   87c10:	bcb0      	pop	{r4, r5, r7}
   87c12:	4770      	bx	lr
   87c14:	0009ac60 	.word	0x0009ac60
   87c18:	431bde83 	.word	0x431bde83

00087c1c <adc_configure_trigger>:
 * ADC_MR_FREERUN_OFF disables freerun mode.
 *
 */
void adc_configure_trigger(Adc *p_adc, const enum adc_trigger_t trigger,
		uint8_t uc_freerun)
{
   87c1c:	b480      	push	{r7}
   87c1e:	b083      	sub	sp, #12
   87c20:	af00      	add	r7, sp, #0
   87c22:	6078      	str	r0, [r7, #4]
   87c24:	460b      	mov	r3, r1
   87c26:	70fb      	strb	r3, [r7, #3]
   87c28:	4613      	mov	r3, r2
   87c2a:	70bb      	strb	r3, [r7, #2]
	//Warning ADC_MR_TRGSEL_Msk does not include ADC_MR_TRGEN.
	p_adc->ADC_MR &= ~(ADC_MR_TRGEN | ADC_MR_TRGSEL_Msk | ADC_MR_FREERUN); //Clear all bits related to triggers and freerun
   87c2c:	687b      	ldr	r3, [r7, #4]
   87c2e:	685b      	ldr	r3, [r3, #4]
   87c30:	f023 028f 	bic.w	r2, r3, #143	; 0x8f
   87c34:	687b      	ldr	r3, [r7, #4]
   87c36:	605a      	str	r2, [r3, #4]
	
	//Configure FreeRun
	if(uc_freerun & ADC_MR_FREERUN == ADC_MR_FREERUN_ON) {                 //FreeRun is enabled
   87c38:	78bb      	ldrb	r3, [r7, #2]
   87c3a:	f003 0301 	and.w	r3, r3, #1
   87c3e:	2b00      	cmp	r3, #0
   87c40:	d006      	beq.n	87c50 <adc_configure_trigger+0x34>
		p_adc->ADC_MR |= ADC_MR_FREERUN_ON;
   87c42:	687b      	ldr	r3, [r7, #4]
   87c44:	685b      	ldr	r3, [r3, #4]
   87c46:	f043 0280 	orr.w	r2, r3, #128	; 0x80
   87c4a:	687b      	ldr	r3, [r7, #4]
   87c4c:	605a      	str	r2, [r3, #4]
		
		//Free Run Mode: Never wait for any trigger
		//No need to continue and enable hardware triggers
		return;
   87c4e:	e00e      	b.n	87c6e <adc_configure_trigger+0x52>
	}
	
	//Configure hardware triggers
	if(trigger & ADC_MR_TRGEN == ADC_MR_TRGEN_EN) {                       //Hardware trigger is enabled
   87c50:	78fb      	ldrb	r3, [r7, #3]
   87c52:	f003 0301 	and.w	r3, r3, #1
   87c56:	2b00      	cmp	r3, #0
   87c58:	d009      	beq.n	87c6e <adc_configure_trigger+0x52>
		p_adc->ADC_MR |= (trigger & ADC_MR_TRGSEL_Msk) | ADC_MR_TRGEN_EN; //Set trigger selection bits and enable hardware trigger
   87c5a:	687b      	ldr	r3, [r7, #4]
   87c5c:	685a      	ldr	r2, [r3, #4]
   87c5e:	78fb      	ldrb	r3, [r7, #3]
   87c60:	f003 030e 	and.w	r3, r3, #14
   87c64:	4313      	orrs	r3, r2
   87c66:	f043 0201 	orr.w	r2, r3, #1
   87c6a:	687b      	ldr	r3, [r7, #4]
   87c6c:	605a      	str	r2, [r3, #4]
	}
}
   87c6e:	370c      	adds	r7, #12
   87c70:	46bd      	mov	sp, r7
   87c72:	bc80      	pop	{r7}
   87c74:	4770      	bx	lr
   87c76:	bf00      	nop

00087c78 <adc_configure_timing>:
 * \param uc_settling Analog settling time = (uc_settling + 1) / ADC clock.
 * \param uc_transfer Data transfer time = (uc_transfer * 2 + 3) / ADC clock.
 */
void adc_configure_timing(Adc *p_adc, const uint8_t uc_tracking,
		const enum adc_settling_time_t settling,const uint8_t uc_transfer)
{
   87c78:	b480      	push	{r7}
   87c7a:	b085      	sub	sp, #20
   87c7c:	af00      	add	r7, sp, #0
   87c7e:	60f8      	str	r0, [r7, #12]
   87c80:	607a      	str	r2, [r7, #4]
   87c82:	461a      	mov	r2, r3
   87c84:	460b      	mov	r3, r1
   87c86:	72fb      	strb	r3, [r7, #11]
   87c88:	4613      	mov	r3, r2
   87c8a:	72bb      	strb	r3, [r7, #10]
	p_adc->ADC_MR |= ADC_MR_TRANSFER(uc_transfer)
   87c8c:	68fb      	ldr	r3, [r7, #12]
   87c8e:	685a      	ldr	r2, [r3, #4]
   87c90:	7abb      	ldrb	r3, [r7, #10]
   87c92:	071b      	lsls	r3, r3, #28
   87c94:	f003 5140 	and.w	r1, r3, #805306368	; 0x30000000
			| settling | ADC_MR_TRACKTIM(uc_tracking);
   87c98:	687b      	ldr	r3, [r7, #4]
   87c9a:	4319      	orrs	r1, r3
   87c9c:	7afb      	ldrb	r3, [r7, #11]
   87c9e:	061b      	lsls	r3, r3, #24
   87ca0:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
   87ca4:	430b      	orrs	r3, r1
 * \param uc_transfer Data transfer time = (uc_transfer * 2 + 3) / ADC clock.
 */
void adc_configure_timing(Adc *p_adc, const uint8_t uc_tracking,
		const enum adc_settling_time_t settling,const uint8_t uc_transfer)
{
	p_adc->ADC_MR |= ADC_MR_TRANSFER(uc_transfer)
   87ca6:	431a      	orrs	r2, r3
   87ca8:	68fb      	ldr	r3, [r7, #12]
   87caa:	605a      	str	r2, [r3, #4]
			| settling | ADC_MR_TRACKTIM(uc_tracking);
}
   87cac:	bf00      	nop
   87cae:	3714      	adds	r7, #20
   87cb0:	46bd      	mov	sp, r7
   87cb2:	bc80      	pop	{r7}
   87cb4:	4770      	bx	lr
   87cb6:	bf00      	nop

00087cb8 <adc_disable_channel>:
 *
 * \param p_adc Pointer to an ADC instance.
 * \param adc_ch ADC channel number.
 */
void adc_disable_channel(Adc *p_adc, const enum adc_channel_num_t adc_ch)
{
   87cb8:	b480      	push	{r7}
   87cba:	b083      	sub	sp, #12
   87cbc:	af00      	add	r7, sp, #0
   87cbe:	6078      	str	r0, [r7, #4]
   87cc0:	460b      	mov	r3, r1
   87cc2:	70fb      	strb	r3, [r7, #3]
	p_adc->ADC_CHDR = 1 << adc_ch;
   87cc4:	78fb      	ldrb	r3, [r7, #3]
   87cc6:	2201      	movs	r2, #1
   87cc8:	fa02 f303 	lsl.w	r3, r2, r3
   87ccc:	461a      	mov	r2, r3
   87cce:	687b      	ldr	r3, [r7, #4]
   87cd0:	615a      	str	r2, [r3, #20]
}
   87cd2:	bf00      	nop
   87cd4:	370c      	adds	r7, #12
   87cd6:	46bd      	mov	sp, r7
   87cd8:	bc80      	pop	{r7}
   87cda:	4770      	bx	lr

00087cdc <adc_disable_all_channel>:
 * \brief Disable all ADC channel.
 *
 * \param p_adc Pointer to an ADC instance.
 */
void adc_disable_all_channel(Adc *p_adc)
{
   87cdc:	b480      	push	{r7}
   87cde:	b083      	sub	sp, #12
   87ce0:	af00      	add	r7, sp, #0
   87ce2:	6078      	str	r0, [r7, #4]
#if SAM3S_SERIES || SAM4S_SERIES || SAM3N_SERIES || SAM3XA_SERIES
	p_adc->ADC_CHDR = 0xFFFF;
   87ce4:	687b      	ldr	r3, [r7, #4]
   87ce6:	f64f 72ff 	movw	r2, #65535	; 0xffff
   87cea:	615a      	str	r2, [r3, #20]
#elif SAM3U_SERIES
	p_adc->ADC_CHDR = 0xFF;
#endif
}
   87cec:	bf00      	nop
   87cee:	370c      	adds	r7, #12
   87cf0:	46bd      	mov	sp, r7
   87cf2:	bc80      	pop	{r7}
   87cf4:	4770      	bx	lr
   87cf6:	bf00      	nop

00087cf8 <adc_disable_interrupt>:
 *
 * \param p_adc Pointer to an ADC instance.
 * \param ul_source Interrupts to be disabled.
 */
void adc_disable_interrupt(Adc *p_adc, const uint32_t ul_source)
{
   87cf8:	b480      	push	{r7}
   87cfa:	b083      	sub	sp, #12
   87cfc:	af00      	add	r7, sp, #0
   87cfe:	6078      	str	r0, [r7, #4]
   87d00:	6039      	str	r1, [r7, #0]
	p_adc->ADC_IDR = ul_source;
   87d02:	687b      	ldr	r3, [r7, #4]
   87d04:	683a      	ldr	r2, [r7, #0]
   87d06:	629a      	str	r2, [r3, #40]	; 0x28
}
   87d08:	bf00      	nop
   87d0a:	370c      	adds	r7, #12
   87d0c:	46bd      	mov	sp, r7
   87d0e:	bc80      	pop	{r7}
   87d10:	4770      	bx	lr
   87d12:	bf00      	nop

00087d14 <PIO_DisableInterrupt>:
 * \param pPio            Pointer to a PIO controller.
 * \param dwMask          Bitmask of one or more pin(s) to configure.
 * \param dwPullUpEnable  Indicates if the pin(s) internal pull-up shall be configured.
 */
extern void PIO_DisableInterrupt( Pio *pPio, const uint32_t dwMask )
{
   87d14:	b480      	push	{r7}
   87d16:	b083      	sub	sp, #12
   87d18:	af00      	add	r7, sp, #0
   87d1a:	6078      	str	r0, [r7, #4]
   87d1c:	6039      	str	r1, [r7, #0]
    /* Disable interrupts on the pin */
    pPio->PIO_IDR = dwMask ;
   87d1e:	687b      	ldr	r3, [r7, #4]
   87d20:	683a      	ldr	r2, [r7, #0]
   87d22:	645a      	str	r2, [r3, #68]	; 0x44
}
   87d24:	bf00      	nop
   87d26:	370c      	adds	r7, #12
   87d28:	46bd      	mov	sp, r7
   87d2a:	bc80      	pop	{r7}
   87d2c:	4770      	bx	lr
   87d2e:	bf00      	nop

00087d30 <PIO_PullUp>:
 * \param pPio            Pointer to a PIO controller.
 * \param dwMask          Bitmask of one or more pin(s) to configure.
 * \param dwPullUpEnable  Indicates if the pin(s) internal pull-up shall be configured.
 */
extern void PIO_PullUp( Pio *pPio, const uint32_t dwMask, const uint32_t dwPullUpEnable )
{
   87d30:	b480      	push	{r7}
   87d32:	b085      	sub	sp, #20
   87d34:	af00      	add	r7, sp, #0
   87d36:	60f8      	str	r0, [r7, #12]
   87d38:	60b9      	str	r1, [r7, #8]
   87d3a:	607a      	str	r2, [r7, #4]
    /* Enable the pull-up(s) if necessary */
    if ( dwPullUpEnable )
   87d3c:	687b      	ldr	r3, [r7, #4]
   87d3e:	2b00      	cmp	r3, #0
   87d40:	d003      	beq.n	87d4a <PIO_PullUp+0x1a>
    {
        pPio->PIO_PUER = dwMask ;
   87d42:	68fb      	ldr	r3, [r7, #12]
   87d44:	68ba      	ldr	r2, [r7, #8]
   87d46:	665a      	str	r2, [r3, #100]	; 0x64
    }
    else
    {
        pPio->PIO_PUDR = dwMask ;
    }
}
   87d48:	e002      	b.n	87d50 <PIO_PullUp+0x20>
    {
        pPio->PIO_PUER = dwMask ;
    }
    else
    {
        pPio->PIO_PUDR = dwMask ;
   87d4a:	68fb      	ldr	r3, [r7, #12]
   87d4c:	68ba      	ldr	r2, [r7, #8]
   87d4e:	661a      	str	r2, [r3, #96]	; 0x60
    }
}
   87d50:	bf00      	nop
   87d52:	3714      	adds	r7, #20
   87d54:	46bd      	mov	sp, r7
   87d56:	bc80      	pop	{r7}
   87d58:	4770      	bx	lr
   87d5a:	bf00      	nop

00087d5c <PIO_Get>:
 *
 * \return 1 if the Pin instance contains at least one PIO that currently has
 * a high level; otherwise 0.
 */
extern uint32_t PIO_Get( Pio* pPio, const EPioType dwType, const uint32_t dwMask )
{
   87d5c:	b480      	push	{r7}
   87d5e:	b087      	sub	sp, #28
   87d60:	af00      	add	r7, sp, #0
   87d62:	60f8      	str	r0, [r7, #12]
   87d64:	460b      	mov	r3, r1
   87d66:	607a      	str	r2, [r7, #4]
   87d68:	72fb      	strb	r3, [r7, #11]
    uint32_t dwReg ;

    if ( (dwType == PIO_OUTPUT_0) || (dwType == PIO_OUTPUT_1) )
   87d6a:	7afb      	ldrb	r3, [r7, #11]
   87d6c:	2b04      	cmp	r3, #4
   87d6e:	d002      	beq.n	87d76 <PIO_Get+0x1a>
   87d70:	7afb      	ldrb	r3, [r7, #11]
   87d72:	2b05      	cmp	r3, #5
   87d74:	d103      	bne.n	87d7e <PIO_Get+0x22>
    {
        dwReg = pPio->PIO_ODSR ;
   87d76:	68fb      	ldr	r3, [r7, #12]
   87d78:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   87d7a:	617b      	str	r3, [r7, #20]
   87d7c:	e002      	b.n	87d84 <PIO_Get+0x28>
    }
    else
    {
        dwReg = pPio->PIO_PDSR ;
   87d7e:	68fb      	ldr	r3, [r7, #12]
   87d80:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   87d82:	617b      	str	r3, [r7, #20]
    }

    if ( (dwReg & dwMask) == 0 )
   87d84:	697a      	ldr	r2, [r7, #20]
   87d86:	687b      	ldr	r3, [r7, #4]
   87d88:	4013      	ands	r3, r2
   87d8a:	2b00      	cmp	r3, #0
   87d8c:	d101      	bne.n	87d92 <PIO_Get+0x36>
    {
        return 0 ;
   87d8e:	2300      	movs	r3, #0
   87d90:	e000      	b.n	87d94 <PIO_Get+0x38>
    }
    else
    {
        return 1 ;
   87d92:	2301      	movs	r3, #1
    }
}
   87d94:	4618      	mov	r0, r3
   87d96:	371c      	adds	r7, #28
   87d98:	46bd      	mov	sp, r7
   87d9a:	bc80      	pop	{r7}
   87d9c:	4770      	bx	lr
   87d9e:	bf00      	nop

00087da0 <PIO_SetPeripheral>:
 * \param pPio    Pointer to a PIO controller.
 * \param dwType  PIO type.
 * \param dwMask  Bitmask of one or more pin(s) to configure.
 */
extern void PIO_SetPeripheral( Pio* pPio, EPioType dwType, uint32_t dwMask )
{
   87da0:	b480      	push	{r7}
   87da2:	b087      	sub	sp, #28
   87da4:	af00      	add	r7, sp, #0
   87da6:	60f8      	str	r0, [r7, #12]
   87da8:	460b      	mov	r3, r1
   87daa:	607a      	str	r2, [r7, #4]
   87dac:	72fb      	strb	r3, [r7, #11]
    uint32_t dwSR ;

    /* Disable interrupts on the pin(s) */
    pPio->PIO_IDR = dwMask ;
   87dae:	68fb      	ldr	r3, [r7, #12]
   87db0:	687a      	ldr	r2, [r7, #4]
   87db2:	645a      	str	r2, [r3, #68]	; 0x44

    switch ( dwType )
   87db4:	7afb      	ldrb	r3, [r7, #11]
   87db6:	2b05      	cmp	r3, #5
   87db8:	d824      	bhi.n	87e04 <PIO_SetPeripheral+0x64>
   87dba:	a201      	add	r2, pc, #4	; (adr r2, 87dc0 <PIO_SetPeripheral+0x20>)
   87dbc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   87dc0:	00087e0d 	.word	0x00087e0d
   87dc4:	00087dd9 	.word	0x00087dd9
   87dc8:	00087df3 	.word	0x00087df3
   87dcc:	00087e0d 	.word	0x00087e0d
   87dd0:	00087e0d 	.word	0x00087e0d
   87dd4:	00087e0d 	.word	0x00087e0d
            dwSR = pPio->PIO_ABCDSR[1];
            pPio->PIO_ABCDSR[1] &= (~dwMask & dwSR) ;
#endif /* (defined _SAM3S_) || (defined _SAM3S8_) || (defined _SAM3N_) */

#if (defined _SAM3U_) || (defined _SAM3XA_)
            dwSR = pPio->PIO_ABSR ;
   87dd8:	68fb      	ldr	r3, [r7, #12]
   87dda:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   87ddc:	617b      	str	r3, [r7, #20]
            pPio->PIO_ABSR &= (~dwMask & dwSR) ;
   87dde:	68fb      	ldr	r3, [r7, #12]
   87de0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   87de2:	687b      	ldr	r3, [r7, #4]
   87de4:	43d9      	mvns	r1, r3
   87de6:	697b      	ldr	r3, [r7, #20]
   87de8:	400b      	ands	r3, r1
   87dea:	401a      	ands	r2, r3
   87dec:	68fb      	ldr	r3, [r7, #12]
   87dee:	671a      	str	r2, [r3, #112]	; 0x70
#endif /* (defined _SAM3U_) || (defined _SAM3XA_) */
        break ;
   87df0:	e008      	b.n	87e04 <PIO_SetPeripheral+0x64>
            dwSR = pPio->PIO_ABCDSR[1] ;
            pPio->PIO_ABCDSR[1] &= (~dwMask & dwSR) ;
#endif /* (defined _SAM3S_) || (defined _SAM3S8_) || (defined _SAM3N_) */

#if (defined _SAM3U_) || (defined _SAM3XA_)
            dwSR = pPio->PIO_ABSR ;
   87df2:	68fb      	ldr	r3, [r7, #12]
   87df4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   87df6:	617b      	str	r3, [r7, #20]
            pPio->PIO_ABSR = (dwMask | dwSR) ;
   87df8:	687a      	ldr	r2, [r7, #4]
   87dfa:	697b      	ldr	r3, [r7, #20]
   87dfc:	431a      	orrs	r2, r3
   87dfe:	68fb      	ldr	r3, [r7, #12]
   87e00:	671a      	str	r2, [r3, #112]	; 0x70
#endif /* (defined _SAM3U_) || (defined _SAM3XA_) */
        break ;
   87e02:	bf00      	nop
        case PIO_NOT_A_PIN :
        return ;
    }

    // Remove the pins from under the control of PIO
    pPio->PIO_PDR = dwMask ;
   87e04:	68fb      	ldr	r3, [r7, #12]
   87e06:	687a      	ldr	r2, [r7, #4]
   87e08:	605a      	str	r2, [r3, #4]
   87e0a:	e000      	b.n	87e0e <PIO_SetPeripheral+0x6e>
        // other types are invalid in this function
        case PIO_INPUT :
        case PIO_OUTPUT_0 :
        case PIO_OUTPUT_1 :
        case PIO_NOT_A_PIN :
        return ;
   87e0c:	bf00      	nop
    }

    // Remove the pins from under the control of PIO
    pPio->PIO_PDR = dwMask ;
}
   87e0e:	371c      	adds	r7, #28
   87e10:	46bd      	mov	sp, r7
   87e12:	bc80      	pop	{r7}
   87e14:	4770      	bx	lr
   87e16:	bf00      	nop

00087e18 <PIO_SetInput>:
 * \param pPio        Pointer to a PIO controller.
 * \param dwMask      Bitmask indicating which pin(s) to configure as input(s).
 * \param dwAttribute .
 */
extern void PIO_SetInput( Pio* pPio, uint32_t dwMask, uint32_t dwAttribute )
{
   87e18:	b580      	push	{r7, lr}
   87e1a:	b084      	sub	sp, #16
   87e1c:	af00      	add	r7, sp, #0
   87e1e:	60f8      	str	r0, [r7, #12]
   87e20:	60b9      	str	r1, [r7, #8]
   87e22:	607a      	str	r2, [r7, #4]
    PIO_DisableInterrupt( pPio, dwMask ) ;
   87e24:	68b9      	ldr	r1, [r7, #8]
   87e26:	68f8      	ldr	r0, [r7, #12]
   87e28:	4b19      	ldr	r3, [pc, #100]	; (87e90 <PIO_SetInput+0x78>)
   87e2a:	4798      	blx	r3
    PIO_PullUp( pPio, dwMask, dwAttribute & PIO_PULLUP ) ;
   87e2c:	687b      	ldr	r3, [r7, #4]
   87e2e:	f003 0301 	and.w	r3, r3, #1
   87e32:	461a      	mov	r2, r3
   87e34:	68b9      	ldr	r1, [r7, #8]
   87e36:	68f8      	ldr	r0, [r7, #12]
   87e38:	4b16      	ldr	r3, [pc, #88]	; (87e94 <PIO_SetInput+0x7c>)
   87e3a:	4798      	blx	r3

    /* Enable Input Filter if necessary */
    if ( dwAttribute & (PIO_DEGLITCH | PIO_DEBOUNCE) )
   87e3c:	687b      	ldr	r3, [r7, #4]
   87e3e:	f003 030a 	and.w	r3, r3, #10
   87e42:	2b00      	cmp	r3, #0
   87e44:	d003      	beq.n	87e4e <PIO_SetInput+0x36>
    {
        pPio->PIO_IFER = dwMask ;
   87e46:	68fb      	ldr	r3, [r7, #12]
   87e48:	68ba      	ldr	r2, [r7, #8]
   87e4a:	621a      	str	r2, [r3, #32]
   87e4c:	e002      	b.n	87e54 <PIO_SetInput+0x3c>
    }
    else
    {
        pPio->PIO_IFDR = dwMask ;
   87e4e:	68fb      	ldr	r3, [r7, #12]
   87e50:	68ba      	ldr	r2, [r7, #8]
   87e52:	625a      	str	r2, [r3, #36]	; 0x24
        {
            pPio->PIO_IFSCER = dwMask ;
        }
    }
#elif (defined _SAM3U_) || (defined _SAM3XA_)
    if ( dwAttribute & PIO_DEGLITCH )
   87e54:	687b      	ldr	r3, [r7, #4]
   87e56:	f003 0302 	and.w	r3, r3, #2
   87e5a:	2b00      	cmp	r3, #0
   87e5c:	d004      	beq.n	87e68 <PIO_SetInput+0x50>
    {
        pPio->PIO_SCIFSR = dwMask ;
   87e5e:	68fb      	ldr	r3, [r7, #12]
   87e60:	68ba      	ldr	r2, [r7, #8]
   87e62:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
   87e66:	e008      	b.n	87e7a <PIO_SetInput+0x62>
    }
    else
    {
        if ( dwAttribute & PIO_DEBOUNCE )
   87e68:	687b      	ldr	r3, [r7, #4]
   87e6a:	f003 0308 	and.w	r3, r3, #8
   87e6e:	2b00      	cmp	r3, #0
   87e70:	d003      	beq.n	87e7a <PIO_SetInput+0x62>
        {
            pPio->PIO_SCIFSR = dwMask ;
   87e72:	68fb      	ldr	r3, [r7, #12]
   87e74:	68ba      	ldr	r2, [r7, #8]
   87e76:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#else
    #error "The specified chip is not supported."
#endif

    /* Configure pin as input */
    pPio->PIO_ODR = dwMask ;
   87e7a:	68fb      	ldr	r3, [r7, #12]
   87e7c:	68ba      	ldr	r2, [r7, #8]
   87e7e:	615a      	str	r2, [r3, #20]
    pPio->PIO_PER = dwMask ;
   87e80:	68fb      	ldr	r3, [r7, #12]
   87e82:	68ba      	ldr	r2, [r7, #8]
   87e84:	601a      	str	r2, [r3, #0]
}
   87e86:	bf00      	nop
   87e88:	3710      	adds	r7, #16
   87e8a:	46bd      	mov	sp, r7
   87e8c:	bd80      	pop	{r7, pc}
   87e8e:	bf00      	nop
   87e90:	00087d15 	.word	0x00087d15
   87e94:	00087d31 	.word	0x00087d31

00087e98 <PIO_SetOutput>:
 * \param enableMultiDrive  Indicates if the pin(s) shall be configured as open-drain.
 * \param enablePullUp      Indicates if the pin shall have its pull-up activated.
 */
extern void PIO_SetOutput( Pio* pPio, uint32_t dwMask, uint32_t dwDefaultValue,
                                      uint32_t dwMultiDriveEnable, uint32_t dwPullUpEnable )
{
   87e98:	b580      	push	{r7, lr}
   87e9a:	b084      	sub	sp, #16
   87e9c:	af00      	add	r7, sp, #0
   87e9e:	60f8      	str	r0, [r7, #12]
   87ea0:	60b9      	str	r1, [r7, #8]
   87ea2:	607a      	str	r2, [r7, #4]
   87ea4:	603b      	str	r3, [r7, #0]
    PIO_DisableInterrupt( pPio, dwMask ) ;
   87ea6:	68b9      	ldr	r1, [r7, #8]
   87ea8:	68f8      	ldr	r0, [r7, #12]
   87eaa:	4b12      	ldr	r3, [pc, #72]	; (87ef4 <PIO_SetOutput+0x5c>)
   87eac:	4798      	blx	r3
    PIO_PullUp( pPio, dwMask, dwPullUpEnable ) ;
   87eae:	69ba      	ldr	r2, [r7, #24]
   87eb0:	68b9      	ldr	r1, [r7, #8]
   87eb2:	68f8      	ldr	r0, [r7, #12]
   87eb4:	4b10      	ldr	r3, [pc, #64]	; (87ef8 <PIO_SetOutput+0x60>)
   87eb6:	4798      	blx	r3

    /* Enable multi-drive if necessary */
    if ( dwMultiDriveEnable )
   87eb8:	683b      	ldr	r3, [r7, #0]
   87eba:	2b00      	cmp	r3, #0
   87ebc:	d003      	beq.n	87ec6 <PIO_SetOutput+0x2e>
    {
        pPio->PIO_MDER = dwMask ;
   87ebe:	68fb      	ldr	r3, [r7, #12]
   87ec0:	68ba      	ldr	r2, [r7, #8]
   87ec2:	651a      	str	r2, [r3, #80]	; 0x50
   87ec4:	e002      	b.n	87ecc <PIO_SetOutput+0x34>
    }
    else
    {
        pPio->PIO_MDDR = dwMask ;
   87ec6:	68fb      	ldr	r3, [r7, #12]
   87ec8:	68ba      	ldr	r2, [r7, #8]
   87eca:	655a      	str	r2, [r3, #84]	; 0x54
    }

    /* Set default value */
    if ( dwDefaultValue )
   87ecc:	687b      	ldr	r3, [r7, #4]
   87ece:	2b00      	cmp	r3, #0
   87ed0:	d003      	beq.n	87eda <PIO_SetOutput+0x42>
    {
        pPio->PIO_SODR = dwMask ;
   87ed2:	68fb      	ldr	r3, [r7, #12]
   87ed4:	68ba      	ldr	r2, [r7, #8]
   87ed6:	631a      	str	r2, [r3, #48]	; 0x30
   87ed8:	e002      	b.n	87ee0 <PIO_SetOutput+0x48>
    }
    else
    {
        pPio->PIO_CODR = dwMask ;
   87eda:	68fb      	ldr	r3, [r7, #12]
   87edc:	68ba      	ldr	r2, [r7, #8]
   87ede:	635a      	str	r2, [r3, #52]	; 0x34
    }

    /* Configure pin(s) as output(s) */
    pPio->PIO_OER = dwMask ;
   87ee0:	68fb      	ldr	r3, [r7, #12]
   87ee2:	68ba      	ldr	r2, [r7, #8]
   87ee4:	611a      	str	r2, [r3, #16]
    pPio->PIO_PER = dwMask ;
   87ee6:	68fb      	ldr	r3, [r7, #12]
   87ee8:	68ba      	ldr	r2, [r7, #8]
   87eea:	601a      	str	r2, [r3, #0]
}
   87eec:	bf00      	nop
   87eee:	3710      	adds	r7, #16
   87ef0:	46bd      	mov	sp, r7
   87ef2:	bd80      	pop	{r7, pc}
   87ef4:	00087d15 	.word	0x00087d15
   87ef8:	00087d31 	.word	0x00087d31

00087efc <PIO_Configure>:
/**
 *
 * \return 1 if the pins have been configured properly; otherwise 0.
 */
extern uint32_t PIO_Configure( Pio* pPio, const EPioType dwType, const uint32_t dwMask, const uint32_t dwAttribute )
{
   87efc:	b590      	push	{r4, r7, lr}
   87efe:	b087      	sub	sp, #28
   87f00:	af02      	add	r7, sp, #8
   87f02:	60f8      	str	r0, [r7, #12]
   87f04:	607a      	str	r2, [r7, #4]
   87f06:	603b      	str	r3, [r7, #0]
   87f08:	460b      	mov	r3, r1
   87f0a:	72fb      	strb	r3, [r7, #11]
    /* Configure pins */
    switch ( dwType )
   87f0c:	7afb      	ldrb	r3, [r7, #11]
   87f0e:	3b01      	subs	r3, #1
   87f10:	2b04      	cmp	r3, #4
   87f12:	d845      	bhi.n	87fa0 <PIO_Configure+0xa4>
   87f14:	a201      	add	r2, pc, #4	; (adr r2, 87f1c <PIO_Configure+0x20>)
   87f16:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   87f1a:	bf00      	nop
   87f1c:	00087f31 	.word	0x00087f31
   87f20:	00087f31 	.word	0x00087f31
   87f24:	00087f57 	.word	0x00087f57
   87f28:	00087f63 	.word	0x00087f63
   87f2c:	00087f63 	.word	0x00087f63
#if (defined _SAM3S_) || (defined _SAM3S8_) || (defined _SAM3N_)
        case PIO_PERIPH_C :
        case PIO_PERIPH_D :
#endif /* (defined _SAM3S_) || (defined _SAM3S8_) || (defined _SAM3N_) */
            /* Put the pin under control of peripheral */
            PIO_SetPeripheral( pPio, dwType, dwMask ) ;
   87f30:	7afb      	ldrb	r3, [r7, #11]
   87f32:	687a      	ldr	r2, [r7, #4]
   87f34:	4619      	mov	r1, r3
   87f36:	68f8      	ldr	r0, [r7, #12]
   87f38:	4b1d      	ldr	r3, [pc, #116]	; (87fb0 <PIO_Configure+0xb4>)
   87f3a:	4798      	blx	r3
            /* Disable interrupts on the pin(s) */
            PIO_DisableInterrupt( pPio, dwMask ) ;
   87f3c:	6879      	ldr	r1, [r7, #4]
   87f3e:	68f8      	ldr	r0, [r7, #12]
   87f40:	4b1c      	ldr	r3, [pc, #112]	; (87fb4 <PIO_Configure+0xb8>)
   87f42:	4798      	blx	r3
            /* Enable Pullup */
            PIO_PullUp( pPio, dwMask, (dwAttribute & PIO_PULLUP) ) ;
   87f44:	683b      	ldr	r3, [r7, #0]
   87f46:	f003 0301 	and.w	r3, r3, #1
   87f4a:	461a      	mov	r2, r3
   87f4c:	6879      	ldr	r1, [r7, #4]
   87f4e:	68f8      	ldr	r0, [r7, #12]
   87f50:	4b19      	ldr	r3, [pc, #100]	; (87fb8 <PIO_Configure+0xbc>)
   87f52:	4798      	blx	r3
        break;
   87f54:	e026      	b.n	87fa4 <PIO_Configure+0xa8>

        case PIO_INPUT :
            PIO_SetInput( pPio, dwMask, dwAttribute ) ;
   87f56:	683a      	ldr	r2, [r7, #0]
   87f58:	6879      	ldr	r1, [r7, #4]
   87f5a:	68f8      	ldr	r0, [r7, #12]
   87f5c:	4b17      	ldr	r3, [pc, #92]	; (87fbc <PIO_Configure+0xc0>)
   87f5e:	4798      	blx	r3
        break;
   87f60:	e020      	b.n	87fa4 <PIO_Configure+0xa8>

        case PIO_OUTPUT_0 :
        case PIO_OUTPUT_1 :
            PIO_SetOutput( pPio, dwMask, (dwType == PIO_OUTPUT_1),
   87f62:	7afb      	ldrb	r3, [r7, #11]
   87f64:	2b05      	cmp	r3, #5
   87f66:	bf0c      	ite	eq
   87f68:	2301      	moveq	r3, #1
   87f6a:	2300      	movne	r3, #0
   87f6c:	b2db      	uxtb	r3, r3
   87f6e:	461a      	mov	r2, r3
                          (dwAttribute & PIO_OPENDRAIN) ? 1 : 0,
   87f70:	683b      	ldr	r3, [r7, #0]
   87f72:	f003 0304 	and.w	r3, r3, #4
            PIO_SetInput( pPio, dwMask, dwAttribute ) ;
        break;

        case PIO_OUTPUT_0 :
        case PIO_OUTPUT_1 :
            PIO_SetOutput( pPio, dwMask, (dwType == PIO_OUTPUT_1),
   87f76:	2b00      	cmp	r3, #0
   87f78:	bf14      	ite	ne
   87f7a:	2301      	movne	r3, #1
   87f7c:	2300      	moveq	r3, #0
   87f7e:	b2db      	uxtb	r3, r3
   87f80:	4619      	mov	r1, r3
                          (dwAttribute & PIO_OPENDRAIN) ? 1 : 0,
                          (dwAttribute & PIO_PULLUP) ? 1 : 0);
   87f82:	683b      	ldr	r3, [r7, #0]
   87f84:	f003 0301 	and.w	r3, r3, #1
            PIO_SetInput( pPio, dwMask, dwAttribute ) ;
        break;

        case PIO_OUTPUT_0 :
        case PIO_OUTPUT_1 :
            PIO_SetOutput( pPio, dwMask, (dwType == PIO_OUTPUT_1),
   87f88:	2b00      	cmp	r3, #0
   87f8a:	bf14      	ite	ne
   87f8c:	2301      	movne	r3, #1
   87f8e:	2300      	moveq	r3, #0
   87f90:	b2db      	uxtb	r3, r3
   87f92:	9300      	str	r3, [sp, #0]
   87f94:	460b      	mov	r3, r1
   87f96:	6879      	ldr	r1, [r7, #4]
   87f98:	68f8      	ldr	r0, [r7, #12]
   87f9a:	4c09      	ldr	r4, [pc, #36]	; (87fc0 <PIO_Configure+0xc4>)
   87f9c:	47a0      	blx	r4
                          (dwAttribute & PIO_OPENDRAIN) ? 1 : 0,
                          (dwAttribute & PIO_PULLUP) ? 1 : 0);
        break ;
   87f9e:	e001      	b.n	87fa4 <PIO_Configure+0xa8>

        default :
        return 0 ;
   87fa0:	2300      	movs	r3, #0
   87fa2:	e000      	b.n	87fa6 <PIO_Configure+0xaa>
    }

    return 1 ;
   87fa4:	2301      	movs	r3, #1
}
   87fa6:	4618      	mov	r0, r3
   87fa8:	3714      	adds	r7, #20
   87faa:	46bd      	mov	sp, r7
   87fac:	bd90      	pop	{r4, r7, pc}
   87fae:	bf00      	nop
   87fb0:	00087da1 	.word	0x00087da1
   87fb4:	00087d15 	.word	0x00087d15
   87fb8:	00087d31 	.word	0x00087d31
   87fbc:	00087e19 	.word	0x00087e19
   87fc0:	00087e99 	.word	0x00087e99

00087fc4 <PIO_GetOutputDataStatus>:
 *
 * \return 1 if the Pin instance contains at least one PIO that is configured
 * to output a high level; otherwise 0.
 */
extern uint32_t PIO_GetOutputDataStatus( const Pio* pPio, const uint32_t dwMask )
{
   87fc4:	b480      	push	{r7}
   87fc6:	b083      	sub	sp, #12
   87fc8:	af00      	add	r7, sp, #0
   87fca:	6078      	str	r0, [r7, #4]
   87fcc:	6039      	str	r1, [r7, #0]
  /* Test if pin is under control of PIO */
  if ( (pPio->PIO_PSR & dwMask) != 0 )
   87fce:	687b      	ldr	r3, [r7, #4]
   87fd0:	689a      	ldr	r2, [r3, #8]
   87fd2:	683b      	ldr	r3, [r7, #0]
   87fd4:	4013      	ands	r3, r2
   87fd6:	2b00      	cmp	r3, #0
   87fd8:	d007      	beq.n	87fea <PIO_GetOutputDataStatus+0x26>
  {
    /* Test if pin is configured as output */
    if ( (pPio->PIO_OSR & dwMask) != 0 )
   87fda:	687b      	ldr	r3, [r7, #4]
   87fdc:	699a      	ldr	r2, [r3, #24]
   87fde:	683b      	ldr	r3, [r7, #0]
   87fe0:	4013      	ands	r3, r2
   87fe2:	2b00      	cmp	r3, #0
   87fe4:	d001      	beq.n	87fea <PIO_GetOutputDataStatus+0x26>
    {
      return 1 ;
   87fe6:	2301      	movs	r3, #1
   87fe8:	e000      	b.n	87fec <PIO_GetOutputDataStatus+0x28>
    }
  }

  return 0 ;
   87fea:	2300      	movs	r3, #0
}
   87fec:	4618      	mov	r0, r3
   87fee:	370c      	adds	r7, #12
   87ff0:	46bd      	mov	sp, r7
   87ff2:	bc80      	pop	{r7}
   87ff4:	4770      	bx	lr
   87ff6:	bf00      	nop

00087ff8 <pmc_enable_upll_clock>:
#if (SAM3XA_SERIES || SAM3U_SERIES)
/**
 * \brief Enable UPLL clock.
 */
void pmc_enable_upll_clock(void)
{
   87ff8:	b480      	push	{r7}
   87ffa:	af00      	add	r7, sp, #0
	PMC->CKGR_UCKR = CKGR_UCKR_UPLLCOUNT(3) | CKGR_UCKR_UPLLEN;
   87ffc:	4b07      	ldr	r3, [pc, #28]	; (8801c <pmc_enable_upll_clock+0x24>)
   87ffe:	f44f 1244 	mov.w	r2, #3211264	; 0x310000
   88002:	61da      	str	r2, [r3, #28]

	/* Wait UTMI PLL Lock Status */
	while (!(PMC->PMC_SR & PMC_SR_LOCKU));
   88004:	bf00      	nop
   88006:	4b05      	ldr	r3, [pc, #20]	; (8801c <pmc_enable_upll_clock+0x24>)
   88008:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   8800a:	f003 0340 	and.w	r3, r3, #64	; 0x40
   8800e:	2b00      	cmp	r3, #0
   88010:	d0f9      	beq.n	88006 <pmc_enable_upll_clock+0xe>
}
   88012:	bf00      	nop
   88014:	46bd      	mov	sp, r7
   88016:	bc80      	pop	{r7}
   88018:	4770      	bx	lr
   8801a:	bf00      	nop
   8801c:	400e0600 	.word	0x400e0600

00088020 <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
   88020:	b480      	push	{r7}
   88022:	b083      	sub	sp, #12
   88024:	af00      	add	r7, sp, #0
   88026:	6078      	str	r0, [r7, #4]
	if (ul_id > MAX_PERIPH_ID) {
   88028:	687b      	ldr	r3, [r7, #4]
   8802a:	2b2c      	cmp	r3, #44	; 0x2c
   8802c:	d901      	bls.n	88032 <pmc_enable_periph_clk+0x12>
		return 1;
   8802e:	2301      	movs	r3, #1
   88030:	e02f      	b.n	88092 <pmc_enable_periph_clk+0x72>
	}

	if (ul_id < 32) {
   88032:	687b      	ldr	r3, [r7, #4]
   88034:	2b1f      	cmp	r3, #31
   88036:	d813      	bhi.n	88060 <pmc_enable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
   88038:	4b18      	ldr	r3, [pc, #96]	; (8809c <pmc_enable_periph_clk+0x7c>)
   8803a:	699a      	ldr	r2, [r3, #24]
   8803c:	2101      	movs	r1, #1
   8803e:	687b      	ldr	r3, [r7, #4]
   88040:	fa01 f303 	lsl.w	r3, r1, r3
   88044:	401a      	ands	r2, r3
   88046:	2101      	movs	r1, #1
   88048:	687b      	ldr	r3, [r7, #4]
   8804a:	fa01 f303 	lsl.w	r3, r1, r3
   8804e:	429a      	cmp	r2, r3
   88050:	d01e      	beq.n	88090 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER0 = 1 << ul_id;
   88052:	4a12      	ldr	r2, [pc, #72]	; (8809c <pmc_enable_periph_clk+0x7c>)
   88054:	2101      	movs	r1, #1
   88056:	687b      	ldr	r3, [r7, #4]
   88058:	fa01 f303 	lsl.w	r3, r1, r3
   8805c:	6113      	str	r3, [r2, #16]
   8805e:	e017      	b.n	88090 <pmc_enable_periph_clk+0x70>
		}
#if (SAM3S_SERIES || SAM3XA_SERIES || SAM4S_SERIES)
	} else {
		ul_id -= 32;
   88060:	687b      	ldr	r3, [r7, #4]
   88062:	3b20      	subs	r3, #32
   88064:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
   88066:	4b0d      	ldr	r3, [pc, #52]	; (8809c <pmc_enable_periph_clk+0x7c>)
   88068:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
   8806c:	2101      	movs	r1, #1
   8806e:	687b      	ldr	r3, [r7, #4]
   88070:	fa01 f303 	lsl.w	r3, r1, r3
   88074:	401a      	ands	r2, r3
   88076:	2101      	movs	r1, #1
   88078:	687b      	ldr	r3, [r7, #4]
   8807a:	fa01 f303 	lsl.w	r3, r1, r3
   8807e:	429a      	cmp	r2, r3
   88080:	d006      	beq.n	88090 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER1 = 1 << ul_id;
   88082:	4a06      	ldr	r2, [pc, #24]	; (8809c <pmc_enable_periph_clk+0x7c>)
   88084:	2101      	movs	r1, #1
   88086:	687b      	ldr	r3, [r7, #4]
   88088:	fa01 f303 	lsl.w	r3, r1, r3
   8808c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
   88090:	2300      	movs	r3, #0
}
   88092:	4618      	mov	r0, r3
   88094:	370c      	adds	r7, #12
   88096:	46bd      	mov	sp, r7
   88098:	bc80      	pop	{r7}
   8809a:	4770      	bx	lr
   8809c:	400e0600 	.word	0x400e0600

000880a0 <pmc_disable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_disable_periph_clk(uint32_t ul_id)
{
   880a0:	b480      	push	{r7}
   880a2:	b083      	sub	sp, #12
   880a4:	af00      	add	r7, sp, #0
   880a6:	6078      	str	r0, [r7, #4]
	if (ul_id > MAX_PERIPH_ID) {
   880a8:	687b      	ldr	r3, [r7, #4]
   880aa:	2b2c      	cmp	r3, #44	; 0x2c
   880ac:	d901      	bls.n	880b2 <pmc_disable_periph_clk+0x12>
		return 1;
   880ae:	2301      	movs	r3, #1
   880b0:	e02f      	b.n	88112 <pmc_disable_periph_clk+0x72>
	}

	if (ul_id < 32) {
   880b2:	687b      	ldr	r3, [r7, #4]
   880b4:	2b1f      	cmp	r3, #31
   880b6:	d813      	bhi.n	880e0 <pmc_disable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) == (1u << ul_id)) {
   880b8:	4b18      	ldr	r3, [pc, #96]	; (8811c <pmc_disable_periph_clk+0x7c>)
   880ba:	699a      	ldr	r2, [r3, #24]
   880bc:	2101      	movs	r1, #1
   880be:	687b      	ldr	r3, [r7, #4]
   880c0:	fa01 f303 	lsl.w	r3, r1, r3
   880c4:	401a      	ands	r2, r3
   880c6:	2101      	movs	r1, #1
   880c8:	687b      	ldr	r3, [r7, #4]
   880ca:	fa01 f303 	lsl.w	r3, r1, r3
   880ce:	429a      	cmp	r2, r3
   880d0:	d11e      	bne.n	88110 <pmc_disable_periph_clk+0x70>
			PMC->PMC_PCDR0 = 1 << ul_id;
   880d2:	4a12      	ldr	r2, [pc, #72]	; (8811c <pmc_disable_periph_clk+0x7c>)
   880d4:	2101      	movs	r1, #1
   880d6:	687b      	ldr	r3, [r7, #4]
   880d8:	fa01 f303 	lsl.w	r3, r1, r3
   880dc:	6153      	str	r3, [r2, #20]
   880de:	e017      	b.n	88110 <pmc_disable_periph_clk+0x70>
		}
#if (SAM3S_SERIES || SAM3XA_SERIES || SAM4S_SERIES)
	} else {
		ul_id -= 32;
   880e0:	687b      	ldr	r3, [r7, #4]
   880e2:	3b20      	subs	r3, #32
   880e4:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) == (1u << ul_id)) {
   880e6:	4b0d      	ldr	r3, [pc, #52]	; (8811c <pmc_disable_periph_clk+0x7c>)
   880e8:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
   880ec:	2101      	movs	r1, #1
   880ee:	687b      	ldr	r3, [r7, #4]
   880f0:	fa01 f303 	lsl.w	r3, r1, r3
   880f4:	401a      	ands	r2, r3
   880f6:	2101      	movs	r1, #1
   880f8:	687b      	ldr	r3, [r7, #4]
   880fa:	fa01 f303 	lsl.w	r3, r1, r3
   880fe:	429a      	cmp	r2, r3
   88100:	d106      	bne.n	88110 <pmc_disable_periph_clk+0x70>
			PMC->PMC_PCDR1 = 1 << ul_id;
   88102:	4a06      	ldr	r2, [pc, #24]	; (8811c <pmc_disable_periph_clk+0x7c>)
   88104:	2101      	movs	r1, #1
   88106:	687b      	ldr	r3, [r7, #4]
   88108:	fa01 f303 	lsl.w	r3, r1, r3
   8810c:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
		}
#endif
	}
	return 0;
   88110:	2300      	movs	r3, #0
}
   88112:	4618      	mov	r0, r3
   88114:	370c      	adds	r7, #12
   88116:	46bd      	mov	sp, r7
   88118:	bc80      	pop	{r7}
   8811a:	4770      	bx	lr
   8811c:	400e0600 	.word	0x400e0600

00088120 <pmc_switch_udpck_to_upllck>:
 * \brief Switch UDP (USB) clock source selection to UPLL clock.
 *
 * \param dw_usbdiv Clock divisor.
 */
void pmc_switch_udpck_to_upllck(uint32_t ul_usbdiv)
{
   88120:	b480      	push	{r7}
   88122:	b083      	sub	sp, #12
   88124:	af00      	add	r7, sp, #0
   88126:	6078      	str	r0, [r7, #4]
	PMC->PMC_USB = PMC_USB_USBS | PMC_USB_USBDIV(ul_usbdiv);
   88128:	4a06      	ldr	r2, [pc, #24]	; (88144 <pmc_switch_udpck_to_upllck+0x24>)
   8812a:	687b      	ldr	r3, [r7, #4]
   8812c:	021b      	lsls	r3, r3, #8
   8812e:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
   88132:	f043 0301 	orr.w	r3, r3, #1
   88136:	6393      	str	r3, [r2, #56]	; 0x38
}
   88138:	bf00      	nop
   8813a:	370c      	adds	r7, #12
   8813c:	46bd      	mov	sp, r7
   8813e:	bc80      	pop	{r7}
   88140:	4770      	bx	lr
   88142:	bf00      	nop
   88144:	400e0600 	.word	0x400e0600

00088148 <pmc_enable_udpck>:
#if (SAM3S_SERIES || SAM3XA_SERIES || SAM4S_SERIES)
/**
 * \brief Enable UDP (USB) clock.
 */
void pmc_enable_udpck(void)
{
   88148:	b480      	push	{r7}
   8814a:	af00      	add	r7, sp, #0
# if (SAM3S_SERIES || SAM4S_SERIES)
	PMC->PMC_SCER = PMC_SCER_UDP;
# else
	PMC->PMC_SCER = PMC_SCER_UOTGCLK;
   8814c:	4b03      	ldr	r3, [pc, #12]	; (8815c <pmc_enable_udpck+0x14>)
   8814e:	2220      	movs	r2, #32
   88150:	601a      	str	r2, [r3, #0]
# endif
}
   88152:	bf00      	nop
   88154:	46bd      	mov	sp, r7
   88156:	bc80      	pop	{r7}
   88158:	4770      	bx	lr
   8815a:	bf00      	nop
   8815c:	400e0600 	.word	0x400e0600

00088160 <pmc_set_writeprotect>:
 * \brief Enable or disable write protect of PMC registers.
 *
 * \param ul_enable 1 to enable, 0 to disable.
 */
void pmc_set_writeprotect(uint32_t ul_enable)
{
   88160:	b480      	push	{r7}
   88162:	b083      	sub	sp, #12
   88164:	af00      	add	r7, sp, #0
   88166:	6078      	str	r0, [r7, #4]
	if (ul_enable) {
   88168:	687b      	ldr	r3, [r7, #4]
   8816a:	2b00      	cmp	r3, #0
   8816c:	d004      	beq.n	88178 <pmc_set_writeprotect+0x18>
		PMC->PMC_WPMR = PMC_WPMR_WPKEY_VALUE | PMC_WPMR_WPEN;
   8816e:	4b07      	ldr	r3, [pc, #28]	; (8818c <pmc_set_writeprotect+0x2c>)
   88170:	4a07      	ldr	r2, [pc, #28]	; (88190 <pmc_set_writeprotect+0x30>)
   88172:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	} else {
		PMC->PMC_WPMR = PMC_WPMR_WPKEY_VALUE;
	}
}
   88176:	e003      	b.n	88180 <pmc_set_writeprotect+0x20>
void pmc_set_writeprotect(uint32_t ul_enable)
{
	if (ul_enable) {
		PMC->PMC_WPMR = PMC_WPMR_WPKEY_VALUE | PMC_WPMR_WPEN;
	} else {
		PMC->PMC_WPMR = PMC_WPMR_WPKEY_VALUE;
   88178:	4b04      	ldr	r3, [pc, #16]	; (8818c <pmc_set_writeprotect+0x2c>)
   8817a:	4a06      	ldr	r2, [pc, #24]	; (88194 <pmc_set_writeprotect+0x34>)
   8817c:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
	}
}
   88180:	bf00      	nop
   88182:	370c      	adds	r7, #12
   88184:	46bd      	mov	sp, r7
   88186:	bc80      	pop	{r7}
   88188:	4770      	bx	lr
   8818a:	bf00      	nop
   8818c:	400e0600 	.word	0x400e0600
   88190:	504d4301 	.word	0x504d4301
   88194:	504d4300 	.word	0x504d4300

00088198 <TC_Configure>:
 * \param pTc  Pointer to a Tc instance.
 * \param channel Channel number.
 * \param mode  Operating mode (TC_CMR value).
 */
extern void TC_Configure( Tc *pTc, uint32_t dwChannel, uint32_t dwMode )
{
   88198:	b590      	push	{r4, r7, lr}
   8819a:	b087      	sub	sp, #28
   8819c:	af00      	add	r7, sp, #0
   8819e:	60f8      	str	r0, [r7, #12]
   881a0:	60b9      	str	r1, [r7, #8]
   881a2:	607a      	str	r2, [r7, #4]
    TcChannel* pTcCh ;

    assert( dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] )) ) ;
   881a4:	68bb      	ldr	r3, [r7, #8]
   881a6:	2b02      	cmp	r3, #2
   881a8:	d905      	bls.n	881b6 <TC_Configure+0x1e>
   881aa:	4b0d      	ldr	r3, [pc, #52]	; (881e0 <TC_Configure+0x48>)
   881ac:	4a0d      	ldr	r2, [pc, #52]	; (881e4 <TC_Configure+0x4c>)
   881ae:	2140      	movs	r1, #64	; 0x40
   881b0:	480d      	ldr	r0, [pc, #52]	; (881e8 <TC_Configure+0x50>)
   881b2:	4c0e      	ldr	r4, [pc, #56]	; (881ec <TC_Configure+0x54>)
   881b4:	47a0      	blx	r4
    pTcCh = pTc->TC_CHANNEL+dwChannel ;
   881b6:	68fa      	ldr	r2, [r7, #12]
   881b8:	68bb      	ldr	r3, [r7, #8]
   881ba:	019b      	lsls	r3, r3, #6
   881bc:	4413      	add	r3, r2
   881be:	617b      	str	r3, [r7, #20]

    /*  Disable TC clock */
    pTcCh->TC_CCR = TC_CCR_CLKDIS ;
   881c0:	697b      	ldr	r3, [r7, #20]
   881c2:	2202      	movs	r2, #2
   881c4:	601a      	str	r2, [r3, #0]

    /*  Disable interrupts */
    pTcCh->TC_IDR = 0xFFFFFFFF ;
   881c6:	697b      	ldr	r3, [r7, #20]
   881c8:	f04f 32ff 	mov.w	r2, #4294967295
   881cc:	629a      	str	r2, [r3, #40]	; 0x28

    /*  Clear status register */
    pTcCh->TC_SR ;
   881ce:	697b      	ldr	r3, [r7, #20]
   881d0:	6a1b      	ldr	r3, [r3, #32]

    /*  Set mode */
    pTcCh->TC_CMR = dwMode ;
   881d2:	697b      	ldr	r3, [r7, #20]
   881d4:	687a      	ldr	r2, [r7, #4]
   881d6:	605a      	str	r2, [r3, #4]
}
   881d8:	bf00      	nop
   881da:	371c      	adds	r7, #28
   881dc:	46bd      	mov	sp, r7
   881de:	bd90      	pop	{r4, r7, pc}
   881e0:	0009aca0 	.word	0x0009aca0
   881e4:	0009ad0c 	.word	0x0009ad0c
   881e8:	0009ace8 	.word	0x0009ace8
   881ec:	00093441 	.word	0x00093441

000881f0 <TC_Start>:
 *
 * \param pTc  Pointer to a Tc instance.
 * \param dwChannel Channel number.
 */
extern void TC_Start( Tc *pTc, uint32_t dwChannel )
{
   881f0:	b590      	push	{r4, r7, lr}
   881f2:	b085      	sub	sp, #20
   881f4:	af00      	add	r7, sp, #0
   881f6:	6078      	str	r0, [r7, #4]
   881f8:	6039      	str	r1, [r7, #0]
    TcChannel* pTcCh ;

    assert( dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] )) ) ;
   881fa:	683b      	ldr	r3, [r7, #0]
   881fc:	2b02      	cmp	r3, #2
   881fe:	d905      	bls.n	8820c <TC_Start+0x1c>
   88200:	4b08      	ldr	r3, [pc, #32]	; (88224 <TC_Start+0x34>)
   88202:	4a09      	ldr	r2, [pc, #36]	; (88228 <TC_Start+0x38>)
   88204:	215c      	movs	r1, #92	; 0x5c
   88206:	4809      	ldr	r0, [pc, #36]	; (8822c <TC_Start+0x3c>)
   88208:	4c09      	ldr	r4, [pc, #36]	; (88230 <TC_Start+0x40>)
   8820a:	47a0      	blx	r4

    pTcCh = pTc->TC_CHANNEL+dwChannel ;
   8820c:	687a      	ldr	r2, [r7, #4]
   8820e:	683b      	ldr	r3, [r7, #0]
   88210:	019b      	lsls	r3, r3, #6
   88212:	4413      	add	r3, r2
   88214:	60fb      	str	r3, [r7, #12]
    pTcCh->TC_CCR = TC_CCR_CLKEN | TC_CCR_SWTRG ;
   88216:	68fb      	ldr	r3, [r7, #12]
   88218:	2205      	movs	r2, #5
   8821a:	601a      	str	r2, [r3, #0]
}
   8821c:	bf00      	nop
   8821e:	3714      	adds	r7, #20
   88220:	46bd      	mov	sp, r7
   88222:	bd90      	pop	{r4, r7, pc}
   88224:	0009aca0 	.word	0x0009aca0
   88228:	0009ad1c 	.word	0x0009ad1c
   8822c:	0009ace8 	.word	0x0009ace8
   88230:	00093441 	.word	0x00093441

00088234 <TC_GetStatus>:
 * \param ul_channel Channel to configure.
 *
 * \return The current TC status.
 */
uint32_t TC_GetStatus(Tc *p_tc, uint32_t ul_channel)
{
   88234:	b480      	push	{r7}
   88236:	b085      	sub	sp, #20
   88238:	af00      	add	r7, sp, #0
   8823a:	6078      	str	r0, [r7, #4]
   8823c:	6039      	str	r1, [r7, #0]
	TcChannel *tc_channel;

	tc_channel = p_tc->TC_CHANNEL + ul_channel;
   8823e:	687a      	ldr	r2, [r7, #4]
   88240:	683b      	ldr	r3, [r7, #0]
   88242:	019b      	lsls	r3, r3, #6
   88244:	4413      	add	r3, r2
   88246:	60fb      	str	r3, [r7, #12]
	return tc_channel->TC_SR;
   88248:	68fb      	ldr	r3, [r7, #12]
   8824a:	6a1b      	ldr	r3, [r3, #32]
}
   8824c:	4618      	mov	r0, r3
   8824e:	3714      	adds	r7, #20
   88250:	46bd      	mov	sp, r7
   88252:	bc80      	pop	{r7}
   88254:	4770      	bx	lr
   88256:	bf00      	nop

00088258 <TC_SetRC>:
 *
 * \param tc Pointer to a TC instance.
 * \param chan Channel to configure.
 * \param v New value for RC.
 */
void TC_SetRC(Tc *tc, uint32_t chan, uint32_t v) {
   88258:	b480      	push	{r7}
   8825a:	b085      	sub	sp, #20
   8825c:	af00      	add	r7, sp, #0
   8825e:	60f8      	str	r0, [r7, #12]
   88260:	60b9      	str	r1, [r7, #8]
   88262:	607a      	str	r2, [r7, #4]
	tc->TC_CHANNEL[chan].TC_RC = v;
   88264:	68fa      	ldr	r2, [r7, #12]
   88266:	68bb      	ldr	r3, [r7, #8]
   88268:	019b      	lsls	r3, r3, #6
   8826a:	4413      	add	r3, r2
   8826c:	331c      	adds	r3, #28
   8826e:	687a      	ldr	r2, [r7, #4]
   88270:	601a      	str	r2, [r3, #0]
}
   88272:	bf00      	nop
   88274:	3714      	adds	r7, #20
   88276:	46bd      	mov	sp, r7
   88278:	bc80      	pop	{r7}
   8827a:	4770      	bx	lr

0008827c <TimeTick_Increment>:

/**
 *  \brief Handler for Sytem Tick interrupt.
 */
extern void TimeTick_Increment( void )
{
   8827c:	b480      	push	{r7}
   8827e:	af00      	add	r7, sp, #0
    _dwTickCount++ ;
   88280:	4b04      	ldr	r3, [pc, #16]	; (88294 <TimeTick_Increment+0x18>)
   88282:	681b      	ldr	r3, [r3, #0]
   88284:	3301      	adds	r3, #1
   88286:	4a03      	ldr	r2, [pc, #12]	; (88294 <TimeTick_Increment+0x18>)
   88288:	6013      	str	r3, [r2, #0]
}
   8828a:	bf00      	nop
   8828c:	46bd      	mov	sp, r7
   8828e:	bc80      	pop	{r7}
   88290:	4770      	bx	lr
   88292:	bf00      	nop
   88294:	20071628 	.word	0x20071628

00088298 <GetTickCount>:

/**
 *  \brief Get current Tick Count, in ms.
 */
extern uint32_t GetTickCount( void )
{
   88298:	b480      	push	{r7}
   8829a:	af00      	add	r7, sp, #0
    return _dwTickCount ;
   8829c:	4b02      	ldr	r3, [pc, #8]	; (882a8 <GetTickCount+0x10>)
   8829e:	681b      	ldr	r3, [r3, #0]
}
   882a0:	4618      	mov	r0, r3
   882a2:	46bd      	mov	sp, r7
   882a4:	bc80      	pop	{r7}
   882a6:	4770      	bx	lr
   882a8:	20071628 	.word	0x20071628

000882ac <NVIC_EnableIRQ>:
    The interrupt number cannot be a negative value.

    \param [in]      IRQn  Number of the external interrupt to enable
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   882ac:	b480      	push	{r7}
   882ae:	b083      	sub	sp, #12
   882b0:	af00      	add	r7, sp, #0
   882b2:	4603      	mov	r3, r0
   882b4:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   882b6:	4908      	ldr	r1, [pc, #32]	; (882d8 <NVIC_EnableIRQ+0x2c>)
   882b8:	f997 3007 	ldrsb.w	r3, [r7, #7]
   882bc:	095b      	lsrs	r3, r3, #5
   882be:	79fa      	ldrb	r2, [r7, #7]
   882c0:	f002 021f 	and.w	r2, r2, #31
   882c4:	2001      	movs	r0, #1
   882c6:	fa00 f202 	lsl.w	r2, r0, r2
   882ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   882ce:	bf00      	nop
   882d0:	370c      	adds	r7, #12
   882d2:	46bd      	mov	sp, r7
   882d4:	bc80      	pop	{r7}
   882d6:	4770      	bx	lr
   882d8:	e000e100 	.word	0xe000e100

000882dc <NVIC_SetPriority>:

    \param [in]      IRQn  Number of the interrupt for set priority
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   882dc:	b480      	push	{r7}
   882de:	b083      	sub	sp, #12
   882e0:	af00      	add	r7, sp, #0
   882e2:	4603      	mov	r3, r0
   882e4:	6039      	str	r1, [r7, #0]
   882e6:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
   882e8:	f997 3007 	ldrsb.w	r3, [r7, #7]
   882ec:	2b00      	cmp	r3, #0
   882ee:	da0b      	bge.n	88308 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
   882f0:	490d      	ldr	r1, [pc, #52]	; (88328 <NVIC_SetPriority+0x4c>)
   882f2:	79fb      	ldrb	r3, [r7, #7]
   882f4:	f003 030f 	and.w	r3, r3, #15
   882f8:	3b04      	subs	r3, #4
   882fa:	683a      	ldr	r2, [r7, #0]
   882fc:	b2d2      	uxtb	r2, r2
   882fe:	0112      	lsls	r2, r2, #4
   88300:	b2d2      	uxtb	r2, r2
   88302:	440b      	add	r3, r1
   88304:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
}
   88306:	e009      	b.n	8831c <NVIC_SetPriority+0x40>
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   88308:	4908      	ldr	r1, [pc, #32]	; (8832c <NVIC_SetPriority+0x50>)
   8830a:	f997 3007 	ldrsb.w	r3, [r7, #7]
   8830e:	683a      	ldr	r2, [r7, #0]
   88310:	b2d2      	uxtb	r2, r2
   88312:	0112      	lsls	r2, r2, #4
   88314:	b2d2      	uxtb	r2, r2
   88316:	440b      	add	r3, r1
   88318:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   8831c:	bf00      	nop
   8831e:	370c      	adds	r7, #12
   88320:	46bd      	mov	sp, r7
   88322:	bc80      	pop	{r7}
   88324:	4770      	bx	lr
   88326:	bf00      	nop
   88328:	e000ed00 	.word	0xe000ed00
   8832c:	e000e100 	.word	0xe000e100

00088330 <cpu_irq_save>:

typedef uint32_t irqflags_t;
extern int g_interrupt_enabled;

static inline irqflags_t cpu_irq_save(void)
{
   88330:	b480      	push	{r7}
   88332:	b083      	sub	sp, #12
   88334:	af00      	add	r7, sp, #0
	irqflags_t flags = g_interrupt_enabled;
   88336:	4b07      	ldr	r3, [pc, #28]	; (88354 <cpu_irq_save+0x24>)
   88338:	681b      	ldr	r3, [r3, #0]
   8833a:	607b      	str	r3, [r7, #4]
   8833c:	b672      	cpsid	i
   8833e:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   88342:	4b04      	ldr	r3, [pc, #16]	; (88354 <cpu_irq_save+0x24>)
   88344:	2200      	movs	r2, #0
   88346:	601a      	str	r2, [r3, #0]
	return flags;
   88348:	687b      	ldr	r3, [r7, #4]
}
   8834a:	4618      	mov	r0, r3
   8834c:	370c      	adds	r7, #12
   8834e:	46bd      	mov	sp, r7
   88350:	bc80      	pop	{r7}
   88352:	4770      	bx	lr
   88354:	20070104 	.word	0x20070104

00088358 <cpu_irq_is_enabled_flags>:

static inline int cpu_irq_is_enabled_flags(irqflags_t flags)
{
   88358:	b480      	push	{r7}
   8835a:	b083      	sub	sp, #12
   8835c:	af00      	add	r7, sp, #0
   8835e:	6078      	str	r0, [r7, #4]
	return (flags);
   88360:	687b      	ldr	r3, [r7, #4]
}
   88362:	4618      	mov	r0, r3
   88364:	370c      	adds	r7, #12
   88366:	46bd      	mov	sp, r7
   88368:	bc80      	pop	{r7}
   8836a:	4770      	bx	lr

0008836c <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
   8836c:	b580      	push	{r7, lr}
   8836e:	b082      	sub	sp, #8
   88370:	af00      	add	r7, sp, #0
   88372:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
   88374:	6878      	ldr	r0, [r7, #4]
   88376:	4b07      	ldr	r3, [pc, #28]	; (88394 <cpu_irq_restore+0x28>)
   88378:	4798      	blx	r3
   8837a:	4603      	mov	r3, r0
   8837c:	2b00      	cmp	r3, #0
   8837e:	d005      	beq.n	8838c <cpu_irq_restore+0x20>
		cpu_irq_enable();
   88380:	4b05      	ldr	r3, [pc, #20]	; (88398 <cpu_irq_restore+0x2c>)
   88382:	2201      	movs	r2, #1
   88384:	601a      	str	r2, [r3, #0]
   88386:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
   8838a:	b662      	cpsie	i
}
   8838c:	bf00      	nop
   8838e:	3708      	adds	r7, #8
   88390:	46bd      	mov	sp, r7
   88392:	bd80      	pop	{r7, pc}
   88394:	00088359 	.word	0x00088359
   88398:	20070104 	.word	0x20070104

0008839c <UDD_SetStack>:

static volatile uint32_t ul_send_fifo_ptr[MAX_ENDPOINTS];
static volatile uint32_t ul_recv_fifo_ptr[MAX_ENDPOINTS];

void UDD_SetStack(void (*pf_isr)(void))
{
   8839c:	b480      	push	{r7}
   8839e:	b083      	sub	sp, #12
   883a0:	af00      	add	r7, sp, #0
   883a2:	6078      	str	r0, [r7, #4]
	gpf_isr = pf_isr;
   883a4:	4a03      	ldr	r2, [pc, #12]	; (883b4 <UDD_SetStack+0x18>)
   883a6:	687b      	ldr	r3, [r7, #4]
   883a8:	6013      	str	r3, [r2, #0]
}
   883aa:	bf00      	nop
   883ac:	370c      	adds	r7, #12
   883ae:	46bd      	mov	sp, r7
   883b0:	bc80      	pop	{r7}
   883b2:	4770      	bx	lr
   883b4:	20071cbc 	.word	0x20071cbc

000883b8 <UDD_Init>:

uint32_t UDD_Init(void)
{
   883b8:	b580      	push	{r7, lr}
   883ba:	b082      	sub	sp, #8
   883bc:	af00      	add	r7, sp, #0
	uint32_t i;

	for (i = 0; i < MAX_ENDPOINTS; ++i)
   883be:	2300      	movs	r3, #0
   883c0:	607b      	str	r3, [r7, #4]
   883c2:	e00c      	b.n	883de <UDD_Init+0x26>
	{
		ul_send_fifo_ptr[i] = 0;
   883c4:	4a38      	ldr	r2, [pc, #224]	; (884a8 <UDD_Init+0xf0>)
   883c6:	687b      	ldr	r3, [r7, #4]
   883c8:	2100      	movs	r1, #0
   883ca:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		ul_recv_fifo_ptr[i] = 0;
   883ce:	4a37      	ldr	r2, [pc, #220]	; (884ac <UDD_Init+0xf4>)
   883d0:	687b      	ldr	r3, [r7, #4]
   883d2:	2100      	movs	r1, #0
   883d4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

uint32_t UDD_Init(void)
{
	uint32_t i;

	for (i = 0; i < MAX_ENDPOINTS; ++i)
   883d8:	687b      	ldr	r3, [r7, #4]
   883da:	3301      	adds	r3, #1
   883dc:	607b      	str	r3, [r7, #4]
   883de:	687b      	ldr	r3, [r7, #4]
   883e0:	2b09      	cmp	r3, #9
   883e2:	d9ef      	bls.n	883c4 <UDD_Init+0xc>
		ul_send_fifo_ptr[i] = 0;
		ul_recv_fifo_ptr[i] = 0;
	}

	// Enables the USB Clock
	pmc_enable_periph_clk(ID_UOTGHS);
   883e4:	2028      	movs	r0, #40	; 0x28
   883e6:	4b32      	ldr	r3, [pc, #200]	; (884b0 <UDD_Init+0xf8>)
   883e8:	4798      	blx	r3
	pmc_enable_upll_clock();
   883ea:	4b32      	ldr	r3, [pc, #200]	; (884b4 <UDD_Init+0xfc>)
   883ec:	4798      	blx	r3
	pmc_switch_udpck_to_upllck(0); // div=0+1
   883ee:	2000      	movs	r0, #0
   883f0:	4b31      	ldr	r3, [pc, #196]	; (884b8 <UDD_Init+0x100>)
   883f2:	4798      	blx	r3
	pmc_enable_udpck();
   883f4:	4b31      	ldr	r3, [pc, #196]	; (884bc <UDD_Init+0x104>)
   883f6:	4798      	blx	r3

	// Configure interrupts
	NVIC_SetPriority((IRQn_Type) ID_UOTGHS, 0UL);
   883f8:	2100      	movs	r1, #0
   883fa:	2028      	movs	r0, #40	; 0x28
   883fc:	4b30      	ldr	r3, [pc, #192]	; (884c0 <UDD_Init+0x108>)
   883fe:	4798      	blx	r3
	NVIC_EnableIRQ((IRQn_Type) ID_UOTGHS);
   88400:	2028      	movs	r0, #40	; 0x28
   88402:	4b30      	ldr	r3, [pc, #192]	; (884c4 <UDD_Init+0x10c>)
   88404:	4798      	blx	r3
	// Always authorize asynchrone USB interrupts to exit from sleep mode
	//   for SAM3 USB wake up device except BACKUP mode
	//pmc_set_fast_startup_input(PMC_FSMR_USBAL);

	// ID pin not used then force device mode
	otg_disable_id_pin();
   88406:	4a30      	ldr	r2, [pc, #192]	; (884c8 <UDD_Init+0x110>)
   88408:	4b2f      	ldr	r3, [pc, #188]	; (884c8 <UDD_Init+0x110>)
   8840a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
   8840e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   88412:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
	otg_force_device_mode();
   88416:	4a2c      	ldr	r2, [pc, #176]	; (884c8 <UDD_Init+0x110>)
   88418:	4b2b      	ldr	r3, [pc, #172]	; (884c8 <UDD_Init+0x110>)
   8841a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
   8841e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   88422:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
   88426:	4a28      	ldr	r2, [pc, #160]	; (884c8 <UDD_Init+0x110>)
   88428:	4b27      	ldr	r3, [pc, #156]	; (884c8 <UDD_Init+0x110>)
   8842a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
   8842e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   88432:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800

	// Enable USB hardware
	otg_disable_pad();
   88436:	4a24      	ldr	r2, [pc, #144]	; (884c8 <UDD_Init+0x110>)
   88438:	4b23      	ldr	r3, [pc, #140]	; (884c8 <UDD_Init+0x110>)
   8843a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
   8843e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   88442:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
	otg_enable_pad();
   88446:	4a20      	ldr	r2, [pc, #128]	; (884c8 <UDD_Init+0x110>)
   88448:	4b1f      	ldr	r3, [pc, #124]	; (884c8 <UDD_Init+0x110>)
   8844a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
   8844e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   88452:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
	otg_enable();
   88456:	4a1c      	ldr	r2, [pc, #112]	; (884c8 <UDD_Init+0x110>)
   88458:	4b1b      	ldr	r3, [pc, #108]	; (884c8 <UDD_Init+0x110>)
   8845a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
   8845e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   88462:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
	otg_unfreeze_clock();
   88466:	4a18      	ldr	r2, [pc, #96]	; (884c8 <UDD_Init+0x110>)
   88468:	4b17      	ldr	r3, [pc, #92]	; (884c8 <UDD_Init+0x110>)
   8846a:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
   8846e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
   88472:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
	// Check USB clock
	//while (!Is_otg_clock_usable())
	//	;

	// Enable High Speed
	udd_low_speed_disable();
   88476:	4a14      	ldr	r2, [pc, #80]	; (884c8 <UDD_Init+0x110>)
   88478:	4b13      	ldr	r3, [pc, #76]	; (884c8 <UDD_Init+0x110>)
   8847a:	681b      	ldr	r3, [r3, #0]
   8847c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   88480:	6013      	str	r3, [r2, #0]
	udd_high_speed_enable();
   88482:	4a11      	ldr	r2, [pc, #68]	; (884c8 <UDD_Init+0x110>)
   88484:	4b10      	ldr	r3, [pc, #64]	; (884c8 <UDD_Init+0x110>)
   88486:	681b      	ldr	r3, [r3, #0]
   88488:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
   8848c:	6013      	str	r3, [r2, #0]
	// This is possible with a short timing between a Host mode stop/start.
	/*if (Is_otg_vbus_high()) {
		otg_raise_vbus_transition();
	}
	otg_enable_vbus_interrupt();*/
	otg_freeze_clock();
   8848e:	4a0e      	ldr	r2, [pc, #56]	; (884c8 <UDD_Init+0x110>)
   88490:	4b0d      	ldr	r3, [pc, #52]	; (884c8 <UDD_Init+0x110>)
   88492:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
   88496:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   8849a:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800

	return 0UL ;
   8849e:	2300      	movs	r3, #0
}
   884a0:	4618      	mov	r0, r3
   884a2:	3708      	adds	r7, #8
   884a4:	46bd      	mov	sp, r7
   884a6:	bd80      	pop	{r7, pc}
   884a8:	2007162c 	.word	0x2007162c
   884ac:	20071654 	.word	0x20071654
   884b0:	00088021 	.word	0x00088021
   884b4:	00087ff9 	.word	0x00087ff9
   884b8:	00088121 	.word	0x00088121
   884bc:	00088149 	.word	0x00088149
   884c0:	000882dd 	.word	0x000882dd
   884c4:	000882ad 	.word	0x000882ad
   884c8:	400ac000 	.word	0x400ac000

000884cc <UDD_Attach>:

void UDD_Attach(void)
{
   884cc:	b580      	push	{r7, lr}
   884ce:	b082      	sub	sp, #8
   884d0:	af00      	add	r7, sp, #0
	irqflags_t flags = cpu_irq_save();
   884d2:	4b11      	ldr	r3, [pc, #68]	; (88518 <UDD_Attach+0x4c>)
   884d4:	4798      	blx	r3
   884d6:	6078      	str	r0, [r7, #4]

	TRACE_UOTGHS_DEVICE(printf("=> UDD_Attach\r\n");)

	otg_unfreeze_clock();
   884d8:	4a10      	ldr	r2, [pc, #64]	; (8851c <UDD_Attach+0x50>)
   884da:	4b10      	ldr	r3, [pc, #64]	; (8851c <UDD_Attach+0x50>)
   884dc:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
   884e0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
   884e4:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800

	// Check USB clock because the source can be a PLL
	while (!Is_otg_clock_usable());
   884e8:	bf00      	nop
   884ea:	4b0c      	ldr	r3, [pc, #48]	; (8851c <UDD_Attach+0x50>)
   884ec:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   884f0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   884f4:	2b00      	cmp	r3, #0
   884f6:	d0f8      	beq.n	884ea <UDD_Attach+0x1e>

	// Authorize attach if Vbus is present
	udd_attach_device();
   884f8:	4a08      	ldr	r2, [pc, #32]	; (8851c <UDD_Attach+0x50>)
   884fa:	4b08      	ldr	r3, [pc, #32]	; (8851c <UDD_Attach+0x50>)
   884fc:	681b      	ldr	r3, [r3, #0]
   884fe:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   88502:	6013      	str	r3, [r2, #0]

	// Enable USB line events
	udd_enable_reset_interrupt();
   88504:	4b05      	ldr	r3, [pc, #20]	; (8851c <UDD_Attach+0x50>)
   88506:	2208      	movs	r2, #8
   88508:	619a      	str	r2, [r3, #24]
//	udd_enable_sof_interrupt();

	cpu_irq_restore(flags);
   8850a:	6878      	ldr	r0, [r7, #4]
   8850c:	4b04      	ldr	r3, [pc, #16]	; (88520 <UDD_Attach+0x54>)
   8850e:	4798      	blx	r3
}
   88510:	bf00      	nop
   88512:	3708      	adds	r7, #8
   88514:	46bd      	mov	sp, r7
   88516:	bd80      	pop	{r7, pc}
   88518:	00088331 	.word	0x00088331
   8851c:	400ac000 	.word	0x400ac000
   88520:	0008836d 	.word	0x0008836d

00088524 <UDD_InitEP>:
	TRACE_UOTGHS_DEVICE(printf("=> UDD_Detach\r\n");)
	UOTGHS->UOTGHS_DEVCTRL |= UOTGHS_DEVCTRL_DETACH;
}

void UDD_InitEP( uint32_t ul_ep_nb, uint32_t ul_ep_cfg )
{
   88524:	b480      	push	{r7}
   88526:	b083      	sub	sp, #12
   88528:	af00      	add	r7, sp, #0
   8852a:	6078      	str	r0, [r7, #4]
   8852c:	6039      	str	r1, [r7, #0]
	ul_ep_nb = ul_ep_nb & 0xF; // EP range is 0..9, hence mask is 0xF.
   8852e:	687b      	ldr	r3, [r7, #4]
   88530:	f003 030f 	and.w	r3, r3, #15
   88534:	607b      	str	r3, [r7, #4]

	TRACE_UOTGHS_DEVICE(printf("=> UDD_InitEP : init EP %lu\r\n", ul_ep_nb);)

	// Configure EP
	UOTGHS->UOTGHS_DEVEPTCFG[ul_ep_nb] = ul_ep_cfg;
   88536:	490f      	ldr	r1, [pc, #60]	; (88574 <UDD_InitEP+0x50>)
   88538:	687b      	ldr	r3, [r7, #4]
   8853a:	3340      	adds	r3, #64	; 0x40
   8853c:	683a      	ldr	r2, [r7, #0]
   8853e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	// Enable EP
	udd_enable_endpoint(ul_ep_nb);
   88542:	490c      	ldr	r1, [pc, #48]	; (88574 <UDD_InitEP+0x50>)
   88544:	4b0b      	ldr	r3, [pc, #44]	; (88574 <UDD_InitEP+0x50>)
   88546:	69da      	ldr	r2, [r3, #28]
   88548:	2001      	movs	r0, #1
   8854a:	687b      	ldr	r3, [r7, #4]
   8854c:	fa00 f303 	lsl.w	r3, r0, r3
   88550:	4313      	orrs	r3, r2
   88552:	61cb      	str	r3, [r1, #28]

	if (!Is_udd_endpoint_configured(ul_ep_nb)) {
   88554:	687b      	ldr	r3, [r7, #4]
   88556:	009a      	lsls	r2, r3, #2
   88558:	4b07      	ldr	r3, [pc, #28]	; (88578 <UDD_InitEP+0x54>)
   8855a:	4413      	add	r3, r2
   8855c:	681b      	ldr	r3, [r3, #0]
   8855e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
   88562:	2b00      	cmp	r3, #0
   88564:	d100      	bne.n	88568 <UDD_InitEP+0x44>
		TRACE_UOTGHS_DEVICE(printf("=> UDD_InitEP : ERROR FAILED TO INIT EP %lu\r\n", ul_ep_nb);)
		while(1);
   88566:	e7fe      	b.n	88566 <UDD_InitEP+0x42>
	}
}
   88568:	bf00      	nop
   8856a:	370c      	adds	r7, #12
   8856c:	46bd      	mov	sp, r7
   8856e:	bc80      	pop	{r7}
   88570:	4770      	bx	lr
   88572:	bf00      	nop
   88574:	400ac000 	.word	0x400ac000
   88578:	400ac130 	.word	0x400ac130

0008857c <UDD_InitEndpoints>:


void UDD_InitEndpoints(const uint32_t* eps_table, const uint32_t ul_eps_table_size)
{
   8857c:	b480      	push	{r7}
   8857e:	b085      	sub	sp, #20
   88580:	af00      	add	r7, sp, #0
   88582:	6078      	str	r0, [r7, #4]
   88584:	6039      	str	r1, [r7, #0]
	uint32_t ul_ep_nb ;

	for (ul_ep_nb = 1; ul_ep_nb < ul_eps_table_size; ul_ep_nb++)
   88586:	2301      	movs	r3, #1
   88588:	60fb      	str	r3, [r7, #12]
   8858a:	e01f      	b.n	885cc <UDD_InitEndpoints+0x50>
	{
		// Configure EP
		UOTGHS->UOTGHS_DEVEPTCFG[ul_ep_nb] = eps_table[ul_ep_nb];
   8858c:	4914      	ldr	r1, [pc, #80]	; (885e0 <UDD_InitEndpoints+0x64>)
   8858e:	68fb      	ldr	r3, [r7, #12]
   88590:	009b      	lsls	r3, r3, #2
   88592:	687a      	ldr	r2, [r7, #4]
   88594:	4413      	add	r3, r2
   88596:	681a      	ldr	r2, [r3, #0]
   88598:	68fb      	ldr	r3, [r7, #12]
   8859a:	3340      	adds	r3, #64	; 0x40
   8859c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		// Enable EP
		udd_enable_endpoint(ul_ep_nb);
   885a0:	490f      	ldr	r1, [pc, #60]	; (885e0 <UDD_InitEndpoints+0x64>)
   885a2:	4b0f      	ldr	r3, [pc, #60]	; (885e0 <UDD_InitEndpoints+0x64>)
   885a4:	69da      	ldr	r2, [r3, #28]
   885a6:	2001      	movs	r0, #1
   885a8:	68fb      	ldr	r3, [r7, #12]
   885aa:	fa00 f303 	lsl.w	r3, r0, r3
   885ae:	4313      	orrs	r3, r2
   885b0:	61cb      	str	r3, [r1, #28]

		if (!Is_udd_endpoint_configured(ul_ep_nb)) {
   885b2:	68fb      	ldr	r3, [r7, #12]
   885b4:	009a      	lsls	r2, r3, #2
   885b6:	4b0b      	ldr	r3, [pc, #44]	; (885e4 <UDD_InitEndpoints+0x68>)
   885b8:	4413      	add	r3, r2
   885ba:	681b      	ldr	r3, [r3, #0]
   885bc:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
   885c0:	2b00      	cmp	r3, #0
   885c2:	d100      	bne.n	885c6 <UDD_InitEndpoints+0x4a>
			TRACE_UOTGHS_DEVICE(printf("=> UDD_InitEP : ERROR FAILED TO INIT EP %lu\r\n", ul_ep_nb);)
			while(1);
   885c4:	e7fe      	b.n	885c4 <UDD_InitEndpoints+0x48>

void UDD_InitEndpoints(const uint32_t* eps_table, const uint32_t ul_eps_table_size)
{
	uint32_t ul_ep_nb ;

	for (ul_ep_nb = 1; ul_ep_nb < ul_eps_table_size; ul_ep_nb++)
   885c6:	68fb      	ldr	r3, [r7, #12]
   885c8:	3301      	adds	r3, #1
   885ca:	60fb      	str	r3, [r7, #12]
   885cc:	68fa      	ldr	r2, [r7, #12]
   885ce:	683b      	ldr	r3, [r7, #0]
   885d0:	429a      	cmp	r2, r3
   885d2:	d3db      	bcc.n	8858c <UDD_InitEndpoints+0x10>
		if (!Is_udd_endpoint_configured(ul_ep_nb)) {
			TRACE_UOTGHS_DEVICE(printf("=> UDD_InitEP : ERROR FAILED TO INIT EP %lu\r\n", ul_ep_nb);)
			while(1);
		}
	}
}
   885d4:	bf00      	nop
   885d6:	3714      	adds	r7, #20
   885d8:	46bd      	mov	sp, r7
   885da:	bc80      	pop	{r7}
   885dc:	4770      	bx	lr
   885de:	bf00      	nop
   885e0:	400ac000 	.word	0x400ac000
   885e4:	400ac130 	.word	0x400ac130

000885e8 <UDD_WaitIN>:

// Wait until ready to accept IN packet.
void UDD_WaitIN(void)
{
   885e8:	b480      	push	{r7}
   885ea:	af00      	add	r7, sp, #0
	while (!(UOTGHS->UOTGHS_DEVEPTISR[EP0] & UOTGHS_DEVEPTISR_TXINI))
   885ec:	bf00      	nop
   885ee:	4b05      	ldr	r3, [pc, #20]	; (88604 <UDD_WaitIN+0x1c>)
   885f0:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   885f4:	f003 0301 	and.w	r3, r3, #1
   885f8:	2b00      	cmp	r3, #0
   885fa:	d0f8      	beq.n	885ee <UDD_WaitIN+0x6>
		;
}
   885fc:	bf00      	nop
   885fe:	46bd      	mov	sp, r7
   88600:	bc80      	pop	{r7}
   88602:	4770      	bx	lr
   88604:	400ac000 	.word	0x400ac000

00088608 <UDD_WaitOUT>:

void UDD_WaitOUT(void)
{
   88608:	b480      	push	{r7}
   8860a:	af00      	add	r7, sp, #0
	while (!(UOTGHS->UOTGHS_DEVEPTISR[EP0] & UOTGHS_DEVEPTISR_RXOUTI))
   8860c:	bf00      	nop
   8860e:	4b05      	ldr	r3, [pc, #20]	; (88624 <UDD_WaitOUT+0x1c>)
   88610:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   88614:	f003 0302 	and.w	r3, r3, #2
   88618:	2b00      	cmp	r3, #0
   8861a:	d0f8      	beq.n	8860e <UDD_WaitOUT+0x6>
		;
}
   8861c:	bf00      	nop
   8861e:	46bd      	mov	sp, r7
   88620:	bc80      	pop	{r7}
   88622:	4770      	bx	lr
   88624:	400ac000 	.word	0x400ac000

00088628 <UDD_ClearIN>:

// Send packet.
void UDD_ClearIN(void)
{
   88628:	b480      	push	{r7}
   8862a:	af00      	add	r7, sp, #0
	TRACE_UOTGHS_DEVICE(printf("=> UDD_ClearIN: sent %lu bytes\r\n", ul_send_fifo_ptr[EP0]);)

	UOTGHS->UOTGHS_DEVEPTICR[EP0] = UOTGHS_DEVEPTICR_TXINIC;
   8862c:	4b05      	ldr	r3, [pc, #20]	; (88644 <UDD_ClearIN+0x1c>)
   8862e:	2201      	movs	r2, #1
   88630:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
	ul_send_fifo_ptr[EP0] = 0;
   88634:	4b04      	ldr	r3, [pc, #16]	; (88648 <UDD_ClearIN+0x20>)
   88636:	2200      	movs	r2, #0
   88638:	601a      	str	r2, [r3, #0]
}
   8863a:	bf00      	nop
   8863c:	46bd      	mov	sp, r7
   8863e:	bc80      	pop	{r7}
   88640:	4770      	bx	lr
   88642:	bf00      	nop
   88644:	400ac000 	.word	0x400ac000
   88648:	2007162c 	.word	0x2007162c

0008864c <UDD_ClearOUT>:

void UDD_ClearOUT(void)
{
   8864c:	b480      	push	{r7}
   8864e:	af00      	add	r7, sp, #0
	UOTGHS->UOTGHS_DEVEPTICR[EP0] = UOTGHS_DEVEPTICR_RXOUTIC;
   88650:	4b05      	ldr	r3, [pc, #20]	; (88668 <UDD_ClearOUT+0x1c>)
   88652:	2202      	movs	r2, #2
   88654:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
	ul_recv_fifo_ptr[EP0] = 0;
   88658:	4b04      	ldr	r3, [pc, #16]	; (8866c <UDD_ClearOUT+0x20>)
   8865a:	2200      	movs	r2, #0
   8865c:	601a      	str	r2, [r3, #0]
}
   8865e:	bf00      	nop
   88660:	46bd      	mov	sp, r7
   88662:	bc80      	pop	{r7}
   88664:	4770      	bx	lr
   88666:	bf00      	nop
   88668:	400ac000 	.word	0x400ac000
   8866c:	20071654 	.word	0x20071654

00088670 <UDD_ReceivedSetupInt>:
		;
	return ((UOTGHS->UOTGHS_DEVEPTISR[EP0] & UOTGHS_DEVEPTISR_RXOUTI) == 0);
}

uint32_t UDD_ReceivedSetupInt(void)
{
   88670:	b480      	push	{r7}
   88672:	af00      	add	r7, sp, #0
	return UOTGHS->UOTGHS_DEVEPTISR[EP0] & UOTGHS_DEVEPTISR_RXSTPI;
   88674:	4b04      	ldr	r3, [pc, #16]	; (88688 <UDD_ReceivedSetupInt+0x18>)
   88676:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
   8867a:	f003 0304 	and.w	r3, r3, #4
}
   8867e:	4618      	mov	r0, r3
   88680:	46bd      	mov	sp, r7
   88682:	bc80      	pop	{r7}
   88684:	4770      	bx	lr
   88686:	bf00      	nop
   88688:	400ac000 	.word	0x400ac000

0008868c <UDD_ClearSetupInt>:

void UDD_ClearSetupInt(void)
{
   8868c:	b480      	push	{r7}
   8868e:	af00      	add	r7, sp, #0
	UOTGHS->UOTGHS_DEVEPTICR[EP0] = (UOTGHS_DEVEPTICR_RXSTPIC);
   88690:	4b03      	ldr	r3, [pc, #12]	; (886a0 <UDD_ClearSetupInt+0x14>)
   88692:	2204      	movs	r2, #4
   88694:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
}
   88698:	bf00      	nop
   8869a:	46bd      	mov	sp, r7
   8869c:	bc80      	pop	{r7}
   8869e:	4770      	bx	lr
   886a0:	400ac000 	.word	0x400ac000

000886a4 <UDD_Send>:

uint32_t UDD_Send(uint32_t ep, const void* data, uint32_t len)
{
   886a4:	b580      	push	{r7, lr}
   886a6:	b088      	sub	sp, #32
   886a8:	af00      	add	r7, sp, #0
   886aa:	60f8      	str	r0, [r7, #12]
   886ac:	60b9      	str	r1, [r7, #8]
   886ae:	607a      	str	r2, [r7, #4]
	const uint8_t *ptr_src = data;
   886b0:	68bb      	ldr	r3, [r7, #8]
   886b2:	61fb      	str	r3, [r7, #28]
	uint8_t *ptr_dest = (uint8_t *) &udd_get_endpoint_fifo_access8(ep);
   886b4:	68fb      	ldr	r3, [r7, #12]
   886b6:	03db      	lsls	r3, r3, #15
   886b8:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   886bc:	f503 13c0 	add.w	r3, r3, #1572864	; 0x180000
   886c0:	61bb      	str	r3, [r7, #24]
	uint32_t i;

	TRACE_UOTGHS_DEVICE(printf("=> UDD_Send (1): ep=%lu ul_send_fifo_ptr=%lu len=%lu\r\n", ep, ul_send_fifo_ptr[ep], len);)

	while( UOTGHS_DEVEPTISR_TXINI != (UOTGHS->UOTGHS_DEVEPTISR[ep] & UOTGHS_DEVEPTISR_TXINI )) {}
   886c2:	bf00      	nop
   886c4:	4a30      	ldr	r2, [pc, #192]	; (88788 <UDD_Send+0xe4>)
   886c6:	68fb      	ldr	r3, [r7, #12]
   886c8:	334c      	adds	r3, #76	; 0x4c
   886ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   886ce:	f003 0301 	and.w	r3, r3, #1
   886d2:	2b00      	cmp	r3, #0
   886d4:	d0f6      	beq.n	886c4 <UDD_Send+0x20>

	if (ep == EP0)
   886d6:	68fb      	ldr	r3, [r7, #12]
   886d8:	2b00      	cmp	r3, #0
   886da:	d10f      	bne.n	886fc <UDD_Send+0x58>
	{
		if (ul_send_fifo_ptr[ep] + len > EP0_SIZE)
   886dc:	4a2b      	ldr	r2, [pc, #172]	; (8878c <UDD_Send+0xe8>)
   886de:	68fb      	ldr	r3, [r7, #12]
   886e0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   886e4:	687b      	ldr	r3, [r7, #4]
   886e6:	4413      	add	r3, r2
   886e8:	2b40      	cmp	r3, #64	; 0x40
   886ea:	d90c      	bls.n	88706 <UDD_Send+0x62>
			len = EP0_SIZE - ul_send_fifo_ptr[ep];
   886ec:	4a27      	ldr	r2, [pc, #156]	; (8878c <UDD_Send+0xe8>)
   886ee:	68fb      	ldr	r3, [r7, #12]
   886f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   886f4:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
   886f8:	607b      	str	r3, [r7, #4]
   886fa:	e004      	b.n	88706 <UDD_Send+0x62>
	}
	else
	{
		ul_send_fifo_ptr[ep] = 0;
   886fc:	4a23      	ldr	r2, [pc, #140]	; (8878c <UDD_Send+0xe8>)
   886fe:	68fb      	ldr	r3, [r7, #12]
   88700:	2100      	movs	r1, #0
   88702:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	}
	for (i = 0, ptr_dest += ul_send_fifo_ptr[ep]; i < len; ++i)
   88706:	2300      	movs	r3, #0
   88708:	617b      	str	r3, [r7, #20]
   8870a:	4a20      	ldr	r2, [pc, #128]	; (8878c <UDD_Send+0xe8>)
   8870c:	68fb      	ldr	r3, [r7, #12]
   8870e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   88712:	69ba      	ldr	r2, [r7, #24]
   88714:	4413      	add	r3, r2
   88716:	61bb      	str	r3, [r7, #24]
   88718:	e00a      	b.n	88730 <UDD_Send+0x8c>
		*ptr_dest++ = *ptr_src++;
   8871a:	69bb      	ldr	r3, [r7, #24]
   8871c:	1c5a      	adds	r2, r3, #1
   8871e:	61ba      	str	r2, [r7, #24]
   88720:	69fa      	ldr	r2, [r7, #28]
   88722:	1c51      	adds	r1, r2, #1
   88724:	61f9      	str	r1, [r7, #28]
   88726:	7812      	ldrb	r2, [r2, #0]
   88728:	701a      	strb	r2, [r3, #0]
	}
	else
	{
		ul_send_fifo_ptr[ep] = 0;
	}
	for (i = 0, ptr_dest += ul_send_fifo_ptr[ep]; i < len; ++i)
   8872a:	697b      	ldr	r3, [r7, #20]
   8872c:	3301      	adds	r3, #1
   8872e:	617b      	str	r3, [r7, #20]
   88730:	697a      	ldr	r2, [r7, #20]
   88732:	687b      	ldr	r3, [r7, #4]
   88734:	429a      	cmp	r2, r3
   88736:	d3f0      	bcc.n	8871a <UDD_Send+0x76>
		*ptr_dest++ = *ptr_src++;

	ul_send_fifo_ptr[ep] += i;
   88738:	4a14      	ldr	r2, [pc, #80]	; (8878c <UDD_Send+0xe8>)
   8873a:	68fb      	ldr	r3, [r7, #12]
   8873c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   88740:	697b      	ldr	r3, [r7, #20]
   88742:	441a      	add	r2, r3
   88744:	4911      	ldr	r1, [pc, #68]	; (8878c <UDD_Send+0xe8>)
   88746:	68fb      	ldr	r3, [r7, #12]
   88748:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	if (ep == EP0)
   8874c:	68fb      	ldr	r3, [r7, #12]
   8874e:	2b00      	cmp	r3, #0
   88750:	d108      	bne.n	88764 <UDD_Send+0xc0>
	{
		TRACE_UOTGHS_DEVICE(printf("=> UDD_Send (2): ep=%lu ptr_dest=%lu maxlen=%d\r\n", ep, ul_send_fifo_ptr[ep], EP0_SIZE);)
		if (ul_send_fifo_ptr[ep] == EP0_SIZE)
   88752:	4a0e      	ldr	r2, [pc, #56]	; (8878c <UDD_Send+0xe8>)
   88754:	68fb      	ldr	r3, [r7, #12]
   88756:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   8875a:	2b40      	cmp	r3, #64	; 0x40
   8875c:	d10f      	bne.n	8877e <UDD_Send+0xda>
		{
			UDD_ClearIN();	// Fifo is full, release this packet  // UOTGHS->UOTGHS_DEVEPTICR[EP0] = UOTGHS_DEVEPTICR_TXINIC;
   8875e:	4b0c      	ldr	r3, [pc, #48]	; (88790 <UDD_Send+0xec>)
   88760:	4798      	blx	r3
   88762:	e00c      	b.n	8877e <UDD_Send+0xda>
        }
	}
	else
	{
		UOTGHS->UOTGHS_DEVEPTICR[ep] = UOTGHS_DEVEPTICR_TXINIC;
   88764:	4a08      	ldr	r2, [pc, #32]	; (88788 <UDD_Send+0xe4>)
   88766:	68fb      	ldr	r3, [r7, #12]
   88768:	3358      	adds	r3, #88	; 0x58
   8876a:	2101      	movs	r1, #1
   8876c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		UOTGHS->UOTGHS_DEVEPTIDR[ep] = UOTGHS_DEVEPTIDR_FIFOCONC;
   88770:	4a05      	ldr	r2, [pc, #20]	; (88788 <UDD_Send+0xe4>)
   88772:	68fb      	ldr	r3, [r7, #12]
   88774:	3388      	adds	r3, #136	; 0x88
   88776:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   8877a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	}
	return len;
   8877e:	687b      	ldr	r3, [r7, #4]
}
   88780:	4618      	mov	r0, r3
   88782:	3720      	adds	r7, #32
   88784:	46bd      	mov	sp, r7
   88786:	bd80      	pop	{r7, pc}
   88788:	400ac000 	.word	0x400ac000
   8878c:	2007162c 	.word	0x2007162c
   88790:	00088629 	.word	0x00088629

00088794 <UDD_Send8>:

void UDD_Send8(uint32_t ep,  uint8_t data )
{
   88794:	b480      	push	{r7}
   88796:	b085      	sub	sp, #20
   88798:	af00      	add	r7, sp, #0
   8879a:	6078      	str	r0, [r7, #4]
   8879c:	460b      	mov	r3, r1
   8879e:	70fb      	strb	r3, [r7, #3]
	uint8_t *ptr_dest = (uint8_t *) &udd_get_endpoint_fifo_access8(ep);
   887a0:	687b      	ldr	r3, [r7, #4]
   887a2:	03db      	lsls	r3, r3, #15
   887a4:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   887a8:	f503 13c0 	add.w	r3, r3, #1572864	; 0x180000
   887ac:	60fb      	str	r3, [r7, #12]

	TRACE_UOTGHS_DEVICE(printf("=> UDD_Send8 : ul_send_fifo_ptr=%lu data=0x%x\r\n", ul_send_fifo_ptr[ep], data);)

	ptr_dest[ul_send_fifo_ptr[ep]] = data;
   887ae:	4a0b      	ldr	r2, [pc, #44]	; (887dc <UDD_Send8+0x48>)
   887b0:	687b      	ldr	r3, [r7, #4]
   887b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   887b6:	68fa      	ldr	r2, [r7, #12]
   887b8:	4413      	add	r3, r2
   887ba:	78fa      	ldrb	r2, [r7, #3]
   887bc:	701a      	strb	r2, [r3, #0]
	ul_send_fifo_ptr[ep] += 1;
   887be:	4a07      	ldr	r2, [pc, #28]	; (887dc <UDD_Send8+0x48>)
   887c0:	687b      	ldr	r3, [r7, #4]
   887c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   887c6:	1c5a      	adds	r2, r3, #1
   887c8:	4904      	ldr	r1, [pc, #16]	; (887dc <UDD_Send8+0x48>)
   887ca:	687b      	ldr	r3, [r7, #4]
   887cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   887d0:	bf00      	nop
   887d2:	3714      	adds	r7, #20
   887d4:	46bd      	mov	sp, r7
   887d6:	bc80      	pop	{r7}
   887d8:	4770      	bx	lr
   887da:	bf00      	nop
   887dc:	2007162c 	.word	0x2007162c

000887e0 <UDD_Recv8>:

uint8_t UDD_Recv8(uint32_t ep)
{
   887e0:	b480      	push	{r7}
   887e2:	b085      	sub	sp, #20
   887e4:	af00      	add	r7, sp, #0
   887e6:	6078      	str	r0, [r7, #4]
	uint8_t *ptr_dest = (uint8_t *) &udd_get_endpoint_fifo_access8(ep);
   887e8:	687b      	ldr	r3, [r7, #4]
   887ea:	03db      	lsls	r3, r3, #15
   887ec:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   887f0:	f503 13c0 	add.w	r3, r3, #1572864	; 0x180000
   887f4:	60fb      	str	r3, [r7, #12]
	uint8_t data = ptr_dest[ul_recv_fifo_ptr[ep]];
   887f6:	4a0b      	ldr	r2, [pc, #44]	; (88824 <UDD_Recv8+0x44>)
   887f8:	687b      	ldr	r3, [r7, #4]
   887fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   887fe:	68fa      	ldr	r2, [r7, #12]
   88800:	4413      	add	r3, r2
   88802:	781b      	ldrb	r3, [r3, #0]
   88804:	72fb      	strb	r3, [r7, #11]

	TRACE_UOTGHS_DEVICE(printf("=> UDD_Recv8 : ul_recv_fifo_ptr=%lu\r\n", ul_recv_fifo_ptr[ep]);)

	ul_recv_fifo_ptr[ep] += 1;
   88806:	4a07      	ldr	r2, [pc, #28]	; (88824 <UDD_Recv8+0x44>)
   88808:	687b      	ldr	r3, [r7, #4]
   8880a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   8880e:	1c5a      	adds	r2, r3, #1
   88810:	4904      	ldr	r1, [pc, #16]	; (88824 <UDD_Recv8+0x44>)
   88812:	687b      	ldr	r3, [r7, #4]
   88814:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	return data;
   88818:	7afb      	ldrb	r3, [r7, #11]
}
   8881a:	4618      	mov	r0, r3
   8881c:	3714      	adds	r7, #20
   8881e:	46bd      	mov	sp, r7
   88820:	bc80      	pop	{r7}
   88822:	4770      	bx	lr
   88824:	20071654 	.word	0x20071654

00088828 <UDD_Recv>:

void UDD_Recv(uint32_t ep, uint8_t* data, uint32_t len)
{
   88828:	b480      	push	{r7}
   8882a:	b089      	sub	sp, #36	; 0x24
   8882c:	af00      	add	r7, sp, #0
   8882e:	60f8      	str	r0, [r7, #12]
   88830:	60b9      	str	r1, [r7, #8]
   88832:	607a      	str	r2, [r7, #4]
	uint8_t *ptr_src = (uint8_t *) &udd_get_endpoint_fifo_access8(ep);
   88834:	68fb      	ldr	r3, [r7, #12]
   88836:	03db      	lsls	r3, r3, #15
   88838:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   8883c:	f503 13c0 	add.w	r3, r3, #1572864	; 0x180000
   88840:	61fb      	str	r3, [r7, #28]
	uint8_t *ptr_dest = data;
   88842:	68bb      	ldr	r3, [r7, #8]
   88844:	61bb      	str	r3, [r7, #24]
	uint32_t i;

	for (i = 0, ptr_src += ul_recv_fifo_ptr[ep]; i < len; ++i)
   88846:	2300      	movs	r3, #0
   88848:	617b      	str	r3, [r7, #20]
   8884a:	4a13      	ldr	r2, [pc, #76]	; (88898 <UDD_Recv+0x70>)
   8884c:	68fb      	ldr	r3, [r7, #12]
   8884e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   88852:	69fa      	ldr	r2, [r7, #28]
   88854:	4413      	add	r3, r2
   88856:	61fb      	str	r3, [r7, #28]
   88858:	e00a      	b.n	88870 <UDD_Recv+0x48>
		*ptr_dest++ = *ptr_src++;
   8885a:	69bb      	ldr	r3, [r7, #24]
   8885c:	1c5a      	adds	r2, r3, #1
   8885e:	61ba      	str	r2, [r7, #24]
   88860:	69fa      	ldr	r2, [r7, #28]
   88862:	1c51      	adds	r1, r2, #1
   88864:	61f9      	str	r1, [r7, #28]
   88866:	7812      	ldrb	r2, [r2, #0]
   88868:	701a      	strb	r2, [r3, #0]
{
	uint8_t *ptr_src = (uint8_t *) &udd_get_endpoint_fifo_access8(ep);
	uint8_t *ptr_dest = data;
	uint32_t i;

	for (i = 0, ptr_src += ul_recv_fifo_ptr[ep]; i < len; ++i)
   8886a:	697b      	ldr	r3, [r7, #20]
   8886c:	3301      	adds	r3, #1
   8886e:	617b      	str	r3, [r7, #20]
   88870:	697a      	ldr	r2, [r7, #20]
   88872:	687b      	ldr	r3, [r7, #4]
   88874:	429a      	cmp	r2, r3
   88876:	d3f0      	bcc.n	8885a <UDD_Recv+0x32>
		*ptr_dest++ = *ptr_src++;

	ul_recv_fifo_ptr[ep] += i;
   88878:	4a07      	ldr	r2, [pc, #28]	; (88898 <UDD_Recv+0x70>)
   8887a:	68fb      	ldr	r3, [r7, #12]
   8887c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   88880:	697b      	ldr	r3, [r7, #20]
   88882:	441a      	add	r2, r3
   88884:	4904      	ldr	r1, [pc, #16]	; (88898 <UDD_Recv+0x70>)
   88886:	68fb      	ldr	r3, [r7, #12]
   88888:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   8888c:	bf00      	nop
   8888e:	3724      	adds	r7, #36	; 0x24
   88890:	46bd      	mov	sp, r7
   88892:	bc80      	pop	{r7}
   88894:	4770      	bx	lr
   88896:	bf00      	nop
   88898:	20071654 	.word	0x20071654

0008889c <UDD_Stall>:

void UDD_Stall(void)
{
   8889c:	b480      	push	{r7}
   8889e:	af00      	add	r7, sp, #0
	UOTGHS->UOTGHS_DEVEPT = (UOTGHS_DEVEPT_EPEN0 << EP0);
   888a0:	4b05      	ldr	r3, [pc, #20]	; (888b8 <UDD_Stall+0x1c>)
   888a2:	2201      	movs	r2, #1
   888a4:	61da      	str	r2, [r3, #28]
	UOTGHS->UOTGHS_DEVEPTIER[EP0] = UOTGHS_DEVEPTIER_STALLRQS;
   888a6:	4b04      	ldr	r3, [pc, #16]	; (888b8 <UDD_Stall+0x1c>)
   888a8:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   888ac:	f8c3 21f0 	str.w	r2, [r3, #496]	; 0x1f0
}
   888b0:	bf00      	nop
   888b2:	46bd      	mov	sp, r7
   888b4:	bc80      	pop	{r7}
   888b6:	4770      	bx	lr
   888b8:	400ac000 	.word	0x400ac000

000888bc <UDD_FifoByteCount>:


uint32_t UDD_FifoByteCount(uint32_t ep)
{
   888bc:	b480      	push	{r7}
   888be:	b083      	sub	sp, #12
   888c0:	af00      	add	r7, sp, #0
   888c2:	6078      	str	r0, [r7, #4]
	return ((UOTGHS->UOTGHS_DEVEPTISR[ep] & UOTGHS_DEVEPTISR_BYCT_Msk) >> UOTGHS_DEVEPTISR_BYCT_Pos);
   888c4:	4a06      	ldr	r2, [pc, #24]	; (888e0 <UDD_FifoByteCount+0x24>)
   888c6:	687b      	ldr	r3, [r7, #4]
   888c8:	334c      	adds	r3, #76	; 0x4c
   888ca:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   888ce:	4b05      	ldr	r3, [pc, #20]	; (888e4 <UDD_FifoByteCount+0x28>)
   888d0:	4013      	ands	r3, r2
   888d2:	0d1b      	lsrs	r3, r3, #20
}
   888d4:	4618      	mov	r0, r3
   888d6:	370c      	adds	r7, #12
   888d8:	46bd      	mov	sp, r7
   888da:	bc80      	pop	{r7}
   888dc:	4770      	bx	lr
   888de:	bf00      	nop
   888e0:	400ac000 	.word	0x400ac000
   888e4:	7ff00000 	.word	0x7ff00000

000888e8 <UDD_ReleaseRX>:

void UDD_ReleaseRX(uint32_t ep)
{
   888e8:	b480      	push	{r7}
   888ea:	b083      	sub	sp, #12
   888ec:	af00      	add	r7, sp, #0
   888ee:	6078      	str	r0, [r7, #4]
	TRACE_UOTGHS_DEVICE(puts("=> UDD_ReleaseRX\r\n");)
//	UOTGHS->UOTGHS_DEVEPTICR[ep] = (UOTGHS_DEVEPTICR_NAKOUTIC | UOTGHS_DEVEPTICR_RXOUTIC);
	UOTGHS->UOTGHS_DEVEPTICR[ep] = UOTGHS_DEVEPTICR_RXOUTIC;
   888f0:	4a0b      	ldr	r2, [pc, #44]	; (88920 <UDD_ReleaseRX+0x38>)
   888f2:	687b      	ldr	r3, [r7, #4]
   888f4:	3358      	adds	r3, #88	; 0x58
   888f6:	2102      	movs	r1, #2
   888f8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	UOTGHS->UOTGHS_DEVEPTIDR[ep] = UOTGHS_DEVEPTIDR_FIFOCONC;
   888fc:	4a08      	ldr	r2, [pc, #32]	; (88920 <UDD_ReleaseRX+0x38>)
   888fe:	687b      	ldr	r3, [r7, #4]
   88900:	3388      	adds	r3, #136	; 0x88
   88902:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   88906:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	ul_recv_fifo_ptr[ep] = 0;
   8890a:	4a06      	ldr	r2, [pc, #24]	; (88924 <UDD_ReleaseRX+0x3c>)
   8890c:	687b      	ldr	r3, [r7, #4]
   8890e:	2100      	movs	r1, #0
   88910:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
   88914:	bf00      	nop
   88916:	370c      	adds	r7, #12
   88918:	46bd      	mov	sp, r7
   8891a:	bc80      	pop	{r7}
   8891c:	4770      	bx	lr
   8891e:	bf00      	nop
   88920:	400ac000 	.word	0x400ac000
   88924:	20071654 	.word	0x20071654

00088928 <UDD_ReleaseTX>:

void UDD_ReleaseTX(uint32_t ep)
{
   88928:	b480      	push	{r7}
   8892a:	b083      	sub	sp, #12
   8892c:	af00      	add	r7, sp, #0
   8892e:	6078      	str	r0, [r7, #4]
	TRACE_UOTGHS_DEVICE(printf("=> UDD_ReleaseTX ep=%lu\r\n", ep);)
//	UOTGHS->UOTGHS_DEVEPTICR[ep] = (UOTGHS_DEVEPTICR_NAKINIC | UOTGHS_DEVEPTICR_RXOUTIC | UOTGHS_DEVEPTICR_TXINIC);
	UOTGHS->UOTGHS_DEVEPTICR[ep] = UOTGHS_DEVEPTICR_TXINIC;
   88930:	4a0b      	ldr	r2, [pc, #44]	; (88960 <UDD_ReleaseTX+0x38>)
   88932:	687b      	ldr	r3, [r7, #4]
   88934:	3358      	adds	r3, #88	; 0x58
   88936:	2101      	movs	r1, #1
   88938:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	UOTGHS->UOTGHS_DEVEPTIDR[ep] = UOTGHS_DEVEPTIDR_FIFOCONC;
   8893c:	4a08      	ldr	r2, [pc, #32]	; (88960 <UDD_ReleaseTX+0x38>)
   8893e:	687b      	ldr	r3, [r7, #4]
   88940:	3388      	adds	r3, #136	; 0x88
   88942:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   88946:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	ul_send_fifo_ptr[ep] = 0;
   8894a:	4a06      	ldr	r2, [pc, #24]	; (88964 <UDD_ReleaseTX+0x3c>)
   8894c:	687b      	ldr	r3, [r7, #4]
   8894e:	2100      	movs	r1, #0
   88950:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
   88954:	bf00      	nop
   88956:	370c      	adds	r7, #12
   88958:	46bd      	mov	sp, r7
   8895a:	bc80      	pop	{r7}
   8895c:	4770      	bx	lr
   8895e:	bf00      	nop
   88960:	400ac000 	.word	0x400ac000
   88964:	2007162c 	.word	0x2007162c

00088968 <UDD_SetAddress>:
{
	return (UOTGHS->UOTGHS_DEVEPTISR[ep] & UOTGHS_DEVEPTISR_RWALL);
}

void UDD_SetAddress(uint32_t addr)
{
   88968:	b480      	push	{r7}
   8896a:	b083      	sub	sp, #12
   8896c:	af00      	add	r7, sp, #0
   8896e:	6078      	str	r0, [r7, #4]
	TRACE_UOTGHS_DEVICE(printf("=> UDD_SetAddress : setting address to %lu\r\n", addr);)

	udd_configure_address(addr);
   88970:	490a      	ldr	r1, [pc, #40]	; (8899c <UDD_SetAddress+0x34>)
   88972:	4b0a      	ldr	r3, [pc, #40]	; (8899c <UDD_SetAddress+0x34>)
   88974:	681b      	ldr	r3, [r3, #0]
   88976:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
   8897a:	687b      	ldr	r3, [r7, #4]
   8897c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   88980:	4313      	orrs	r3, r2
   88982:	600b      	str	r3, [r1, #0]
	udd_enable_address();
   88984:	4a05      	ldr	r2, [pc, #20]	; (8899c <UDD_SetAddress+0x34>)
   88986:	4b05      	ldr	r3, [pc, #20]	; (8899c <UDD_SetAddress+0x34>)
   88988:	681b      	ldr	r3, [r3, #0]
   8898a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   8898e:	6013      	str	r3, [r2, #0]
}
   88990:	bf00      	nop
   88992:	370c      	adds	r7, #12
   88994:	46bd      	mov	sp, r7
   88996:	bc80      	pop	{r7}
   88998:	4770      	bx	lr
   8899a:	bf00      	nop
   8899c:	400ac000 	.word	0x400ac000

000889a0 <WDT_Disable>:
 *
 * \note The Watchdog Mode Register (WDT_MR) can be written only once.
 * Only a processor reset resets it.
 */
extern void WDT_Disable( Wdt* pWDT )
{
   889a0:	b480      	push	{r7}
   889a2:	b083      	sub	sp, #12
   889a4:	af00      	add	r7, sp, #0
   889a6:	6078      	str	r0, [r7, #4]
    pWDT->WDT_MR = WDT_MR_WDDIS;
   889a8:	687b      	ldr	r3, [r7, #4]
   889aa:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   889ae:	605a      	str	r2, [r3, #4]
}
   889b0:	bf00      	nop
   889b2:	370c      	adds	r7, #12
   889b4:	46bd      	mov	sp, r7
   889b6:	bc80      	pop	{r7}
   889b8:	4770      	bx	lr
   889ba:	bf00      	nop

000889bc <_ZN10USARTClassC1EP5Usart4IRQnmP10RingBufferS4_>:
#include <string.h>
#include "USARTClass.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTClass::USARTClass( Usart* pUsart, IRQn_Type dwIrq, uint32_t dwId, RingBuffer* pRx_buffer, RingBuffer* pTx_buffer )
   889bc:	b590      	push	{r4, r7, lr}
   889be:	b087      	sub	sp, #28
   889c0:	af02      	add	r7, sp, #8
   889c2:	60f8      	str	r0, [r7, #12]
   889c4:	60b9      	str	r1, [r7, #8]
   889c6:	603b      	str	r3, [r7, #0]
   889c8:	4613      	mov	r3, r2
   889ca:	71fb      	strb	r3, [r7, #7]
  : UARTClass((Uart*)pUsart, dwIrq, dwId, pRx_buffer, pTx_buffer)
   889cc:	68f8      	ldr	r0, [r7, #12]
   889ce:	f997 2007 	ldrsb.w	r2, [r7, #7]
   889d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   889d4:	9301      	str	r3, [sp, #4]
   889d6:	6a3b      	ldr	r3, [r7, #32]
   889d8:	9300      	str	r3, [sp, #0]
   889da:	683b      	ldr	r3, [r7, #0]
   889dc:	68b9      	ldr	r1, [r7, #8]
   889de:	4c06      	ldr	r4, [pc, #24]	; (889f8 <_ZN10USARTClassC1EP5Usart4IRQnmP10RingBufferS4_+0x3c>)
   889e0:	47a0      	blx	r4
   889e2:	4a06      	ldr	r2, [pc, #24]	; (889fc <_ZN10USARTClassC1EP5Usart4IRQnmP10RingBufferS4_+0x40>)
   889e4:	68fb      	ldr	r3, [r7, #12]
   889e6:	601a      	str	r2, [r3, #0]
{
  // In case anyone needs USART specific functionality in the future
  _pUsart=pUsart;
   889e8:	68fb      	ldr	r3, [r7, #12]
   889ea:	68ba      	ldr	r2, [r7, #8]
   889ec:	625a      	str	r2, [r3, #36]	; 0x24
}
   889ee:	68fb      	ldr	r3, [r7, #12]
   889f0:	4618      	mov	r0, r3
   889f2:	3714      	adds	r7, #20
   889f4:	46bd      	mov	sp, r7
   889f6:	bd90      	pop	{r4, r7, pc}
   889f8:	0008058d 	.word	0x0008058d
   889fc:	0009ad30 	.word	0x0009ad30

00088a00 <_ZN10USARTClass5beginEm>:

// Public Methods //////////////////////////////////////////////////////////////

void USARTClass::begin(const uint32_t dwBaudRate)
{
   88a00:	b580      	push	{r7, lr}
   88a02:	b082      	sub	sp, #8
   88a04:	af00      	add	r7, sp, #0
   88a06:	6078      	str	r0, [r7, #4]
   88a08:	6039      	str	r1, [r7, #0]
  begin(dwBaudRate, Mode_8N1);
   88a0a:	f44f 620c 	mov.w	r2, #2240	; 0x8c0
   88a0e:	6839      	ldr	r1, [r7, #0]
   88a10:	6878      	ldr	r0, [r7, #4]
   88a12:	4b03      	ldr	r3, [pc, #12]	; (88a20 <_ZN10USARTClass5beginEm+0x20>)
   88a14:	4798      	blx	r3
}
   88a16:	bf00      	nop
   88a18:	3708      	adds	r7, #8
   88a1a:	46bd      	mov	sp, r7
   88a1c:	bd80      	pop	{r7, pc}
   88a1e:	bf00      	nop
   88a20:	00088a25 	.word	0x00088a25

00088a24 <_ZN10USARTClass5beginEmN9UARTClass9UARTModesE>:

void USARTClass::begin(const uint32_t dwBaudRate, const UARTModes config)
{
   88a24:	b580      	push	{r7, lr}
   88a26:	b086      	sub	sp, #24
   88a28:	af00      	add	r7, sp, #0
   88a2a:	60f8      	str	r0, [r7, #12]
   88a2c:	60b9      	str	r1, [r7, #8]
   88a2e:	4613      	mov	r3, r2
   88a30:	80fb      	strh	r3, [r7, #6]
  uint32_t modeReg = static_cast<uint32_t>(config);
   88a32:	88fb      	ldrh	r3, [r7, #6]
   88a34:	617b      	str	r3, [r7, #20]
  modeReg |= US_MR_USART_MODE_NORMAL | US_MR_USCLKS_MCK | US_MR_CHMODE_NORMAL;
  init(dwBaudRate, modeReg);
   88a36:	68fb      	ldr	r3, [r7, #12]
   88a38:	697a      	ldr	r2, [r7, #20]
   88a3a:	68b9      	ldr	r1, [r7, #8]
   88a3c:	4618      	mov	r0, r3
   88a3e:	4b03      	ldr	r3, [pc, #12]	; (88a4c <_ZN10USARTClass5beginEmN9UARTClass9UARTModesE+0x28>)
   88a40:	4798      	blx	r3
}
   88a42:	bf00      	nop
   88a44:	3718      	adds	r7, #24
   88a46:	46bd      	mov	sp, r7
   88a48:	bd80      	pop	{r7, pc}
   88a4a:	bf00      	nop
   88a4c:	0008062d 	.word	0x0008062d

00088a50 <_ZN5Print13setWriteErrorEi>:
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
   88a50:	b480      	push	{r7}
   88a52:	b083      	sub	sp, #12
   88a54:	af00      	add	r7, sp, #0
   88a56:	6078      	str	r0, [r7, #4]
   88a58:	6039      	str	r1, [r7, #0]
   88a5a:	687b      	ldr	r3, [r7, #4]
   88a5c:	683a      	ldr	r2, [r7, #0]
   88a5e:	605a      	str	r2, [r3, #4]
   88a60:	bf00      	nop
   88a62:	370c      	adds	r7, #12
   88a64:	46bd      	mov	sp, r7
   88a66:	bc80      	pop	{r7}
   88a68:	4770      	bx	lr
   88a6a:	bf00      	nop

00088a6c <_Z16CDC_GetInterfacePh>:
	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_IN ),USB_ENDPOINT_TYPE_BULK,64,0)
};
_Pragma("pack()")

int WEAK CDC_GetInterface(uint8_t* interfaceNum)
{
   88a6c:	b580      	push	{r7, lr}
   88a6e:	b082      	sub	sp, #8
   88a70:	af00      	add	r7, sp, #0
   88a72:	6078      	str	r0, [r7, #4]
	interfaceNum[0] += 2;	// uses 2
   88a74:	687b      	ldr	r3, [r7, #4]
   88a76:	781b      	ldrb	r3, [r3, #0]
   88a78:	3302      	adds	r3, #2
   88a7a:	b2da      	uxtb	r2, r3
   88a7c:	687b      	ldr	r3, [r7, #4]
   88a7e:	701a      	strb	r2, [r3, #0]
	return USBD_SendControl(0,&_cdcInterface,sizeof(_cdcInterface));
   88a80:	2242      	movs	r2, #66	; 0x42
   88a82:	4904      	ldr	r1, [pc, #16]	; (88a94 <_Z16CDC_GetInterfacePh+0x28>)
   88a84:	2000      	movs	r0, #0
   88a86:	4b04      	ldr	r3, [pc, #16]	; (88a98 <_Z16CDC_GetInterfacePh+0x2c>)
   88a88:	4798      	blx	r3
   88a8a:	4603      	mov	r3, r0
}
   88a8c:	4618      	mov	r0, r3
   88a8e:	3708      	adds	r7, #8
   88a90:	46bd      	mov	sp, r7
   88a92:	bd80      	pop	{r7, pc}
   88a94:	0009ad54 	.word	0x0009ad54
   88a98:	00080c79 	.word	0x00080c79

00088a9c <_Z21CDC_GetOtherInterfacePh>:

int WEAK CDC_GetOtherInterface(uint8_t* interfaceNum)
{
   88a9c:	b580      	push	{r7, lr}
   88a9e:	b082      	sub	sp, #8
   88aa0:	af00      	add	r7, sp, #0
   88aa2:	6078      	str	r0, [r7, #4]
	interfaceNum[0] += 2;	// uses 2
   88aa4:	687b      	ldr	r3, [r7, #4]
   88aa6:	781b      	ldrb	r3, [r3, #0]
   88aa8:	3302      	adds	r3, #2
   88aaa:	b2da      	uxtb	r2, r3
   88aac:	687b      	ldr	r3, [r7, #4]
   88aae:	701a      	strb	r2, [r3, #0]
	return USBD_SendControl(0,&_cdcOtherInterface,sizeof(_cdcOtherInterface));
   88ab0:	2242      	movs	r2, #66	; 0x42
   88ab2:	4904      	ldr	r1, [pc, #16]	; (88ac4 <_Z21CDC_GetOtherInterfacePh+0x28>)
   88ab4:	2000      	movs	r0, #0
   88ab6:	4b04      	ldr	r3, [pc, #16]	; (88ac8 <_Z21CDC_GetOtherInterfacePh+0x2c>)
   88ab8:	4798      	blx	r3
   88aba:	4603      	mov	r3, r0
}
   88abc:	4618      	mov	r0, r3
   88abe:	3708      	adds	r7, #8
   88ac0:	46bd      	mov	sp, r7
   88ac2:	bd80      	pop	{r7, pc}
   88ac4:	0009ad98 	.word	0x0009ad98
   88ac8:	00080c79 	.word	0x00080c79

00088acc <_Z9CDC_SetupR8USBSetup>:

bool WEAK CDC_Setup(USBSetup& setup)
{
   88acc:	b580      	push	{r7, lr}
   88ace:	b084      	sub	sp, #16
   88ad0:	af00      	add	r7, sp, #0
   88ad2:	6078      	str	r0, [r7, #4]
	uint8_t r = setup.bRequest;
   88ad4:	687b      	ldr	r3, [r7, #4]
   88ad6:	785b      	ldrb	r3, [r3, #1]
   88ad8:	73fb      	strb	r3, [r7, #15]
	uint8_t requestType = setup.bmRequestType;
   88ada:	687b      	ldr	r3, [r7, #4]
   88adc:	781b      	ldrb	r3, [r3, #0]
   88ade:	73bb      	strb	r3, [r7, #14]

	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
   88ae0:	7bbb      	ldrb	r3, [r7, #14]
   88ae2:	2ba1      	cmp	r3, #161	; 0xa1
   88ae4:	d109      	bne.n	88afa <_Z9CDC_SetupR8USBSetup+0x2e>
	{
		if (CDC_GET_LINE_CODING == r)
   88ae6:	7bfb      	ldrb	r3, [r7, #15]
   88ae8:	2b21      	cmp	r3, #33	; 0x21
   88aea:	d106      	bne.n	88afa <_Z9CDC_SetupR8USBSetup+0x2e>
		{
			USBD_SendControl(0,(void*)&_usbLineInfo,7);
   88aec:	2207      	movs	r2, #7
   88aee:	4924      	ldr	r1, [pc, #144]	; (88b80 <_Z9CDC_SetupR8USBSetup+0xb4>)
   88af0:	2000      	movs	r0, #0
   88af2:	4b24      	ldr	r3, [pc, #144]	; (88b84 <_Z9CDC_SetupR8USBSetup+0xb8>)
   88af4:	4798      	blx	r3
			return true;
   88af6:	2301      	movs	r3, #1
   88af8:	e03e      	b.n	88b78 <_Z9CDC_SetupR8USBSetup+0xac>
		}
	}

	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
   88afa:	7bbb      	ldrb	r3, [r7, #14]
   88afc:	2b21      	cmp	r3, #33	; 0x21
   88afe:	d13a      	bne.n	88b76 <_Z9CDC_SetupR8USBSetup+0xaa>
	{
		if (CDC_SET_LINE_CODING == r)
   88b00:	7bfb      	ldrb	r3, [r7, #15]
   88b02:	2b20      	cmp	r3, #32
   88b04:	d105      	bne.n	88b12 <_Z9CDC_SetupR8USBSetup+0x46>
		{
			USBD_RecvControl((void*)&_usbLineInfo,7);
   88b06:	2107      	movs	r1, #7
   88b08:	481d      	ldr	r0, [pc, #116]	; (88b80 <_Z9CDC_SetupR8USBSetup+0xb4>)
   88b0a:	4b1f      	ldr	r3, [pc, #124]	; (88b88 <_Z9CDC_SetupR8USBSetup+0xbc>)
   88b0c:	4798      	blx	r3
			return true;
   88b0e:	2301      	movs	r3, #1
   88b10:	e032      	b.n	88b78 <_Z9CDC_SetupR8USBSetup+0xac>
		}

		if (CDC_SET_CONTROL_LINE_STATE == r)
   88b12:	7bfb      	ldrb	r3, [r7, #15]
   88b14:	2b22      	cmp	r3, #34	; 0x22
   88b16:	d121      	bne.n	88b5c <_Z9CDC_SetupR8USBSetup+0x90>
		{
			_usbLineInfo.lineState = setup.wValueL;
   88b18:	687b      	ldr	r3, [r7, #4]
   88b1a:	789a      	ldrb	r2, [r3, #2]
   88b1c:	4b18      	ldr	r3, [pc, #96]	; (88b80 <_Z9CDC_SetupR8USBSetup+0xb4>)
   88b1e:	71da      	strb	r2, [r3, #7]
			// auto-reset into the bootloader is triggered when the port, already
			// open at 1200 bps, is closed.
			if (1200 == _usbLineInfo.dwDTERate)
   88b20:	4b17      	ldr	r3, [pc, #92]	; (88b80 <_Z9CDC_SetupR8USBSetup+0xb4>)
   88b22:	681b      	ldr	r3, [r3, #0]
   88b24:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   88b28:	bf0c      	ite	eq
   88b2a:	2301      	moveq	r3, #1
   88b2c:	2300      	movne	r3, #0
   88b2e:	b2db      	uxtb	r3, r3
   88b30:	2b00      	cmp	r3, #0
   88b32:	d011      	beq.n	88b58 <_Z9CDC_SetupR8USBSetup+0x8c>
			{
				// We check DTR state to determine if host port is open (bit 0 of lineState).
				if ((_usbLineInfo.lineState & 0x01) == 0)
   88b34:	4b12      	ldr	r3, [pc, #72]	; (88b80 <_Z9CDC_SetupR8USBSetup+0xb4>)
   88b36:	79db      	ldrb	r3, [r3, #7]
   88b38:	b2db      	uxtb	r3, r3
   88b3a:	f003 0301 	and.w	r3, r3, #1
   88b3e:	2b00      	cmp	r3, #0
   88b40:	bf0c      	ite	eq
   88b42:	2301      	moveq	r3, #1
   88b44:	2300      	movne	r3, #0
   88b46:	b2db      	uxtb	r3, r3
   88b48:	2b00      	cmp	r3, #0
   88b4a:	d003      	beq.n	88b54 <_Z9CDC_SetupR8USBSetup+0x88>
					initiateReset(250);
   88b4c:	20fa      	movs	r0, #250	; 0xfa
   88b4e:	4b0f      	ldr	r3, [pc, #60]	; (88b8c <_Z9CDC_SetupR8USBSetup+0xc0>)
   88b50:	4798      	blx	r3
   88b52:	e001      	b.n	88b58 <_Z9CDC_SetupR8USBSetup+0x8c>
				else
					cancelReset();
   88b54:	4b0e      	ldr	r3, [pc, #56]	; (88b90 <_Z9CDC_SetupR8USBSetup+0xc4>)
   88b56:	4798      	blx	r3
			}
			return true;
   88b58:	2301      	movs	r3, #1
   88b5a:	e00d      	b.n	88b78 <_Z9CDC_SetupR8USBSetup+0xac>
		}

		if (CDC_SEND_BREAK == r)
   88b5c:	7bfb      	ldrb	r3, [r7, #15]
   88b5e:	2b23      	cmp	r3, #35	; 0x23
   88b60:	d109      	bne.n	88b76 <_Z9CDC_SetupR8USBSetup+0xaa>
		{
			breakValue = ((uint16_t)setup.wValueH << 8) | setup.wValueL;
   88b62:	687b      	ldr	r3, [r7, #4]
   88b64:	78db      	ldrb	r3, [r3, #3]
   88b66:	021b      	lsls	r3, r3, #8
   88b68:	687a      	ldr	r2, [r7, #4]
   88b6a:	7892      	ldrb	r2, [r2, #2]
   88b6c:	4313      	orrs	r3, r2
   88b6e:	4a09      	ldr	r2, [pc, #36]	; (88b94 <_Z9CDC_SetupR8USBSetup+0xc8>)
   88b70:	6013      	str	r3, [r2, #0]
			return true;
   88b72:	2301      	movs	r3, #1
   88b74:	e000      	b.n	88b78 <_Z9CDC_SetupR8USBSetup+0xac>
		}
	}
	return false;
   88b76:	2300      	movs	r3, #0
}
   88b78:	4618      	mov	r0, r3
   88b7a:	3710      	adds	r7, #16
   88b7c:	46bd      	mov	sp, r7
   88b7e:	bd80      	pop	{r7, pc}
   88b80:	20070108 	.word	0x20070108
   88b84:	00080c79 	.word	0x00080c79
   88b88:	00080dd5 	.word	0x00080dd5
   88b8c:	00087a2d 	.word	0x00087a2d
   88b90:	00087a49 	.word	0x00087a49
   88b94:	20070110 	.word	0x20070110

00088b98 <_ZN7Serial_6acceptEv>:
void Serial_::end(void)
{
}

void Serial_::accept(void)
{
   88b98:	b580      	push	{r7, lr}
   88b9a:	b08a      	sub	sp, #40	; 0x28
   88b9c:	af00      	add	r7, sp, #0
   88b9e:	6078      	str	r0, [r7, #4]
   88ba0:	4b30      	ldr	r3, [pc, #192]	; (88c64 <_ZN7Serial_6acceptEv+0xcc>)
   88ba2:	613b      	str	r3, [r7, #16]
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;
  
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
   88ba4:	693b      	ldr	r3, [r7, #16]
   88ba6:	e853 3f00 	ldrex	r3, [r3]
   88baa:	60fb      	str	r3, [r7, #12]
   return(result);
   88bac:	68fb      	ldr	r3, [r7, #12]
	static uint32_t guard = 0;

	// synchronized access to guard
	do {
		if (__LDREXW(&guard) != 0) {
   88bae:	2b00      	cmp	r3, #0
   88bb0:	bf14      	ite	ne
   88bb2:	2301      	movne	r3, #1
   88bb4:	2300      	moveq	r3, #0
   88bb6:	b2db      	uxtb	r3, r3
   88bb8:	2b00      	cmp	r3, #0
   88bba:	d002      	beq.n	88bc2 <_ZN7Serial_6acceptEv+0x2a>
    This function removes the exclusive lock which is created by LDREX.

 */
__attribute__( ( always_inline ) ) static __INLINE void __CLREX(void)
{
  __ASM volatile ("clrex");
   88bbc:	f3bf 8f2f 	clrex
			__CLREX();
			return;  // busy
   88bc0:	e04d      	b.n	88c5e <_ZN7Serial_6acceptEv+0xc6>
   88bc2:	2301      	movs	r3, #1
   88bc4:	617b      	str	r3, [r7, #20]
   88bc6:	4b27      	ldr	r3, [pc, #156]	; (88c64 <_ZN7Serial_6acceptEv+0xcc>)
   88bc8:	623b      	str	r3, [r7, #32]
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;
  
   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
   88bca:	6a3b      	ldr	r3, [r7, #32]
   88bcc:	697a      	ldr	r2, [r7, #20]
   88bce:	e843 2300 	strex	r3, r2, [r3]
   88bd2:	60bb      	str	r3, [r7, #8]
   return(result);
   88bd4:	68bb      	ldr	r3, [r7, #8]
void Serial_::accept(void)
{
	static uint32_t guard = 0;

	// synchronized access to guard
	do {
   88bd6:	2b00      	cmp	r3, #0
   88bd8:	bf14      	ite	ne
   88bda:	2301      	movne	r3, #1
   88bdc:	2300      	moveq	r3, #0
   88bde:	b2db      	uxtb	r3, r3
   88be0:	2b00      	cmp	r3, #0
   88be2:	d000      	beq.n	88be6 <_ZN7Serial_6acceptEv+0x4e>
   88be4:	e7dc      	b.n	88ba0 <_ZN7Serial_6acceptEv+0x8>
			__CLREX();
			return;  // busy
		}
	} while (__STREXW(1, &guard) != 0); // retry until write succeed

	ring_buffer *buffer = &cdc_rx_buffer;
   88be6:	4b20      	ldr	r3, [pc, #128]	; (88c68 <_ZN7Serial_6acceptEv+0xd0>)
   88be8:	61fb      	str	r3, [r7, #28]
	uint32_t i = (uint32_t)(buffer->head+1) % CDC_SERIAL_BUFFER_SIZE;
   88bea:	69fb      	ldr	r3, [r7, #28]
   88bec:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
   88bf0:	3301      	adds	r3, #1
   88bf2:	f3c3 0308 	ubfx	r3, r3, #0, #9
   88bf6:	627b      	str	r3, [r7, #36]	; 0x24

	// if we should be storing the received character into the location
	// just before the tail (meaning that the head would advance to the
	// current location of the tail), we're about to overflow the buffer
	// and so we don't write the character or advance the head.
	while (i != buffer->tail) {
   88bf8:	69fb      	ldr	r3, [r7, #28]
   88bfa:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
   88bfe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   88c00:	429a      	cmp	r2, r3
   88c02:	bf14      	ite	ne
   88c04:	2301      	movne	r3, #1
   88c06:	2300      	moveq	r3, #0
   88c08:	b2db      	uxtb	r3, r3
   88c0a:	2b00      	cmp	r3, #0
   88c0c:	d024      	beq.n	88c58 <_ZN7Serial_6acceptEv+0xc0>
		uint32_t c;
		if (!USBD_Available(CDC_RX)) {
   88c0e:	2002      	movs	r0, #2
   88c10:	4b16      	ldr	r3, [pc, #88]	; (88c6c <_ZN7Serial_6acceptEv+0xd4>)
   88c12:	4798      	blx	r3
   88c14:	4603      	mov	r3, r0
   88c16:	2b00      	cmp	r3, #0
   88c18:	bf0c      	ite	eq
   88c1a:	2301      	moveq	r3, #1
   88c1c:	2300      	movne	r3, #0
   88c1e:	b2db      	uxtb	r3, r3
   88c20:	2b00      	cmp	r3, #0
   88c22:	d004      	beq.n	88c2e <_ZN7Serial_6acceptEv+0x96>
			udd_ack_fifocon(CDC_RX);
   88c24:	4b12      	ldr	r3, [pc, #72]	; (88c70 <_ZN7Serial_6acceptEv+0xd8>)
   88c26:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   88c2a:	601a      	str	r2, [r3, #0]
			break;
   88c2c:	e014      	b.n	88c58 <_ZN7Serial_6acceptEv+0xc0>
		}
		c = USBD_Recv(CDC_RX);
   88c2e:	2002      	movs	r0, #2
   88c30:	4b10      	ldr	r3, [pc, #64]	; (88c74 <_ZN7Serial_6acceptEv+0xdc>)
   88c32:	4798      	blx	r3
   88c34:	61b8      	str	r0, [r7, #24]
		// c = UDD_Recv8(CDC_RX & 0xF);
		buffer->buffer[buffer->head] = c;
   88c36:	69fb      	ldr	r3, [r7, #28]
   88c38:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
   88c3c:	69ba      	ldr	r2, [r7, #24]
   88c3e:	b2d1      	uxtb	r1, r2
   88c40:	69fa      	ldr	r2, [r7, #28]
   88c42:	54d1      	strb	r1, [r2, r3]
		buffer->head = i;
   88c44:	69fb      	ldr	r3, [r7, #28]
   88c46:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   88c48:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

		i = (i + 1) % CDC_SERIAL_BUFFER_SIZE;
   88c4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   88c4e:	3301      	adds	r3, #1
   88c50:	f3c3 0308 	ubfx	r3, r3, #0, #9
   88c54:	627b      	str	r3, [r7, #36]	; 0x24

	// if we should be storing the received character into the location
	// just before the tail (meaning that the head would advance to the
	// current location of the tail), we're about to overflow the buffer
	// and so we don't write the character or advance the head.
	while (i != buffer->tail) {
   88c56:	e7cf      	b.n	88bf8 <_ZN7Serial_6acceptEv+0x60>

		i = (i + 1) % CDC_SERIAL_BUFFER_SIZE;
	}

	// release the guard
	guard = 0;
   88c58:	4b02      	ldr	r3, [pc, #8]	; (88c64 <_ZN7Serial_6acceptEv+0xcc>)
   88c5a:	2200      	movs	r2, #0
   88c5c:	601a      	str	r2, [r3, #0]
}
   88c5e:	3728      	adds	r7, #40	; 0x28
   88c60:	46bd      	mov	sp, r7
   88c62:	bd80      	pop	{r7, pc}
   88c64:	20071898 	.word	0x20071898
   88c68:	2007167c 	.word	0x2007167c
   88c6c:	00080a69 	.word	0x00080a69
   88c70:	400ac228 	.word	0x400ac228
   88c74:	00080b8d 	.word	0x00080b8d

00088c78 <_ZN7Serial_9availableEv>:

int Serial_::available(void)
{
   88c78:	b480      	push	{r7}
   88c7a:	b085      	sub	sp, #20
   88c7c:	af00      	add	r7, sp, #0
   88c7e:	6078      	str	r0, [r7, #4]
	ring_buffer *buffer = &cdc_rx_buffer;
   88c80:	4b07      	ldr	r3, [pc, #28]	; (88ca0 <_ZN7Serial_9availableEv+0x28>)
   88c82:	60fb      	str	r3, [r7, #12]
	return (unsigned int)(CDC_SERIAL_BUFFER_SIZE + buffer->head - buffer->tail) % CDC_SERIAL_BUFFER_SIZE;
   88c84:	68fb      	ldr	r3, [r7, #12]
   88c86:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   88c8a:	68fb      	ldr	r3, [r7, #12]
   88c8c:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
   88c90:	1ad3      	subs	r3, r2, r3
   88c92:	f3c3 0308 	ubfx	r3, r3, #0, #9
}
   88c96:	4618      	mov	r0, r3
   88c98:	3714      	adds	r7, #20
   88c9a:	46bd      	mov	sp, r7
   88c9c:	bc80      	pop	{r7}
   88c9e:	4770      	bx	lr
   88ca0:	2007167c 	.word	0x2007167c

00088ca4 <_ZN7Serial_17availableForWriteEv>:

int Serial_::availableForWrite(void)
{
   88ca4:	b480      	push	{r7}
   88ca6:	b083      	sub	sp, #12
   88ca8:	af00      	add	r7, sp, #0
   88caa:	6078      	str	r0, [r7, #4]
	// return the number of bytes left in the current bank,
	// always EP size - 1, because bank is flushed on every write
	return (EPX_SIZE - 1);
   88cac:	f240 13ff 	movw	r3, #511	; 0x1ff
}
   88cb0:	4618      	mov	r0, r3
   88cb2:	370c      	adds	r7, #12
   88cb4:	46bd      	mov	sp, r7
   88cb6:	bc80      	pop	{r7}
   88cb8:	4770      	bx	lr
   88cba:	bf00      	nop

00088cbc <_ZN7Serial_4peekEv>:

int Serial_::peek(void)
{
   88cbc:	b480      	push	{r7}
   88cbe:	b085      	sub	sp, #20
   88cc0:	af00      	add	r7, sp, #0
   88cc2:	6078      	str	r0, [r7, #4]
	ring_buffer *buffer = &cdc_rx_buffer;
   88cc4:	4b0d      	ldr	r3, [pc, #52]	; (88cfc <_ZN7Serial_4peekEv+0x40>)
   88cc6:	60fb      	str	r3, [r7, #12]

	if (buffer->head == buffer->tail)
   88cc8:	68fb      	ldr	r3, [r7, #12]
   88cca:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   88cce:	68fb      	ldr	r3, [r7, #12]
   88cd0:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
   88cd4:	429a      	cmp	r2, r3
   88cd6:	bf0c      	ite	eq
   88cd8:	2301      	moveq	r3, #1
   88cda:	2300      	movne	r3, #0
   88cdc:	b2db      	uxtb	r3, r3
   88cde:	2b00      	cmp	r3, #0
   88ce0:	d002      	beq.n	88ce8 <_ZN7Serial_4peekEv+0x2c>
	{
		return -1;
   88ce2:	f04f 33ff 	mov.w	r3, #4294967295
   88ce6:	e004      	b.n	88cf2 <_ZN7Serial_4peekEv+0x36>
	}
	else
	{
		return buffer->buffer[buffer->tail];
   88ce8:	68fb      	ldr	r3, [r7, #12]
   88cea:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
   88cee:	68fa      	ldr	r2, [r7, #12]
   88cf0:	5cd3      	ldrb	r3, [r2, r3]
	}
}
   88cf2:	4618      	mov	r0, r3
   88cf4:	3714      	adds	r7, #20
   88cf6:	46bd      	mov	sp, r7
   88cf8:	bc80      	pop	{r7}
   88cfa:	4770      	bx	lr
   88cfc:	2007167c 	.word	0x2007167c

00088d00 <_ZN7Serial_4readEv>:

int Serial_::read(void)
{
   88d00:	b580      	push	{r7, lr}
   88d02:	b084      	sub	sp, #16
   88d04:	af00      	add	r7, sp, #0
   88d06:	6078      	str	r0, [r7, #4]
	ring_buffer *buffer = &cdc_rx_buffer;
   88d08:	4b1b      	ldr	r3, [pc, #108]	; (88d78 <_ZN7Serial_4readEv+0x78>)
   88d0a:	60fb      	str	r3, [r7, #12]

	// if the head isn't ahead of the tail, we don't have any characters
	if (buffer->head == buffer->tail)
   88d0c:	68fb      	ldr	r3, [r7, #12]
   88d0e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   88d12:	68fb      	ldr	r3, [r7, #12]
   88d14:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
   88d18:	429a      	cmp	r2, r3
   88d1a:	bf0c      	ite	eq
   88d1c:	2301      	moveq	r3, #1
   88d1e:	2300      	movne	r3, #0
   88d20:	b2db      	uxtb	r3, r3
   88d22:	2b00      	cmp	r3, #0
   88d24:	d002      	beq.n	88d2c <_ZN7Serial_4readEv+0x2c>
	{
		return -1;
   88d26:	f04f 33ff 	mov.w	r3, #4294967295
   88d2a:	e020      	b.n	88d6e <_ZN7Serial_4readEv+0x6e>
	}
	else
	{
		unsigned char c = buffer->buffer[buffer->tail];
   88d2c:	68fb      	ldr	r3, [r7, #12]
   88d2e:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
   88d32:	68fa      	ldr	r2, [r7, #12]
   88d34:	5cd3      	ldrb	r3, [r2, r3]
   88d36:	72fb      	strb	r3, [r7, #11]
		buffer->tail = (unsigned int)(buffer->tail + 1) % CDC_SERIAL_BUFFER_SIZE;
   88d38:	68fb      	ldr	r3, [r7, #12]
   88d3a:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
   88d3e:	3301      	adds	r3, #1
   88d40:	f3c3 0208 	ubfx	r2, r3, #0, #9
   88d44:	68fb      	ldr	r3, [r7, #12]
   88d46:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		if (USBD_Available(CDC_RX))
   88d4a:	2002      	movs	r0, #2
   88d4c:	4b0b      	ldr	r3, [pc, #44]	; (88d7c <_ZN7Serial_4readEv+0x7c>)
   88d4e:	4798      	blx	r3
   88d50:	4603      	mov	r3, r0
   88d52:	2b00      	cmp	r3, #0
   88d54:	bf14      	ite	ne
   88d56:	2301      	movne	r3, #1
   88d58:	2300      	moveq	r3, #0
   88d5a:	b2db      	uxtb	r3, r3
   88d5c:	2b00      	cmp	r3, #0
   88d5e:	d005      	beq.n	88d6c <_ZN7Serial_4readEv+0x6c>
			accept();
   88d60:	687b      	ldr	r3, [r7, #4]
   88d62:	681b      	ldr	r3, [r3, #0]
   88d64:	331c      	adds	r3, #28
   88d66:	681b      	ldr	r3, [r3, #0]
   88d68:	6878      	ldr	r0, [r7, #4]
   88d6a:	4798      	blx	r3
		return c;
   88d6c:	7afb      	ldrb	r3, [r7, #11]
	}
}
   88d6e:	4618      	mov	r0, r3
   88d70:	3710      	adds	r7, #16
   88d72:	46bd      	mov	sp, r7
   88d74:	bd80      	pop	{r7, pc}
   88d76:	bf00      	nop
   88d78:	2007167c 	.word	0x2007167c
   88d7c:	00080a69 	.word	0x00080a69

00088d80 <_ZN7Serial_5flushEv>:

void Serial_::flush(void)
{
   88d80:	b580      	push	{r7, lr}
   88d82:	b082      	sub	sp, #8
   88d84:	af00      	add	r7, sp, #0
   88d86:	6078      	str	r0, [r7, #4]
	USBD_Flush(CDC_TX);
   88d88:	2003      	movs	r0, #3
   88d8a:	4b03      	ldr	r3, [pc, #12]	; (88d98 <_ZN7Serial_5flushEv+0x18>)
   88d8c:	4798      	blx	r3
}
   88d8e:	bf00      	nop
   88d90:	3708      	adds	r7, #8
   88d92:	46bd      	mov	sp, r7
   88d94:	bd80      	pop	{r7, pc}
   88d96:	bf00      	nop
   88d98:	00081665 	.word	0x00081665

00088d9c <_ZN7Serial_5writeEPKhj>:

size_t Serial_::write(const uint8_t *buffer, size_t size)
{
   88d9c:	b580      	push	{r7, lr}
   88d9e:	b086      	sub	sp, #24
   88da0:	af00      	add	r7, sp, #0
   88da2:	60f8      	str	r0, [r7, #12]
   88da4:	60b9      	str	r1, [r7, #8]
   88da6:	607a      	str	r2, [r7, #4]
	 the connection is closed are lost - just like with a UART. */

	// TODO - ZE - check behavior on different OSes and test what happens if an
	// open connection isn't broken cleanly (cable is yanked out, host dies
	// or locks up, or host virtual serial port hangs)
	if (_usbLineInfo.lineState > 0)
   88da8:	4b13      	ldr	r3, [pc, #76]	; (88df8 <_ZN7Serial_5writeEPKhj+0x5c>)
   88daa:	79db      	ldrb	r3, [r3, #7]
   88dac:	b2db      	uxtb	r3, r3
   88dae:	2b00      	cmp	r3, #0
   88db0:	bf14      	ite	ne
   88db2:	2301      	movne	r3, #1
   88db4:	2300      	moveq	r3, #0
   88db6:	b2db      	uxtb	r3, r3
   88db8:	2b00      	cmp	r3, #0
   88dba:	d012      	beq.n	88de2 <_ZN7Serial_5writeEPKhj+0x46>
	{
		int r = USBD_Send(CDC_TX, buffer, size);
   88dbc:	687a      	ldr	r2, [r7, #4]
   88dbe:	68b9      	ldr	r1, [r7, #8]
   88dc0:	2003      	movs	r0, #3
   88dc2:	4b0e      	ldr	r3, [pc, #56]	; (88dfc <_ZN7Serial_5writeEPKhj+0x60>)
   88dc4:	4798      	blx	r3
   88dc6:	4603      	mov	r3, r0
   88dc8:	617b      	str	r3, [r7, #20]

		if (r > 0)
   88dca:	697b      	ldr	r3, [r7, #20]
   88dcc:	2b00      	cmp	r3, #0
   88dce:	dd01      	ble.n	88dd4 <_ZN7Serial_5writeEPKhj+0x38>
		{
			return r;
   88dd0:	697b      	ldr	r3, [r7, #20]
   88dd2:	e00c      	b.n	88dee <_ZN7Serial_5writeEPKhj+0x52>
		} else
		{
			setWriteError();
   88dd4:	68fb      	ldr	r3, [r7, #12]
   88dd6:	2101      	movs	r1, #1
   88dd8:	4618      	mov	r0, r3
   88dda:	4b09      	ldr	r3, [pc, #36]	; (88e00 <_ZN7Serial_5writeEPKhj+0x64>)
   88ddc:	4798      	blx	r3
			return 0;
   88dde:	2300      	movs	r3, #0
   88de0:	e005      	b.n	88dee <_ZN7Serial_5writeEPKhj+0x52>
		}
	}
	setWriteError();
   88de2:	68fb      	ldr	r3, [r7, #12]
   88de4:	2101      	movs	r1, #1
   88de6:	4618      	mov	r0, r3
   88de8:	4b05      	ldr	r3, [pc, #20]	; (88e00 <_ZN7Serial_5writeEPKhj+0x64>)
   88dea:	4798      	blx	r3
	return 0;
   88dec:	2300      	movs	r3, #0
}
   88dee:	4618      	mov	r0, r3
   88df0:	3718      	adds	r7, #24
   88df2:	46bd      	mov	sp, r7
   88df4:	bd80      	pop	{r7, pc}
   88df6:	bf00      	nop
   88df8:	20070108 	.word	0x20070108
   88dfc:	00080bcd 	.word	0x00080bcd
   88e00:	00088a51 	.word	0x00088a51

00088e04 <_ZN7Serial_5writeEh>:

size_t Serial_::write(uint8_t c) {
   88e04:	b580      	push	{r7, lr}
   88e06:	b082      	sub	sp, #8
   88e08:	af00      	add	r7, sp, #0
   88e0a:	6078      	str	r0, [r7, #4]
   88e0c:	460b      	mov	r3, r1
   88e0e:	70fb      	strb	r3, [r7, #3]
	return write(&c, 1);
   88e10:	687b      	ldr	r3, [r7, #4]
   88e12:	681b      	ldr	r3, [r3, #0]
   88e14:	3304      	adds	r3, #4
   88e16:	681b      	ldr	r3, [r3, #0]
   88e18:	1cf9      	adds	r1, r7, #3
   88e1a:	2201      	movs	r2, #1
   88e1c:	6878      	ldr	r0, [r7, #4]
   88e1e:	4798      	blx	r3
   88e20:	4603      	mov	r3, r0
}
   88e22:	4618      	mov	r0, r3
   88e24:	3708      	adds	r7, #8
   88e26:	46bd      	mov	sp, r7
   88e28:	bd80      	pop	{r7, pc}
   88e2a:	bf00      	nop

00088e2c <_ZN7Serial_C1Ev>:

//================================================================================
//================================================================================
//	Serial over CDC (Serial1 is the physical port)

class Serial_ : public Stream
   88e2c:	b580      	push	{r7, lr}
   88e2e:	b082      	sub	sp, #8
   88e30:	af00      	add	r7, sp, #0
   88e32:	6078      	str	r0, [r7, #4]
   88e34:	687b      	ldr	r3, [r7, #4]
   88e36:	4618      	mov	r0, r3
   88e38:	4b04      	ldr	r3, [pc, #16]	; (88e4c <_ZN7Serial_C1Ev+0x20>)
   88e3a:	4798      	blx	r3
   88e3c:	4a04      	ldr	r2, [pc, #16]	; (88e50 <_ZN7Serial_C1Ev+0x24>)
   88e3e:	687b      	ldr	r3, [r7, #4]
   88e40:	601a      	str	r2, [r3, #0]
   88e42:	687b      	ldr	r3, [r7, #4]
   88e44:	4618      	mov	r0, r3
   88e46:	3708      	adds	r7, #8
   88e48:	46bd      	mov	sp, r7
   88e4a:	bd80      	pop	{r7, pc}
   88e4c:	000804bd 	.word	0x000804bd
   88e50:	0009ade4 	.word	0x0009ade4

00088e54 <_Z41__static_initialization_and_destruction_0ii>:

bool Serial_::rts() {
	return _usbLineInfo.lineState & 0x2;
}

Serial_ SerialUSB;
   88e54:	b580      	push	{r7, lr}
   88e56:	b082      	sub	sp, #8
   88e58:	af00      	add	r7, sp, #0
   88e5a:	6078      	str	r0, [r7, #4]
   88e5c:	6039      	str	r1, [r7, #0]
   88e5e:	687b      	ldr	r3, [r7, #4]
   88e60:	2b01      	cmp	r3, #1
   88e62:	d107      	bne.n	88e74 <_Z41__static_initialization_and_destruction_0ii+0x20>
   88e64:	683b      	ldr	r3, [r7, #0]
   88e66:	f64f 72ff 	movw	r2, #65535	; 0xffff
   88e6a:	4293      	cmp	r3, r2
   88e6c:	d102      	bne.n	88e74 <_Z41__static_initialization_and_destruction_0ii+0x20>
   88e6e:	4803      	ldr	r0, [pc, #12]	; (88e7c <_Z41__static_initialization_and_destruction_0ii+0x28>)
   88e70:	4b03      	ldr	r3, [pc, #12]	; (88e80 <_Z41__static_initialization_and_destruction_0ii+0x2c>)
   88e72:	4798      	blx	r3
   88e74:	bf00      	nop
   88e76:	3708      	adds	r7, #8
   88e78:	46bd      	mov	sp, r7
   88e7a:	bd80      	pop	{r7, pc}
   88e7c:	20071884 	.word	0x20071884
   88e80:	00088e2d 	.word	0x00088e2d

00088e84 <_GLOBAL__sub_I_cdc_rx_buffer>:
   88e84:	b580      	push	{r7, lr}
   88e86:	af00      	add	r7, sp, #0
   88e88:	f64f 71ff 	movw	r1, #65535	; 0xffff
   88e8c:	2001      	movs	r0, #1
   88e8e:	4b01      	ldr	r3, [pc, #4]	; (88e94 <_GLOBAL__sub_I_cdc_rx_buffer+0x10>)
   88e90:	4798      	blx	r3
   88e92:	bd80      	pop	{r7, pc}
   88e94:	00088e55 	.word	0x00088e55

00088e98 <_ZN13PluggableUSB_12getInterfaceEPh>:
#ifdef PLUGGABLE_USB_ENABLED

extern uint32_t EndPoints[];

int PluggableUSB_::getInterface(uint8_t* interfaceCount)
{
   88e98:	b580      	push	{r7, lr}
   88e9a:	b086      	sub	sp, #24
   88e9c:	af00      	add	r7, sp, #0
   88e9e:	6078      	str	r0, [r7, #4]
   88ea0:	6039      	str	r1, [r7, #0]
	int sent = 0;
   88ea2:	2300      	movs	r3, #0
   88ea4:	617b      	str	r3, [r7, #20]
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   88ea6:	687b      	ldr	r3, [r7, #4]
   88ea8:	685b      	ldr	r3, [r3, #4]
   88eaa:	613b      	str	r3, [r7, #16]
   88eac:	693b      	ldr	r3, [r7, #16]
   88eae:	2b00      	cmp	r3, #0
   88eb0:	d015      	beq.n	88ede <_ZN13PluggableUSB_12getInterfaceEPh+0x46>
		int res = node->getInterface(interfaceCount);
   88eb2:	693b      	ldr	r3, [r7, #16]
   88eb4:	681b      	ldr	r3, [r3, #0]
   88eb6:	3304      	adds	r3, #4
   88eb8:	681b      	ldr	r3, [r3, #0]
   88eba:	6839      	ldr	r1, [r7, #0]
   88ebc:	6938      	ldr	r0, [r7, #16]
   88ebe:	4798      	blx	r3
   88ec0:	60f8      	str	r0, [r7, #12]
		if (res < 0)
   88ec2:	68fb      	ldr	r3, [r7, #12]
   88ec4:	2b00      	cmp	r3, #0
   88ec6:	da02      	bge.n	88ece <_ZN13PluggableUSB_12getInterfaceEPh+0x36>
			return -1;
   88ec8:	f04f 33ff 	mov.w	r3, #4294967295
   88ecc:	e008      	b.n	88ee0 <_ZN13PluggableUSB_12getInterfaceEPh+0x48>
		sent += res;
   88ece:	697a      	ldr	r2, [r7, #20]
   88ed0:	68fb      	ldr	r3, [r7, #12]
   88ed2:	4413      	add	r3, r2
   88ed4:	617b      	str	r3, [r7, #20]

int PluggableUSB_::getInterface(uint8_t* interfaceCount)
{
	int sent = 0;
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   88ed6:	693b      	ldr	r3, [r7, #16]
   88ed8:	68db      	ldr	r3, [r3, #12]
   88eda:	613b      	str	r3, [r7, #16]
   88edc:	e7e6      	b.n	88eac <_ZN13PluggableUSB_12getInterfaceEPh+0x14>
		int res = node->getInterface(interfaceCount);
		if (res < 0)
			return -1;
		sent += res;
	}
	return sent;
   88ede:	697b      	ldr	r3, [r7, #20]
}
   88ee0:	4618      	mov	r0, r3
   88ee2:	3718      	adds	r7, #24
   88ee4:	46bd      	mov	sp, r7
   88ee6:	bd80      	pop	{r7, pc}

00088ee8 <_ZN13PluggableUSB_13getDescriptorER8USBSetup>:

int PluggableUSB_::getDescriptor(USBSetup& setup)
{
   88ee8:	b580      	push	{r7, lr}
   88eea:	b084      	sub	sp, #16
   88eec:	af00      	add	r7, sp, #0
   88eee:	6078      	str	r0, [r7, #4]
   88ef0:	6039      	str	r1, [r7, #0]
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   88ef2:	687b      	ldr	r3, [r7, #4]
   88ef4:	685b      	ldr	r3, [r3, #4]
   88ef6:	60fb      	str	r3, [r7, #12]
   88ef8:	68fb      	ldr	r3, [r7, #12]
   88efa:	2b00      	cmp	r3, #0
   88efc:	d010      	beq.n	88f20 <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x38>
		int ret = node->getDescriptor(setup);
   88efe:	68fb      	ldr	r3, [r7, #12]
   88f00:	681b      	ldr	r3, [r3, #0]
   88f02:	3308      	adds	r3, #8
   88f04:	681b      	ldr	r3, [r3, #0]
   88f06:	6839      	ldr	r1, [r7, #0]
   88f08:	68f8      	ldr	r0, [r7, #12]
   88f0a:	4798      	blx	r3
   88f0c:	60b8      	str	r0, [r7, #8]
		// ret!=0 -> request has been processed
		if (ret)
   88f0e:	68bb      	ldr	r3, [r7, #8]
   88f10:	2b00      	cmp	r3, #0
   88f12:	d001      	beq.n	88f18 <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x30>
			return ret;
   88f14:	68bb      	ldr	r3, [r7, #8]
   88f16:	e004      	b.n	88f22 <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x3a>
}

int PluggableUSB_::getDescriptor(USBSetup& setup)
{
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   88f18:	68fb      	ldr	r3, [r7, #12]
   88f1a:	68db      	ldr	r3, [r3, #12]
   88f1c:	60fb      	str	r3, [r7, #12]
   88f1e:	e7eb      	b.n	88ef8 <_ZN13PluggableUSB_13getDescriptorER8USBSetup+0x10>
		int ret = node->getDescriptor(setup);
		// ret!=0 -> request has been processed
		if (ret)
			return ret;
	}
	return 0;
   88f20:	2300      	movs	r3, #0
}
   88f22:	4618      	mov	r0, r3
   88f24:	3710      	adds	r7, #16
   88f26:	46bd      	mov	sp, r7
   88f28:	bd80      	pop	{r7, pc}
   88f2a:	bf00      	nop

00088f2c <_ZN13PluggableUSB_12getShortNameEPc>:

void PluggableUSB_::getShortName(char *iSerialNum)
{
   88f2c:	b580      	push	{r7, lr}
   88f2e:	b084      	sub	sp, #16
   88f30:	af00      	add	r7, sp, #0
   88f32:	6078      	str	r0, [r7, #4]
   88f34:	6039      	str	r1, [r7, #0]
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   88f36:	687b      	ldr	r3, [r7, #4]
   88f38:	685b      	ldr	r3, [r3, #4]
   88f3a:	60fb      	str	r3, [r7, #12]
   88f3c:	68fb      	ldr	r3, [r7, #12]
   88f3e:	2b00      	cmp	r3, #0
   88f40:	d00f      	beq.n	88f62 <_ZN13PluggableUSB_12getShortNameEPc+0x36>
		iSerialNum += node->getShortName(iSerialNum);
   88f42:	68fb      	ldr	r3, [r7, #12]
   88f44:	681b      	ldr	r3, [r3, #0]
   88f46:	330c      	adds	r3, #12
   88f48:	681b      	ldr	r3, [r3, #0]
   88f4a:	6839      	ldr	r1, [r7, #0]
   88f4c:	68f8      	ldr	r0, [r7, #12]
   88f4e:	4798      	blx	r3
   88f50:	4603      	mov	r3, r0
   88f52:	461a      	mov	r2, r3
   88f54:	683b      	ldr	r3, [r7, #0]
   88f56:	4413      	add	r3, r2
   88f58:	603b      	str	r3, [r7, #0]
}

void PluggableUSB_::getShortName(char *iSerialNum)
{
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   88f5a:	68fb      	ldr	r3, [r7, #12]
   88f5c:	68db      	ldr	r3, [r3, #12]
   88f5e:	60fb      	str	r3, [r7, #12]
   88f60:	e7ec      	b.n	88f3c <_ZN13PluggableUSB_12getShortNameEPc+0x10>
		iSerialNum += node->getShortName(iSerialNum);
	}
	*iSerialNum = 0;
   88f62:	683b      	ldr	r3, [r7, #0]
   88f64:	2200      	movs	r2, #0
   88f66:	701a      	strb	r2, [r3, #0]
}
   88f68:	bf00      	nop
   88f6a:	3710      	adds	r7, #16
   88f6c:	46bd      	mov	sp, r7
   88f6e:	bd80      	pop	{r7, pc}

00088f70 <_ZN13PluggableUSB_5setupER8USBSetup>:

bool PluggableUSB_::setup(USBSetup& setup)
{
   88f70:	b580      	push	{r7, lr}
   88f72:	b084      	sub	sp, #16
   88f74:	af00      	add	r7, sp, #0
   88f76:	6078      	str	r0, [r7, #4]
   88f78:	6039      	str	r1, [r7, #0]
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   88f7a:	687b      	ldr	r3, [r7, #4]
   88f7c:	685b      	ldr	r3, [r3, #4]
   88f7e:	60fb      	str	r3, [r7, #12]
   88f80:	68fb      	ldr	r3, [r7, #12]
   88f82:	2b00      	cmp	r3, #0
   88f84:	d00e      	beq.n	88fa4 <_ZN13PluggableUSB_5setupER8USBSetup+0x34>
		if (node->setup(setup)) {
   88f86:	68fb      	ldr	r3, [r7, #12]
   88f88:	681b      	ldr	r3, [r3, #0]
   88f8a:	681b      	ldr	r3, [r3, #0]
   88f8c:	6839      	ldr	r1, [r7, #0]
   88f8e:	68f8      	ldr	r0, [r7, #12]
   88f90:	4798      	blx	r3
   88f92:	4603      	mov	r3, r0
   88f94:	2b00      	cmp	r3, #0
   88f96:	d001      	beq.n	88f9c <_ZN13PluggableUSB_5setupER8USBSetup+0x2c>
			return true;
   88f98:	2301      	movs	r3, #1
   88f9a:	e004      	b.n	88fa6 <_ZN13PluggableUSB_5setupER8USBSetup+0x36>
}

bool PluggableUSB_::setup(USBSetup& setup)
{
	PluggableUSBModule* node;
	for (node = rootNode; node; node = node->next) {
   88f9c:	68fb      	ldr	r3, [r7, #12]
   88f9e:	68db      	ldr	r3, [r3, #12]
   88fa0:	60fb      	str	r3, [r7, #12]
   88fa2:	e7ed      	b.n	88f80 <_ZN13PluggableUSB_5setupER8USBSetup+0x10>
		if (node->setup(setup)) {
			return true;
		}
	}
	return false;
   88fa4:	2300      	movs	r3, #0
}
   88fa6:	4618      	mov	r0, r3
   88fa8:	3710      	adds	r7, #16
   88faa:	46bd      	mov	sp, r7
   88fac:	bd80      	pop	{r7, pc}
   88fae:	bf00      	nop

00088fb0 <_Z12PluggableUSBv>:
	return true;
	// restart USB layer???
}

PluggableUSB_& PluggableUSB()
{
   88fb0:	b580      	push	{r7, lr}
   88fb2:	af00      	add	r7, sp, #0
	static PluggableUSB_ obj;
   88fb4:	4b07      	ldr	r3, [pc, #28]	; (88fd4 <_Z12PluggableUSBv+0x24>)
   88fb6:	681b      	ldr	r3, [r3, #0]
   88fb8:	f003 0301 	and.w	r3, r3, #1
   88fbc:	2b00      	cmp	r3, #0
   88fbe:	d105      	bne.n	88fcc <_Z12PluggableUSBv+0x1c>
   88fc0:	4805      	ldr	r0, [pc, #20]	; (88fd8 <_Z12PluggableUSBv+0x28>)
   88fc2:	4b06      	ldr	r3, [pc, #24]	; (88fdc <_Z12PluggableUSBv+0x2c>)
   88fc4:	4798      	blx	r3
   88fc6:	4b03      	ldr	r3, [pc, #12]	; (88fd4 <_Z12PluggableUSBv+0x24>)
   88fc8:	2201      	movs	r2, #1
   88fca:	601a      	str	r2, [r3, #0]
	return obj;
   88fcc:	4b02      	ldr	r3, [pc, #8]	; (88fd8 <_Z12PluggableUSBv+0x28>)
}
   88fce:	4618      	mov	r0, r3
   88fd0:	bd80      	pop	{r7, pc}
   88fd2:	bf00      	nop
   88fd4:	2007189c 	.word	0x2007189c
   88fd8:	200718a0 	.word	0x200718a0
   88fdc:	00088fe1 	.word	0x00088fe1

00088fe0 <_ZN13PluggableUSB_C1Ev>:

PluggableUSB_::PluggableUSB_() : lastIf(CDC_ACM_INTERFACE + CDC_INTERFACE_COUNT),
   88fe0:	b480      	push	{r7}
   88fe2:	b083      	sub	sp, #12
   88fe4:	af00      	add	r7, sp, #0
   88fe6:	6078      	str	r0, [r7, #4]
                                 lastEp(CDC_FIRST_ENDPOINT + CDC_ENPOINT_COUNT),
                                 rootNode(NULL)
   88fe8:	687b      	ldr	r3, [r7, #4]
   88fea:	2202      	movs	r2, #2
   88fec:	701a      	strb	r2, [r3, #0]
   88fee:	687b      	ldr	r3, [r7, #4]
   88ff0:	2204      	movs	r2, #4
   88ff2:	705a      	strb	r2, [r3, #1]
   88ff4:	687b      	ldr	r3, [r7, #4]
   88ff6:	2200      	movs	r2, #0
   88ff8:	605a      	str	r2, [r3, #4]
{
	// Empty
}
   88ffa:	687b      	ldr	r3, [r7, #4]
   88ffc:	4618      	mov	r0, r3
   88ffe:	370c      	adds	r7, #12
   89000:	46bd      	mov	sp, r7
   89002:	bc80      	pop	{r7}
   89004:	4770      	bx	lr
   89006:	bf00      	nop

00089008 <_ZN6StringC1EPKc>:

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr)
   89008:	b580      	push	{r7, lr}
   8900a:	b082      	sub	sp, #8
   8900c:	af00      	add	r7, sp, #0
   8900e:	6078      	str	r0, [r7, #4]
   89010:	6039      	str	r1, [r7, #0]
{
	init();
   89012:	6878      	ldr	r0, [r7, #4]
   89014:	4b09      	ldr	r3, [pc, #36]	; (8903c <_ZN6StringC1EPKc+0x34>)
   89016:	4798      	blx	r3
	if (cstr) copy(cstr, strlen(cstr));
   89018:	683b      	ldr	r3, [r7, #0]
   8901a:	2b00      	cmp	r3, #0
   8901c:	d008      	beq.n	89030 <_ZN6StringC1EPKc+0x28>
   8901e:	6838      	ldr	r0, [r7, #0]
   89020:	4b07      	ldr	r3, [pc, #28]	; (89040 <_ZN6StringC1EPKc+0x38>)
   89022:	4798      	blx	r3
   89024:	4603      	mov	r3, r0
   89026:	461a      	mov	r2, r3
   89028:	6839      	ldr	r1, [r7, #0]
   8902a:	6878      	ldr	r0, [r7, #4]
   8902c:	4b05      	ldr	r3, [pc, #20]	; (89044 <_ZN6StringC1EPKc+0x3c>)
   8902e:	4798      	blx	r3
}
   89030:	687b      	ldr	r3, [r7, #4]
   89032:	4618      	mov	r0, r3
   89034:	3708      	adds	r7, #8
   89036:	46bd      	mov	sp, r7
   89038:	bd80      	pop	{r7, pc}
   8903a:	bf00      	nop
   8903c:	00089165 	.word	0x00089165
   89040:	00094349 	.word	0x00094349
   89044:	00089261 	.word	0x00089261

00089048 <_ZN6StringC1ERKS_>:

String::String(const String &value)
   89048:	b580      	push	{r7, lr}
   8904a:	b082      	sub	sp, #8
   8904c:	af00      	add	r7, sp, #0
   8904e:	6078      	str	r0, [r7, #4]
   89050:	6039      	str	r1, [r7, #0]
{
	init();
   89052:	6878      	ldr	r0, [r7, #4]
   89054:	4b05      	ldr	r3, [pc, #20]	; (8906c <_ZN6StringC1ERKS_+0x24>)
   89056:	4798      	blx	r3
	*this = value;
   89058:	6839      	ldr	r1, [r7, #0]
   8905a:	6878      	ldr	r0, [r7, #4]
   8905c:	4b04      	ldr	r3, [pc, #16]	; (89070 <_ZN6StringC1ERKS_+0x28>)
   8905e:	4798      	blx	r3
}
   89060:	687b      	ldr	r3, [r7, #4]
   89062:	4618      	mov	r0, r3
   89064:	3708      	adds	r7, #8
   89066:	46bd      	mov	sp, r7
   89068:	bd80      	pop	{r7, pc}
   8906a:	bf00      	nop
   8906c:	00089165 	.word	0x00089165
   89070:	000892b9 	.word	0x000892b9

00089074 <_ZN6StringC1Ehh>:
	buf[0] = c;
	buf[1] = 0;
	*this = buf;
}

String::String(unsigned char value, unsigned char base)
   89074:	b580      	push	{r7, lr}
   89076:	b086      	sub	sp, #24
   89078:	af00      	add	r7, sp, #0
   8907a:	6078      	str	r0, [r7, #4]
   8907c:	460b      	mov	r3, r1
   8907e:	70fb      	strb	r3, [r7, #3]
   89080:	4613      	mov	r3, r2
   89082:	70bb      	strb	r3, [r7, #2]
{
	init();
   89084:	6878      	ldr	r0, [r7, #4]
   89086:	4b0a      	ldr	r3, [pc, #40]	; (890b0 <_ZN6StringC1Ehh+0x3c>)
   89088:	4798      	blx	r3
	char buf[1 + 8 * sizeof(unsigned char)];
	utoa(value, buf, base);
   8908a:	78fb      	ldrb	r3, [r7, #3]
   8908c:	78ba      	ldrb	r2, [r7, #2]
   8908e:	f107 010c 	add.w	r1, r7, #12
   89092:	4618      	mov	r0, r3
   89094:	4b07      	ldr	r3, [pc, #28]	; (890b4 <_ZN6StringC1Ehh+0x40>)
   89096:	4798      	blx	r3
	*this = buf;
   89098:	f107 030c 	add.w	r3, r7, #12
   8909c:	4619      	mov	r1, r3
   8909e:	6878      	ldr	r0, [r7, #4]
   890a0:	4b05      	ldr	r3, [pc, #20]	; (890b8 <_ZN6StringC1Ehh+0x44>)
   890a2:	4798      	blx	r3
}
   890a4:	687b      	ldr	r3, [r7, #4]
   890a6:	4618      	mov	r0, r3
   890a8:	3718      	adds	r7, #24
   890aa:	46bd      	mov	sp, r7
   890ac:	bd80      	pop	{r7, pc}
   890ae:	bf00      	nop
   890b0:	00089165 	.word	0x00089165
   890b4:	0008fe09 	.word	0x0008fe09
   890b8:	00089301 	.word	0x00089301

000890bc <_ZN6StringC1Eih>:

String::String(int value, unsigned char base)
   890bc:	b580      	push	{r7, lr}
   890be:	b08e      	sub	sp, #56	; 0x38
   890c0:	af00      	add	r7, sp, #0
   890c2:	60f8      	str	r0, [r7, #12]
   890c4:	60b9      	str	r1, [r7, #8]
   890c6:	4613      	mov	r3, r2
   890c8:	71fb      	strb	r3, [r7, #7]
{
	init();
   890ca:	68f8      	ldr	r0, [r7, #12]
   890cc:	4b09      	ldr	r3, [pc, #36]	; (890f4 <_ZN6StringC1Eih+0x38>)
   890ce:	4798      	blx	r3
	char buf[2 + 8 * sizeof(int)];
	itoa(value, buf, base);
   890d0:	79fa      	ldrb	r2, [r7, #7]
   890d2:	f107 0314 	add.w	r3, r7, #20
   890d6:	4619      	mov	r1, r3
   890d8:	68b8      	ldr	r0, [r7, #8]
   890da:	4b07      	ldr	r3, [pc, #28]	; (890f8 <_ZN6StringC1Eih+0x3c>)
   890dc:	4798      	blx	r3
	*this = buf;
   890de:	f107 0314 	add.w	r3, r7, #20
   890e2:	4619      	mov	r1, r3
   890e4:	68f8      	ldr	r0, [r7, #12]
   890e6:	4b05      	ldr	r3, [pc, #20]	; (890fc <_ZN6StringC1Eih+0x40>)
   890e8:	4798      	blx	r3
}
   890ea:	68fb      	ldr	r3, [r7, #12]
   890ec:	4618      	mov	r0, r3
   890ee:	3738      	adds	r7, #56	; 0x38
   890f0:	46bd      	mov	sp, r7
   890f2:	bd80      	pop	{r7, pc}
   890f4:	00089165 	.word	0x00089165
   890f8:	0008fcf9 	.word	0x0008fcf9
   890fc:	00089301 	.word	0x00089301

00089100 <_ZN6StringC1Emh>:
	char buf[2 + 8 * sizeof(long)];
	ltoa(value, buf, base);
	*this = buf;
}

String::String(unsigned long value, unsigned char base)
   89100:	b580      	push	{r7, lr}
   89102:	b08e      	sub	sp, #56	; 0x38
   89104:	af00      	add	r7, sp, #0
   89106:	60f8      	str	r0, [r7, #12]
   89108:	60b9      	str	r1, [r7, #8]
   8910a:	4613      	mov	r3, r2
   8910c:	71fb      	strb	r3, [r7, #7]
{
	init();
   8910e:	68f8      	ldr	r0, [r7, #12]
   89110:	4b09      	ldr	r3, [pc, #36]	; (89138 <_ZN6StringC1Emh+0x38>)
   89112:	4798      	blx	r3
	char buf[1 + 8 * sizeof(unsigned long)];
	ultoa(value, buf, base);
   89114:	79fa      	ldrb	r2, [r7, #7]
   89116:	f107 0314 	add.w	r3, r7, #20
   8911a:	4619      	mov	r1, r3
   8911c:	68b8      	ldr	r0, [r7, #8]
   8911e:	4b07      	ldr	r3, [pc, #28]	; (8913c <_ZN6StringC1Emh+0x3c>)
   89120:	4798      	blx	r3
	*this = buf;
   89122:	f107 0314 	add.w	r3, r7, #20
   89126:	4619      	mov	r1, r3
   89128:	68f8      	ldr	r0, [r7, #12]
   8912a:	4b05      	ldr	r3, [pc, #20]	; (89140 <_ZN6StringC1Emh+0x40>)
   8912c:	4798      	blx	r3
}
   8912e:	68fb      	ldr	r3, [r7, #12]
   89130:	4618      	mov	r0, r3
   89132:	3738      	adds	r7, #56	; 0x38
   89134:	46bd      	mov	sp, r7
   89136:	bd80      	pop	{r7, pc}
   89138:	00089165 	.word	0x00089165
   8913c:	0008fe2d 	.word	0x0008fe2d
   89140:	00089301 	.word	0x00089301

00089144 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	*this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String()
   89144:	b580      	push	{r7, lr}
   89146:	b082      	sub	sp, #8
   89148:	af00      	add	r7, sp, #0
   8914a:	6078      	str	r0, [r7, #4]
{
	free(buffer);
   8914c:	687b      	ldr	r3, [r7, #4]
   8914e:	681b      	ldr	r3, [r3, #0]
   89150:	4618      	mov	r0, r3
   89152:	4b03      	ldr	r3, [pc, #12]	; (89160 <_ZN6StringD1Ev+0x1c>)
   89154:	4798      	blx	r3
}
   89156:	687b      	ldr	r3, [r7, #4]
   89158:	4618      	mov	r0, r3
   8915a:	3708      	adds	r7, #8
   8915c:	46bd      	mov	sp, r7
   8915e:	bd80      	pop	{r7, pc}
   89160:	00093545 	.word	0x00093545

00089164 <_ZN6String4initEv>:
/*********************************************/
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
   89164:	b480      	push	{r7}
   89166:	b083      	sub	sp, #12
   89168:	af00      	add	r7, sp, #0
   8916a:	6078      	str	r0, [r7, #4]
	buffer = NULL;
   8916c:	687b      	ldr	r3, [r7, #4]
   8916e:	2200      	movs	r2, #0
   89170:	601a      	str	r2, [r3, #0]
	capacity = 0;
   89172:	687b      	ldr	r3, [r7, #4]
   89174:	2200      	movs	r2, #0
   89176:	605a      	str	r2, [r3, #4]
	len = 0;
   89178:	687b      	ldr	r3, [r7, #4]
   8917a:	2200      	movs	r2, #0
   8917c:	609a      	str	r2, [r3, #8]
}
   8917e:	bf00      	nop
   89180:	370c      	adds	r7, #12
   89182:	46bd      	mov	sp, r7
   89184:	bc80      	pop	{r7}
   89186:	4770      	bx	lr

00089188 <_ZN6String10invalidateEv>:

void String::invalidate(void)
{
   89188:	b580      	push	{r7, lr}
   8918a:	b082      	sub	sp, #8
   8918c:	af00      	add	r7, sp, #0
   8918e:	6078      	str	r0, [r7, #4]
	if (buffer) free(buffer);
   89190:	687b      	ldr	r3, [r7, #4]
   89192:	681b      	ldr	r3, [r3, #0]
   89194:	2b00      	cmp	r3, #0
   89196:	d004      	beq.n	891a2 <_ZN6String10invalidateEv+0x1a>
   89198:	687b      	ldr	r3, [r7, #4]
   8919a:	681b      	ldr	r3, [r3, #0]
   8919c:	4618      	mov	r0, r3
   8919e:	4b08      	ldr	r3, [pc, #32]	; (891c0 <_ZN6String10invalidateEv+0x38>)
   891a0:	4798      	blx	r3
	buffer = NULL;
   891a2:	687b      	ldr	r3, [r7, #4]
   891a4:	2200      	movs	r2, #0
   891a6:	601a      	str	r2, [r3, #0]
	capacity = len = 0;
   891a8:	687b      	ldr	r3, [r7, #4]
   891aa:	2200      	movs	r2, #0
   891ac:	609a      	str	r2, [r3, #8]
   891ae:	687b      	ldr	r3, [r7, #4]
   891b0:	689a      	ldr	r2, [r3, #8]
   891b2:	687b      	ldr	r3, [r7, #4]
   891b4:	605a      	str	r2, [r3, #4]
}
   891b6:	bf00      	nop
   891b8:	3708      	adds	r7, #8
   891ba:	46bd      	mov	sp, r7
   891bc:	bd80      	pop	{r7, pc}
   891be:	bf00      	nop
   891c0:	00093545 	.word	0x00093545

000891c4 <_ZN6String7reserveEj>:

unsigned char String::reserve(unsigned int size)
{
   891c4:	b580      	push	{r7, lr}
   891c6:	b082      	sub	sp, #8
   891c8:	af00      	add	r7, sp, #0
   891ca:	6078      	str	r0, [r7, #4]
   891cc:	6039      	str	r1, [r7, #0]
	if (buffer && capacity >= size) return 1;
   891ce:	687b      	ldr	r3, [r7, #4]
   891d0:	681b      	ldr	r3, [r3, #0]
   891d2:	2b00      	cmp	r3, #0
   891d4:	d006      	beq.n	891e4 <_ZN6String7reserveEj+0x20>
   891d6:	687b      	ldr	r3, [r7, #4]
   891d8:	685a      	ldr	r2, [r3, #4]
   891da:	683b      	ldr	r3, [r7, #0]
   891dc:	429a      	cmp	r2, r3
   891de:	d301      	bcc.n	891e4 <_ZN6String7reserveEj+0x20>
   891e0:	2301      	movs	r3, #1
   891e2:	e016      	b.n	89212 <_ZN6String7reserveEj+0x4e>
	if (changeBuffer(size)) {
   891e4:	6839      	ldr	r1, [r7, #0]
   891e6:	6878      	ldr	r0, [r7, #4]
   891e8:	4b0c      	ldr	r3, [pc, #48]	; (8921c <_ZN6String7reserveEj+0x58>)
   891ea:	4798      	blx	r3
   891ec:	4603      	mov	r3, r0
   891ee:	2b00      	cmp	r3, #0
   891f0:	bf14      	ite	ne
   891f2:	2301      	movne	r3, #1
   891f4:	2300      	moveq	r3, #0
   891f6:	b2db      	uxtb	r3, r3
   891f8:	2b00      	cmp	r3, #0
   891fa:	d009      	beq.n	89210 <_ZN6String7reserveEj+0x4c>
		if (len == 0) buffer[0] = 0;
   891fc:	687b      	ldr	r3, [r7, #4]
   891fe:	689b      	ldr	r3, [r3, #8]
   89200:	2b00      	cmp	r3, #0
   89202:	d103      	bne.n	8920c <_ZN6String7reserveEj+0x48>
   89204:	687b      	ldr	r3, [r7, #4]
   89206:	681b      	ldr	r3, [r3, #0]
   89208:	2200      	movs	r2, #0
   8920a:	701a      	strb	r2, [r3, #0]
		return 1;
   8920c:	2301      	movs	r3, #1
   8920e:	e000      	b.n	89212 <_ZN6String7reserveEj+0x4e>
	}
	return 0;
   89210:	2300      	movs	r3, #0
}
   89212:	4618      	mov	r0, r3
   89214:	3708      	adds	r7, #8
   89216:	46bd      	mov	sp, r7
   89218:	bd80      	pop	{r7, pc}
   8921a:	bf00      	nop
   8921c:	00089221 	.word	0x00089221

00089220 <_ZN6String12changeBufferEj>:

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
   89220:	b580      	push	{r7, lr}
   89222:	b084      	sub	sp, #16
   89224:	af00      	add	r7, sp, #0
   89226:	6078      	str	r0, [r7, #4]
   89228:	6039      	str	r1, [r7, #0]
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
   8922a:	687b      	ldr	r3, [r7, #4]
   8922c:	681a      	ldr	r2, [r3, #0]
   8922e:	683b      	ldr	r3, [r7, #0]
   89230:	3301      	adds	r3, #1
   89232:	4619      	mov	r1, r3
   89234:	4610      	mov	r0, r2
   89236:	4b09      	ldr	r3, [pc, #36]	; (8925c <_ZN6String12changeBufferEj+0x3c>)
   89238:	4798      	blx	r3
   8923a:	60f8      	str	r0, [r7, #12]
	if (newbuffer) {
   8923c:	68fb      	ldr	r3, [r7, #12]
   8923e:	2b00      	cmp	r3, #0
   89240:	d007      	beq.n	89252 <_ZN6String12changeBufferEj+0x32>
		buffer = newbuffer;
   89242:	687b      	ldr	r3, [r7, #4]
   89244:	68fa      	ldr	r2, [r7, #12]
   89246:	601a      	str	r2, [r3, #0]
		capacity = maxStrLen;
   89248:	687b      	ldr	r3, [r7, #4]
   8924a:	683a      	ldr	r2, [r7, #0]
   8924c:	605a      	str	r2, [r3, #4]
		return 1;
   8924e:	2301      	movs	r3, #1
   89250:	e000      	b.n	89254 <_ZN6String12changeBufferEj+0x34>
	}
	return 0;
   89252:	2300      	movs	r3, #0
}
   89254:	4618      	mov	r0, r3
   89256:	3710      	adds	r7, #16
   89258:	46bd      	mov	sp, r7
   8925a:	bd80      	pop	{r7, pc}
   8925c:	00093d69 	.word	0x00093d69

00089260 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
   89260:	b580      	push	{r7, lr}
   89262:	b084      	sub	sp, #16
   89264:	af00      	add	r7, sp, #0
   89266:	60f8      	str	r0, [r7, #12]
   89268:	60b9      	str	r1, [r7, #8]
   8926a:	607a      	str	r2, [r7, #4]
	if (!reserve(length)) {
   8926c:	6879      	ldr	r1, [r7, #4]
   8926e:	68f8      	ldr	r0, [r7, #12]
   89270:	4b0e      	ldr	r3, [pc, #56]	; (892ac <_ZN6String4copyEPKcj+0x4c>)
   89272:	4798      	blx	r3
   89274:	4603      	mov	r3, r0
   89276:	2b00      	cmp	r3, #0
   89278:	bf0c      	ite	eq
   8927a:	2301      	moveq	r3, #1
   8927c:	2300      	movne	r3, #0
   8927e:	b2db      	uxtb	r3, r3
   89280:	2b00      	cmp	r3, #0
   89282:	d004      	beq.n	8928e <_ZN6String4copyEPKcj+0x2e>
		invalidate();
   89284:	68f8      	ldr	r0, [r7, #12]
   89286:	4b0a      	ldr	r3, [pc, #40]	; (892b0 <_ZN6String4copyEPKcj+0x50>)
   89288:	4798      	blx	r3
		return *this;
   8928a:	68fb      	ldr	r3, [r7, #12]
   8928c:	e009      	b.n	892a2 <_ZN6String4copyEPKcj+0x42>
	}
	len = length;
   8928e:	68fb      	ldr	r3, [r7, #12]
   89290:	687a      	ldr	r2, [r7, #4]
   89292:	609a      	str	r2, [r3, #8]
	strcpy(buffer, cstr);
   89294:	68fb      	ldr	r3, [r7, #12]
   89296:	681b      	ldr	r3, [r3, #0]
   89298:	68b9      	ldr	r1, [r7, #8]
   8929a:	4618      	mov	r0, r3
   8929c:	4b05      	ldr	r3, [pc, #20]	; (892b4 <_ZN6String4copyEPKcj+0x54>)
   8929e:	4798      	blx	r3
	return *this;
   892a0:	68fb      	ldr	r3, [r7, #12]
}
   892a2:	4618      	mov	r0, r3
   892a4:	3710      	adds	r7, #16
   892a6:	46bd      	mov	sp, r7
   892a8:	bd80      	pop	{r7, pc}
   892aa:	bf00      	nop
   892ac:	000891c5 	.word	0x000891c5
   892b0:	00089189 	.word	0x00089189
   892b4:	0009428d 	.word	0x0009428d

000892b8 <_ZN6StringaSERKS_>:
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
   892b8:	b580      	push	{r7, lr}
   892ba:	b082      	sub	sp, #8
   892bc:	af00      	add	r7, sp, #0
   892be:	6078      	str	r0, [r7, #4]
   892c0:	6039      	str	r1, [r7, #0]
	if (this == &rhs) return *this;
   892c2:	687a      	ldr	r2, [r7, #4]
   892c4:	683b      	ldr	r3, [r7, #0]
   892c6:	429a      	cmp	r2, r3
   892c8:	d101      	bne.n	892ce <_ZN6StringaSERKS_+0x16>
   892ca:	687b      	ldr	r3, [r7, #4]
   892cc:	e010      	b.n	892f0 <_ZN6StringaSERKS_+0x38>
	
	if (rhs.buffer) copy(rhs.buffer, rhs.len);
   892ce:	683b      	ldr	r3, [r7, #0]
   892d0:	681b      	ldr	r3, [r3, #0]
   892d2:	2b00      	cmp	r3, #0
   892d4:	d008      	beq.n	892e8 <_ZN6StringaSERKS_+0x30>
   892d6:	683b      	ldr	r3, [r7, #0]
   892d8:	6819      	ldr	r1, [r3, #0]
   892da:	683b      	ldr	r3, [r7, #0]
   892dc:	689b      	ldr	r3, [r3, #8]
   892de:	461a      	mov	r2, r3
   892e0:	6878      	ldr	r0, [r7, #4]
   892e2:	4b05      	ldr	r3, [pc, #20]	; (892f8 <_ZN6StringaSERKS_+0x40>)
   892e4:	4798      	blx	r3
   892e6:	e002      	b.n	892ee <_ZN6StringaSERKS_+0x36>
	else invalidate();
   892e8:	6878      	ldr	r0, [r7, #4]
   892ea:	4b04      	ldr	r3, [pc, #16]	; (892fc <_ZN6StringaSERKS_+0x44>)
   892ec:	4798      	blx	r3
	
	return *this;
   892ee:	687b      	ldr	r3, [r7, #4]
}
   892f0:	4618      	mov	r0, r3
   892f2:	3708      	adds	r7, #8
   892f4:	46bd      	mov	sp, r7
   892f6:	bd80      	pop	{r7, pc}
   892f8:	00089261 	.word	0x00089261
   892fc:	00089189 	.word	0x00089189

00089300 <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
   89300:	b580      	push	{r7, lr}
   89302:	b082      	sub	sp, #8
   89304:	af00      	add	r7, sp, #0
   89306:	6078      	str	r0, [r7, #4]
   89308:	6039      	str	r1, [r7, #0]
	if (cstr) copy(cstr, strlen(cstr));
   8930a:	683b      	ldr	r3, [r7, #0]
   8930c:	2b00      	cmp	r3, #0
   8930e:	d009      	beq.n	89324 <_ZN6StringaSEPKc+0x24>
   89310:	6838      	ldr	r0, [r7, #0]
   89312:	4b08      	ldr	r3, [pc, #32]	; (89334 <_ZN6StringaSEPKc+0x34>)
   89314:	4798      	blx	r3
   89316:	4603      	mov	r3, r0
   89318:	461a      	mov	r2, r3
   8931a:	6839      	ldr	r1, [r7, #0]
   8931c:	6878      	ldr	r0, [r7, #4]
   8931e:	4b06      	ldr	r3, [pc, #24]	; (89338 <_ZN6StringaSEPKc+0x38>)
   89320:	4798      	blx	r3
   89322:	e002      	b.n	8932a <_ZN6StringaSEPKc+0x2a>
	else invalidate();
   89324:	6878      	ldr	r0, [r7, #4]
   89326:	4b05      	ldr	r3, [pc, #20]	; (8933c <_ZN6StringaSEPKc+0x3c>)
   89328:	4798      	blx	r3
	
	return *this;
   8932a:	687b      	ldr	r3, [r7, #4]
}
   8932c:	4618      	mov	r0, r3
   8932e:	3708      	adds	r7, #8
   89330:	46bd      	mov	sp, r7
   89332:	bd80      	pop	{r7, pc}
   89334:	00094349 	.word	0x00094349
   89338:	00089261 	.word	0x00089261
   8933c:	00089189 	.word	0x00089189

00089340 <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
   89340:	b580      	push	{r7, lr}
   89342:	b086      	sub	sp, #24
   89344:	af00      	add	r7, sp, #0
   89346:	60f8      	str	r0, [r7, #12]
   89348:	60b9      	str	r1, [r7, #8]
   8934a:	607a      	str	r2, [r7, #4]
	unsigned int newlen = len + length;
   8934c:	68fb      	ldr	r3, [r7, #12]
   8934e:	689a      	ldr	r2, [r3, #8]
   89350:	687b      	ldr	r3, [r7, #4]
   89352:	4413      	add	r3, r2
   89354:	617b      	str	r3, [r7, #20]
	if (!cstr) return 0;
   89356:	68bb      	ldr	r3, [r7, #8]
   89358:	2b00      	cmp	r3, #0
   8935a:	d101      	bne.n	89360 <_ZN6String6concatEPKcj+0x20>
   8935c:	2300      	movs	r3, #0
   8935e:	e01f      	b.n	893a0 <_ZN6String6concatEPKcj+0x60>
	if (length == 0) return 1;
   89360:	687b      	ldr	r3, [r7, #4]
   89362:	2b00      	cmp	r3, #0
   89364:	d101      	bne.n	8936a <_ZN6String6concatEPKcj+0x2a>
   89366:	2301      	movs	r3, #1
   89368:	e01a      	b.n	893a0 <_ZN6String6concatEPKcj+0x60>
	if (!reserve(newlen)) return 0;
   8936a:	6979      	ldr	r1, [r7, #20]
   8936c:	68f8      	ldr	r0, [r7, #12]
   8936e:	4b0e      	ldr	r3, [pc, #56]	; (893a8 <_ZN6String6concatEPKcj+0x68>)
   89370:	4798      	blx	r3
   89372:	4603      	mov	r3, r0
   89374:	2b00      	cmp	r3, #0
   89376:	bf0c      	ite	eq
   89378:	2301      	moveq	r3, #1
   8937a:	2300      	movne	r3, #0
   8937c:	b2db      	uxtb	r3, r3
   8937e:	2b00      	cmp	r3, #0
   89380:	d001      	beq.n	89386 <_ZN6String6concatEPKcj+0x46>
   89382:	2300      	movs	r3, #0
   89384:	e00c      	b.n	893a0 <_ZN6String6concatEPKcj+0x60>
	strcpy(buffer + len, cstr);
   89386:	68fb      	ldr	r3, [r7, #12]
   89388:	681a      	ldr	r2, [r3, #0]
   8938a:	68fb      	ldr	r3, [r7, #12]
   8938c:	689b      	ldr	r3, [r3, #8]
   8938e:	4413      	add	r3, r2
   89390:	68b9      	ldr	r1, [r7, #8]
   89392:	4618      	mov	r0, r3
   89394:	4b05      	ldr	r3, [pc, #20]	; (893ac <_ZN6String6concatEPKcj+0x6c>)
   89396:	4798      	blx	r3
	len = newlen;
   89398:	68fb      	ldr	r3, [r7, #12]
   8939a:	697a      	ldr	r2, [r7, #20]
   8939c:	609a      	str	r2, [r3, #8]
	return 1;
   8939e:	2301      	movs	r3, #1
}
   893a0:	4618      	mov	r0, r3
   893a2:	3718      	adds	r7, #24
   893a4:	46bd      	mov	sp, r7
   893a6:	bd80      	pop	{r7, pc}
   893a8:	000891c5 	.word	0x000891c5
   893ac:	0009428d 	.word	0x0009428d

000893b0 <_ZN6String6concatEh>:
	buf[1] = 0;
	return concat(buf, 1);
}

unsigned char String::concat(unsigned char num)
{
   893b0:	b580      	push	{r7, lr}
   893b2:	b084      	sub	sp, #16
   893b4:	af00      	add	r7, sp, #0
   893b6:	6078      	str	r0, [r7, #4]
   893b8:	460b      	mov	r3, r1
   893ba:	70fb      	strb	r3, [r7, #3]
	char buf[1 + 3 * sizeof(unsigned char)];
	itoa(num, buf, 10);
   893bc:	78fb      	ldrb	r3, [r7, #3]
   893be:	f107 010c 	add.w	r1, r7, #12
   893c2:	220a      	movs	r2, #10
   893c4:	4618      	mov	r0, r3
   893c6:	4b09      	ldr	r3, [pc, #36]	; (893ec <_ZN6String6concatEh+0x3c>)
   893c8:	4798      	blx	r3
	return concat(buf, strlen(buf));
   893ca:	f107 030c 	add.w	r3, r7, #12
   893ce:	4618      	mov	r0, r3
   893d0:	4b07      	ldr	r3, [pc, #28]	; (893f0 <_ZN6String6concatEh+0x40>)
   893d2:	4798      	blx	r3
   893d4:	4602      	mov	r2, r0
   893d6:	f107 030c 	add.w	r3, r7, #12
   893da:	4619      	mov	r1, r3
   893dc:	6878      	ldr	r0, [r7, #4]
   893de:	4b05      	ldr	r3, [pc, #20]	; (893f4 <_ZN6String6concatEh+0x44>)
   893e0:	4798      	blx	r3
   893e2:	4603      	mov	r3, r0
}
   893e4:	4618      	mov	r0, r3
   893e6:	3710      	adds	r7, #16
   893e8:	46bd      	mov	sp, r7
   893ea:	bd80      	pop	{r7, pc}
   893ec:	0008fcf9 	.word	0x0008fcf9
   893f0:	00094349 	.word	0x00094349
   893f4:	00089341 	.word	0x00089341

000893f8 <_ZN6String6concatEi>:

unsigned char String::concat(int num)
{
   893f8:	b580      	push	{r7, lr}
   893fa:	b086      	sub	sp, #24
   893fc:	af00      	add	r7, sp, #0
   893fe:	6078      	str	r0, [r7, #4]
   89400:	6039      	str	r1, [r7, #0]
	char buf[2 + 3 * sizeof(int)];
	itoa(num, buf, 10);
   89402:	f107 0308 	add.w	r3, r7, #8
   89406:	220a      	movs	r2, #10
   89408:	4619      	mov	r1, r3
   8940a:	6838      	ldr	r0, [r7, #0]
   8940c:	4b09      	ldr	r3, [pc, #36]	; (89434 <_ZN6String6concatEi+0x3c>)
   8940e:	4798      	blx	r3
	return concat(buf, strlen(buf));
   89410:	f107 0308 	add.w	r3, r7, #8
   89414:	4618      	mov	r0, r3
   89416:	4b08      	ldr	r3, [pc, #32]	; (89438 <_ZN6String6concatEi+0x40>)
   89418:	4798      	blx	r3
   8941a:	4602      	mov	r2, r0
   8941c:	f107 0308 	add.w	r3, r7, #8
   89420:	4619      	mov	r1, r3
   89422:	6878      	ldr	r0, [r7, #4]
   89424:	4b05      	ldr	r3, [pc, #20]	; (8943c <_ZN6String6concatEi+0x44>)
   89426:	4798      	blx	r3
   89428:	4603      	mov	r3, r0
}
   8942a:	4618      	mov	r0, r3
   8942c:	3718      	adds	r7, #24
   8942e:	46bd      	mov	sp, r7
   89430:	bd80      	pop	{r7, pc}
   89432:	bf00      	nop
   89434:	0008fcf9 	.word	0x0008fcf9
   89438:	00094349 	.word	0x00094349
   8943c:	00089341 	.word	0x00089341

00089440 <_ZN6String6concatEm>:
	ltoa(num, buf, 10);
	return concat(buf, strlen(buf));
}

unsigned char String::concat(unsigned long num)
{
   89440:	b580      	push	{r7, lr}
   89442:	b086      	sub	sp, #24
   89444:	af00      	add	r7, sp, #0
   89446:	6078      	str	r0, [r7, #4]
   89448:	6039      	str	r1, [r7, #0]
	char buf[1 + 3 * sizeof(unsigned long)];
	ultoa(num, buf, 10);
   8944a:	f107 0308 	add.w	r3, r7, #8
   8944e:	220a      	movs	r2, #10
   89450:	4619      	mov	r1, r3
   89452:	6838      	ldr	r0, [r7, #0]
   89454:	4b09      	ldr	r3, [pc, #36]	; (8947c <_ZN6String6concatEm+0x3c>)
   89456:	4798      	blx	r3
	return concat(buf, strlen(buf));
   89458:	f107 0308 	add.w	r3, r7, #8
   8945c:	4618      	mov	r0, r3
   8945e:	4b08      	ldr	r3, [pc, #32]	; (89480 <_ZN6String6concatEm+0x40>)
   89460:	4798      	blx	r3
   89462:	4602      	mov	r2, r0
   89464:	f107 0308 	add.w	r3, r7, #8
   89468:	4619      	mov	r1, r3
   8946a:	6878      	ldr	r0, [r7, #4]
   8946c:	4b05      	ldr	r3, [pc, #20]	; (89484 <_ZN6String6concatEm+0x44>)
   8946e:	4798      	blx	r3
   89470:	4603      	mov	r3, r0
}
   89472:	4618      	mov	r0, r3
   89474:	3718      	adds	r7, #24
   89476:	46bd      	mov	sp, r7
   89478:	bd80      	pop	{r7, pc}
   8947a:	bf00      	nop
   8947c:	0008fe2d 	.word	0x0008fe2d
   89480:	00094349 	.word	0x00094349
   89484:	00089341 	.word	0x00089341

00089488 <_ZN6String6concatEf>:

unsigned char String::concat(float num)
{
   89488:	b590      	push	{r4, r7, lr}
   8948a:	b08b      	sub	sp, #44	; 0x2c
   8948c:	af02      	add	r7, sp, #8
   8948e:	6078      	str	r0, [r7, #4]
   89490:	6039      	str	r1, [r7, #0]
	char buf[20];
	char* string = dtostrf(num, 4, 2, buf);
   89492:	4b0c      	ldr	r3, [pc, #48]	; (894c4 <_ZN6String6concatEf+0x3c>)
   89494:	6838      	ldr	r0, [r7, #0]
   89496:	4798      	blx	r3
   89498:	f107 0308 	add.w	r3, r7, #8
   8949c:	9300      	str	r3, [sp, #0]
   8949e:	2302      	movs	r3, #2
   894a0:	2204      	movs	r2, #4
   894a2:	4c09      	ldr	r4, [pc, #36]	; (894c8 <_ZN6String6concatEf+0x40>)
   894a4:	47a0      	blx	r4
   894a6:	61f8      	str	r0, [r7, #28]
	return concat(string, strlen(string));
   894a8:	69f8      	ldr	r0, [r7, #28]
   894aa:	4b08      	ldr	r3, [pc, #32]	; (894cc <_ZN6String6concatEf+0x44>)
   894ac:	4798      	blx	r3
   894ae:	4603      	mov	r3, r0
   894b0:	461a      	mov	r2, r3
   894b2:	69f9      	ldr	r1, [r7, #28]
   894b4:	6878      	ldr	r0, [r7, #4]
   894b6:	4b06      	ldr	r3, [pc, #24]	; (894d0 <_ZN6String6concatEf+0x48>)
   894b8:	4798      	blx	r3
   894ba:	4603      	mov	r3, r0
}
   894bc:	4618      	mov	r0, r3
   894be:	3724      	adds	r7, #36	; 0x24
   894c0:	46bd      	mov	sp, r7
   894c2:	bd90      	pop	{r4, r7, pc}
   894c4:	000926d5 	.word	0x000926d5
   894c8:	0008fcb1 	.word	0x0008fcb1
   894cc:	00094349 	.word	0x00094349
   894d0:	00089341 	.word	0x00089341

000894d4 <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
   894d4:	b580      	push	{r7, lr}
   894d6:	b084      	sub	sp, #16
   894d8:	af00      	add	r7, sp, #0
   894da:	6078      	str	r0, [r7, #4]
   894dc:	6039      	str	r1, [r7, #0]
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
   894de:	687b      	ldr	r3, [r7, #4]
   894e0:	60fb      	str	r3, [r7, #12]
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
   894e2:	68f8      	ldr	r0, [r7, #12]
   894e4:	683b      	ldr	r3, [r7, #0]
   894e6:	6819      	ldr	r1, [r3, #0]
   894e8:	683b      	ldr	r3, [r7, #0]
   894ea:	689b      	ldr	r3, [r3, #8]
   894ec:	461a      	mov	r2, r3
   894ee:	4b09      	ldr	r3, [pc, #36]	; (89514 <_ZplRK15StringSumHelperRK6String+0x40>)
   894f0:	4798      	blx	r3
   894f2:	4603      	mov	r3, r0
   894f4:	2b00      	cmp	r3, #0
   894f6:	bf0c      	ite	eq
   894f8:	2301      	moveq	r3, #1
   894fa:	2300      	movne	r3, #0
   894fc:	b2db      	uxtb	r3, r3
   894fe:	2b00      	cmp	r3, #0
   89500:	d003      	beq.n	8950a <_ZplRK15StringSumHelperRK6String+0x36>
   89502:	68fb      	ldr	r3, [r7, #12]
   89504:	4618      	mov	r0, r3
   89506:	4b04      	ldr	r3, [pc, #16]	; (89518 <_ZplRK15StringSumHelperRK6String+0x44>)
   89508:	4798      	blx	r3
	return a;
   8950a:	68fb      	ldr	r3, [r7, #12]
}
   8950c:	4618      	mov	r0, r3
   8950e:	3710      	adds	r7, #16
   89510:	46bd      	mov	sp, r7
   89512:	bd80      	pop	{r7, pc}
   89514:	00089341 	.word	0x00089341
   89518:	00089189 	.word	0x00089189

0008951c <_ZplRK15StringSumHelperPKc>:

StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
{
   8951c:	b590      	push	{r4, r7, lr}
   8951e:	b085      	sub	sp, #20
   89520:	af00      	add	r7, sp, #0
   89522:	6078      	str	r0, [r7, #4]
   89524:	6039      	str	r1, [r7, #0]
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
   89526:	687b      	ldr	r3, [r7, #4]
   89528:	60fb      	str	r3, [r7, #12]
	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
   8952a:	683b      	ldr	r3, [r7, #0]
   8952c:	2b00      	cmp	r3, #0
   8952e:	d00c      	beq.n	8954a <_ZplRK15StringSumHelperPKc+0x2e>
   89530:	68fc      	ldr	r4, [r7, #12]
   89532:	6838      	ldr	r0, [r7, #0]
   89534:	4b0c      	ldr	r3, [pc, #48]	; (89568 <_ZplRK15StringSumHelperPKc+0x4c>)
   89536:	4798      	blx	r3
   89538:	4603      	mov	r3, r0
   8953a:	461a      	mov	r2, r3
   8953c:	6839      	ldr	r1, [r7, #0]
   8953e:	4620      	mov	r0, r4
   89540:	4b0a      	ldr	r3, [pc, #40]	; (8956c <_ZplRK15StringSumHelperPKc+0x50>)
   89542:	4798      	blx	r3
   89544:	4603      	mov	r3, r0
   89546:	2b00      	cmp	r3, #0
   89548:	d101      	bne.n	8954e <_ZplRK15StringSumHelperPKc+0x32>
   8954a:	2301      	movs	r3, #1
   8954c:	e000      	b.n	89550 <_ZplRK15StringSumHelperPKc+0x34>
   8954e:	2300      	movs	r3, #0
   89550:	2b00      	cmp	r3, #0
   89552:	d003      	beq.n	8955c <_ZplRK15StringSumHelperPKc+0x40>
   89554:	68fb      	ldr	r3, [r7, #12]
   89556:	4618      	mov	r0, r3
   89558:	4b05      	ldr	r3, [pc, #20]	; (89570 <_ZplRK15StringSumHelperPKc+0x54>)
   8955a:	4798      	blx	r3
	return a;
   8955c:	68fb      	ldr	r3, [r7, #12]
}
   8955e:	4618      	mov	r0, r3
   89560:	3714      	adds	r7, #20
   89562:	46bd      	mov	sp, r7
   89564:	bd90      	pop	{r4, r7, pc}
   89566:	bf00      	nop
   89568:	00094349 	.word	0x00094349
   8956c:	00089341 	.word	0x00089341
   89570:	00089189 	.word	0x00089189

00089574 <_ZplRK15StringSumHelperh>:
	if (!a.concat(c)) a.invalidate();
	return a;
}

StringSumHelper & operator + (const StringSumHelper &lhs, unsigned char num)
{
   89574:	b580      	push	{r7, lr}
   89576:	b084      	sub	sp, #16
   89578:	af00      	add	r7, sp, #0
   8957a:	6078      	str	r0, [r7, #4]
   8957c:	460b      	mov	r3, r1
   8957e:	70fb      	strb	r3, [r7, #3]
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
   89580:	687b      	ldr	r3, [r7, #4]
   89582:	60fb      	str	r3, [r7, #12]
	if (!a.concat(num)) a.invalidate();
   89584:	68fb      	ldr	r3, [r7, #12]
   89586:	78fa      	ldrb	r2, [r7, #3]
   89588:	4611      	mov	r1, r2
   8958a:	4618      	mov	r0, r3
   8958c:	4b09      	ldr	r3, [pc, #36]	; (895b4 <_ZplRK15StringSumHelperh+0x40>)
   8958e:	4798      	blx	r3
   89590:	4603      	mov	r3, r0
   89592:	2b00      	cmp	r3, #0
   89594:	bf0c      	ite	eq
   89596:	2301      	moveq	r3, #1
   89598:	2300      	movne	r3, #0
   8959a:	b2db      	uxtb	r3, r3
   8959c:	2b00      	cmp	r3, #0
   8959e:	d003      	beq.n	895a8 <_ZplRK15StringSumHelperh+0x34>
   895a0:	68fb      	ldr	r3, [r7, #12]
   895a2:	4618      	mov	r0, r3
   895a4:	4b04      	ldr	r3, [pc, #16]	; (895b8 <_ZplRK15StringSumHelperh+0x44>)
   895a6:	4798      	blx	r3
	return a;
   895a8:	68fb      	ldr	r3, [r7, #12]
}
   895aa:	4618      	mov	r0, r3
   895ac:	3710      	adds	r7, #16
   895ae:	46bd      	mov	sp, r7
   895b0:	bd80      	pop	{r7, pc}
   895b2:	bf00      	nop
   895b4:	000893b1 	.word	0x000893b1
   895b8:	00089189 	.word	0x00089189

000895bc <_ZplRK15StringSumHelperi>:

StringSumHelper & operator + (const StringSumHelper &lhs, int num)
{
   895bc:	b580      	push	{r7, lr}
   895be:	b084      	sub	sp, #16
   895c0:	af00      	add	r7, sp, #0
   895c2:	6078      	str	r0, [r7, #4]
   895c4:	6039      	str	r1, [r7, #0]
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
   895c6:	687b      	ldr	r3, [r7, #4]
   895c8:	60fb      	str	r3, [r7, #12]
	if (!a.concat(num)) a.invalidate();
   895ca:	68fb      	ldr	r3, [r7, #12]
   895cc:	6839      	ldr	r1, [r7, #0]
   895ce:	4618      	mov	r0, r3
   895d0:	4b09      	ldr	r3, [pc, #36]	; (895f8 <_ZplRK15StringSumHelperi+0x3c>)
   895d2:	4798      	blx	r3
   895d4:	4603      	mov	r3, r0
   895d6:	2b00      	cmp	r3, #0
   895d8:	bf0c      	ite	eq
   895da:	2301      	moveq	r3, #1
   895dc:	2300      	movne	r3, #0
   895de:	b2db      	uxtb	r3, r3
   895e0:	2b00      	cmp	r3, #0
   895e2:	d003      	beq.n	895ec <_ZplRK15StringSumHelperi+0x30>
   895e4:	68fb      	ldr	r3, [r7, #12]
   895e6:	4618      	mov	r0, r3
   895e8:	4b04      	ldr	r3, [pc, #16]	; (895fc <_ZplRK15StringSumHelperi+0x40>)
   895ea:	4798      	blx	r3
	return a;
   895ec:	68fb      	ldr	r3, [r7, #12]
}
   895ee:	4618      	mov	r0, r3
   895f0:	3710      	adds	r7, #16
   895f2:	46bd      	mov	sp, r7
   895f4:	bd80      	pop	{r7, pc}
   895f6:	bf00      	nop
   895f8:	000893f9 	.word	0x000893f9
   895fc:	00089189 	.word	0x00089189

00089600 <_ZplRK15StringSumHelperm>:
	if (!a.concat(num)) a.invalidate();
	return a;
}

StringSumHelper & operator + (const StringSumHelper &lhs, unsigned long num)
{
   89600:	b580      	push	{r7, lr}
   89602:	b084      	sub	sp, #16
   89604:	af00      	add	r7, sp, #0
   89606:	6078      	str	r0, [r7, #4]
   89608:	6039      	str	r1, [r7, #0]
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
   8960a:	687b      	ldr	r3, [r7, #4]
   8960c:	60fb      	str	r3, [r7, #12]
	if (!a.concat(num)) a.invalidate();
   8960e:	68fb      	ldr	r3, [r7, #12]
   89610:	6839      	ldr	r1, [r7, #0]
   89612:	4618      	mov	r0, r3
   89614:	4b09      	ldr	r3, [pc, #36]	; (8963c <_ZplRK15StringSumHelperm+0x3c>)
   89616:	4798      	blx	r3
   89618:	4603      	mov	r3, r0
   8961a:	2b00      	cmp	r3, #0
   8961c:	bf0c      	ite	eq
   8961e:	2301      	moveq	r3, #1
   89620:	2300      	movne	r3, #0
   89622:	b2db      	uxtb	r3, r3
   89624:	2b00      	cmp	r3, #0
   89626:	d003      	beq.n	89630 <_ZplRK15StringSumHelperm+0x30>
   89628:	68fb      	ldr	r3, [r7, #12]
   8962a:	4618      	mov	r0, r3
   8962c:	4b04      	ldr	r3, [pc, #16]	; (89640 <_ZplRK15StringSumHelperm+0x40>)
   8962e:	4798      	blx	r3
	return a;
   89630:	68fb      	ldr	r3, [r7, #12]
}
   89632:	4618      	mov	r0, r3
   89634:	3710      	adds	r7, #16
   89636:	46bd      	mov	sp, r7
   89638:	bd80      	pop	{r7, pc}
   8963a:	bf00      	nop
   8963c:	00089441 	.word	0x00089441
   89640:	00089189 	.word	0x00089189

00089644 <_ZplRK15StringSumHelperf>:

StringSumHelper & operator + (const StringSumHelper &lhs, float num)
{
   89644:	b580      	push	{r7, lr}
   89646:	b084      	sub	sp, #16
   89648:	af00      	add	r7, sp, #0
   8964a:	6078      	str	r0, [r7, #4]
   8964c:	6039      	str	r1, [r7, #0]
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
   8964e:	687b      	ldr	r3, [r7, #4]
   89650:	60fb      	str	r3, [r7, #12]
	if (!a.concat(num)) a.invalidate();
   89652:	68fb      	ldr	r3, [r7, #12]
   89654:	6839      	ldr	r1, [r7, #0]
   89656:	4618      	mov	r0, r3
   89658:	4b09      	ldr	r3, [pc, #36]	; (89680 <_ZplRK15StringSumHelperf+0x3c>)
   8965a:	4798      	blx	r3
   8965c:	4603      	mov	r3, r0
   8965e:	2b00      	cmp	r3, #0
   89660:	bf0c      	ite	eq
   89662:	2301      	moveq	r3, #1
   89664:	2300      	movne	r3, #0
   89666:	b2db      	uxtb	r3, r3
   89668:	2b00      	cmp	r3, #0
   8966a:	d003      	beq.n	89674 <_ZplRK15StringSumHelperf+0x30>
   8966c:	68fb      	ldr	r3, [r7, #12]
   8966e:	4618      	mov	r0, r3
   89670:	4b04      	ldr	r3, [pc, #16]	; (89684 <_ZplRK15StringSumHelperf+0x40>)
   89672:	4798      	blx	r3
	return a;
   89674:	68fb      	ldr	r3, [r7, #12]
}
   89676:	4618      	mov	r0, r3
   89678:	3710      	adds	r7, #16
   8967a:	46bd      	mov	sp, r7
   8967c:	bd80      	pop	{r7, pc}
   8967e:	bf00      	nop
   89680:	00089489 	.word	0x00089489
   89684:	00089189 	.word	0x00089189

00089688 <_ZN12AccelStepper6moveToEl>:
	Serial.println("");
}
#endif

void AccelStepper::moveTo(long absolute)
{
   89688:	b580      	push	{r7, lr}
   8968a:	b082      	sub	sp, #8
   8968c:	af00      	add	r7, sp, #0
   8968e:	6078      	str	r0, [r7, #4]
   89690:	6039      	str	r1, [r7, #0]
	if (_targetPos != absolute)
   89692:	687b      	ldr	r3, [r7, #4]
   89694:	695a      	ldr	r2, [r3, #20]
   89696:	683b      	ldr	r3, [r7, #0]
   89698:	429a      	cmp	r2, r3
   8969a:	d005      	beq.n	896a8 <_ZN12AccelStepper6moveToEl+0x20>
	{
		_targetPos = absolute;
   8969c:	687b      	ldr	r3, [r7, #4]
   8969e:	683a      	ldr	r2, [r7, #0]
   896a0:	615a      	str	r2, [r3, #20]
		computeNewSpeed();
   896a2:	6878      	ldr	r0, [r7, #4]
   896a4:	4b02      	ldr	r3, [pc, #8]	; (896b0 <_ZN12AccelStepper6moveToEl+0x28>)
   896a6:	4798      	blx	r3
		// compute new n?
	}
}
   896a8:	bf00      	nop
   896aa:	3708      	adds	r7, #8
   896ac:	46bd      	mov	sp, r7
   896ae:	bd80      	pop	{r7, pc}
   896b0:	000897a9 	.word	0x000897a9

000896b4 <_ZN12AccelStepper8runSpeedEv>:

// Implements steps according to the current step interval
// You must call this at least once per step
// returns true if a step occurred
boolean AccelStepper::runSpeed()
{
   896b4:	b580      	push	{r7, lr}
   896b6:	b084      	sub	sp, #16
   896b8:	af00      	add	r7, sp, #0
   896ba:	6078      	str	r0, [r7, #4]
	// Dont do anything unless we actually have a step interval
	if (!_stepInterval)
   896bc:	687b      	ldr	r3, [r7, #4]
   896be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   896c0:	2b00      	cmp	r3, #0
   896c2:	d101      	bne.n	896c8 <_ZN12AccelStepper8runSpeedEv+0x14>
		return false;
   896c4:	2300      	movs	r3, #0
   896c6:	e043      	b.n	89750 <_ZN12AccelStepper8runSpeedEv+0x9c>

	unsigned long time = micros();
   896c8:	4b23      	ldr	r3, [pc, #140]	; (89758 <_ZN12AccelStepper8runSpeedEv+0xa4>)
   896ca:	4798      	blx	r3
   896cc:	60f8      	str	r0, [r7, #12]
	// Gymnastics to detect wrapping of either the nextStepTime and/or the current time
	unsigned long nextStepTime = _lastStepTime + _stepInterval;
   896ce:	687b      	ldr	r3, [r7, #4]
   896d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   896d2:	687b      	ldr	r3, [r7, #4]
   896d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   896d6:	4413      	add	r3, r2
   896d8:	60bb      	str	r3, [r7, #8]
	if (   ((nextStepTime >= _lastStepTime) && ((time >= nextStepTime) || (time < _lastStepTime)))
   896da:	687b      	ldr	r3, [r7, #4]
   896dc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   896de:	68bb      	ldr	r3, [r7, #8]
   896e0:	429a      	cmp	r2, r3
   896e2:	d808      	bhi.n	896f6 <_ZN12AccelStepper8runSpeedEv+0x42>
   896e4:	68fa      	ldr	r2, [r7, #12]
   896e6:	68bb      	ldr	r3, [r7, #8]
   896e8:	429a      	cmp	r2, r3
   896ea:	d212      	bcs.n	89712 <_ZN12AccelStepper8runSpeedEv+0x5e>
   896ec:	687b      	ldr	r3, [r7, #4]
   896ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   896f0:	68fb      	ldr	r3, [r7, #12]
   896f2:	429a      	cmp	r2, r3
   896f4:	d80d      	bhi.n	89712 <_ZN12AccelStepper8runSpeedEv+0x5e>
			|| ((nextStepTime < _lastStepTime) && ((time >= nextStepTime) && (time < _lastStepTime))))
   896f6:	687b      	ldr	r3, [r7, #4]
   896f8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   896fa:	68bb      	ldr	r3, [r7, #8]
   896fc:	429a      	cmp	r2, r3
   896fe:	d926      	bls.n	8974e <_ZN12AccelStepper8runSpeedEv+0x9a>
   89700:	68fa      	ldr	r2, [r7, #12]
   89702:	68bb      	ldr	r3, [r7, #8]
   89704:	429a      	cmp	r2, r3
   89706:	d322      	bcc.n	8974e <_ZN12AccelStepper8runSpeedEv+0x9a>
   89708:	687b      	ldr	r3, [r7, #4]
   8970a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8970c:	68fb      	ldr	r3, [r7, #12]
   8970e:	429a      	cmp	r2, r3
   89710:	d91d      	bls.n	8974e <_ZN12AccelStepper8runSpeedEv+0x9a>

	{
		if (_direction == DIRECTION_CW)
   89712:	687b      	ldr	r3, [r7, #4]
   89714:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
   89718:	2b00      	cmp	r3, #0
   8971a:	d005      	beq.n	89728 <_ZN12AccelStepper8runSpeedEv+0x74>
		{
			// Clockwise
			_currentPos += 1;
   8971c:	687b      	ldr	r3, [r7, #4]
   8971e:	691b      	ldr	r3, [r3, #16]
   89720:	1c5a      	adds	r2, r3, #1
   89722:	687b      	ldr	r3, [r7, #4]
   89724:	611a      	str	r2, [r3, #16]
   89726:	e004      	b.n	89732 <_ZN12AccelStepper8runSpeedEv+0x7e>
		}
		else
		{
			// Anticlockwise
			_currentPos -= 1;
   89728:	687b      	ldr	r3, [r7, #4]
   8972a:	691b      	ldr	r3, [r3, #16]
   8972c:	1e5a      	subs	r2, r3, #1
   8972e:	687b      	ldr	r3, [r7, #4]
   89730:	611a      	str	r2, [r3, #16]
		}
		step(_currentPos);
   89732:	687b      	ldr	r3, [r7, #4]
   89734:	681b      	ldr	r3, [r3, #0]
   89736:	330c      	adds	r3, #12
   89738:	681b      	ldr	r3, [r3, #0]
   8973a:	687a      	ldr	r2, [r7, #4]
   8973c:	6912      	ldr	r2, [r2, #16]
   8973e:	4611      	mov	r1, r2
   89740:	6878      	ldr	r0, [r7, #4]
   89742:	4798      	blx	r3

		_lastStepTime = time;
   89744:	687b      	ldr	r3, [r7, #4]
   89746:	68fa      	ldr	r2, [r7, #12]
   89748:	62da      	str	r2, [r3, #44]	; 0x2c
		return true;
   8974a:	2301      	movs	r3, #1
   8974c:	e000      	b.n	89750 <_ZN12AccelStepper8runSpeedEv+0x9c>
	}
	else
	{
		return false;
   8974e:	2300      	movs	r3, #0
	}
}
   89750:	4618      	mov	r0, r3
   89752:	3710      	adds	r7, #16
   89754:	46bd      	mov	sp, r7
   89756:	bd80      	pop	{r7, pc}
   89758:	00081bc5 	.word	0x00081bc5

0008975c <_ZN12AccelStepper12distanceToGoEv>:

long AccelStepper::distanceToGo()
{
   8975c:	b480      	push	{r7}
   8975e:	b083      	sub	sp, #12
   89760:	af00      	add	r7, sp, #0
   89762:	6078      	str	r0, [r7, #4]
	return _targetPos - _currentPos;
   89764:	687b      	ldr	r3, [r7, #4]
   89766:	695a      	ldr	r2, [r3, #20]
   89768:	687b      	ldr	r3, [r7, #4]
   8976a:	691b      	ldr	r3, [r3, #16]
   8976c:	1ad3      	subs	r3, r2, r3
}
   8976e:	4618      	mov	r0, r3
   89770:	370c      	adds	r7, #12
   89772:	46bd      	mov	sp, r7
   89774:	bc80      	pop	{r7}
   89776:	4770      	bx	lr

00089778 <_ZN12AccelStepper18setCurrentPositionEl>:
}

// Useful during initialisations or after initial positioning
// Sets speed to 0
void AccelStepper::setCurrentPosition(long position)
{
   89778:	b480      	push	{r7}
   8977a:	b083      	sub	sp, #12
   8977c:	af00      	add	r7, sp, #0
   8977e:	6078      	str	r0, [r7, #4]
   89780:	6039      	str	r1, [r7, #0]
	_targetPos = _currentPos = position;
   89782:	687b      	ldr	r3, [r7, #4]
   89784:	683a      	ldr	r2, [r7, #0]
   89786:	611a      	str	r2, [r3, #16]
   89788:	687b      	ldr	r3, [r7, #4]
   8978a:	691a      	ldr	r2, [r3, #16]
   8978c:	687b      	ldr	r3, [r7, #4]
   8978e:	615a      	str	r2, [r3, #20]
	_n = 0;
   89790:	687b      	ldr	r3, [r7, #4]
   89792:	2200      	movs	r2, #0
   89794:	641a      	str	r2, [r3, #64]	; 0x40
	_stepInterval = 0;
   89796:	687b      	ldr	r3, [r7, #4]
   89798:	2200      	movs	r2, #0
   8979a:	629a      	str	r2, [r3, #40]	; 0x28
}
   8979c:	bf00      	nop
   8979e:	370c      	adds	r7, #12
   897a0:	46bd      	mov	sp, r7
   897a2:	bc80      	pop	{r7}
   897a4:	4770      	bx	lr
   897a6:	bf00      	nop

000897a8 <_ZN12AccelStepper15computeNewSpeedEv>:

void AccelStepper::computeNewSpeed()
{
   897a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   897ac:	b087      	sub	sp, #28
   897ae:	af00      	add	r7, sp, #0
   897b0:	6078      	str	r0, [r7, #4]
	long distanceTo = distanceToGo(); // +ve is clockwise from curent location
   897b2:	6878      	ldr	r0, [r7, #4]
   897b4:	4b91      	ldr	r3, [pc, #580]	; (899fc <_ZN12AccelStepper15computeNewSpeedEv+0x254>)
   897b6:	4798      	blx	r3
   897b8:	6178      	str	r0, [r7, #20]

	unsigned long acc = (2.0 * _acceleration);
   897ba:	687b      	ldr	r3, [r7, #4]
   897bc:	6a1a      	ldr	r2, [r3, #32]
   897be:	4b90      	ldr	r3, [pc, #576]	; (89a00 <_ZN12AccelStepper15computeNewSpeedEv+0x258>)
   897c0:	4610      	mov	r0, r2
   897c2:	4798      	blx	r3
   897c4:	4c8f      	ldr	r4, [pc, #572]	; (89a04 <_ZN12AccelStepper15computeNewSpeedEv+0x25c>)
   897c6:	4602      	mov	r2, r0
   897c8:	460b      	mov	r3, r1
   897ca:	47a0      	blx	r4
   897cc:	4603      	mov	r3, r0
   897ce:	460c      	mov	r4, r1
   897d0:	4619      	mov	r1, r3
   897d2:	4622      	mov	r2, r4
   897d4:	4b8c      	ldr	r3, [pc, #560]	; (89a08 <_ZN12AccelStepper15computeNewSpeedEv+0x260>)
   897d6:	4608      	mov	r0, r1
   897d8:	4611      	mov	r1, r2
   897da:	4798      	blx	r3
   897dc:	4603      	mov	r3, r0
   897de:	613b      	str	r3, [r7, #16]
	long stepsToStop = (long)((_speed * _speed) / acc); // Equation 16
   897e0:	687b      	ldr	r3, [r7, #4]
   897e2:	699a      	ldr	r2, [r3, #24]
   897e4:	687b      	ldr	r3, [r7, #4]
   897e6:	6999      	ldr	r1, [r3, #24]
   897e8:	4b88      	ldr	r3, [pc, #544]	; (89a0c <_ZN12AccelStepper15computeNewSpeedEv+0x264>)
   897ea:	4610      	mov	r0, r2
   897ec:	4798      	blx	r3
   897ee:	4603      	mov	r3, r0
   897f0:	461c      	mov	r4, r3
   897f2:	4b87      	ldr	r3, [pc, #540]	; (89a10 <_ZN12AccelStepper15computeNewSpeedEv+0x268>)
   897f4:	6938      	ldr	r0, [r7, #16]
   897f6:	4798      	blx	r3
   897f8:	4602      	mov	r2, r0
   897fa:	4b86      	ldr	r3, [pc, #536]	; (89a14 <_ZN12AccelStepper15computeNewSpeedEv+0x26c>)
   897fc:	4611      	mov	r1, r2
   897fe:	4620      	mov	r0, r4
   89800:	4798      	blx	r3
   89802:	4603      	mov	r3, r0
   89804:	461a      	mov	r2, r3
   89806:	4b84      	ldr	r3, [pc, #528]	; (89a18 <_ZN12AccelStepper15computeNewSpeedEv+0x270>)
   89808:	4610      	mov	r0, r2
   8980a:	4798      	blx	r3
   8980c:	4603      	mov	r3, r0
   8980e:	60fb      	str	r3, [r7, #12]

	if (distanceTo == 0 && stepsToStop <= 1)
   89810:	697b      	ldr	r3, [r7, #20]
   89812:	2b00      	cmp	r3, #0
   89814:	d10d      	bne.n	89832 <_ZN12AccelStepper15computeNewSpeedEv+0x8a>
   89816:	68fb      	ldr	r3, [r7, #12]
   89818:	2b01      	cmp	r3, #1
   8981a:	dc0a      	bgt.n	89832 <_ZN12AccelStepper15computeNewSpeedEv+0x8a>
	{
		// We are at the target and its time to stop
		_stepInterval = 0;
   8981c:	687b      	ldr	r3, [r7, #4]
   8981e:	2200      	movs	r2, #0
   89820:	629a      	str	r2, [r3, #40]	; 0x28
		_speed = 0.0;
   89822:	687b      	ldr	r3, [r7, #4]
   89824:	f04f 0200 	mov.w	r2, #0
   89828:	619a      	str	r2, [r3, #24]
		_n = 0;
   8982a:	687b      	ldr	r3, [r7, #4]
   8982c:	2200      	movs	r2, #0
   8982e:	641a      	str	r2, [r3, #64]	; 0x40
		return;
   89830:	e0e0      	b.n	899f4 <_ZN12AccelStepper15computeNewSpeedEv+0x24c>
	}

	if (distanceTo > 0)
   89832:	697b      	ldr	r3, [r7, #20]
   89834:	2b00      	cmp	r3, #0
   89836:	dd27      	ble.n	89888 <_ZN12AccelStepper15computeNewSpeedEv+0xe0>
	{
		// We are anticlockwise from the target
		// Need to go clockwise from here, maybe decelerate now
		if (_n > 0)
   89838:	687b      	ldr	r3, [r7, #4]
   8983a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8983c:	2b00      	cmp	r3, #0
   8983e:	dd10      	ble.n	89862 <_ZN12AccelStepper15computeNewSpeedEv+0xba>
		{
			// Currently accelerating, need to decel now? Or maybe going the wrong way?
			if ((stepsToStop >= distanceTo) || _direction == DIRECTION_CCW)
   89840:	68fa      	ldr	r2, [r7, #12]
   89842:	697b      	ldr	r3, [r7, #20]
   89844:	429a      	cmp	r2, r3
   89846:	da07      	bge.n	89858 <_ZN12AccelStepper15computeNewSpeedEv+0xb0>
   89848:	687b      	ldr	r3, [r7, #4]
   8984a:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
   8984e:	f083 0301 	eor.w	r3, r3, #1
   89852:	b2db      	uxtb	r3, r3
   89854:	2b00      	cmp	r3, #0
   89856:	d043      	beq.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
				_n = -stepsToStop; // Start deceleration
   89858:	68fb      	ldr	r3, [r7, #12]
   8985a:	425a      	negs	r2, r3
   8985c:	687b      	ldr	r3, [r7, #4]
   8985e:	641a      	str	r2, [r3, #64]	; 0x40
   89860:	e03e      	b.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
		}
		else if (_n < 0)
   89862:	687b      	ldr	r3, [r7, #4]
   89864:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   89866:	2b00      	cmp	r3, #0
   89868:	da3a      	bge.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
		{
			// Currently decelerating, need to accel again?
			if ((stepsToStop < distanceTo) && _direction == DIRECTION_CW)
   8986a:	68fa      	ldr	r2, [r7, #12]
   8986c:	697b      	ldr	r3, [r7, #20]
   8986e:	429a      	cmp	r2, r3
   89870:	da36      	bge.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
   89872:	687b      	ldr	r3, [r7, #4]
   89874:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
   89878:	2b00      	cmp	r3, #0
   8987a:	d031      	beq.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
				_n = -_n; // Start accceleration
   8987c:	687b      	ldr	r3, [r7, #4]
   8987e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   89880:	425a      	negs	r2, r3
   89882:	687b      	ldr	r3, [r7, #4]
   89884:	641a      	str	r2, [r3, #64]	; 0x40
   89886:	e02b      	b.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
		}
	}
	else if (distanceTo < 0)
   89888:	697b      	ldr	r3, [r7, #20]
   8988a:	2b00      	cmp	r3, #0
   8988c:	da28      	bge.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
	{
		// We are clockwise from the target
		// Need to go anticlockwise from here, maybe decelerate
		if (_n > 0)
   8988e:	687b      	ldr	r3, [r7, #4]
   89890:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   89892:	2b00      	cmp	r3, #0
   89894:	dd0e      	ble.n	898b4 <_ZN12AccelStepper15computeNewSpeedEv+0x10c>
		{
			// Currently accelerating, need to decel now? Or maybe going the wrong way?
			if ((stepsToStop >= -distanceTo) || _direction == DIRECTION_CW)
   89896:	697b      	ldr	r3, [r7, #20]
   89898:	425a      	negs	r2, r3
   8989a:	68fb      	ldr	r3, [r7, #12]
   8989c:	429a      	cmp	r2, r3
   8989e:	dd04      	ble.n	898aa <_ZN12AccelStepper15computeNewSpeedEv+0x102>
   898a0:	687b      	ldr	r3, [r7, #4]
   898a2:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
   898a6:	2b00      	cmp	r3, #0
   898a8:	d01a      	beq.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
				_n = -stepsToStop; // Start deceleration
   898aa:	68fb      	ldr	r3, [r7, #12]
   898ac:	425a      	negs	r2, r3
   898ae:	687b      	ldr	r3, [r7, #4]
   898b0:	641a      	str	r2, [r3, #64]	; 0x40
   898b2:	e015      	b.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
		}
		else if (_n < 0)
   898b4:	687b      	ldr	r3, [r7, #4]
   898b6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   898b8:	2b00      	cmp	r3, #0
   898ba:	da11      	bge.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
		{
			// Currently decelerating, need to accel again?
			if ((stepsToStop < -distanceTo) && _direction == DIRECTION_CCW)
   898bc:	697b      	ldr	r3, [r7, #20]
   898be:	425a      	negs	r2, r3
   898c0:	68fb      	ldr	r3, [r7, #12]
   898c2:	429a      	cmp	r2, r3
   898c4:	dd0c      	ble.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
   898c6:	687b      	ldr	r3, [r7, #4]
   898c8:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
   898cc:	f083 0301 	eor.w	r3, r3, #1
   898d0:	b2db      	uxtb	r3, r3
   898d2:	2b00      	cmp	r3, #0
   898d4:	d004      	beq.n	898e0 <_ZN12AccelStepper15computeNewSpeedEv+0x138>
				_n = -_n; // Start accceleration
   898d6:	687b      	ldr	r3, [r7, #4]
   898d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   898da:	425a      	negs	r2, r3
   898dc:	687b      	ldr	r3, [r7, #4]
   898de:	641a      	str	r2, [r3, #64]	; 0x40
		}
	}

	// Need to accelerate or decelerate
	if (_n == 0)
   898e0:	687b      	ldr	r3, [r7, #4]
   898e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   898e4:	2b00      	cmp	r3, #0
   898e6:	d10d      	bne.n	89904 <_ZN12AccelStepper15computeNewSpeedEv+0x15c>
	{
		// First step from stopped
		_cn = _c0;
   898e8:	687b      	ldr	r3, [r7, #4]
   898ea:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   898ec:	687b      	ldr	r3, [r7, #4]
   898ee:	649a      	str	r2, [r3, #72]	; 0x48
		_direction = (distanceTo > 0) ? DIRECTION_CW : DIRECTION_CCW;
   898f0:	697b      	ldr	r3, [r7, #20]
   898f2:	2b00      	cmp	r3, #0
   898f4:	bfcc      	ite	gt
   898f6:	2301      	movgt	r3, #1
   898f8:	2300      	movle	r3, #0
   898fa:	b2da      	uxtb	r2, r3
   898fc:	687b      	ldr	r3, [r7, #4]
   898fe:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
   89902:	e052      	b.n	899aa <_ZN12AccelStepper15computeNewSpeedEv+0x202>
	}
	else
	{
		// Subsequent step. Works for accel (n is +_ve) and decel (n is -ve).
		_cn = _cn - ((2.0 * _cn) / ((4.0 * _n) + 1.0)); // Equation 13
   89904:	687b      	ldr	r3, [r7, #4]
   89906:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   89908:	4b3d      	ldr	r3, [pc, #244]	; (89a00 <_ZN12AccelStepper15computeNewSpeedEv+0x258>)
   8990a:	4610      	mov	r0, r2
   8990c:	4798      	blx	r3
   8990e:	4605      	mov	r5, r0
   89910:	460e      	mov	r6, r1
   89912:	687b      	ldr	r3, [r7, #4]
   89914:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   89916:	4b3a      	ldr	r3, [pc, #232]	; (89a00 <_ZN12AccelStepper15computeNewSpeedEv+0x258>)
   89918:	4610      	mov	r0, r2
   8991a:	4798      	blx	r3
   8991c:	4c39      	ldr	r4, [pc, #228]	; (89a04 <_ZN12AccelStepper15computeNewSpeedEv+0x25c>)
   8991e:	4602      	mov	r2, r0
   89920:	460b      	mov	r3, r1
   89922:	47a0      	blx	r4
   89924:	4603      	mov	r3, r0
   89926:	460c      	mov	r4, r1
   89928:	4698      	mov	r8, r3
   8992a:	46a1      	mov	r9, r4
   8992c:	687b      	ldr	r3, [r7, #4]
   8992e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   89930:	4b3a      	ldr	r3, [pc, #232]	; (89a1c <_ZN12AccelStepper15computeNewSpeedEv+0x274>)
   89932:	4610      	mov	r0, r2
   89934:	4798      	blx	r3
   89936:	4c3a      	ldr	r4, [pc, #232]	; (89a20 <_ZN12AccelStepper15computeNewSpeedEv+0x278>)
   89938:	f04f 0200 	mov.w	r2, #0
   8993c:	4b39      	ldr	r3, [pc, #228]	; (89a24 <_ZN12AccelStepper15computeNewSpeedEv+0x27c>)
   8993e:	47a0      	blx	r4
   89940:	4603      	mov	r3, r0
   89942:	460c      	mov	r4, r1
   89944:	4618      	mov	r0, r3
   89946:	4621      	mov	r1, r4
   89948:	4c2e      	ldr	r4, [pc, #184]	; (89a04 <_ZN12AccelStepper15computeNewSpeedEv+0x25c>)
   8994a:	f04f 0200 	mov.w	r2, #0
   8994e:	4b36      	ldr	r3, [pc, #216]	; (89a28 <_ZN12AccelStepper15computeNewSpeedEv+0x280>)
   89950:	47a0      	blx	r4
   89952:	4603      	mov	r3, r0
   89954:	460c      	mov	r4, r1
   89956:	461a      	mov	r2, r3
   89958:	4623      	mov	r3, r4
   8995a:	4c34      	ldr	r4, [pc, #208]	; (89a2c <_ZN12AccelStepper15computeNewSpeedEv+0x284>)
   8995c:	4640      	mov	r0, r8
   8995e:	4649      	mov	r1, r9
   89960:	47a0      	blx	r4
   89962:	4603      	mov	r3, r0
   89964:	460c      	mov	r4, r1
   89966:	461a      	mov	r2, r3
   89968:	4623      	mov	r3, r4
   8996a:	4c31      	ldr	r4, [pc, #196]	; (89a30 <_ZN12AccelStepper15computeNewSpeedEv+0x288>)
   8996c:	4628      	mov	r0, r5
   8996e:	4631      	mov	r1, r6
   89970:	47a0      	blx	r4
   89972:	4603      	mov	r3, r0
   89974:	460c      	mov	r4, r1
   89976:	4619      	mov	r1, r3
   89978:	4622      	mov	r2, r4
   8997a:	4b2e      	ldr	r3, [pc, #184]	; (89a34 <_ZN12AccelStepper15computeNewSpeedEv+0x28c>)
   8997c:	4608      	mov	r0, r1
   8997e:	4611      	mov	r1, r2
   89980:	4798      	blx	r3
   89982:	4602      	mov	r2, r0
   89984:	687b      	ldr	r3, [r7, #4]
   89986:	649a      	str	r2, [r3, #72]	; 0x48
		_cn = max(_cn, _cmin);
   89988:	687b      	ldr	r3, [r7, #4]
   8998a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   8998c:	687b      	ldr	r3, [r7, #4]
   8998e:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
   89990:	4b29      	ldr	r3, [pc, #164]	; (89a38 <_ZN12AccelStepper15computeNewSpeedEv+0x290>)
   89992:	4610      	mov	r0, r2
   89994:	4798      	blx	r3
   89996:	4603      	mov	r3, r0
   89998:	2b00      	cmp	r3, #0
   8999a:	d002      	beq.n	899a2 <_ZN12AccelStepper15computeNewSpeedEv+0x1fa>
   8999c:	687b      	ldr	r3, [r7, #4]
   8999e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   899a0:	e001      	b.n	899a6 <_ZN12AccelStepper15computeNewSpeedEv+0x1fe>
   899a2:	687b      	ldr	r3, [r7, #4]
   899a4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   899a6:	687a      	ldr	r2, [r7, #4]
   899a8:	6493      	str	r3, [r2, #72]	; 0x48
	}
	_n++;
   899aa:	687b      	ldr	r3, [r7, #4]
   899ac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   899ae:	1c5a      	adds	r2, r3, #1
   899b0:	687b      	ldr	r3, [r7, #4]
   899b2:	641a      	str	r2, [r3, #64]	; 0x40
	_stepInterval = _cn;
   899b4:	687b      	ldr	r3, [r7, #4]
   899b6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   899b8:	4b20      	ldr	r3, [pc, #128]	; (89a3c <_ZN12AccelStepper15computeNewSpeedEv+0x294>)
   899ba:	4610      	mov	r0, r2
   899bc:	4798      	blx	r3
   899be:	4602      	mov	r2, r0
   899c0:	687b      	ldr	r3, [r7, #4]
   899c2:	629a      	str	r2, [r3, #40]	; 0x28
	_speed = 1000000.0 / _cn;
   899c4:	687b      	ldr	r3, [r7, #4]
   899c6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   899c8:	4b12      	ldr	r3, [pc, #72]	; (89a14 <_ZN12AccelStepper15computeNewSpeedEv+0x26c>)
   899ca:	4611      	mov	r1, r2
   899cc:	481c      	ldr	r0, [pc, #112]	; (89a40 <_ZN12AccelStepper15computeNewSpeedEv+0x298>)
   899ce:	4798      	blx	r3
   899d0:	4603      	mov	r3, r0
   899d2:	461a      	mov	r2, r3
   899d4:	687b      	ldr	r3, [r7, #4]
   899d6:	619a      	str	r2, [r3, #24]
	if (_direction == DIRECTION_CCW)
   899d8:	687b      	ldr	r3, [r7, #4]
   899da:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
   899de:	f083 0301 	eor.w	r3, r3, #1
   899e2:	b2db      	uxtb	r3, r3
   899e4:	2b00      	cmp	r3, #0
   899e6:	d005      	beq.n	899f4 <_ZN12AccelStepper15computeNewSpeedEv+0x24c>
		_speed = -_speed;
   899e8:	687b      	ldr	r3, [r7, #4]
   899ea:	699b      	ldr	r3, [r3, #24]
   899ec:	f083 4200 	eor.w	r2, r3, #2147483648	; 0x80000000
   899f0:	687b      	ldr	r3, [r7, #4]
   899f2:	619a      	str	r2, [r3, #24]
	Serial.println(_stepInterval);
	Serial.println(distanceTo);
	Serial.println(stepsToStop);
	Serial.println("-----");
#endif
}
   899f4:	371c      	adds	r7, #28
   899f6:	46bd      	mov	sp, r7
   899f8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   899fc:	0008975d 	.word	0x0008975d
   89a00:	000926d5 	.word	0x000926d5
   89a04:	00092419 	.word	0x00092419
   89a08:	00092d2d 	.word	0x00092d2d
   89a0c:	00093029 	.word	0x00093029
   89a10:	00092f79 	.word	0x00092f79
   89a14:	00093191 	.word	0x00093191
   89a18:	000933b5 	.word	0x000933b5
   89a1c:	000926b1 	.word	0x000926b1
   89a20:	0009277d 	.word	0x0009277d
   89a24:	40100000 	.word	0x40100000
   89a28:	3ff00000 	.word	0x3ff00000
   89a2c:	000929d1 	.word	0x000929d1
   89a30:	00092415 	.word	0x00092415
   89a34:	00092d6d 	.word	0x00092d6d
   89a38:	000933a1 	.word	0x000933a1
   89a3c:	00093401 	.word	0x00093401
   89a40:	49742400 	.word	0x49742400

00089a44 <_ZN12AccelStepper3runEv>:
// Run the motor to implement speed and acceleration in order to proceed to the target position
// You must call this at least once per step, preferably in your main loop
// If the motor is in the desired position, the cost is very small
// returns true if the motor is still running to the target position.
boolean AccelStepper::run()
{
   89a44:	b580      	push	{r7, lr}
   89a46:	b082      	sub	sp, #8
   89a48:	af00      	add	r7, sp, #0
   89a4a:	6078      	str	r0, [r7, #4]
	if (runSpeed())
   89a4c:	6878      	ldr	r0, [r7, #4]
   89a4e:	4b0f      	ldr	r3, [pc, #60]	; (89a8c <_ZN12AccelStepper3runEv+0x48>)
   89a50:	4798      	blx	r3
   89a52:	4603      	mov	r3, r0
   89a54:	2b00      	cmp	r3, #0
   89a56:	d002      	beq.n	89a5e <_ZN12AccelStepper3runEv+0x1a>
		computeNewSpeed();
   89a58:	6878      	ldr	r0, [r7, #4]
   89a5a:	4b0d      	ldr	r3, [pc, #52]	; (89a90 <_ZN12AccelStepper3runEv+0x4c>)
   89a5c:	4798      	blx	r3
	return _speed != 0.0 || distanceToGo() != 0;
   89a5e:	687b      	ldr	r3, [r7, #4]
   89a60:	699a      	ldr	r2, [r3, #24]
   89a62:	4b0c      	ldr	r3, [pc, #48]	; (89a94 <_ZN12AccelStepper3runEv+0x50>)
   89a64:	f04f 0100 	mov.w	r1, #0
   89a68:	4610      	mov	r0, r2
   89a6a:	4798      	blx	r3
   89a6c:	4603      	mov	r3, r0
   89a6e:	2b00      	cmp	r3, #0
   89a70:	d005      	beq.n	89a7e <_ZN12AccelStepper3runEv+0x3a>
   89a72:	6878      	ldr	r0, [r7, #4]
   89a74:	4b08      	ldr	r3, [pc, #32]	; (89a98 <_ZN12AccelStepper3runEv+0x54>)
   89a76:	4798      	blx	r3
   89a78:	4603      	mov	r3, r0
   89a7a:	2b00      	cmp	r3, #0
   89a7c:	d001      	beq.n	89a82 <_ZN12AccelStepper3runEv+0x3e>
   89a7e:	2301      	movs	r3, #1
   89a80:	e000      	b.n	89a84 <_ZN12AccelStepper3runEv+0x40>
   89a82:	2300      	movs	r3, #0
}
   89a84:	4618      	mov	r0, r3
   89a86:	3708      	adds	r7, #8
   89a88:	46bd      	mov	sp, r7
   89a8a:	bd80      	pop	{r7, pc}
   89a8c:	000896b5 	.word	0x000896b5
   89a90:	000897a9 	.word	0x000897a9
   89a94:	00093351 	.word	0x00093351
   89a98:	0008975d 	.word	0x0008975d

00089a9c <_ZN12AccelStepperC1Ehhhhhb>:

AccelStepper::AccelStepper(uint8_t interface, uint8_t pin1, uint8_t pin2, uint8_t pin3, uint8_t pin4, bool enable)
   89a9c:	b580      	push	{r7, lr}
   89a9e:	b084      	sub	sp, #16
   89aa0:	af00      	add	r7, sp, #0
   89aa2:	6078      	str	r0, [r7, #4]
   89aa4:	4608      	mov	r0, r1
   89aa6:	4611      	mov	r1, r2
   89aa8:	461a      	mov	r2, r3
   89aaa:	4603      	mov	r3, r0
   89aac:	70fb      	strb	r3, [r7, #3]
   89aae:	460b      	mov	r3, r1
   89ab0:	70bb      	strb	r3, [r7, #2]
   89ab2:	4613      	mov	r3, r2
   89ab4:	707b      	strb	r3, [r7, #1]
   89ab6:	4a34      	ldr	r2, [pc, #208]	; (89b88 <_ZN12AccelStepperC1Ehhhhhb+0xec>)
   89ab8:	687b      	ldr	r3, [r7, #4]
   89aba:	601a      	str	r2, [r3, #0]
{
	_interface = interface;
   89abc:	687b      	ldr	r3, [r7, #4]
   89abe:	78fa      	ldrb	r2, [r7, #3]
   89ac0:	711a      	strb	r2, [r3, #4]
	_currentPos = 0;
   89ac2:	687b      	ldr	r3, [r7, #4]
   89ac4:	2200      	movs	r2, #0
   89ac6:	611a      	str	r2, [r3, #16]
	_targetPos = 0;
   89ac8:	687b      	ldr	r3, [r7, #4]
   89aca:	2200      	movs	r2, #0
   89acc:	615a      	str	r2, [r3, #20]
	_speed = 0.0;
   89ace:	687b      	ldr	r3, [r7, #4]
   89ad0:	f04f 0200 	mov.w	r2, #0
   89ad4:	619a      	str	r2, [r3, #24]
	_maxSpeed = 1.0;
   89ad6:	687b      	ldr	r3, [r7, #4]
   89ad8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
   89adc:	61da      	str	r2, [r3, #28]
	_acceleration = 0.0;
   89ade:	687b      	ldr	r3, [r7, #4]
   89ae0:	f04f 0200 	mov.w	r2, #0
   89ae4:	621a      	str	r2, [r3, #32]
	_sqrt_twoa = 1.0;
   89ae6:	687b      	ldr	r3, [r7, #4]
   89ae8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
   89aec:	625a      	str	r2, [r3, #36]	; 0x24
	_stepInterval = 0;
   89aee:	687b      	ldr	r3, [r7, #4]
   89af0:	2200      	movs	r2, #0
   89af2:	629a      	str	r2, [r3, #40]	; 0x28
	_minPulseWidth = 1;
   89af4:	687b      	ldr	r3, [r7, #4]
   89af6:	2201      	movs	r2, #1
   89af8:	631a      	str	r2, [r3, #48]	; 0x30
	_enablePin = 0xff;
   89afa:	687b      	ldr	r3, [r7, #4]
   89afc:	22ff      	movs	r2, #255	; 0xff
   89afe:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
	_lastStepTime = 0;
   89b02:	687b      	ldr	r3, [r7, #4]
   89b04:	2200      	movs	r2, #0
   89b06:	62da      	str	r2, [r3, #44]	; 0x2c
	_pin[0] = pin1;
   89b08:	687b      	ldr	r3, [r7, #4]
   89b0a:	78ba      	ldrb	r2, [r7, #2]
   89b0c:	715a      	strb	r2, [r3, #5]
	_pin[1] = pin2;
   89b0e:	687b      	ldr	r3, [r7, #4]
   89b10:	787a      	ldrb	r2, [r7, #1]
   89b12:	719a      	strb	r2, [r3, #6]
	_pin[2] = pin3;
   89b14:	687b      	ldr	r3, [r7, #4]
   89b16:	7e3a      	ldrb	r2, [r7, #24]
   89b18:	71da      	strb	r2, [r3, #7]
	_pin[3] = pin4;
   89b1a:	687b      	ldr	r3, [r7, #4]
   89b1c:	7f3a      	ldrb	r2, [r7, #28]
   89b1e:	721a      	strb	r2, [r3, #8]

	// NEW
	_n = 0;
   89b20:	687b      	ldr	r3, [r7, #4]
   89b22:	2200      	movs	r2, #0
   89b24:	641a      	str	r2, [r3, #64]	; 0x40
	_c0 = 0.0;
   89b26:	687b      	ldr	r3, [r7, #4]
   89b28:	f04f 0200 	mov.w	r2, #0
   89b2c:	645a      	str	r2, [r3, #68]	; 0x44
	_cn = 0.0;
   89b2e:	687b      	ldr	r3, [r7, #4]
   89b30:	f04f 0200 	mov.w	r2, #0
   89b34:	649a      	str	r2, [r3, #72]	; 0x48
	_cmin = 1.0;
   89b36:	687b      	ldr	r3, [r7, #4]
   89b38:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
   89b3c:	64da      	str	r2, [r3, #76]	; 0x4c
	_direction = DIRECTION_CCW;
   89b3e:	687b      	ldr	r3, [r7, #4]
   89b40:	2200      	movs	r2, #0
   89b42:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

	int i;
	for (i = 0; i < 4; i++)
   89b46:	2300      	movs	r3, #0
   89b48:	60fb      	str	r3, [r7, #12]
   89b4a:	68fb      	ldr	r3, [r7, #12]
   89b4c:	2b03      	cmp	r3, #3
   89b4e:	dc09      	bgt.n	89b64 <_ZN12AccelStepperC1Ehhhhhb+0xc8>
		_pinInverted[i] = 0;
   89b50:	687a      	ldr	r2, [r7, #4]
   89b52:	68fb      	ldr	r3, [r7, #12]
   89b54:	4413      	add	r3, r2
   89b56:	3309      	adds	r3, #9
   89b58:	2200      	movs	r2, #0
   89b5a:	701a      	strb	r2, [r3, #0]
	_cn = 0.0;
	_cmin = 1.0;
	_direction = DIRECTION_CCW;

	int i;
	for (i = 0; i < 4; i++)
   89b5c:	68fb      	ldr	r3, [r7, #12]
   89b5e:	3301      	adds	r3, #1
   89b60:	60fb      	str	r3, [r7, #12]
   89b62:	e7f2      	b.n	89b4a <_ZN12AccelStepperC1Ehhhhhb+0xae>
		_pinInverted[i] = 0;
	if (enable)
   89b64:	f897 3020 	ldrb.w	r3, [r7, #32]
   89b68:	2b00      	cmp	r3, #0
   89b6a:	d002      	beq.n	89b72 <_ZN12AccelStepperC1Ehhhhhb+0xd6>
		enableOutputs();
   89b6c:	6878      	ldr	r0, [r7, #4]
   89b6e:	4b07      	ldr	r3, [pc, #28]	; (89b8c <_ZN12AccelStepperC1Ehhhhhb+0xf0>)
   89b70:	4798      	blx	r3
	// Some reasonable default
	setAcceleration(1);
   89b72:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
   89b76:	6878      	ldr	r0, [r7, #4]
   89b78:	4b05      	ldr	r3, [pc, #20]	; (89b90 <_ZN12AccelStepperC1Ehhhhhb+0xf4>)
   89b7a:	4798      	blx	r3
}
   89b7c:	687b      	ldr	r3, [r7, #4]
   89b7e:	4618      	mov	r0, r3
   89b80:	3710      	adds	r7, #16
   89b82:	46bd      	mov	sp, r7
   89b84:	bd80      	pop	{r7, pc}
   89b86:	bf00      	nop
   89b88:	0009ae0c 	.word	0x0009ae0c
   89b8c:	0008a269 	.word	0x0008a269
   89b90:	00089c61 	.word	0x00089c61

00089b94 <_ZN12AccelStepper11setMaxSpeedEf>:
	// Some reasonable default
	setAcceleration(1);
}

void AccelStepper::setMaxSpeed(float speed)
{
   89b94:	b590      	push	{r4, r7, lr}
   89b96:	b085      	sub	sp, #20
   89b98:	af00      	add	r7, sp, #0
   89b9a:	6078      	str	r0, [r7, #4]
   89b9c:	6039      	str	r1, [r7, #0]
	if (_maxSpeed != speed)
   89b9e:	687b      	ldr	r3, [r7, #4]
   89ba0:	69da      	ldr	r2, [r3, #28]
   89ba2:	4b25      	ldr	r3, [pc, #148]	; (89c38 <_ZN12AccelStepper11setMaxSpeedEf+0xa4>)
   89ba4:	6839      	ldr	r1, [r7, #0]
   89ba6:	4610      	mov	r0, r2
   89ba8:	4798      	blx	r3
   89baa:	4603      	mov	r3, r0
   89bac:	2b00      	cmp	r3, #0
   89bae:	d000      	beq.n	89bb2 <_ZN12AccelStepper11setMaxSpeedEf+0x1e>
			unsigned long acc = (2.0 * _acceleration);
			_n = (long)((_speed * _speed) / acc); // Equation 16
			computeNewSpeed();
		}
	}
}
   89bb0:	e03d      	b.n	89c2e <_ZN12AccelStepper11setMaxSpeedEf+0x9a>

void AccelStepper::setMaxSpeed(float speed)
{
	if (_maxSpeed != speed)
	{
		_maxSpeed = speed;
   89bb2:	687b      	ldr	r3, [r7, #4]
   89bb4:	683a      	ldr	r2, [r7, #0]
   89bb6:	61da      	str	r2, [r3, #28]
		_cmin = 1000000.0 / speed;
   89bb8:	4b20      	ldr	r3, [pc, #128]	; (89c3c <_ZN12AccelStepper11setMaxSpeedEf+0xa8>)
   89bba:	6839      	ldr	r1, [r7, #0]
   89bbc:	4820      	ldr	r0, [pc, #128]	; (89c40 <_ZN12AccelStepper11setMaxSpeedEf+0xac>)
   89bbe:	4798      	blx	r3
   89bc0:	4603      	mov	r3, r0
   89bc2:	461a      	mov	r2, r3
   89bc4:	687b      	ldr	r3, [r7, #4]
   89bc6:	64da      	str	r2, [r3, #76]	; 0x4c
		// Recompute _n from current speed and adjust speed if accelerating or cruising
		if (_n > 0)
   89bc8:	687b      	ldr	r3, [r7, #4]
   89bca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   89bcc:	2b00      	cmp	r3, #0
   89bce:	dd2e      	ble.n	89c2e <_ZN12AccelStepper11setMaxSpeedEf+0x9a>
		{
			unsigned long acc = (2.0 * _acceleration);
   89bd0:	687b      	ldr	r3, [r7, #4]
   89bd2:	6a1a      	ldr	r2, [r3, #32]
   89bd4:	4b1b      	ldr	r3, [pc, #108]	; (89c44 <_ZN12AccelStepper11setMaxSpeedEf+0xb0>)
   89bd6:	4610      	mov	r0, r2
   89bd8:	4798      	blx	r3
   89bda:	4c1b      	ldr	r4, [pc, #108]	; (89c48 <_ZN12AccelStepper11setMaxSpeedEf+0xb4>)
   89bdc:	4602      	mov	r2, r0
   89bde:	460b      	mov	r3, r1
   89be0:	47a0      	blx	r4
   89be2:	4603      	mov	r3, r0
   89be4:	460c      	mov	r4, r1
   89be6:	4619      	mov	r1, r3
   89be8:	4622      	mov	r2, r4
   89bea:	4b18      	ldr	r3, [pc, #96]	; (89c4c <_ZN12AccelStepper11setMaxSpeedEf+0xb8>)
   89bec:	4608      	mov	r0, r1
   89bee:	4611      	mov	r1, r2
   89bf0:	4798      	blx	r3
   89bf2:	4603      	mov	r3, r0
   89bf4:	60fb      	str	r3, [r7, #12]
			_n = (long)((_speed * _speed) / acc); // Equation 16
   89bf6:	687b      	ldr	r3, [r7, #4]
   89bf8:	699a      	ldr	r2, [r3, #24]
   89bfa:	687b      	ldr	r3, [r7, #4]
   89bfc:	6999      	ldr	r1, [r3, #24]
   89bfe:	4b14      	ldr	r3, [pc, #80]	; (89c50 <_ZN12AccelStepper11setMaxSpeedEf+0xbc>)
   89c00:	4610      	mov	r0, r2
   89c02:	4798      	blx	r3
   89c04:	4603      	mov	r3, r0
   89c06:	461c      	mov	r4, r3
   89c08:	4b12      	ldr	r3, [pc, #72]	; (89c54 <_ZN12AccelStepper11setMaxSpeedEf+0xc0>)
   89c0a:	68f8      	ldr	r0, [r7, #12]
   89c0c:	4798      	blx	r3
   89c0e:	4602      	mov	r2, r0
   89c10:	4b0a      	ldr	r3, [pc, #40]	; (89c3c <_ZN12AccelStepper11setMaxSpeedEf+0xa8>)
   89c12:	4611      	mov	r1, r2
   89c14:	4620      	mov	r0, r4
   89c16:	4798      	blx	r3
   89c18:	4603      	mov	r3, r0
   89c1a:	461a      	mov	r2, r3
   89c1c:	4b0e      	ldr	r3, [pc, #56]	; (89c58 <_ZN12AccelStepper11setMaxSpeedEf+0xc4>)
   89c1e:	4610      	mov	r0, r2
   89c20:	4798      	blx	r3
   89c22:	4602      	mov	r2, r0
   89c24:	687b      	ldr	r3, [r7, #4]
   89c26:	641a      	str	r2, [r3, #64]	; 0x40
			computeNewSpeed();
   89c28:	6878      	ldr	r0, [r7, #4]
   89c2a:	4b0c      	ldr	r3, [pc, #48]	; (89c5c <_ZN12AccelStepper11setMaxSpeedEf+0xc8>)
   89c2c:	4798      	blx	r3
		}
	}
}
   89c2e:	bf00      	nop
   89c30:	3714      	adds	r7, #20
   89c32:	46bd      	mov	sp, r7
   89c34:	bd90      	pop	{r4, r7, pc}
   89c36:	bf00      	nop
   89c38:	00093351 	.word	0x00093351
   89c3c:	00093191 	.word	0x00093191
   89c40:	49742400 	.word	0x49742400
   89c44:	000926d5 	.word	0x000926d5
   89c48:	00092419 	.word	0x00092419
   89c4c:	00092d2d 	.word	0x00092d2d
   89c50:	00093029 	.word	0x00093029
   89c54:	00092f79 	.word	0x00092f79
   89c58:	000933b5 	.word	0x000933b5
   89c5c:	000897a9 	.word	0x000897a9

00089c60 <_ZN12AccelStepper15setAccelerationEf>:

void AccelStepper::setAcceleration(float acceleration)
{
   89c60:	b590      	push	{r4, r7, lr}
   89c62:	b083      	sub	sp, #12
   89c64:	af00      	add	r7, sp, #0
   89c66:	6078      	str	r0, [r7, #4]
   89c68:	6039      	str	r1, [r7, #0]
	if (acceleration == 0.0)
   89c6a:	4b2d      	ldr	r3, [pc, #180]	; (89d20 <_ZN12AccelStepper15setAccelerationEf+0xc0>)
   89c6c:	f04f 0100 	mov.w	r1, #0
   89c70:	6838      	ldr	r0, [r7, #0]
   89c72:	4798      	blx	r3
   89c74:	4603      	mov	r3, r0
   89c76:	2b00      	cmp	r3, #0
   89c78:	d14a      	bne.n	89d10 <_ZN12AccelStepper15setAccelerationEf+0xb0>
		return;
	if (_acceleration != acceleration)
   89c7a:	687b      	ldr	r3, [r7, #4]
   89c7c:	6a1a      	ldr	r2, [r3, #32]
   89c7e:	4b28      	ldr	r3, [pc, #160]	; (89d20 <_ZN12AccelStepper15setAccelerationEf+0xc0>)
   89c80:	6839      	ldr	r1, [r7, #0]
   89c82:	4610      	mov	r0, r2
   89c84:	4798      	blx	r3
   89c86:	4603      	mov	r3, r0
   89c88:	2b00      	cmp	r3, #0
   89c8a:	d142      	bne.n	89d12 <_ZN12AccelStepper15setAccelerationEf+0xb2>
	{
		// Recompute _n per Equation 17
		_n *= (_acceleration / acceleration);
   89c8c:	687b      	ldr	r3, [r7, #4]
   89c8e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   89c90:	4b24      	ldr	r3, [pc, #144]	; (89d24 <_ZN12AccelStepper15setAccelerationEf+0xc4>)
   89c92:	4610      	mov	r0, r2
   89c94:	4798      	blx	r3
   89c96:	4604      	mov	r4, r0
   89c98:	687b      	ldr	r3, [r7, #4]
   89c9a:	6a1a      	ldr	r2, [r3, #32]
   89c9c:	4b22      	ldr	r3, [pc, #136]	; (89d28 <_ZN12AccelStepper15setAccelerationEf+0xc8>)
   89c9e:	6839      	ldr	r1, [r7, #0]
   89ca0:	4610      	mov	r0, r2
   89ca2:	4798      	blx	r3
   89ca4:	4603      	mov	r3, r0
   89ca6:	461a      	mov	r2, r3
   89ca8:	4b20      	ldr	r3, [pc, #128]	; (89d2c <_ZN12AccelStepper15setAccelerationEf+0xcc>)
   89caa:	4611      	mov	r1, r2
   89cac:	4620      	mov	r0, r4
   89cae:	4798      	blx	r3
   89cb0:	4603      	mov	r3, r0
   89cb2:	461a      	mov	r2, r3
   89cb4:	4b1e      	ldr	r3, [pc, #120]	; (89d30 <_ZN12AccelStepper15setAccelerationEf+0xd0>)
   89cb6:	4610      	mov	r0, r2
   89cb8:	4798      	blx	r3
   89cba:	4602      	mov	r2, r0
   89cbc:	687b      	ldr	r3, [r7, #4]
   89cbe:	641a      	str	r2, [r3, #64]	; 0x40
		// New c0 per Equation 7
		_c0 = sqrt(2.0 / acceleration) * 1000000.0; // Accelerates at half the expected rate. Why?
   89cc0:	4b1c      	ldr	r3, [pc, #112]	; (89d34 <_ZN12AccelStepper15setAccelerationEf+0xd4>)
   89cc2:	6838      	ldr	r0, [r7, #0]
   89cc4:	4798      	blx	r3
   89cc6:	4602      	mov	r2, r0
   89cc8:	460b      	mov	r3, r1
   89cca:	4c1b      	ldr	r4, [pc, #108]	; (89d38 <_ZN12AccelStepper15setAccelerationEf+0xd8>)
   89ccc:	f04f 0000 	mov.w	r0, #0
   89cd0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
   89cd4:	47a0      	blx	r4
   89cd6:	4603      	mov	r3, r0
   89cd8:	460c      	mov	r4, r1
   89cda:	4618      	mov	r0, r3
   89cdc:	4621      	mov	r1, r4
   89cde:	4b17      	ldr	r3, [pc, #92]	; (89d3c <_ZN12AccelStepper15setAccelerationEf+0xdc>)
   89ce0:	4798      	blx	r3
   89ce2:	4c17      	ldr	r4, [pc, #92]	; (89d40 <_ZN12AccelStepper15setAccelerationEf+0xe0>)
   89ce4:	a30c      	add	r3, pc, #48	; (adr r3, 89d18 <_ZN12AccelStepper15setAccelerationEf+0xb8>)
   89ce6:	e9d3 2300 	ldrd	r2, r3, [r3]
   89cea:	47a0      	blx	r4
   89cec:	4603      	mov	r3, r0
   89cee:	460c      	mov	r4, r1
   89cf0:	4619      	mov	r1, r3
   89cf2:	4622      	mov	r2, r4
   89cf4:	4b13      	ldr	r3, [pc, #76]	; (89d44 <_ZN12AccelStepper15setAccelerationEf+0xe4>)
   89cf6:	4608      	mov	r0, r1
   89cf8:	4611      	mov	r1, r2
   89cfa:	4798      	blx	r3
   89cfc:	4602      	mov	r2, r0
   89cfe:	687b      	ldr	r3, [r7, #4]
   89d00:	645a      	str	r2, [r3, #68]	; 0x44
		//	_c0 = sqrt(1.0/acceleration) * 1000000.0;
		_acceleration = acceleration;
   89d02:	687b      	ldr	r3, [r7, #4]
   89d04:	683a      	ldr	r2, [r7, #0]
   89d06:	621a      	str	r2, [r3, #32]
		computeNewSpeed();
   89d08:	6878      	ldr	r0, [r7, #4]
   89d0a:	4b0f      	ldr	r3, [pc, #60]	; (89d48 <_ZN12AccelStepper15setAccelerationEf+0xe8>)
   89d0c:	4798      	blx	r3
   89d0e:	e000      	b.n	89d12 <_ZN12AccelStepper15setAccelerationEf+0xb2>
}

void AccelStepper::setAcceleration(float acceleration)
{
	if (acceleration == 0.0)
		return;
   89d10:	bf00      	nop
		_c0 = sqrt(2.0 / acceleration) * 1000000.0; // Accelerates at half the expected rate. Why?
		//	_c0 = sqrt(1.0/acceleration) * 1000000.0;
		_acceleration = acceleration;
		computeNewSpeed();
	}
}
   89d12:	370c      	adds	r7, #12
   89d14:	46bd      	mov	sp, r7
   89d16:	bd90      	pop	{r4, r7, pc}
   89d18:	00000000 	.word	0x00000000
   89d1c:	412e8480 	.word	0x412e8480
   89d20:	00093351 	.word	0x00093351
   89d24:	00092f81 	.word	0x00092f81
   89d28:	00093191 	.word	0x00093191
   89d2c:	00093029 	.word	0x00093029
   89d30:	000933b5 	.word	0x000933b5
   89d34:	000926d5 	.word	0x000926d5
   89d38:	000929d1 	.word	0x000929d1
   89d3c:	00090afd 	.word	0x00090afd
   89d40:	0009277d 	.word	0x0009277d
   89d44:	00092d6d 	.word	0x00092d6d
   89d48:	000897a9 	.word	0x000897a9

00089d4c <_ZN12AccelStepper4stepEl>:
	return _speed;
}

// Subclasses can override
void AccelStepper::step(long step)
{
   89d4c:	b580      	push	{r7, lr}
   89d4e:	b082      	sub	sp, #8
   89d50:	af00      	add	r7, sp, #0
   89d52:	6078      	str	r0, [r7, #4]
   89d54:	6039      	str	r1, [r7, #0]
	switch (_interface)
   89d56:	687b      	ldr	r3, [r7, #4]
   89d58:	791b      	ldrb	r3, [r3, #4]
   89d5a:	2b08      	cmp	r3, #8
   89d5c:	d84c      	bhi.n	89df8 <_ZN12AccelStepper4stepEl+0xac>
   89d5e:	a201      	add	r2, pc, #4	; (adr r2, 89d64 <_ZN12AccelStepper4stepEl+0x18>)
   89d60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   89d64:	00089d89 	.word	0x00089d89
   89d68:	00089d99 	.word	0x00089d99
   89d6c:	00089da9 	.word	0x00089da9
   89d70:	00089db9 	.word	0x00089db9
   89d74:	00089dc9 	.word	0x00089dc9
   89d78:	00089df9 	.word	0x00089df9
   89d7c:	00089dd9 	.word	0x00089dd9
   89d80:	00089df9 	.word	0x00089df9
   89d84:	00089de9 	.word	0x00089de9
	{
	case FUNCTION:
		step0(step);
   89d88:	687b      	ldr	r3, [r7, #4]
   89d8a:	681b      	ldr	r3, [r3, #0]
   89d8c:	3310      	adds	r3, #16
   89d8e:	681b      	ldr	r3, [r3, #0]
   89d90:	6839      	ldr	r1, [r7, #0]
   89d92:	6878      	ldr	r0, [r7, #4]
   89d94:	4798      	blx	r3
		break;
   89d96:	e02f      	b.n	89df8 <_ZN12AccelStepper4stepEl+0xac>

	case DRIVER:
		step1(step);
   89d98:	687b      	ldr	r3, [r7, #4]
   89d9a:	681b      	ldr	r3, [r3, #0]
   89d9c:	3314      	adds	r3, #20
   89d9e:	681b      	ldr	r3, [r3, #0]
   89da0:	6839      	ldr	r1, [r7, #0]
   89da2:	6878      	ldr	r0, [r7, #4]
   89da4:	4798      	blx	r3
		break;
   89da6:	e027      	b.n	89df8 <_ZN12AccelStepper4stepEl+0xac>

	case FULL2WIRE:
		step2(step);
   89da8:	687b      	ldr	r3, [r7, #4]
   89daa:	681b      	ldr	r3, [r3, #0]
   89dac:	3318      	adds	r3, #24
   89dae:	681b      	ldr	r3, [r3, #0]
   89db0:	6839      	ldr	r1, [r7, #0]
   89db2:	6878      	ldr	r0, [r7, #4]
   89db4:	4798      	blx	r3
		break;
   89db6:	e01f      	b.n	89df8 <_ZN12AccelStepper4stepEl+0xac>

	case FULL3WIRE:
		step3(step);
   89db8:	687b      	ldr	r3, [r7, #4]
   89dba:	681b      	ldr	r3, [r3, #0]
   89dbc:	331c      	adds	r3, #28
   89dbe:	681b      	ldr	r3, [r3, #0]
   89dc0:	6839      	ldr	r1, [r7, #0]
   89dc2:	6878      	ldr	r0, [r7, #4]
   89dc4:	4798      	blx	r3
		break;
   89dc6:	e017      	b.n	89df8 <_ZN12AccelStepper4stepEl+0xac>

	case FULL4WIRE:
		step4(step);
   89dc8:	687b      	ldr	r3, [r7, #4]
   89dca:	681b      	ldr	r3, [r3, #0]
   89dcc:	3320      	adds	r3, #32
   89dce:	681b      	ldr	r3, [r3, #0]
   89dd0:	6839      	ldr	r1, [r7, #0]
   89dd2:	6878      	ldr	r0, [r7, #4]
   89dd4:	4798      	blx	r3
		break;
   89dd6:	e00f      	b.n	89df8 <_ZN12AccelStepper4stepEl+0xac>

	case HALF3WIRE:
		step6(step);
   89dd8:	687b      	ldr	r3, [r7, #4]
   89dda:	681b      	ldr	r3, [r3, #0]
   89ddc:	3324      	adds	r3, #36	; 0x24
   89dde:	681b      	ldr	r3, [r3, #0]
   89de0:	6839      	ldr	r1, [r7, #0]
   89de2:	6878      	ldr	r0, [r7, #4]
   89de4:	4798      	blx	r3
		break;
   89de6:	e007      	b.n	89df8 <_ZN12AccelStepper4stepEl+0xac>

	case HALF4WIRE:
		step8(step);
   89de8:	687b      	ldr	r3, [r7, #4]
   89dea:	681b      	ldr	r3, [r3, #0]
   89dec:	3328      	adds	r3, #40	; 0x28
   89dee:	681b      	ldr	r3, [r3, #0]
   89df0:	6839      	ldr	r1, [r7, #0]
   89df2:	6878      	ldr	r0, [r7, #4]
   89df4:	4798      	blx	r3
		break;
   89df6:	bf00      	nop
	}
}
   89df8:	bf00      	nop
   89dfa:	3708      	adds	r7, #8
   89dfc:	46bd      	mov	sp, r7
   89dfe:	bd80      	pop	{r7, pc}

00089e00 <_ZN12AccelStepper13setOutputPinsEh>:
// You might want to override this to implement eg serial output
// bit 0 of the mask corresponds to _pin[0]
// bit 1 of the mask corresponds to _pin[1]
// ....
void AccelStepper::setOutputPins(uint8_t mask)
{
   89e00:	b580      	push	{r7, lr}
   89e02:	b084      	sub	sp, #16
   89e04:	af00      	add	r7, sp, #0
   89e06:	6078      	str	r0, [r7, #4]
   89e08:	460b      	mov	r3, r1
   89e0a:	70fb      	strb	r3, [r7, #3]
	uint8_t numpins = 2;
   89e0c:	2302      	movs	r3, #2
   89e0e:	73fb      	strb	r3, [r7, #15]
	if (_interface == FULL4WIRE || _interface == HALF4WIRE)
   89e10:	687b      	ldr	r3, [r7, #4]
   89e12:	791b      	ldrb	r3, [r3, #4]
   89e14:	2b04      	cmp	r3, #4
   89e16:	d003      	beq.n	89e20 <_ZN12AccelStepper13setOutputPinsEh+0x20>
   89e18:	687b      	ldr	r3, [r7, #4]
   89e1a:	791b      	ldrb	r3, [r3, #4]
   89e1c:	2b08      	cmp	r3, #8
   89e1e:	d102      	bne.n	89e26 <_ZN12AccelStepper13setOutputPinsEh+0x26>
		numpins = 4;
   89e20:	2304      	movs	r3, #4
   89e22:	73fb      	strb	r3, [r7, #15]
   89e24:	e009      	b.n	89e3a <_ZN12AccelStepper13setOutputPinsEh+0x3a>
	else if (_interface == FULL3WIRE || _interface == HALF3WIRE)
   89e26:	687b      	ldr	r3, [r7, #4]
   89e28:	791b      	ldrb	r3, [r3, #4]
   89e2a:	2b03      	cmp	r3, #3
   89e2c:	d003      	beq.n	89e36 <_ZN12AccelStepper13setOutputPinsEh+0x36>
   89e2e:	687b      	ldr	r3, [r7, #4]
   89e30:	791b      	ldrb	r3, [r3, #4]
   89e32:	2b06      	cmp	r3, #6
   89e34:	d101      	bne.n	89e3a <_ZN12AccelStepper13setOutputPinsEh+0x3a>
		numpins = 3;
   89e36:	2303      	movs	r3, #3
   89e38:	73fb      	strb	r3, [r7, #15]
	uint8_t i;
	for (i = 0; i < numpins; i++)
   89e3a:	2300      	movs	r3, #0
   89e3c:	73bb      	strb	r3, [r7, #14]
   89e3e:	7bba      	ldrb	r2, [r7, #14]
   89e40:	7bfb      	ldrb	r3, [r7, #15]
   89e42:	429a      	cmp	r2, r3
   89e44:	d21f      	bcs.n	89e86 <_ZN12AccelStepper13setOutputPinsEh+0x86>
		digitalWrite(_pin[i], (mask & (1 << i)) ? (HIGH ^ _pinInverted[i]) : (LOW ^ _pinInverted[i]));
   89e46:	7bbb      	ldrb	r3, [r7, #14]
   89e48:	687a      	ldr	r2, [r7, #4]
   89e4a:	4413      	add	r3, r2
   89e4c:	795b      	ldrb	r3, [r3, #5]
   89e4e:	4618      	mov	r0, r3
   89e50:	78fa      	ldrb	r2, [r7, #3]
   89e52:	7bbb      	ldrb	r3, [r7, #14]
   89e54:	fa42 f303 	asr.w	r3, r2, r3
   89e58:	f003 0301 	and.w	r3, r3, #1
   89e5c:	2b00      	cmp	r3, #0
   89e5e:	d007      	beq.n	89e70 <_ZN12AccelStepper13setOutputPinsEh+0x70>
   89e60:	7bbb      	ldrb	r3, [r7, #14]
   89e62:	687a      	ldr	r2, [r7, #4]
   89e64:	4413      	add	r3, r2
   89e66:	7a5b      	ldrb	r3, [r3, #9]
   89e68:	f083 0301 	eor.w	r3, r3, #1
   89e6c:	b2db      	uxtb	r3, r3
   89e6e:	e003      	b.n	89e78 <_ZN12AccelStepper13setOutputPinsEh+0x78>
   89e70:	7bbb      	ldrb	r3, [r7, #14]
   89e72:	687a      	ldr	r2, [r7, #4]
   89e74:	4413      	add	r3, r2
   89e76:	7a5b      	ldrb	r3, [r3, #9]
   89e78:	4619      	mov	r1, r3
   89e7a:	4b05      	ldr	r3, [pc, #20]	; (89e90 <_ZN12AccelStepper13setOutputPinsEh+0x90>)
   89e7c:	4798      	blx	r3
	if (_interface == FULL4WIRE || _interface == HALF4WIRE)
		numpins = 4;
	else if (_interface == FULL3WIRE || _interface == HALF3WIRE)
		numpins = 3;
	uint8_t i;
	for (i = 0; i < numpins; i++)
   89e7e:	7bbb      	ldrb	r3, [r7, #14]
   89e80:	3301      	adds	r3, #1
   89e82:	73bb      	strb	r3, [r7, #14]
   89e84:	e7db      	b.n	89e3e <_ZN12AccelStepper13setOutputPinsEh+0x3e>
		digitalWrite(_pin[i], (mask & (1 << i)) ? (HIGH ^ _pinInverted[i]) : (LOW ^ _pinInverted[i]));
}
   89e86:	bf00      	nop
   89e88:	3710      	adds	r7, #16
   89e8a:	46bd      	mov	sp, r7
   89e8c:	bd80      	pop	{r7, pc}
   89e8e:	bf00      	nop
   89e90:	00081f29 	.word	0x00081f29

00089e94 <_ZN12AccelStepper5step0El>:

// 0 pin step function (ie for functional usage)
void AccelStepper::step0(long step)
{
   89e94:	b580      	push	{r7, lr}
   89e96:	b082      	sub	sp, #8
   89e98:	af00      	add	r7, sp, #0
   89e9a:	6078      	str	r0, [r7, #4]
   89e9c:	6039      	str	r1, [r7, #0]
	if (_speed > 0)
   89e9e:	687b      	ldr	r3, [r7, #4]
   89ea0:	699a      	ldr	r2, [r3, #24]
   89ea2:	4b09      	ldr	r3, [pc, #36]	; (89ec8 <_ZN12AccelStepper5step0El+0x34>)
   89ea4:	f04f 0100 	mov.w	r1, #0
   89ea8:	4610      	mov	r0, r2
   89eaa:	4798      	blx	r3
   89eac:	4603      	mov	r3, r0
   89eae:	2b00      	cmp	r3, #0
   89eb0:	d003      	beq.n	89eba <_ZN12AccelStepper5step0El+0x26>
		_forward();
   89eb2:	687b      	ldr	r3, [r7, #4]
   89eb4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   89eb6:	4798      	blx	r3
	else
		_backward();
}
   89eb8:	e002      	b.n	89ec0 <_ZN12AccelStepper5step0El+0x2c>
void AccelStepper::step0(long step)
{
	if (_speed > 0)
		_forward();
	else
		_backward();
   89eba:	687b      	ldr	r3, [r7, #4]
   89ebc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   89ebe:	4798      	blx	r3
}
   89ec0:	bf00      	nop
   89ec2:	3708      	adds	r7, #8
   89ec4:	46bd      	mov	sp, r7
   89ec6:	bd80      	pop	{r7, pc}
   89ec8:	000933a1 	.word	0x000933a1

00089ecc <_ZN12AccelStepper5step1El>:

// 1 pin step function (ie for stepper drivers)
// This is passed the current step number (0 to 7)
// Subclasses can override
void AccelStepper::step1(long step)
{
   89ecc:	b580      	push	{r7, lr}
   89ece:	b084      	sub	sp, #16
   89ed0:	af00      	add	r7, sp, #0
   89ed2:	6078      	str	r0, [r7, #4]
   89ed4:	6039      	str	r1, [r7, #0]
	// _pin[0] is step, _pin[1] is direction
	setOutputPins(_direction ? 0b10 : 0b00); // Set direction first else get rogue pulses
   89ed6:	687b      	ldr	r3, [r7, #4]
   89ed8:	681b      	ldr	r3, [r3, #0]
   89eda:	3308      	adds	r3, #8
   89edc:	681b      	ldr	r3, [r3, #0]
   89ede:	687a      	ldr	r2, [r7, #4]
   89ee0:	f892 2050 	ldrb.w	r2, [r2, #80]	; 0x50
   89ee4:	2a00      	cmp	r2, #0
   89ee6:	d001      	beq.n	89eec <_ZN12AccelStepper5step1El+0x20>
   89ee8:	2202      	movs	r2, #2
   89eea:	e000      	b.n	89eee <_ZN12AccelStepper5step1El+0x22>
   89eec:	2200      	movs	r2, #0
   89eee:	4611      	mov	r1, r2
   89ef0:	6878      	ldr	r0, [r7, #4]
   89ef2:	4798      	blx	r3
	setOutputPins(_direction ? 0b11 : 0b01); // step HIGH
   89ef4:	687b      	ldr	r3, [r7, #4]
   89ef6:	681b      	ldr	r3, [r3, #0]
   89ef8:	3308      	adds	r3, #8
   89efa:	681b      	ldr	r3, [r3, #0]
   89efc:	687a      	ldr	r2, [r7, #4]
   89efe:	f892 2050 	ldrb.w	r2, [r2, #80]	; 0x50
   89f02:	2a00      	cmp	r2, #0
   89f04:	d001      	beq.n	89f0a <_ZN12AccelStepper5step1El+0x3e>
   89f06:	2203      	movs	r2, #3
   89f08:	e000      	b.n	89f0c <_ZN12AccelStepper5step1El+0x40>
   89f0a:	2201      	movs	r2, #1
   89f0c:	4611      	mov	r1, r2
   89f0e:	6878      	ldr	r0, [r7, #4]
   89f10:	4798      	blx	r3
	// Caution 200ns setup time
	// Delay the minimum allowed pulse width
	delayMicroseconds(_minPulseWidth);
   89f12:	687b      	ldr	r3, [r7, #4]
   89f14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   89f16:	60fb      	str	r3, [r7, #12]
static inline void delayMicroseconds(uint32_t usec){
    /*
     * Based on Paul Stoffregen's implementation
     * for Teensy 3.0 (http://www.pjrc.com/)
     */
    if (usec == 0) return;
   89f18:	68fb      	ldr	r3, [r7, #12]
   89f1a:	2b00      	cmp	r3, #0
   89f1c:	d009      	beq.n	89f32 <L_1965_delayMicroseconds+0x6>
    uint32_t n = usec * (VARIANT_MCK / 3000000);
   89f1e:	68fa      	ldr	r2, [r7, #12]
   89f20:	4613      	mov	r3, r2
   89f22:	00db      	lsls	r3, r3, #3
   89f24:	1a9b      	subs	r3, r3, r2
   89f26:	009b      	lsls	r3, r3, #2
   89f28:	60bb      	str	r3, [r7, #8]
    asm volatile(
        "L_%=_delayMicroseconds:"       "\n\t"
        "subs   %0, #1"                 "\n\t"
        "bne    L_%=_delayMicroseconds" "\n"
        : "+r" (n) :
    );
   89f2a:	68bb      	ldr	r3, [r7, #8]

00089f2c <L_1965_delayMicroseconds>:
   89f2c:	3b01      	subs	r3, #1
   89f2e:	d1fd      	bne.n	89f2c <L_1965_delayMicroseconds>
   89f30:	60bb      	str	r3, [r7, #8]
	setOutputPins(_direction ? 0b10 : 0b00); // step LOW
   89f32:	687b      	ldr	r3, [r7, #4]
   89f34:	681b      	ldr	r3, [r3, #0]
   89f36:	3308      	adds	r3, #8
   89f38:	681b      	ldr	r3, [r3, #0]
   89f3a:	687a      	ldr	r2, [r7, #4]
   89f3c:	f892 2050 	ldrb.w	r2, [r2, #80]	; 0x50
   89f40:	2a00      	cmp	r2, #0
   89f42:	d001      	beq.n	89f48 <L_1965_delayMicroseconds+0x1c>
   89f44:	2202      	movs	r2, #2
   89f46:	e000      	b.n	89f4a <L_1965_delayMicroseconds+0x1e>
   89f48:	2200      	movs	r2, #0
   89f4a:	4611      	mov	r1, r2
   89f4c:	6878      	ldr	r0, [r7, #4]
   89f4e:	4798      	blx	r3

}
   89f50:	bf00      	nop
   89f52:	3710      	adds	r7, #16
   89f54:	46bd      	mov	sp, r7
   89f56:	bd80      	pop	{r7, pc}

00089f58 <_ZN12AccelStepper5step2El>:

// 2 pin step function
// This is passed the current step number (0 to 7)
// Subclasses can override
void AccelStepper::step2(long step)
{
   89f58:	b580      	push	{r7, lr}
   89f5a:	b082      	sub	sp, #8
   89f5c:	af00      	add	r7, sp, #0
   89f5e:	6078      	str	r0, [r7, #4]
   89f60:	6039      	str	r1, [r7, #0]
	switch (step & 0x3)
   89f62:	683b      	ldr	r3, [r7, #0]
   89f64:	f003 0303 	and.w	r3, r3, #3
   89f68:	2b03      	cmp	r3, #3
   89f6a:	d82b      	bhi.n	89fc4 <_ZN12AccelStepper5step2El+0x6c>
   89f6c:	a201      	add	r2, pc, #4	; (adr r2, 89f74 <_ZN12AccelStepper5step2El+0x1c>)
   89f6e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   89f72:	bf00      	nop
   89f74:	00089f85 	.word	0x00089f85
   89f78:	00089f95 	.word	0x00089f95
   89f7c:	00089fa5 	.word	0x00089fa5
   89f80:	00089fb5 	.word	0x00089fb5
	{
	case 0: /* 01 */
		setOutputPins(0b10);
   89f84:	687b      	ldr	r3, [r7, #4]
   89f86:	681b      	ldr	r3, [r3, #0]
   89f88:	3308      	adds	r3, #8
   89f8a:	681b      	ldr	r3, [r3, #0]
   89f8c:	2102      	movs	r1, #2
   89f8e:	6878      	ldr	r0, [r7, #4]
   89f90:	4798      	blx	r3
		break;
   89f92:	e017      	b.n	89fc4 <_ZN12AccelStepper5step2El+0x6c>

	case 1: /* 11 */
		setOutputPins(0b11);
   89f94:	687b      	ldr	r3, [r7, #4]
   89f96:	681b      	ldr	r3, [r3, #0]
   89f98:	3308      	adds	r3, #8
   89f9a:	681b      	ldr	r3, [r3, #0]
   89f9c:	2103      	movs	r1, #3
   89f9e:	6878      	ldr	r0, [r7, #4]
   89fa0:	4798      	blx	r3
		break;
   89fa2:	e00f      	b.n	89fc4 <_ZN12AccelStepper5step2El+0x6c>

	case 2: /* 10 */
		setOutputPins(0b01);
   89fa4:	687b      	ldr	r3, [r7, #4]
   89fa6:	681b      	ldr	r3, [r3, #0]
   89fa8:	3308      	adds	r3, #8
   89faa:	681b      	ldr	r3, [r3, #0]
   89fac:	2101      	movs	r1, #1
   89fae:	6878      	ldr	r0, [r7, #4]
   89fb0:	4798      	blx	r3
		break;
   89fb2:	e007      	b.n	89fc4 <_ZN12AccelStepper5step2El+0x6c>

	case 3: /* 00 */
		setOutputPins(0b00);
   89fb4:	687b      	ldr	r3, [r7, #4]
   89fb6:	681b      	ldr	r3, [r3, #0]
   89fb8:	3308      	adds	r3, #8
   89fba:	681b      	ldr	r3, [r3, #0]
   89fbc:	2100      	movs	r1, #0
   89fbe:	6878      	ldr	r0, [r7, #4]
   89fc0:	4798      	blx	r3
		break;
   89fc2:	bf00      	nop
	}
}
   89fc4:	bf00      	nop
   89fc6:	3708      	adds	r7, #8
   89fc8:	46bd      	mov	sp, r7
   89fca:	bd80      	pop	{r7, pc}

00089fcc <_ZN12AccelStepper5step3El>:
// 3 pin step function
// This is passed the current step number (0 to 7)
// Subclasses can override
void AccelStepper::step3(long step)
{
   89fcc:	b580      	push	{r7, lr}
   89fce:	b082      	sub	sp, #8
   89fd0:	af00      	add	r7, sp, #0
   89fd2:	6078      	str	r0, [r7, #4]
   89fd4:	6039      	str	r1, [r7, #0]
	switch (step % 3)
   89fd6:	6839      	ldr	r1, [r7, #0]
   89fd8:	4b15      	ldr	r3, [pc, #84]	; (8a030 <_ZN12AccelStepper5step3El+0x64>)
   89fda:	fb83 3201 	smull	r3, r2, r3, r1
   89fde:	17cb      	asrs	r3, r1, #31
   89fe0:	1ad3      	subs	r3, r2, r3
   89fe2:	461a      	mov	r2, r3
   89fe4:	0052      	lsls	r2, r2, #1
   89fe6:	441a      	add	r2, r3
   89fe8:	1a8b      	subs	r3, r1, r2
   89fea:	2b01      	cmp	r3, #1
   89fec:	d00c      	beq.n	8a008 <_ZN12AccelStepper5step3El+0x3c>
   89fee:	2b02      	cmp	r3, #2
   89ff0:	d012      	beq.n	8a018 <_ZN12AccelStepper5step3El+0x4c>
   89ff2:	2b00      	cmp	r3, #0
   89ff4:	d000      	beq.n	89ff8 <_ZN12AccelStepper5step3El+0x2c>
	case 2:    //010
		setOutputPins(0b010);
		break;

	}
}
   89ff6:	e017      	b.n	8a028 <_ZN12AccelStepper5step3El+0x5c>
void AccelStepper::step3(long step)
{
	switch (step % 3)
	{
	case 0:    // 100
		setOutputPins(0b100);
   89ff8:	687b      	ldr	r3, [r7, #4]
   89ffa:	681b      	ldr	r3, [r3, #0]
   89ffc:	3308      	adds	r3, #8
   89ffe:	681b      	ldr	r3, [r3, #0]
   8a000:	2104      	movs	r1, #4
   8a002:	6878      	ldr	r0, [r7, #4]
   8a004:	4798      	blx	r3
		break;
   8a006:	e00f      	b.n	8a028 <_ZN12AccelStepper5step3El+0x5c>

	case 1:    // 001
		setOutputPins(0b001);
   8a008:	687b      	ldr	r3, [r7, #4]
   8a00a:	681b      	ldr	r3, [r3, #0]
   8a00c:	3308      	adds	r3, #8
   8a00e:	681b      	ldr	r3, [r3, #0]
   8a010:	2101      	movs	r1, #1
   8a012:	6878      	ldr	r0, [r7, #4]
   8a014:	4798      	blx	r3
		break;
   8a016:	e007      	b.n	8a028 <_ZN12AccelStepper5step3El+0x5c>

	case 2:    //010
		setOutputPins(0b010);
   8a018:	687b      	ldr	r3, [r7, #4]
   8a01a:	681b      	ldr	r3, [r3, #0]
   8a01c:	3308      	adds	r3, #8
   8a01e:	681b      	ldr	r3, [r3, #0]
   8a020:	2102      	movs	r1, #2
   8a022:	6878      	ldr	r0, [r7, #4]
   8a024:	4798      	blx	r3
		break;
   8a026:	bf00      	nop

	}
}
   8a028:	bf00      	nop
   8a02a:	3708      	adds	r7, #8
   8a02c:	46bd      	mov	sp, r7
   8a02e:	bd80      	pop	{r7, pc}
   8a030:	55555556 	.word	0x55555556

0008a034 <_ZN12AccelStepper5step4El>:

// 4 pin step function for half stepper
// This is passed the current step number (0 to 7)
// Subclasses can override
void AccelStepper::step4(long step)
{
   8a034:	b580      	push	{r7, lr}
   8a036:	b082      	sub	sp, #8
   8a038:	af00      	add	r7, sp, #0
   8a03a:	6078      	str	r0, [r7, #4]
   8a03c:	6039      	str	r1, [r7, #0]
	switch (step & 0x3)
   8a03e:	683b      	ldr	r3, [r7, #0]
   8a040:	f003 0303 	and.w	r3, r3, #3
   8a044:	2b03      	cmp	r3, #3
   8a046:	d82b      	bhi.n	8a0a0 <_ZN12AccelStepper5step4El+0x6c>
   8a048:	a201      	add	r2, pc, #4	; (adr r2, 8a050 <_ZN12AccelStepper5step4El+0x1c>)
   8a04a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   8a04e:	bf00      	nop
   8a050:	0008a061 	.word	0x0008a061
   8a054:	0008a071 	.word	0x0008a071
   8a058:	0008a081 	.word	0x0008a081
   8a05c:	0008a091 	.word	0x0008a091
	{
	case 0:    // 1010
		setOutputPins(0b0101);
   8a060:	687b      	ldr	r3, [r7, #4]
   8a062:	681b      	ldr	r3, [r3, #0]
   8a064:	3308      	adds	r3, #8
   8a066:	681b      	ldr	r3, [r3, #0]
   8a068:	2105      	movs	r1, #5
   8a06a:	6878      	ldr	r0, [r7, #4]
   8a06c:	4798      	blx	r3
		break;
   8a06e:	e017      	b.n	8a0a0 <_ZN12AccelStepper5step4El+0x6c>

	case 1:    // 0110
		setOutputPins(0b0110);
   8a070:	687b      	ldr	r3, [r7, #4]
   8a072:	681b      	ldr	r3, [r3, #0]
   8a074:	3308      	adds	r3, #8
   8a076:	681b      	ldr	r3, [r3, #0]
   8a078:	2106      	movs	r1, #6
   8a07a:	6878      	ldr	r0, [r7, #4]
   8a07c:	4798      	blx	r3
		break;
   8a07e:	e00f      	b.n	8a0a0 <_ZN12AccelStepper5step4El+0x6c>

	case 2:    //0101
		setOutputPins(0b1010);
   8a080:	687b      	ldr	r3, [r7, #4]
   8a082:	681b      	ldr	r3, [r3, #0]
   8a084:	3308      	adds	r3, #8
   8a086:	681b      	ldr	r3, [r3, #0]
   8a088:	210a      	movs	r1, #10
   8a08a:	6878      	ldr	r0, [r7, #4]
   8a08c:	4798      	blx	r3
		break;
   8a08e:	e007      	b.n	8a0a0 <_ZN12AccelStepper5step4El+0x6c>

	case 3:    //1001
		setOutputPins(0b1001);
   8a090:	687b      	ldr	r3, [r7, #4]
   8a092:	681b      	ldr	r3, [r3, #0]
   8a094:	3308      	adds	r3, #8
   8a096:	681b      	ldr	r3, [r3, #0]
   8a098:	2109      	movs	r1, #9
   8a09a:	6878      	ldr	r0, [r7, #4]
   8a09c:	4798      	blx	r3
		break;
   8a09e:	bf00      	nop
	}
}
   8a0a0:	bf00      	nop
   8a0a2:	3708      	adds	r7, #8
   8a0a4:	46bd      	mov	sp, r7
   8a0a6:	bd80      	pop	{r7, pc}

0008a0a8 <_ZN12AccelStepper5step6El>:

// 3 pin half step function
// This is passed the current step number (0 to 7)
// Subclasses can override
void AccelStepper::step6(long step)
{
   8a0a8:	b580      	push	{r7, lr}
   8a0aa:	b082      	sub	sp, #8
   8a0ac:	af00      	add	r7, sp, #0
   8a0ae:	6078      	str	r0, [r7, #4]
   8a0b0:	6039      	str	r1, [r7, #0]
	switch (step % 6)
   8a0b2:	6839      	ldr	r1, [r7, #0]
   8a0b4:	4b27      	ldr	r3, [pc, #156]	; (8a154 <_ZN12AccelStepper5step6El+0xac>)
   8a0b6:	fb83 3201 	smull	r3, r2, r3, r1
   8a0ba:	17cb      	asrs	r3, r1, #31
   8a0bc:	1ad2      	subs	r2, r2, r3
   8a0be:	4613      	mov	r3, r2
   8a0c0:	005b      	lsls	r3, r3, #1
   8a0c2:	4413      	add	r3, r2
   8a0c4:	005b      	lsls	r3, r3, #1
   8a0c6:	1aca      	subs	r2, r1, r3
   8a0c8:	2a05      	cmp	r2, #5
   8a0ca:	d83f      	bhi.n	8a14c <_ZN12AccelStepper5step6El+0xa4>
   8a0cc:	a301      	add	r3, pc, #4	; (adr r3, 8a0d4 <_ZN12AccelStepper5step6El+0x2c>)
   8a0ce:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
   8a0d2:	bf00      	nop
   8a0d4:	0008a0ed 	.word	0x0008a0ed
   8a0d8:	0008a0fd 	.word	0x0008a0fd
   8a0dc:	0008a10d 	.word	0x0008a10d
   8a0e0:	0008a11d 	.word	0x0008a11d
   8a0e4:	0008a12d 	.word	0x0008a12d
   8a0e8:	0008a13d 	.word	0x0008a13d
	{
	case 0:    // 100
		setOutputPins(0b100);
   8a0ec:	687b      	ldr	r3, [r7, #4]
   8a0ee:	681b      	ldr	r3, [r3, #0]
   8a0f0:	3308      	adds	r3, #8
   8a0f2:	681b      	ldr	r3, [r3, #0]
   8a0f4:	2104      	movs	r1, #4
   8a0f6:	6878      	ldr	r0, [r7, #4]
   8a0f8:	4798      	blx	r3
		break;
   8a0fa:	e027      	b.n	8a14c <_ZN12AccelStepper5step6El+0xa4>

	case 1:    // 101
		setOutputPins(0b101);
   8a0fc:	687b      	ldr	r3, [r7, #4]
   8a0fe:	681b      	ldr	r3, [r3, #0]
   8a100:	3308      	adds	r3, #8
   8a102:	681b      	ldr	r3, [r3, #0]
   8a104:	2105      	movs	r1, #5
   8a106:	6878      	ldr	r0, [r7, #4]
   8a108:	4798      	blx	r3
		break;
   8a10a:	e01f      	b.n	8a14c <_ZN12AccelStepper5step6El+0xa4>

	case 2:    // 001
		setOutputPins(0b001);
   8a10c:	687b      	ldr	r3, [r7, #4]
   8a10e:	681b      	ldr	r3, [r3, #0]
   8a110:	3308      	adds	r3, #8
   8a112:	681b      	ldr	r3, [r3, #0]
   8a114:	2101      	movs	r1, #1
   8a116:	6878      	ldr	r0, [r7, #4]
   8a118:	4798      	blx	r3
		break;
   8a11a:	e017      	b.n	8a14c <_ZN12AccelStepper5step6El+0xa4>

	case 3:    // 011
		setOutputPins(0b011);
   8a11c:	687b      	ldr	r3, [r7, #4]
   8a11e:	681b      	ldr	r3, [r3, #0]
   8a120:	3308      	adds	r3, #8
   8a122:	681b      	ldr	r3, [r3, #0]
   8a124:	2103      	movs	r1, #3
   8a126:	6878      	ldr	r0, [r7, #4]
   8a128:	4798      	blx	r3
		break;
   8a12a:	e00f      	b.n	8a14c <_ZN12AccelStepper5step6El+0xa4>

	case 4:    // 010
		setOutputPins(0b010);
   8a12c:	687b      	ldr	r3, [r7, #4]
   8a12e:	681b      	ldr	r3, [r3, #0]
   8a130:	3308      	adds	r3, #8
   8a132:	681b      	ldr	r3, [r3, #0]
   8a134:	2102      	movs	r1, #2
   8a136:	6878      	ldr	r0, [r7, #4]
   8a138:	4798      	blx	r3
		break;
   8a13a:	e007      	b.n	8a14c <_ZN12AccelStepper5step6El+0xa4>

	case 5:    // 011
		setOutputPins(0b110);
   8a13c:	687b      	ldr	r3, [r7, #4]
   8a13e:	681b      	ldr	r3, [r3, #0]
   8a140:	3308      	adds	r3, #8
   8a142:	681b      	ldr	r3, [r3, #0]
   8a144:	2106      	movs	r1, #6
   8a146:	6878      	ldr	r0, [r7, #4]
   8a148:	4798      	blx	r3
		break;
   8a14a:	bf00      	nop

	}
}
   8a14c:	bf00      	nop
   8a14e:	3708      	adds	r7, #8
   8a150:	46bd      	mov	sp, r7
   8a152:	bd80      	pop	{r7, pc}
   8a154:	2aaaaaab 	.word	0x2aaaaaab

0008a158 <_ZN12AccelStepper5step8El>:

// 4 pin half step function
// This is passed the current step number (0 to 7)
// Subclasses can override
void AccelStepper::step8(long step)
{
   8a158:	b580      	push	{r7, lr}
   8a15a:	b082      	sub	sp, #8
   8a15c:	af00      	add	r7, sp, #0
   8a15e:	6078      	str	r0, [r7, #4]
   8a160:	6039      	str	r1, [r7, #0]
	switch (step & 0x7)
   8a162:	683b      	ldr	r3, [r7, #0]
   8a164:	f003 0307 	and.w	r3, r3, #7
   8a168:	2b07      	cmp	r3, #7
   8a16a:	d853      	bhi.n	8a214 <_ZN12AccelStepper5step8El+0xbc>
   8a16c:	a201      	add	r2, pc, #4	; (adr r2, 8a174 <_ZN12AccelStepper5step8El+0x1c>)
   8a16e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   8a172:	bf00      	nop
   8a174:	0008a195 	.word	0x0008a195
   8a178:	0008a1a5 	.word	0x0008a1a5
   8a17c:	0008a1b5 	.word	0x0008a1b5
   8a180:	0008a1c5 	.word	0x0008a1c5
   8a184:	0008a1d5 	.word	0x0008a1d5
   8a188:	0008a1e5 	.word	0x0008a1e5
   8a18c:	0008a1f5 	.word	0x0008a1f5
   8a190:	0008a205 	.word	0x0008a205
	{
	case 0:    // 1000
		setOutputPins(0b0001);
   8a194:	687b      	ldr	r3, [r7, #4]
   8a196:	681b      	ldr	r3, [r3, #0]
   8a198:	3308      	adds	r3, #8
   8a19a:	681b      	ldr	r3, [r3, #0]
   8a19c:	2101      	movs	r1, #1
   8a19e:	6878      	ldr	r0, [r7, #4]
   8a1a0:	4798      	blx	r3
		break;
   8a1a2:	e037      	b.n	8a214 <_ZN12AccelStepper5step8El+0xbc>

	case 1:    // 1010
		setOutputPins(0b0101);
   8a1a4:	687b      	ldr	r3, [r7, #4]
   8a1a6:	681b      	ldr	r3, [r3, #0]
   8a1a8:	3308      	adds	r3, #8
   8a1aa:	681b      	ldr	r3, [r3, #0]
   8a1ac:	2105      	movs	r1, #5
   8a1ae:	6878      	ldr	r0, [r7, #4]
   8a1b0:	4798      	blx	r3
		break;
   8a1b2:	e02f      	b.n	8a214 <_ZN12AccelStepper5step8El+0xbc>

	case 2:    // 0010
		setOutputPins(0b0100);
   8a1b4:	687b      	ldr	r3, [r7, #4]
   8a1b6:	681b      	ldr	r3, [r3, #0]
   8a1b8:	3308      	adds	r3, #8
   8a1ba:	681b      	ldr	r3, [r3, #0]
   8a1bc:	2104      	movs	r1, #4
   8a1be:	6878      	ldr	r0, [r7, #4]
   8a1c0:	4798      	blx	r3
		break;
   8a1c2:	e027      	b.n	8a214 <_ZN12AccelStepper5step8El+0xbc>

	case 3:    // 0110
		setOutputPins(0b0110);
   8a1c4:	687b      	ldr	r3, [r7, #4]
   8a1c6:	681b      	ldr	r3, [r3, #0]
   8a1c8:	3308      	adds	r3, #8
   8a1ca:	681b      	ldr	r3, [r3, #0]
   8a1cc:	2106      	movs	r1, #6
   8a1ce:	6878      	ldr	r0, [r7, #4]
   8a1d0:	4798      	blx	r3
		break;
   8a1d2:	e01f      	b.n	8a214 <_ZN12AccelStepper5step8El+0xbc>

	case 4:    // 0100
		setOutputPins(0b0010);
   8a1d4:	687b      	ldr	r3, [r7, #4]
   8a1d6:	681b      	ldr	r3, [r3, #0]
   8a1d8:	3308      	adds	r3, #8
   8a1da:	681b      	ldr	r3, [r3, #0]
   8a1dc:	2102      	movs	r1, #2
   8a1de:	6878      	ldr	r0, [r7, #4]
   8a1e0:	4798      	blx	r3
		break;
   8a1e2:	e017      	b.n	8a214 <_ZN12AccelStepper5step8El+0xbc>

	case 5:    //0101
		setOutputPins(0b1010);
   8a1e4:	687b      	ldr	r3, [r7, #4]
   8a1e6:	681b      	ldr	r3, [r3, #0]
   8a1e8:	3308      	adds	r3, #8
   8a1ea:	681b      	ldr	r3, [r3, #0]
   8a1ec:	210a      	movs	r1, #10
   8a1ee:	6878      	ldr	r0, [r7, #4]
   8a1f0:	4798      	blx	r3
		break;
   8a1f2:	e00f      	b.n	8a214 <_ZN12AccelStepper5step8El+0xbc>

	case 6:    // 0001
		setOutputPins(0b1000);
   8a1f4:	687b      	ldr	r3, [r7, #4]
   8a1f6:	681b      	ldr	r3, [r3, #0]
   8a1f8:	3308      	adds	r3, #8
   8a1fa:	681b      	ldr	r3, [r3, #0]
   8a1fc:	2108      	movs	r1, #8
   8a1fe:	6878      	ldr	r0, [r7, #4]
   8a200:	4798      	blx	r3
		break;
   8a202:	e007      	b.n	8a214 <_ZN12AccelStepper5step8El+0xbc>

	case 7:    //1001
		setOutputPins(0b1001);
   8a204:	687b      	ldr	r3, [r7, #4]
   8a206:	681b      	ldr	r3, [r3, #0]
   8a208:	3308      	adds	r3, #8
   8a20a:	681b      	ldr	r3, [r3, #0]
   8a20c:	2109      	movs	r1, #9
   8a20e:	6878      	ldr	r0, [r7, #4]
   8a210:	4798      	blx	r3
		break;
   8a212:	bf00      	nop
	}
}
   8a214:	bf00      	nop
   8a216:	3708      	adds	r7, #8
   8a218:	46bd      	mov	sp, r7
   8a21a:	bd80      	pop	{r7, pc}

0008a21c <_ZN12AccelStepper14disableOutputsEv>:

// Prevents power consumption on the outputs
void    AccelStepper::disableOutputs()
{   
   8a21c:	b580      	push	{r7, lr}
   8a21e:	b082      	sub	sp, #8
   8a220:	af00      	add	r7, sp, #0
   8a222:	6078      	str	r0, [r7, #4]
	if (! _interface) return;
   8a224:	687b      	ldr	r3, [r7, #4]
   8a226:	791b      	ldrb	r3, [r3, #4]
   8a228:	2b00      	cmp	r3, #0
   8a22a:	d017      	beq.n	8a25c <_ZN12AccelStepper14disableOutputsEv+0x40>

	setOutputPins(0); // Handles inversion automatically
   8a22c:	687b      	ldr	r3, [r7, #4]
   8a22e:	681b      	ldr	r3, [r3, #0]
   8a230:	3308      	adds	r3, #8
   8a232:	681b      	ldr	r3, [r3, #0]
   8a234:	2100      	movs	r1, #0
   8a236:	6878      	ldr	r0, [r7, #4]
   8a238:	4798      	blx	r3
	if (_enablePin != 0xff)
   8a23a:	687b      	ldr	r3, [r7, #4]
   8a23c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
   8a240:	2bff      	cmp	r3, #255	; 0xff
   8a242:	d00c      	beq.n	8a25e <_ZN12AccelStepper14disableOutputsEv+0x42>
		digitalWrite(_enablePin, LOW ^ _enableInverted);
   8a244:	687b      	ldr	r3, [r7, #4]
   8a246:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
   8a24a:	461a      	mov	r2, r3
   8a24c:	687b      	ldr	r3, [r7, #4]
   8a24e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   8a252:	4619      	mov	r1, r3
   8a254:	4610      	mov	r0, r2
   8a256:	4b03      	ldr	r3, [pc, #12]	; (8a264 <_ZN12AccelStepper14disableOutputsEv+0x48>)
   8a258:	4798      	blx	r3
   8a25a:	e000      	b.n	8a25e <_ZN12AccelStepper14disableOutputsEv+0x42>
}

// Prevents power consumption on the outputs
void    AccelStepper::disableOutputs()
{   
	if (! _interface) return;
   8a25c:	bf00      	nop

	setOutputPins(0); // Handles inversion automatically
	if (_enablePin != 0xff)
		digitalWrite(_enablePin, LOW ^ _enableInverted);
}
   8a25e:	3708      	adds	r7, #8
   8a260:	46bd      	mov	sp, r7
   8a262:	bd80      	pop	{r7, pc}
   8a264:	00081f29 	.word	0x00081f29

0008a268 <_ZN12AccelStepper13enableOutputsEv>:

void    AccelStepper::enableOutputs()
{
   8a268:	b580      	push	{r7, lr}
   8a26a:	b082      	sub	sp, #8
   8a26c:	af00      	add	r7, sp, #0
   8a26e:	6078      	str	r0, [r7, #4]
	if (! _interface)
   8a270:	687b      	ldr	r3, [r7, #4]
   8a272:	791b      	ldrb	r3, [r3, #4]
   8a274:	2b00      	cmp	r3, #0
   8a276:	d049      	beq.n	8a30c <_ZN12AccelStepper13enableOutputsEv+0xa4>
		return;

	pinMode(_pin[0], OUTPUT);
   8a278:	687b      	ldr	r3, [r7, #4]
   8a27a:	795b      	ldrb	r3, [r3, #5]
   8a27c:	2101      	movs	r1, #1
   8a27e:	4618      	mov	r0, r3
   8a280:	4b24      	ldr	r3, [pc, #144]	; (8a314 <_ZN12AccelStepper13enableOutputsEv+0xac>)
   8a282:	4798      	blx	r3
	pinMode(_pin[1], OUTPUT);
   8a284:	687b      	ldr	r3, [r7, #4]
   8a286:	799b      	ldrb	r3, [r3, #6]
   8a288:	2101      	movs	r1, #1
   8a28a:	4618      	mov	r0, r3
   8a28c:	4b21      	ldr	r3, [pc, #132]	; (8a314 <_ZN12AccelStepper13enableOutputsEv+0xac>)
   8a28e:	4798      	blx	r3
	if (_interface == FULL4WIRE || _interface == HALF4WIRE)
   8a290:	687b      	ldr	r3, [r7, #4]
   8a292:	791b      	ldrb	r3, [r3, #4]
   8a294:	2b04      	cmp	r3, #4
   8a296:	d003      	beq.n	8a2a0 <_ZN12AccelStepper13enableOutputsEv+0x38>
   8a298:	687b      	ldr	r3, [r7, #4]
   8a29a:	791b      	ldrb	r3, [r3, #4]
   8a29c:	2b08      	cmp	r3, #8
   8a29e:	d10c      	bne.n	8a2ba <_ZN12AccelStepper13enableOutputsEv+0x52>
	{
		pinMode(_pin[2], OUTPUT);
   8a2a0:	687b      	ldr	r3, [r7, #4]
   8a2a2:	79db      	ldrb	r3, [r3, #7]
   8a2a4:	2101      	movs	r1, #1
   8a2a6:	4618      	mov	r0, r3
   8a2a8:	4b1a      	ldr	r3, [pc, #104]	; (8a314 <_ZN12AccelStepper13enableOutputsEv+0xac>)
   8a2aa:	4798      	blx	r3
		pinMode(_pin[3], OUTPUT);
   8a2ac:	687b      	ldr	r3, [r7, #4]
   8a2ae:	7a1b      	ldrb	r3, [r3, #8]
   8a2b0:	2101      	movs	r1, #1
   8a2b2:	4618      	mov	r0, r3
   8a2b4:	4b17      	ldr	r3, [pc, #92]	; (8a314 <_ZN12AccelStepper13enableOutputsEv+0xac>)
   8a2b6:	4798      	blx	r3
   8a2b8:	e00d      	b.n	8a2d6 <_ZN12AccelStepper13enableOutputsEv+0x6e>
	}
	else if (_interface == FULL3WIRE || _interface == HALF3WIRE)
   8a2ba:	687b      	ldr	r3, [r7, #4]
   8a2bc:	791b      	ldrb	r3, [r3, #4]
   8a2be:	2b03      	cmp	r3, #3
   8a2c0:	d003      	beq.n	8a2ca <_ZN12AccelStepper13enableOutputsEv+0x62>
   8a2c2:	687b      	ldr	r3, [r7, #4]
   8a2c4:	791b      	ldrb	r3, [r3, #4]
   8a2c6:	2b06      	cmp	r3, #6
   8a2c8:	d105      	bne.n	8a2d6 <_ZN12AccelStepper13enableOutputsEv+0x6e>
	{
		pinMode(_pin[2], OUTPUT);
   8a2ca:	687b      	ldr	r3, [r7, #4]
   8a2cc:	79db      	ldrb	r3, [r3, #7]
   8a2ce:	2101      	movs	r1, #1
   8a2d0:	4618      	mov	r0, r3
   8a2d2:	4b10      	ldr	r3, [pc, #64]	; (8a314 <_ZN12AccelStepper13enableOutputsEv+0xac>)
   8a2d4:	4798      	blx	r3
	}

	if (_enablePin != 0xff)
   8a2d6:	687b      	ldr	r3, [r7, #4]
   8a2d8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
   8a2dc:	2bff      	cmp	r3, #255	; 0xff
   8a2de:	d016      	beq.n	8a30e <_ZN12AccelStepper13enableOutputsEv+0xa6>
	{
		pinMode(_enablePin, OUTPUT);
   8a2e0:	687b      	ldr	r3, [r7, #4]
   8a2e2:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
   8a2e6:	2101      	movs	r1, #1
   8a2e8:	4618      	mov	r0, r3
   8a2ea:	4b0a      	ldr	r3, [pc, #40]	; (8a314 <_ZN12AccelStepper13enableOutputsEv+0xac>)
   8a2ec:	4798      	blx	r3
		digitalWrite(_enablePin, HIGH ^ _enableInverted);
   8a2ee:	687b      	ldr	r3, [r7, #4]
   8a2f0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
   8a2f4:	461a      	mov	r2, r3
   8a2f6:	687b      	ldr	r3, [r7, #4]
   8a2f8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   8a2fc:	f083 0301 	eor.w	r3, r3, #1
   8a300:	b2db      	uxtb	r3, r3
   8a302:	4619      	mov	r1, r3
   8a304:	4610      	mov	r0, r2
   8a306:	4b04      	ldr	r3, [pc, #16]	; (8a318 <_ZN12AccelStepper13enableOutputsEv+0xb0>)
   8a308:	4798      	blx	r3
   8a30a:	e000      	b.n	8a30e <_ZN12AccelStepper13enableOutputsEv+0xa6>
}

void    AccelStepper::enableOutputs()
{
	if (! _interface)
		return;
   8a30c:	bf00      	nop
	if (_enablePin != 0xff)
	{
		pinMode(_enablePin, OUTPUT);
		digitalWrite(_enablePin, HIGH ^ _enableInverted);
	}
}
   8a30e:	3708      	adds	r7, #8
   8a310:	46bd      	mov	sp, r7
   8a312:	bd80      	pop	{r7, pc}
   8a314:	00081cc5 	.word	0x00081cc5
   8a318:	00081f29 	.word	0x00081f29

0008a31c <_ZN5Print13getWriteErrorEv>:
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
  
    int getWriteError() { return write_error; }
   8a31c:	b480      	push	{r7}
   8a31e:	b083      	sub	sp, #12
   8a320:	af00      	add	r7, sp, #0
   8a322:	6078      	str	r0, [r7, #4]
   8a324:	687b      	ldr	r3, [r7, #4]
   8a326:	685b      	ldr	r3, [r3, #4]
   8a328:	4618      	mov	r0, r3
   8a32a:	370c      	adds	r7, #12
   8a32c:	46bd      	mov	sp, r7
   8a32e:	bc80      	pop	{r7}
   8a330:	4770      	bx	lr
   8a332:	bf00      	nop

0008a334 <_ZN5Print15clearWriteErrorEv>:
    void clearWriteError() { setWriteError(0); }
   8a334:	b580      	push	{r7, lr}
   8a336:	b082      	sub	sp, #8
   8a338:	af00      	add	r7, sp, #0
   8a33a:	6078      	str	r0, [r7, #4]
   8a33c:	2100      	movs	r1, #0
   8a33e:	6878      	ldr	r0, [r7, #4]
   8a340:	4b02      	ldr	r3, [pc, #8]	; (8a34c <_ZN5Print15clearWriteErrorEv+0x18>)
   8a342:	4798      	blx	r3
   8a344:	bf00      	nop
   8a346:	3708      	adds	r7, #8
   8a348:	46bd      	mov	sp, r7
   8a34a:	bd80      	pop	{r7, pc}
   8a34c:	00088a51 	.word	0x00088a51

0008a350 <_ZNK6SdFile11curPositionEv>:
  uint8_t createContiguous(SdFile* dirFile,
          const char* fileName, uint32_t size);
  /** \return The current cluster number for a file or directory. */
  uint32_t curCluster(void) const {return curCluster_;}
  /** \return The current position for a file or directory. */
  uint32_t curPosition(void) const {return curPosition_;}
   8a350:	b480      	push	{r7}
   8a352:	b083      	sub	sp, #12
   8a354:	af00      	add	r7, sp, #0
   8a356:	6078      	str	r0, [r7, #4]
   8a358:	687b      	ldr	r3, [r7, #4]
   8a35a:	691b      	ldr	r3, [r3, #16]
   8a35c:	4618      	mov	r0, r3
   8a35e:	370c      	adds	r7, #12
   8a360:	46bd      	mov	sp, r7
   8a362:	bc80      	pop	{r7}
   8a364:	4770      	bx	lr
   8a366:	bf00      	nop

0008a368 <_ZNK6SdFile8fileSizeEv>:
  uint8_t dirEntry(dir_t* dir);
  /** \return Index of this file's directory in the block dirBlock. */
  uint8_t dirIndex(void) const {return dirIndex_;}
  static void dirName(const dir_t& dir, char* name);
  /** \return The total number of bytes in a file or directory. */
  uint32_t fileSize(void) const {return fileSize_;}
   8a368:	b480      	push	{r7}
   8a36a:	b083      	sub	sp, #12
   8a36c:	af00      	add	r7, sp, #0
   8a36e:	6078      	str	r0, [r7, #4]
   8a370:	687b      	ldr	r3, [r7, #4]
   8a372:	69db      	ldr	r3, [r3, #28]
   8a374:	4618      	mov	r0, r3
   8a376:	370c      	adds	r7, #12
   8a378:	46bd      	mov	sp, r7
   8a37a:	bc80      	pop	{r7}
   8a37c:	4770      	bx	lr
   8a37e:	bf00      	nop

0008a380 <_ZNK6SdFile5isDirEv>:
  /** \return The first cluster number for a file or directory. */
  uint32_t firstCluster(void) const {return firstCluster_;}
  /** \return True if this is a SdFile for a directory else false. */
  uint8_t isDir(void) const {return type_ >= FAT_FILE_TYPE_MIN_DIR;}
   8a380:	b480      	push	{r7}
   8a382:	b083      	sub	sp, #12
   8a384:	af00      	add	r7, sp, #0
   8a386:	6078      	str	r0, [r7, #4]
   8a388:	687b      	ldr	r3, [r7, #4]
   8a38a:	7a5b      	ldrb	r3, [r3, #9]
   8a38c:	2b01      	cmp	r3, #1
   8a38e:	bf8c      	ite	hi
   8a390:	2301      	movhi	r3, #1
   8a392:	2300      	movls	r3, #0
   8a394:	b2db      	uxtb	r3, r3
   8a396:	4618      	mov	r0, r3
   8a398:	370c      	adds	r7, #12
   8a39a:	46bd      	mov	sp, r7
   8a39c:	bc80      	pop	{r7}
   8a39e:	4770      	bx	lr

0008a3a0 <_ZNK6SdFile6isOpenEv>:
  /** \return True if this is a SdFile for a file else false. */
  uint8_t isFile(void) const {return type_ == FAT_FILE_TYPE_NORMAL;}
  /** \return True if this is a SdFile for an open file/directory else false. */
  uint8_t isOpen(void) const {return type_ != FAT_FILE_TYPE_CLOSED;}
   8a3a0:	b480      	push	{r7}
   8a3a2:	b083      	sub	sp, #12
   8a3a4:	af00      	add	r7, sp, #0
   8a3a6:	6078      	str	r0, [r7, #4]
   8a3a8:	687b      	ldr	r3, [r7, #4]
   8a3aa:	7a5b      	ldrb	r3, [r3, #9]
   8a3ac:	2b00      	cmp	r3, #0
   8a3ae:	bf14      	ite	ne
   8a3b0:	2301      	movne	r3, #1
   8a3b2:	2300      	moveq	r3, #0
   8a3b4:	b2db      	uxtb	r3, r3
   8a3b6:	4618      	mov	r0, r3
   8a3b8:	370c      	adds	r7, #12
   8a3ba:	46bd      	mov	sp, r7
   8a3bc:	bc80      	pop	{r7}
   8a3be:	4770      	bx	lr

0008a3c0 <_ZN6SdFile4readEv>:
   * Read the next byte from a file.
   *
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int16_t read(void) {
   8a3c0:	b580      	push	{r7, lr}
   8a3c2:	b084      	sub	sp, #16
   8a3c4:	af00      	add	r7, sp, #0
   8a3c6:	6078      	str	r0, [r7, #4]
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
   8a3c8:	f107 030f 	add.w	r3, r7, #15
   8a3cc:	2201      	movs	r2, #1
   8a3ce:	4619      	mov	r1, r3
   8a3d0:	6878      	ldr	r0, [r7, #4]
   8a3d2:	4b07      	ldr	r3, [pc, #28]	; (8a3f0 <_ZN6SdFile4readEv+0x30>)
   8a3d4:	4798      	blx	r3
   8a3d6:	4603      	mov	r3, r0
   8a3d8:	2b01      	cmp	r3, #1
   8a3da:	d102      	bne.n	8a3e2 <_ZN6SdFile4readEv+0x22>
   8a3dc:	7bfb      	ldrb	r3, [r7, #15]
   8a3de:	b21b      	sxth	r3, r3
   8a3e0:	e001      	b.n	8a3e6 <_ZN6SdFile4readEv+0x26>
   8a3e2:	f04f 33ff 	mov.w	r3, #4294967295
  }
   8a3e6:	4618      	mov	r0, r3
   8a3e8:	3710      	adds	r7, #16
   8a3ea:	46bd      	mov	sp, r7
   8a3ec:	bd80      	pop	{r7, pc}
   8a3ee:	bf00      	nop
   8a3f0:	0008c1ad 	.word	0x0008c1ad

0008a3f4 <_ZN6SdFile7seekCurEm>:
    curPosition_ = curCluster_ = 0;
  }
  uint8_t rmDir(void);
  uint8_t rmRfStar(void);
  /** Set the files position to current position + \a pos. See seekSet(). */
  uint8_t seekCur(uint32_t pos) {
   8a3f4:	b580      	push	{r7, lr}
   8a3f6:	b082      	sub	sp, #8
   8a3f8:	af00      	add	r7, sp, #0
   8a3fa:	6078      	str	r0, [r7, #4]
   8a3fc:	6039      	str	r1, [r7, #0]
    return seekSet(curPosition_ + pos);
   8a3fe:	687b      	ldr	r3, [r7, #4]
   8a400:	691a      	ldr	r2, [r3, #16]
   8a402:	683b      	ldr	r3, [r7, #0]
   8a404:	4413      	add	r3, r2
   8a406:	4619      	mov	r1, r3
   8a408:	6878      	ldr	r0, [r7, #4]
   8a40a:	4b03      	ldr	r3, [pc, #12]	; (8a418 <_ZN6SdFile7seekCurEm+0x24>)
   8a40c:	4798      	blx	r3
   8a40e:	4603      	mov	r3, r0
  }
   8a410:	4618      	mov	r0, r3
   8a412:	3708      	adds	r7, #8
   8a414:	46bd      	mov	sp, r7
   8a416:	bd80      	pop	{r7, pc}
   8a418:	0008c429 	.word	0x0008c429

0008a41c <_ZN5SDLib4FileC1E6SdFilePKc>:

/* for debugging file open/close leaks
   uint8_t nfilecount=0;
*/

File::File(SdFile f, const char *n) {
   8a41c:	b580      	push	{r7, lr}
   8a41e:	b084      	sub	sp, #16
   8a420:	af00      	add	r7, sp, #0
   8a422:	60f8      	str	r0, [r7, #12]
   8a424:	60b9      	str	r1, [r7, #8]
   8a426:	607a      	str	r2, [r7, #4]
   8a428:	68fb      	ldr	r3, [r7, #12]
   8a42a:	4618      	mov	r0, r3
   8a42c:	4b12      	ldr	r3, [pc, #72]	; (8a478 <_ZN5SDLib4FileC1E6SdFilePKc+0x5c>)
   8a42e:	4798      	blx	r3
   8a430:	4a12      	ldr	r2, [pc, #72]	; (8a47c <_ZN5SDLib4FileC1E6SdFilePKc+0x60>)
   8a432:	68fb      	ldr	r3, [r7, #12]
   8a434:	601a      	str	r2, [r3, #0]
  // oh man you are kidding me, new() doesnt exist? Ok we do it by hand!
  _file = (SdFile *)malloc(sizeof(SdFile)); 
   8a436:	2028      	movs	r0, #40	; 0x28
   8a438:	4b11      	ldr	r3, [pc, #68]	; (8a480 <_ZN5SDLib4FileC1E6SdFilePKc+0x64>)
   8a43a:	4798      	blx	r3
   8a43c:	4603      	mov	r3, r0
   8a43e:	461a      	mov	r2, r3
   8a440:	68fb      	ldr	r3, [r7, #12]
   8a442:	621a      	str	r2, [r3, #32]
  if (_file) {
   8a444:	68fb      	ldr	r3, [r7, #12]
   8a446:	6a1b      	ldr	r3, [r3, #32]
   8a448:	2b00      	cmp	r3, #0
   8a44a:	d010      	beq.n	8a46e <_ZN5SDLib4FileC1E6SdFilePKc+0x52>
    memcpy(_file, &f, sizeof(SdFile));
   8a44c:	68fb      	ldr	r3, [r7, #12]
   8a44e:	6a1b      	ldr	r3, [r3, #32]
   8a450:	2228      	movs	r2, #40	; 0x28
   8a452:	68b9      	ldr	r1, [r7, #8]
   8a454:	4618      	mov	r0, r3
   8a456:	4b0b      	ldr	r3, [pc, #44]	; (8a484 <_ZN5SDLib4FileC1E6SdFilePKc+0x68>)
   8a458:	4798      	blx	r3
    
    strncpy(_name, n, 12);
   8a45a:	68fb      	ldr	r3, [r7, #12]
   8a45c:	3310      	adds	r3, #16
   8a45e:	220c      	movs	r2, #12
   8a460:	6879      	ldr	r1, [r7, #4]
   8a462:	4618      	mov	r0, r3
   8a464:	4b08      	ldr	r3, [pc, #32]	; (8a488 <_ZN5SDLib4FileC1E6SdFilePKc+0x6c>)
   8a466:	4798      	blx	r3
    _name[12] = 0;
   8a468:	68fb      	ldr	r3, [r7, #12]
   8a46a:	2200      	movs	r2, #0
   8a46c:	771a      	strb	r2, [r3, #28]
       Serial.print(n);
       Serial.print("\": ");
       Serial.println(nfilecount, DEC);
    */
  }
}
   8a46e:	68fb      	ldr	r3, [r7, #12]
   8a470:	4618      	mov	r0, r3
   8a472:	3710      	adds	r7, #16
   8a474:	46bd      	mov	sp, r7
   8a476:	bd80      	pop	{r7, pc}
   8a478:	000804bd 	.word	0x000804bd
   8a47c:	0009ae40 	.word	0x0009ae40
   8a480:	00093535 	.word	0x00093535
   8a484:	00093b11 	.word	0x00093b11
   8a488:	000943a5 	.word	0x000943a5

0008a48c <_ZN5SDLib4FileC1Ev>:

File::File(void) {
   8a48c:	b580      	push	{r7, lr}
   8a48e:	b082      	sub	sp, #8
   8a490:	af00      	add	r7, sp, #0
   8a492:	6078      	str	r0, [r7, #4]
   8a494:	687b      	ldr	r3, [r7, #4]
   8a496:	4618      	mov	r0, r3
   8a498:	4b07      	ldr	r3, [pc, #28]	; (8a4b8 <_ZN5SDLib4FileC1Ev+0x2c>)
   8a49a:	4798      	blx	r3
   8a49c:	4a07      	ldr	r2, [pc, #28]	; (8a4bc <_ZN5SDLib4FileC1Ev+0x30>)
   8a49e:	687b      	ldr	r3, [r7, #4]
   8a4a0:	601a      	str	r2, [r3, #0]
  _file = 0;
   8a4a2:	687b      	ldr	r3, [r7, #4]
   8a4a4:	2200      	movs	r2, #0
   8a4a6:	621a      	str	r2, [r3, #32]
  _name[0] = 0;
   8a4a8:	687b      	ldr	r3, [r7, #4]
   8a4aa:	2200      	movs	r2, #0
   8a4ac:	741a      	strb	r2, [r3, #16]
  //Serial.print("Created empty file object");
}
   8a4ae:	687b      	ldr	r3, [r7, #4]
   8a4b0:	4618      	mov	r0, r3
   8a4b2:	3708      	adds	r7, #8
   8a4b4:	46bd      	mov	sp, r7
   8a4b6:	bd80      	pop	{r7, pc}
   8a4b8:	000804bd 	.word	0x000804bd
   8a4bc:	0009ae40 	.word	0x0009ae40

0008a4c0 <_ZN5SDLib4File5writeEh>:
boolean File::isDirectory(void) {
  return (_file && _file->isDir());
}


size_t File::write(uint8_t val) {
   8a4c0:	b580      	push	{r7, lr}
   8a4c2:	b082      	sub	sp, #8
   8a4c4:	af00      	add	r7, sp, #0
   8a4c6:	6078      	str	r0, [r7, #4]
   8a4c8:	460b      	mov	r3, r1
   8a4ca:	70fb      	strb	r3, [r7, #3]
  return write(&val, 1);
   8a4cc:	687b      	ldr	r3, [r7, #4]
   8a4ce:	681b      	ldr	r3, [r3, #0]
   8a4d0:	3304      	adds	r3, #4
   8a4d2:	681b      	ldr	r3, [r3, #0]
   8a4d4:	1cf9      	adds	r1, r7, #3
   8a4d6:	2201      	movs	r2, #1
   8a4d8:	6878      	ldr	r0, [r7, #4]
   8a4da:	4798      	blx	r3
   8a4dc:	4603      	mov	r3, r0
}
   8a4de:	4618      	mov	r0, r3
   8a4e0:	3708      	adds	r7, #8
   8a4e2:	46bd      	mov	sp, r7
   8a4e4:	bd80      	pop	{r7, pc}
   8a4e6:	bf00      	nop

0008a4e8 <_ZN5SDLib4File5writeEPKhj>:

size_t File::write(const uint8_t *buf, size_t size) {
   8a4e8:	b580      	push	{r7, lr}
   8a4ea:	b086      	sub	sp, #24
   8a4ec:	af00      	add	r7, sp, #0
   8a4ee:	60f8      	str	r0, [r7, #12]
   8a4f0:	60b9      	str	r1, [r7, #8]
   8a4f2:	607a      	str	r2, [r7, #4]
  size_t t;
  if (!_file) {
   8a4f4:	68fb      	ldr	r3, [r7, #12]
   8a4f6:	6a1b      	ldr	r3, [r3, #32]
   8a4f8:	2b00      	cmp	r3, #0
   8a4fa:	d106      	bne.n	8a50a <_ZN5SDLib4File5writeEPKhj+0x22>
    setWriteError();
   8a4fc:	68fb      	ldr	r3, [r7, #12]
   8a4fe:	2101      	movs	r1, #1
   8a500:	4618      	mov	r0, r3
   8a502:	4b15      	ldr	r3, [pc, #84]	; (8a558 <_ZN5SDLib4File5writeEPKhj+0x70>)
   8a504:	4798      	blx	r3
    return 0;
   8a506:	2300      	movs	r3, #0
   8a508:	e022      	b.n	8a550 <_ZN5SDLib4File5writeEPKhj+0x68>
  }
  _file->clearWriteError();
   8a50a:	68fb      	ldr	r3, [r7, #12]
   8a50c:	6a1b      	ldr	r3, [r3, #32]
   8a50e:	4618      	mov	r0, r3
   8a510:	4b12      	ldr	r3, [pc, #72]	; (8a55c <_ZN5SDLib4File5writeEPKhj+0x74>)
   8a512:	4798      	blx	r3
  t = _file->write(buf, size);
   8a514:	68fb      	ldr	r3, [r7, #12]
   8a516:	6a1b      	ldr	r3, [r3, #32]
   8a518:	687a      	ldr	r2, [r7, #4]
   8a51a:	b292      	uxth	r2, r2
   8a51c:	68b9      	ldr	r1, [r7, #8]
   8a51e:	4618      	mov	r0, r3
   8a520:	4b0f      	ldr	r3, [pc, #60]	; (8a560 <_ZN5SDLib4File5writeEPKhj+0x78>)
   8a522:	4798      	blx	r3
   8a524:	6178      	str	r0, [r7, #20]
  if (_file->getWriteError()) {
   8a526:	68fb      	ldr	r3, [r7, #12]
   8a528:	6a1b      	ldr	r3, [r3, #32]
   8a52a:	4618      	mov	r0, r3
   8a52c:	4b0d      	ldr	r3, [pc, #52]	; (8a564 <_ZN5SDLib4File5writeEPKhj+0x7c>)
   8a52e:	4798      	blx	r3
   8a530:	4603      	mov	r3, r0
   8a532:	2b00      	cmp	r3, #0
   8a534:	bf14      	ite	ne
   8a536:	2301      	movne	r3, #1
   8a538:	2300      	moveq	r3, #0
   8a53a:	b2db      	uxtb	r3, r3
   8a53c:	2b00      	cmp	r3, #0
   8a53e:	d006      	beq.n	8a54e <_ZN5SDLib4File5writeEPKhj+0x66>
    setWriteError();
   8a540:	68fb      	ldr	r3, [r7, #12]
   8a542:	2101      	movs	r1, #1
   8a544:	4618      	mov	r0, r3
   8a546:	4b04      	ldr	r3, [pc, #16]	; (8a558 <_ZN5SDLib4File5writeEPKhj+0x70>)
   8a548:	4798      	blx	r3
    return 0;
   8a54a:	2300      	movs	r3, #0
   8a54c:	e000      	b.n	8a550 <_ZN5SDLib4File5writeEPKhj+0x68>
  }
  return t;
   8a54e:	697b      	ldr	r3, [r7, #20]
}
   8a550:	4618      	mov	r0, r3
   8a552:	3718      	adds	r7, #24
   8a554:	46bd      	mov	sp, r7
   8a556:	bd80      	pop	{r7, pc}
   8a558:	00088a51 	.word	0x00088a51
   8a55c:	0008a335 	.word	0x0008a335
   8a560:	0008c775 	.word	0x0008c775
   8a564:	0008a31d 	.word	0x0008a31d

0008a568 <_ZN5SDLib4File4peekEv>:

int File::peek() {
   8a568:	b580      	push	{r7, lr}
   8a56a:	b084      	sub	sp, #16
   8a56c:	af00      	add	r7, sp, #0
   8a56e:	6078      	str	r0, [r7, #4]
  if (! _file) 
   8a570:	687b      	ldr	r3, [r7, #4]
   8a572:	6a1b      	ldr	r3, [r3, #32]
   8a574:	2b00      	cmp	r3, #0
   8a576:	d101      	bne.n	8a57c <_ZN5SDLib4File4peekEv+0x14>
    return 0;
   8a578:	2300      	movs	r3, #0
   8a57a:	e012      	b.n	8a5a2 <_ZN5SDLib4File4peekEv+0x3a>

  int c = _file->read();
   8a57c:	687b      	ldr	r3, [r7, #4]
   8a57e:	6a1b      	ldr	r3, [r3, #32]
   8a580:	4618      	mov	r0, r3
   8a582:	4b0a      	ldr	r3, [pc, #40]	; (8a5ac <_ZN5SDLib4File4peekEv+0x44>)
   8a584:	4798      	blx	r3
   8a586:	4603      	mov	r3, r0
   8a588:	60fb      	str	r3, [r7, #12]
  if (c != -1) _file->seekCur(-1);
   8a58a:	68fb      	ldr	r3, [r7, #12]
   8a58c:	f1b3 3fff 	cmp.w	r3, #4294967295
   8a590:	d006      	beq.n	8a5a0 <_ZN5SDLib4File4peekEv+0x38>
   8a592:	687b      	ldr	r3, [r7, #4]
   8a594:	6a1b      	ldr	r3, [r3, #32]
   8a596:	f04f 31ff 	mov.w	r1, #4294967295
   8a59a:	4618      	mov	r0, r3
   8a59c:	4b04      	ldr	r3, [pc, #16]	; (8a5b0 <_ZN5SDLib4File4peekEv+0x48>)
   8a59e:	4798      	blx	r3
  return c;
   8a5a0:	68fb      	ldr	r3, [r7, #12]
}
   8a5a2:	4618      	mov	r0, r3
   8a5a4:	3710      	adds	r7, #16
   8a5a6:	46bd      	mov	sp, r7
   8a5a8:	bd80      	pop	{r7, pc}
   8a5aa:	bf00      	nop
   8a5ac:	0008a3c1 	.word	0x0008a3c1
   8a5b0:	0008a3f5 	.word	0x0008a3f5

0008a5b4 <_ZN5SDLib4File4readEv>:

int File::read() {
   8a5b4:	b580      	push	{r7, lr}
   8a5b6:	b082      	sub	sp, #8
   8a5b8:	af00      	add	r7, sp, #0
   8a5ba:	6078      	str	r0, [r7, #4]
  if (_file) 
   8a5bc:	687b      	ldr	r3, [r7, #4]
   8a5be:	6a1b      	ldr	r3, [r3, #32]
   8a5c0:	2b00      	cmp	r3, #0
   8a5c2:	d006      	beq.n	8a5d2 <_ZN5SDLib4File4readEv+0x1e>
    return _file->read();
   8a5c4:	687b      	ldr	r3, [r7, #4]
   8a5c6:	6a1b      	ldr	r3, [r3, #32]
   8a5c8:	4618      	mov	r0, r3
   8a5ca:	4b05      	ldr	r3, [pc, #20]	; (8a5e0 <_ZN5SDLib4File4readEv+0x2c>)
   8a5cc:	4798      	blx	r3
   8a5ce:	4603      	mov	r3, r0
   8a5d0:	e001      	b.n	8a5d6 <_ZN5SDLib4File4readEv+0x22>
  return -1;
   8a5d2:	f04f 33ff 	mov.w	r3, #4294967295
}
   8a5d6:	4618      	mov	r0, r3
   8a5d8:	3708      	adds	r7, #8
   8a5da:	46bd      	mov	sp, r7
   8a5dc:	bd80      	pop	{r7, pc}
   8a5de:	bf00      	nop
   8a5e0:	0008a3c1 	.word	0x0008a3c1

0008a5e4 <_ZN5SDLib4File9availableEv>:
  if (_file) 
    return _file->read(buf, nbyte);
  return 0;
}

int File::available() {
   8a5e4:	b590      	push	{r4, r7, lr}
   8a5e6:	b085      	sub	sp, #20
   8a5e8:	af00      	add	r7, sp, #0
   8a5ea:	6078      	str	r0, [r7, #4]
  if (! _file) return 0;
   8a5ec:	687b      	ldr	r3, [r7, #4]
   8a5ee:	6a1b      	ldr	r3, [r3, #32]
   8a5f0:	2b00      	cmp	r3, #0
   8a5f2:	d101      	bne.n	8a5f8 <_ZN5SDLib4File9availableEv+0x14>
   8a5f4:	2300      	movs	r3, #0
   8a5f6:	e00f      	b.n	8a618 <_ZN5SDLib4File9availableEv+0x34>

  uint32_t n = size() - position();
   8a5f8:	6878      	ldr	r0, [r7, #4]
   8a5fa:	4b09      	ldr	r3, [pc, #36]	; (8a620 <_ZN5SDLib4File9availableEv+0x3c>)
   8a5fc:	4798      	blx	r3
   8a5fe:	4604      	mov	r4, r0
   8a600:	6878      	ldr	r0, [r7, #4]
   8a602:	4b08      	ldr	r3, [pc, #32]	; (8a624 <_ZN5SDLib4File9availableEv+0x40>)
   8a604:	4798      	blx	r3
   8a606:	4603      	mov	r3, r0
   8a608:	1ae3      	subs	r3, r4, r3
   8a60a:	60fb      	str	r3, [r7, #12]

  return n > 0X7FFF ? 0X7FFF : n;
   8a60c:	68fb      	ldr	r3, [r7, #12]
   8a60e:	f647 72ff 	movw	r2, #32767	; 0x7fff
   8a612:	4293      	cmp	r3, r2
   8a614:	bf28      	it	cs
   8a616:	4613      	movcs	r3, r2
}
   8a618:	4618      	mov	r0, r3
   8a61a:	3714      	adds	r7, #20
   8a61c:	46bd      	mov	sp, r7
   8a61e:	bd90      	pop	{r4, r7, pc}
   8a620:	0008a681 	.word	0x0008a681
   8a624:	0008a651 	.word	0x0008a651

0008a628 <_ZN5SDLib4File5flushEv>:

void File::flush() {
   8a628:	b580      	push	{r7, lr}
   8a62a:	b082      	sub	sp, #8
   8a62c:	af00      	add	r7, sp, #0
   8a62e:	6078      	str	r0, [r7, #4]
  if (_file)
   8a630:	687b      	ldr	r3, [r7, #4]
   8a632:	6a1b      	ldr	r3, [r3, #32]
   8a634:	2b00      	cmp	r3, #0
   8a636:	d004      	beq.n	8a642 <_ZN5SDLib4File5flushEv+0x1a>
    _file->sync();
   8a638:	687b      	ldr	r3, [r7, #4]
   8a63a:	6a1b      	ldr	r3, [r3, #32]
   8a63c:	4618      	mov	r0, r3
   8a63e:	4b03      	ldr	r3, [pc, #12]	; (8a64c <_ZN5SDLib4File5flushEv+0x24>)
   8a640:	4798      	blx	r3
}
   8a642:	bf00      	nop
   8a644:	3708      	adds	r7, #8
   8a646:	46bd      	mov	sp, r7
   8a648:	bd80      	pop	{r7, pc}
   8a64a:	bf00      	nop
   8a64c:	0008c519 	.word	0x0008c519

0008a650 <_ZN5SDLib4File8positionEv>:
  if (! _file) return false;

  return _file->seekSet(pos);
}

uint32_t File::position() {
   8a650:	b580      	push	{r7, lr}
   8a652:	b082      	sub	sp, #8
   8a654:	af00      	add	r7, sp, #0
   8a656:	6078      	str	r0, [r7, #4]
  if (! _file) return -1;
   8a658:	687b      	ldr	r3, [r7, #4]
   8a65a:	6a1b      	ldr	r3, [r3, #32]
   8a65c:	2b00      	cmp	r3, #0
   8a65e:	d102      	bne.n	8a666 <_ZN5SDLib4File8positionEv+0x16>
   8a660:	f04f 33ff 	mov.w	r3, #4294967295
   8a664:	e005      	b.n	8a672 <_ZN5SDLib4File8positionEv+0x22>
  return _file->curPosition();
   8a666:	687b      	ldr	r3, [r7, #4]
   8a668:	6a1b      	ldr	r3, [r3, #32]
   8a66a:	4618      	mov	r0, r3
   8a66c:	4b03      	ldr	r3, [pc, #12]	; (8a67c <_ZN5SDLib4File8positionEv+0x2c>)
   8a66e:	4798      	blx	r3
   8a670:	4603      	mov	r3, r0
}
   8a672:	4618      	mov	r0, r3
   8a674:	3708      	adds	r7, #8
   8a676:	46bd      	mov	sp, r7
   8a678:	bd80      	pop	{r7, pc}
   8a67a:	bf00      	nop
   8a67c:	0008a351 	.word	0x0008a351

0008a680 <_ZN5SDLib4File4sizeEv>:

uint32_t File::size() {
   8a680:	b580      	push	{r7, lr}
   8a682:	b082      	sub	sp, #8
   8a684:	af00      	add	r7, sp, #0
   8a686:	6078      	str	r0, [r7, #4]
  if (! _file) return 0;
   8a688:	687b      	ldr	r3, [r7, #4]
   8a68a:	6a1b      	ldr	r3, [r3, #32]
   8a68c:	2b00      	cmp	r3, #0
   8a68e:	d101      	bne.n	8a694 <_ZN5SDLib4File4sizeEv+0x14>
   8a690:	2300      	movs	r3, #0
   8a692:	e005      	b.n	8a6a0 <_ZN5SDLib4File4sizeEv+0x20>
  return _file->fileSize();
   8a694:	687b      	ldr	r3, [r7, #4]
   8a696:	6a1b      	ldr	r3, [r3, #32]
   8a698:	4618      	mov	r0, r3
   8a69a:	4b03      	ldr	r3, [pc, #12]	; (8a6a8 <_ZN5SDLib4File4sizeEv+0x28>)
   8a69c:	4798      	blx	r3
   8a69e:	4603      	mov	r3, r0
}
   8a6a0:	4618      	mov	r0, r3
   8a6a2:	3708      	adds	r7, #8
   8a6a4:	46bd      	mov	sp, r7
   8a6a6:	bd80      	pop	{r7, pc}
   8a6a8:	0008a369 	.word	0x0008a369

0008a6ac <_ZN5SDLib4File5closeEv>:

void File::close() {
   8a6ac:	b580      	push	{r7, lr}
   8a6ae:	b082      	sub	sp, #8
   8a6b0:	af00      	add	r7, sp, #0
   8a6b2:	6078      	str	r0, [r7, #4]
  if (_file) {
   8a6b4:	687b      	ldr	r3, [r7, #4]
   8a6b6:	6a1b      	ldr	r3, [r3, #32]
   8a6b8:	2b00      	cmp	r3, #0
   8a6ba:	d00c      	beq.n	8a6d6 <_ZN5SDLib4File5closeEv+0x2a>
    _file->close();
   8a6bc:	687b      	ldr	r3, [r7, #4]
   8a6be:	6a1b      	ldr	r3, [r3, #32]
   8a6c0:	4618      	mov	r0, r3
   8a6c2:	4b07      	ldr	r3, [pc, #28]	; (8a6e0 <_ZN5SDLib4File5closeEv+0x34>)
   8a6c4:	4798      	blx	r3
    free(_file); 
   8a6c6:	687b      	ldr	r3, [r7, #4]
   8a6c8:	6a1b      	ldr	r3, [r3, #32]
   8a6ca:	4618      	mov	r0, r3
   8a6cc:	4b05      	ldr	r3, [pc, #20]	; (8a6e4 <_ZN5SDLib4File5closeEv+0x38>)
   8a6ce:	4798      	blx	r3
    _file = 0;
   8a6d0:	687b      	ldr	r3, [r7, #4]
   8a6d2:	2200      	movs	r2, #0
   8a6d4:	621a      	str	r2, [r3, #32]
    nfilecount--;
    Serial.print("Deleted ");
    Serial.println(nfilecount, DEC);
    */
  }
}
   8a6d6:	bf00      	nop
   8a6d8:	3708      	adds	r7, #8
   8a6da:	46bd      	mov	sp, r7
   8a6dc:	bd80      	pop	{r7, pc}
   8a6de:	bf00      	nop
   8a6e0:	0008bc29 	.word	0x0008bc29
   8a6e4:	00093545 	.word	0x00093545

0008a6e8 <_ZN5SDLib4FilecvbEv>:

File::operator bool() {
   8a6e8:	b580      	push	{r7, lr}
   8a6ea:	b082      	sub	sp, #8
   8a6ec:	af00      	add	r7, sp, #0
   8a6ee:	6078      	str	r0, [r7, #4]
  if (_file) 
   8a6f0:	687b      	ldr	r3, [r7, #4]
   8a6f2:	6a1b      	ldr	r3, [r3, #32]
   8a6f4:	2b00      	cmp	r3, #0
   8a6f6:	d00b      	beq.n	8a710 <_ZN5SDLib4FilecvbEv+0x28>
    return  _file->isOpen();
   8a6f8:	687b      	ldr	r3, [r7, #4]
   8a6fa:	6a1b      	ldr	r3, [r3, #32]
   8a6fc:	4618      	mov	r0, r3
   8a6fe:	4b07      	ldr	r3, [pc, #28]	; (8a71c <_ZN5SDLib4FilecvbEv+0x34>)
   8a700:	4798      	blx	r3
   8a702:	4603      	mov	r3, r0
   8a704:	2b00      	cmp	r3, #0
   8a706:	bf14      	ite	ne
   8a708:	2301      	movne	r3, #1
   8a70a:	2300      	moveq	r3, #0
   8a70c:	b2db      	uxtb	r3, r3
   8a70e:	e000      	b.n	8a712 <_ZN5SDLib4FilecvbEv+0x2a>
  return false;
   8a710:	2300      	movs	r3, #0
}
   8a712:	4618      	mov	r0, r3
   8a714:	3708      	adds	r7, #8
   8a716:	46bd      	mov	sp, r7
   8a718:	bd80      	pop	{r7, pc}
   8a71a:	bf00      	nop
   8a71c:	0008a3a1 	.word	0x0008a3a1

0008a720 <_ZN7Sd2CardC1Ev>:
 * \brief Raw access to SD and SDHC flash memory cards.
 */
class Sd2Card {
 public:
  /** Construct an instance of Sd2Card. */
  Sd2Card(void) : errorCode_(0), inBlock_(0), partialBlockRead_(0), type_(0) {}
   8a720:	b480      	push	{r7}
   8a722:	b083      	sub	sp, #12
   8a724:	af00      	add	r7, sp, #0
   8a726:	6078      	str	r0, [r7, #4]
   8a728:	687b      	ldr	r3, [r7, #4]
   8a72a:	2200      	movs	r2, #0
   8a72c:	715a      	strb	r2, [r3, #5]
   8a72e:	687b      	ldr	r3, [r7, #4]
   8a730:	2200      	movs	r2, #0
   8a732:	719a      	strb	r2, [r3, #6]
   8a734:	687b      	ldr	r3, [r7, #4]
   8a736:	2200      	movs	r2, #0
   8a738:	729a      	strb	r2, [r3, #10]
   8a73a:	687b      	ldr	r3, [r7, #4]
   8a73c:	2200      	movs	r2, #0
   8a73e:	731a      	strb	r2, [r3, #12]
   8a740:	687b      	ldr	r3, [r7, #4]
   8a742:	4618      	mov	r0, r3
   8a744:	370c      	adds	r7, #12
   8a746:	46bd      	mov	sp, r7
   8a748:	bc80      	pop	{r7}
   8a74a:	4770      	bx	lr

0008a74c <_ZN6SdFileC1Ev>:
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
   8a74c:	b580      	push	{r7, lr}
   8a74e:	b082      	sub	sp, #8
   8a750:	af00      	add	r7, sp, #0
   8a752:	6078      	str	r0, [r7, #4]
   8a754:	687b      	ldr	r3, [r7, #4]
   8a756:	4618      	mov	r0, r3
   8a758:	4b06      	ldr	r3, [pc, #24]	; (8a774 <_ZN6SdFileC1Ev+0x28>)
   8a75a:	4798      	blx	r3
   8a75c:	4a06      	ldr	r2, [pc, #24]	; (8a778 <_ZN6SdFileC1Ev+0x2c>)
   8a75e:	687b      	ldr	r3, [r7, #4]
   8a760:	601a      	str	r2, [r3, #0]
   8a762:	687b      	ldr	r3, [r7, #4]
   8a764:	2200      	movs	r2, #0
   8a766:	725a      	strb	r2, [r3, #9]
   8a768:	687b      	ldr	r3, [r7, #4]
   8a76a:	4618      	mov	r0, r3
   8a76c:	3708      	adds	r7, #8
   8a76e:	46bd      	mov	sp, r7
   8a770:	bd80      	pop	{r7, pc}
   8a772:	bf00      	nop
   8a774:	00080499 	.word	0x00080499
   8a778:	0009ae74 	.word	0x0009ae74

0008a77c <_ZNK6SdFile6isRootEv>:
  /** \return True if this is a SdFile for an open file/directory else false. */
  uint8_t isOpen(void) const {return type_ != FAT_FILE_TYPE_CLOSED;}
  /** \return True if this is a SdFile for a subdirectory else false. */
  uint8_t isSubDir(void) const {return type_ == FAT_FILE_TYPE_SUBDIR;}
  /** \return True if this is a SdFile for the root directory. */
  uint8_t isRoot(void) const {
   8a77c:	b480      	push	{r7}
   8a77e:	b083      	sub	sp, #12
   8a780:	af00      	add	r7, sp, #0
   8a782:	6078      	str	r0, [r7, #4]
    return type_ == FAT_FILE_TYPE_ROOT16 || type_ == FAT_FILE_TYPE_ROOT32;
   8a784:	687b      	ldr	r3, [r7, #4]
   8a786:	7a5b      	ldrb	r3, [r3, #9]
   8a788:	2b02      	cmp	r3, #2
   8a78a:	d003      	beq.n	8a794 <_ZNK6SdFile6isRootEv+0x18>
   8a78c:	687b      	ldr	r3, [r7, #4]
   8a78e:	7a5b      	ldrb	r3, [r3, #9]
   8a790:	2b03      	cmp	r3, #3
   8a792:	d101      	bne.n	8a798 <_ZNK6SdFile6isRootEv+0x1c>
   8a794:	2301      	movs	r3, #1
   8a796:	e000      	b.n	8a79a <_ZNK6SdFile6isRootEv+0x1e>
   8a798:	2300      	movs	r3, #0
  }
   8a79a:	4618      	mov	r0, r3
   8a79c:	370c      	adds	r7, #12
   8a79e:	46bd      	mov	sp, r7
   8a7a0:	bc80      	pop	{r7}
   8a7a2:	4770      	bx	lr

0008a7a4 <_ZN6SdFile6rewindEv>:
  int16_t read(void* buf, uint16_t nbyte);
  int8_t readDir(dir_t* dir);
  static uint8_t remove(SdFile* dirFile, const char* fileName);
  uint8_t remove(void);
  /** Set the file's current position to zero. */
  void rewind(void) {
   8a7a4:	b480      	push	{r7}
   8a7a6:	b083      	sub	sp, #12
   8a7a8:	af00      	add	r7, sp, #0
   8a7aa:	6078      	str	r0, [r7, #4]
    curPosition_ = curCluster_ = 0;
   8a7ac:	687b      	ldr	r3, [r7, #4]
   8a7ae:	2200      	movs	r2, #0
   8a7b0:	60da      	str	r2, [r3, #12]
   8a7b2:	687b      	ldr	r3, [r7, #4]
   8a7b4:	68da      	ldr	r2, [r3, #12]
   8a7b6:	687b      	ldr	r3, [r7, #4]
   8a7b8:	611a      	str	r2, [r3, #16]
  }
   8a7ba:	bf00      	nop
   8a7bc:	370c      	adds	r7, #12
   8a7be:	46bd      	mov	sp, r7
   8a7c0:	bc80      	pop	{r7}
   8a7c2:	4770      	bx	lr

0008a7c4 <_ZN6SdFile4openERS_PKch>:
    return makeDir(&dir, dirName);
  }
  /** \deprecated Use:
   * uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag);
   */
  uint8_t open(SdFile& dirFile, // NOLINT
   8a7c4:	b590      	push	{r4, r7, lr}
   8a7c6:	b085      	sub	sp, #20
   8a7c8:	af00      	add	r7, sp, #0
   8a7ca:	60f8      	str	r0, [r7, #12]
   8a7cc:	60b9      	str	r1, [r7, #8]
   8a7ce:	607a      	str	r2, [r7, #4]
   8a7d0:	70fb      	strb	r3, [r7, #3]
    const char* fileName, uint8_t oflag) {
    return open(&dirFile, fileName, oflag);
   8a7d2:	78fb      	ldrb	r3, [r7, #3]
   8a7d4:	687a      	ldr	r2, [r7, #4]
   8a7d6:	68b9      	ldr	r1, [r7, #8]
   8a7d8:	68f8      	ldr	r0, [r7, #12]
   8a7da:	4c03      	ldr	r4, [pc, #12]	; (8a7e8 <_ZN6SdFile4openERS_PKch+0x24>)
   8a7dc:	47a0      	blx	r4
   8a7de:	4603      	mov	r3, r0
  }
   8a7e0:	4618      	mov	r0, r3
   8a7e2:	3714      	adds	r7, #20
   8a7e4:	46bd      	mov	sp, r7
   8a7e6:	bd90      	pop	{r4, r7, pc}
   8a7e8:	0008bd71 	.word	0x0008bd71

0008a7ec <_ZN6SdFile8openRootER8SdVolume>:
   */
  uint8_t open(SdFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT
    return open(&dirFile, index, oflag);
  }
  /** \deprecated Use: uint8_t SdFile::openRoot(SdVolume* vol); */
  uint8_t openRoot(SdVolume& vol) {return openRoot(&vol);}  // NOLINT
   8a7ec:	b580      	push	{r7, lr}
   8a7ee:	b082      	sub	sp, #8
   8a7f0:	af00      	add	r7, sp, #0
   8a7f2:	6078      	str	r0, [r7, #4]
   8a7f4:	6039      	str	r1, [r7, #0]
   8a7f6:	6839      	ldr	r1, [r7, #0]
   8a7f8:	6878      	ldr	r0, [r7, #4]
   8a7fa:	4b03      	ldr	r3, [pc, #12]	; (8a808 <_ZN6SdFile8openRootER8SdVolume+0x1c>)
   8a7fc:	4798      	blx	r3
   8a7fe:	4603      	mov	r3, r0
   8a800:	4618      	mov	r0, r3
   8a802:	3708      	adds	r7, #8
   8a804:	46bd      	mov	sp, r7
   8a806:	bd80      	pop	{r7, pc}
   8a808:	0008c0c5 	.word	0x0008c0c5

0008a80c <_ZN8SdVolumeC1Ev>:
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   8a80c:	b480      	push	{r7}
   8a80e:	b083      	sub	sp, #12
   8a810:	af00      	add	r7, sp, #0
   8a812:	6078      	str	r0, [r7, #4]
   8a814:	687b      	ldr	r3, [r7, #4]
   8a816:	2202      	movs	r2, #2
   8a818:	601a      	str	r2, [r3, #0]
   8a81a:	687b      	ldr	r3, [r7, #4]
   8a81c:	2200      	movs	r2, #0
   8a81e:	f883 2020 	strb.w	r2, [r3, #32]
   8a822:	687b      	ldr	r3, [r7, #4]
   8a824:	4618      	mov	r0, r3
   8a826:	370c      	adds	r7, #12
   8a828:	46bd      	mov	sp, r7
   8a82a:	bc80      	pop	{r7}
   8a82c:	4770      	bx	lr
   8a82e:	bf00      	nop

0008a830 <_ZN8SdVolume4initEP7Sd2Card>:
   * \return The value one, true, is returned for success and
   * the value zero, false, is returned for failure.  Reasons for
   * failure include not finding a valid partition, not finding a valid
   * FAT file system or an I/O error.
   */
  uint8_t init(Sd2Card* dev) { return init(dev, 1) ? true : init(dev, 0);}
   8a830:	b580      	push	{r7, lr}
   8a832:	b082      	sub	sp, #8
   8a834:	af00      	add	r7, sp, #0
   8a836:	6078      	str	r0, [r7, #4]
   8a838:	6039      	str	r1, [r7, #0]
   8a83a:	2201      	movs	r2, #1
   8a83c:	6839      	ldr	r1, [r7, #0]
   8a83e:	6878      	ldr	r0, [r7, #4]
   8a840:	4b08      	ldr	r3, [pc, #32]	; (8a864 <_ZN8SdVolume4initEP7Sd2Card+0x34>)
   8a842:	4798      	blx	r3
   8a844:	4603      	mov	r3, r0
   8a846:	2b00      	cmp	r3, #0
   8a848:	d106      	bne.n	8a858 <_ZN8SdVolume4initEP7Sd2Card+0x28>
   8a84a:	2200      	movs	r2, #0
   8a84c:	6839      	ldr	r1, [r7, #0]
   8a84e:	6878      	ldr	r0, [r7, #4]
   8a850:	4b04      	ldr	r3, [pc, #16]	; (8a864 <_ZN8SdVolume4initEP7Sd2Card+0x34>)
   8a852:	4798      	blx	r3
   8a854:	4603      	mov	r3, r0
   8a856:	e000      	b.n	8a85a <_ZN8SdVolume4initEP7Sd2Card+0x2a>
   8a858:	2301      	movs	r3, #1
   8a85a:	4618      	mov	r0, r3
   8a85c:	3708      	adds	r7, #8
   8a85e:	46bd      	mov	sp, r7
   8a860:	bd80      	pop	{r7, pc}
   8a862:	bf00      	nop
   8a864:	0008cfdd 	.word	0x0008cfdd

0008a868 <_ZN8SdVolume4initER7Sd2Card>:
  static Sd2Card* sdCard(void) {return sdCard_;}
//------------------------------------------------------------------------------
#if ALLOW_DEPRECATED_FUNCTIONS
  // Deprecated functions  - suppress cpplint warnings with NOLINT comment
  /** \deprecated Use: uint8_t SdVolume::init(Sd2Card* dev); */
  uint8_t init(Sd2Card& dev) {return init(&dev);}  // NOLINT
   8a868:	b580      	push	{r7, lr}
   8a86a:	b082      	sub	sp, #8
   8a86c:	af00      	add	r7, sp, #0
   8a86e:	6078      	str	r0, [r7, #4]
   8a870:	6039      	str	r1, [r7, #0]
   8a872:	6839      	ldr	r1, [r7, #0]
   8a874:	6878      	ldr	r0, [r7, #4]
   8a876:	4b03      	ldr	r3, [pc, #12]	; (8a884 <_ZN8SdVolume4initER7Sd2Card+0x1c>)
   8a878:	4798      	blx	r3
   8a87a:	4603      	mov	r3, r0
   8a87c:	4618      	mov	r0, r3
   8a87e:	3708      	adds	r7, #8
   8a880:	46bd      	mov	sp, r7
   8a882:	bd80      	pop	{r7, pc}
   8a884:	0008a831 	.word	0x0008a831

0008a888 <_ZN5SDLib7SDClass5beginEh>:

/* Implementation of class used to create `SDCard` object. */



boolean SDClass::begin(uint8_t csPin) {
   8a888:	b580      	push	{r7, lr}
   8a88a:	b082      	sub	sp, #8
   8a88c:	af00      	add	r7, sp, #0
   8a88e:	6078      	str	r0, [r7, #4]
   8a890:	460b      	mov	r3, r1
   8a892:	70fb      	strb	r3, [r7, #3]
    Performs the initialisation required by the sdfatlib library.

    Return true if initialization succeeds, false otherwise.

   */
  return card.init(SPI_HALF_SPEED, csPin) &&
   8a894:	687b      	ldr	r3, [r7, #4]
   8a896:	78fa      	ldrb	r2, [r7, #3]
   8a898:	2101      	movs	r1, #1
   8a89a:	4618      	mov	r0, r3
   8a89c:	4b10      	ldr	r3, [pc, #64]	; (8a8e0 <_ZN5SDLib7SDClass5beginEh+0x58>)
   8a89e:	4798      	blx	r3
   8a8a0:	4603      	mov	r3, r0
         volume.init(card) &&
   8a8a2:	2b00      	cmp	r3, #0
   8a8a4:	d017      	beq.n	8a8d6 <_ZN5SDLib7SDClass5beginEh+0x4e>
   8a8a6:	687b      	ldr	r3, [r7, #4]
   8a8a8:	3310      	adds	r3, #16
   8a8aa:	687a      	ldr	r2, [r7, #4]
   8a8ac:	4611      	mov	r1, r2
   8a8ae:	4618      	mov	r0, r3
   8a8b0:	4b0c      	ldr	r3, [pc, #48]	; (8a8e4 <_ZN5SDLib7SDClass5beginEh+0x5c>)
   8a8b2:	4798      	blx	r3
   8a8b4:	4603      	mov	r3, r0
    Performs the initialisation required by the sdfatlib library.

    Return true if initialization succeeds, false otherwise.

   */
  return card.init(SPI_HALF_SPEED, csPin) &&
   8a8b6:	2b00      	cmp	r3, #0
   8a8b8:	d00d      	beq.n	8a8d6 <_ZN5SDLib7SDClass5beginEh+0x4e>
         volume.init(card) &&
         root.openRoot(volume);
   8a8ba:	687b      	ldr	r3, [r7, #4]
   8a8bc:	f103 0238 	add.w	r2, r3, #56	; 0x38
   8a8c0:	687b      	ldr	r3, [r7, #4]
   8a8c2:	3310      	adds	r3, #16
   8a8c4:	4619      	mov	r1, r3
   8a8c6:	4610      	mov	r0, r2
   8a8c8:	4b07      	ldr	r3, [pc, #28]	; (8a8e8 <_ZN5SDLib7SDClass5beginEh+0x60>)
   8a8ca:	4798      	blx	r3
   8a8cc:	4603      	mov	r3, r0

    Return true if initialization succeeds, false otherwise.

   */
  return card.init(SPI_HALF_SPEED, csPin) &&
         volume.init(card) &&
   8a8ce:	2b00      	cmp	r3, #0
   8a8d0:	d001      	beq.n	8a8d6 <_ZN5SDLib7SDClass5beginEh+0x4e>
   8a8d2:	2301      	movs	r3, #1
   8a8d4:	e000      	b.n	8a8d8 <_ZN5SDLib7SDClass5beginEh+0x50>
   8a8d6:	2300      	movs	r3, #0
         root.openRoot(volume);
}
   8a8d8:	4618      	mov	r0, r3
   8a8da:	3708      	adds	r7, #8
   8a8dc:	46bd      	mov	sp, r7
   8a8de:	bd80      	pop	{r7, pc}
   8a8e0:	0008b061 	.word	0x0008b061
   8a8e4:	0008a869 	.word	0x0008a869
   8a8e8:	0008a7ed 	.word	0x0008a7ed

0008a8ec <_ZN5PrintC1ERKS_>:
#define DEC 10
#define HEX 16
#define OCT 8
#define BIN 2

class Print
   8a8ec:	b480      	push	{r7}
   8a8ee:	b083      	sub	sp, #12
   8a8f0:	af00      	add	r7, sp, #0
   8a8f2:	6078      	str	r0, [r7, #4]
   8a8f4:	6039      	str	r1, [r7, #0]
   8a8f6:	4a06      	ldr	r2, [pc, #24]	; (8a910 <_ZN5PrintC1ERKS_+0x24>)
   8a8f8:	687b      	ldr	r3, [r7, #4]
   8a8fa:	601a      	str	r2, [r3, #0]
   8a8fc:	683b      	ldr	r3, [r7, #0]
   8a8fe:	685a      	ldr	r2, [r3, #4]
   8a900:	687b      	ldr	r3, [r7, #4]
   8a902:	605a      	str	r2, [r3, #4]
   8a904:	687b      	ldr	r3, [r7, #4]
   8a906:	4618      	mov	r0, r3
   8a908:	370c      	adds	r7, #12
   8a90a:	46bd      	mov	sp, r7
   8a90c:	bc80      	pop	{r7}
   8a90e:	4770      	bx	lr
   8a910:	0009ac58 	.word	0x0009ac58

0008a914 <_ZN6SdFileC1ERKS_>:
//------------------------------------------------------------------------------
/**
 * \class SdFile
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
   8a914:	b580      	push	{r7, lr}
   8a916:	b082      	sub	sp, #8
   8a918:	af00      	add	r7, sp, #0
   8a91a:	6078      	str	r0, [r7, #4]
   8a91c:	6039      	str	r1, [r7, #0]
   8a91e:	687b      	ldr	r3, [r7, #4]
   8a920:	683a      	ldr	r2, [r7, #0]
   8a922:	4611      	mov	r1, r2
   8a924:	4618      	mov	r0, r3
   8a926:	4b17      	ldr	r3, [pc, #92]	; (8a984 <_ZN6SdFileC1ERKS_+0x70>)
   8a928:	4798      	blx	r3
   8a92a:	4a17      	ldr	r2, [pc, #92]	; (8a988 <_ZN6SdFileC1ERKS_+0x74>)
   8a92c:	687b      	ldr	r3, [r7, #4]
   8a92e:	601a      	str	r2, [r3, #0]
   8a930:	683b      	ldr	r3, [r7, #0]
   8a932:	7a1a      	ldrb	r2, [r3, #8]
   8a934:	687b      	ldr	r3, [r7, #4]
   8a936:	721a      	strb	r2, [r3, #8]
   8a938:	683b      	ldr	r3, [r7, #0]
   8a93a:	7a5a      	ldrb	r2, [r3, #9]
   8a93c:	687b      	ldr	r3, [r7, #4]
   8a93e:	725a      	strb	r2, [r3, #9]
   8a940:	683b      	ldr	r3, [r7, #0]
   8a942:	68da      	ldr	r2, [r3, #12]
   8a944:	687b      	ldr	r3, [r7, #4]
   8a946:	60da      	str	r2, [r3, #12]
   8a948:	683b      	ldr	r3, [r7, #0]
   8a94a:	691a      	ldr	r2, [r3, #16]
   8a94c:	687b      	ldr	r3, [r7, #4]
   8a94e:	611a      	str	r2, [r3, #16]
   8a950:	683b      	ldr	r3, [r7, #0]
   8a952:	695a      	ldr	r2, [r3, #20]
   8a954:	687b      	ldr	r3, [r7, #4]
   8a956:	615a      	str	r2, [r3, #20]
   8a958:	683b      	ldr	r3, [r7, #0]
   8a95a:	7e1a      	ldrb	r2, [r3, #24]
   8a95c:	687b      	ldr	r3, [r7, #4]
   8a95e:	761a      	strb	r2, [r3, #24]
   8a960:	683b      	ldr	r3, [r7, #0]
   8a962:	69da      	ldr	r2, [r3, #28]
   8a964:	687b      	ldr	r3, [r7, #4]
   8a966:	61da      	str	r2, [r3, #28]
   8a968:	683b      	ldr	r3, [r7, #0]
   8a96a:	6a1a      	ldr	r2, [r3, #32]
   8a96c:	687b      	ldr	r3, [r7, #4]
   8a96e:	621a      	str	r2, [r3, #32]
   8a970:	683b      	ldr	r3, [r7, #0]
   8a972:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   8a974:	687b      	ldr	r3, [r7, #4]
   8a976:	625a      	str	r2, [r3, #36]	; 0x24
   8a978:	687b      	ldr	r3, [r7, #4]
   8a97a:	4618      	mov	r0, r3
   8a97c:	3708      	adds	r7, #8
   8a97e:	46bd      	mov	sp, r7
   8a980:	bd80      	pop	{r7, pc}
   8a982:	bf00      	nop
   8a984:	0008a8ed 	.word	0x0008a8ed
   8a988:	0009ae74 	.word	0x0009ae74

0008a98c <_ZN5SDLib7SDClass12getParentDirEPKcPi>:



// this little helper is used to traverse paths
SdFile SDClass::getParentDir(const char *filepath, int *index) {
   8a98c:	b590      	push	{r4, r7, lr}
   8a98e:	b0a3      	sub	sp, #140	; 0x8c
   8a990:	af00      	add	r7, sp, #0
   8a992:	60f8      	str	r0, [r7, #12]
   8a994:	60b9      	str	r1, [r7, #8]
   8a996:	607a      	str	r2, [r7, #4]
   8a998:	603b      	str	r3, [r7, #0]
  // get parent directory
  SdFile d1 = root; // start with the mostparent, root!
   8a99a:	68bb      	ldr	r3, [r7, #8]
   8a99c:	f103 0238 	add.w	r2, r3, #56	; 0x38
   8a9a0:	f107 034c 	add.w	r3, r7, #76	; 0x4c
   8a9a4:	4611      	mov	r1, r2
   8a9a6:	4618      	mov	r0, r3
   8a9a8:	4b41      	ldr	r3, [pc, #260]	; (8aab0 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x124>)
   8a9aa:	4798      	blx	r3
  SdFile d2;
   8a9ac:	f107 0324 	add.w	r3, r7, #36	; 0x24
   8a9b0:	4618      	mov	r0, r3
   8a9b2:	4b40      	ldr	r3, [pc, #256]	; (8aab4 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x128>)
   8a9b4:	4798      	blx	r3

  // we'll use the pointers to swap between the two objects
  SdFile *parent = &d1;
   8a9b6:	f107 034c 	add.w	r3, r7, #76	; 0x4c
   8a9ba:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  SdFile *subdir = &d2;
   8a9be:	f107 0324 	add.w	r3, r7, #36	; 0x24
   8a9c2:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  
  const char *origpath = filepath;
   8a9c6:	687b      	ldr	r3, [r7, #4]
   8a9c8:	67bb      	str	r3, [r7, #120]	; 0x78

  while (strchr(filepath, '/')) {
   8a9ca:	212f      	movs	r1, #47	; 0x2f
   8a9cc:	6878      	ldr	r0, [r7, #4]
   8a9ce:	4b3a      	ldr	r3, [pc, #232]	; (8aab8 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x12c>)
   8a9d0:	4798      	blx	r3
   8a9d2:	4603      	mov	r3, r0
   8a9d4:	2b00      	cmp	r3, #0
   8a9d6:	d05d      	beq.n	8aa94 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x108>

    // get rid of leading /'s
    if (filepath[0] == '/') {
   8a9d8:	687b      	ldr	r3, [r7, #4]
   8a9da:	781b      	ldrb	r3, [r3, #0]
   8a9dc:	2b2f      	cmp	r3, #47	; 0x2f
   8a9de:	d103      	bne.n	8a9e8 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x5c>
      filepath++;
   8a9e0:	687b      	ldr	r3, [r7, #4]
   8a9e2:	3301      	adds	r3, #1
   8a9e4:	607b      	str	r3, [r7, #4]
   8a9e6:	e7f0      	b.n	8a9ca <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x3e>
      continue;
    }
    
    if (! strchr(filepath, '/')) {
   8a9e8:	212f      	movs	r1, #47	; 0x2f
   8a9ea:	6878      	ldr	r0, [r7, #4]
   8a9ec:	4b32      	ldr	r3, [pc, #200]	; (8aab8 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x12c>)
   8a9ee:	4798      	blx	r3
   8a9f0:	4603      	mov	r3, r0
   8a9f2:	2b00      	cmp	r3, #0
   8a9f4:	d04d      	beq.n	8aa92 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x106>
      // it was in the root directory, so leave now
      break;
    }

    // extract just the name of the next subdirectory
    uint8_t idx = strchr(filepath, '/') - filepath;
   8a9f6:	212f      	movs	r1, #47	; 0x2f
   8a9f8:	6878      	ldr	r0, [r7, #4]
   8a9fa:	4b2f      	ldr	r3, [pc, #188]	; (8aab8 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x12c>)
   8a9fc:	4798      	blx	r3
   8a9fe:	4603      	mov	r3, r0
   8aa00:	461a      	mov	r2, r3
   8aa02:	687b      	ldr	r3, [r7, #4]
   8aa04:	1ad3      	subs	r3, r2, r3
   8aa06:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
    if (idx > 12)
   8aa0a:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
   8aa0e:	2b0c      	cmp	r3, #12
   8aa10:	d902      	bls.n	8aa18 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x8c>
      idx = 12;    // dont let them specify long names
   8aa12:	230c      	movs	r3, #12
   8aa14:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
    char subdirname[13];
    strncpy(subdirname, filepath, idx);
   8aa18:	f897 207f 	ldrb.w	r2, [r7, #127]	; 0x7f
   8aa1c:	f107 0314 	add.w	r3, r7, #20
   8aa20:	6879      	ldr	r1, [r7, #4]
   8aa22:	4618      	mov	r0, r3
   8aa24:	4b25      	ldr	r3, [pc, #148]	; (8aabc <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x130>)
   8aa26:	4798      	blx	r3
    subdirname[idx] = 0;
   8aa28:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
   8aa2c:	f107 0288 	add.w	r2, r7, #136	; 0x88
   8aa30:	4413      	add	r3, r2
   8aa32:	2200      	movs	r2, #0
   8aa34:	f803 2c74 	strb.w	r2, [r3, #-116]

    // close the subdir (we reuse them) if open
    subdir->close();
   8aa38:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
   8aa3c:	4b20      	ldr	r3, [pc, #128]	; (8aac0 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x134>)
   8aa3e:	4798      	blx	r3
    if (! subdir->open(parent, subdirname, O_READ)) {
   8aa40:	f107 0214 	add.w	r2, r7, #20
   8aa44:	2301      	movs	r3, #1
   8aa46:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
   8aa4a:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
   8aa4e:	4c1d      	ldr	r4, [pc, #116]	; (8aac4 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x138>)
   8aa50:	47a0      	blx	r4
   8aa52:	4603      	mov	r3, r0
   8aa54:	2b00      	cmp	r3, #0
   8aa56:	bf0c      	ite	eq
   8aa58:	2301      	moveq	r3, #1
   8aa5a:	2300      	movne	r3, #0
   8aa5c:	b2db      	uxtb	r3, r3
   8aa5e:	2b00      	cmp	r3, #0
   8aa60:	d003      	beq.n	8aa6a <_ZN5SDLib7SDClass12getParentDirEPKcPi+0xde>
      // failed to open one of the subdirectories
      return SdFile();
   8aa62:	68f8      	ldr	r0, [r7, #12]
   8aa64:	4b13      	ldr	r3, [pc, #76]	; (8aab4 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x128>)
   8aa66:	4798      	blx	r3
   8aa68:	e01e      	b.n	8aaa8 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x11c>
    }
    // move forward to the next subdirectory
    filepath += idx;
   8aa6a:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
   8aa6e:	687a      	ldr	r2, [r7, #4]
   8aa70:	4413      	add	r3, r2
   8aa72:	607b      	str	r3, [r7, #4]

    // we reuse the objects, close it.
    parent->close();
   8aa74:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
   8aa78:	4b11      	ldr	r3, [pc, #68]	; (8aac0 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x134>)
   8aa7a:	4798      	blx	r3

    // swap the pointers
    SdFile *t = parent;
   8aa7c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
   8aa80:	677b      	str	r3, [r7, #116]	; 0x74
    parent = subdir;
   8aa82:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
   8aa86:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    subdir = t;
   8aa8a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
   8aa8c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  SdFile *parent = &d1;
  SdFile *subdir = &d2;
  
  const char *origpath = filepath;

  while (strchr(filepath, '/')) {
   8aa90:	e79b      	b.n	8a9ca <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x3e>
      continue;
    }
    
    if (! strchr(filepath, '/')) {
      // it was in the root directory, so leave now
      break;
   8aa92:	bf00      	nop
    SdFile *t = parent;
    parent = subdir;
    subdir = t;
  }

  *index = (int)(filepath - origpath);
   8aa94:	687a      	ldr	r2, [r7, #4]
   8aa96:	6fbb      	ldr	r3, [r7, #120]	; 0x78
   8aa98:	1ad2      	subs	r2, r2, r3
   8aa9a:	683b      	ldr	r3, [r7, #0]
   8aa9c:	601a      	str	r2, [r3, #0]
  // parent is now the parent diretory of the file!
  return *parent;
   8aa9e:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
   8aaa2:	68f8      	ldr	r0, [r7, #12]
   8aaa4:	4b02      	ldr	r3, [pc, #8]	; (8aab0 <_ZN5SDLib7SDClass12getParentDirEPKcPi+0x124>)
   8aaa6:	4798      	blx	r3
}
   8aaa8:	68f8      	ldr	r0, [r7, #12]
   8aaaa:	378c      	adds	r7, #140	; 0x8c
   8aaac:	46bd      	mov	sp, r7
   8aaae:	bd90      	pop	{r4, r7, pc}
   8aab0:	0008a915 	.word	0x0008a915
   8aab4:	0008a74d 	.word	0x0008a74d
   8aab8:	000941bd 	.word	0x000941bd
   8aabc:	000943a5 	.word	0x000943a5
   8aac0:	0008bc29 	.word	0x0008bc29
   8aac4:	0008bd71 	.word	0x0008bd71

0008aac8 <_ZN5SDLib7SDClass4openEPKch>:


File SDClass::open(const char *filepath, uint8_t mode) {
   8aac8:	b590      	push	{r4, r7, lr}
   8aaca:	b0af      	sub	sp, #188	; 0xbc
   8aacc:	af00      	add	r7, sp, #0
   8aace:	60f8      	str	r0, [r7, #12]
   8aad0:	60b9      	str	r1, [r7, #8]
   8aad2:	607a      	str	r2, [r7, #4]
   8aad4:	70fb      	strb	r3, [r7, #3]
   */

  int pathidx;

  // do the interative search
  SdFile parentdir = getParentDir(filepath, &pathidx);
   8aad6:	f107 003c 	add.w	r0, r7, #60	; 0x3c
   8aada:	f107 0364 	add.w	r3, r7, #100	; 0x64
   8aade:	687a      	ldr	r2, [r7, #4]
   8aae0:	68b9      	ldr	r1, [r7, #8]
   8aae2:	4c48      	ldr	r4, [pc, #288]	; (8ac04 <_ZN5SDLib7SDClass4openEPKch+0x13c>)
   8aae4:	47a0      	blx	r4
  // no more subdirs!

  filepath += pathidx;
   8aae6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
   8aae8:	461a      	mov	r2, r3
   8aaea:	687b      	ldr	r3, [r7, #4]
   8aaec:	4413      	add	r3, r2
   8aaee:	607b      	str	r3, [r7, #4]

  if (! filepath[0]) {
   8aaf0:	687b      	ldr	r3, [r7, #4]
   8aaf2:	781b      	ldrb	r3, [r3, #0]
   8aaf4:	2b00      	cmp	r3, #0
   8aaf6:	d10f      	bne.n	8ab18 <_ZN5SDLib7SDClass4openEPKch+0x50>
    // it was the directory itself!
    return File(parentdir, "/");
   8aaf8:	f107 023c 	add.w	r2, r7, #60	; 0x3c
   8aafc:	f107 0368 	add.w	r3, r7, #104	; 0x68
   8ab00:	4611      	mov	r1, r2
   8ab02:	4618      	mov	r0, r3
   8ab04:	4b40      	ldr	r3, [pc, #256]	; (8ac08 <_ZN5SDLib7SDClass4openEPKch+0x140>)
   8ab06:	4798      	blx	r3
   8ab08:	f107 0368 	add.w	r3, r7, #104	; 0x68
   8ab0c:	4a3f      	ldr	r2, [pc, #252]	; (8ac0c <_ZN5SDLib7SDClass4openEPKch+0x144>)
   8ab0e:	4619      	mov	r1, r3
   8ab10:	68f8      	ldr	r0, [r7, #12]
   8ab12:	4b3f      	ldr	r3, [pc, #252]	; (8ac10 <_ZN5SDLib7SDClass4openEPKch+0x148>)
   8ab14:	4798      	blx	r3
   8ab16:	e070      	b.n	8abfa <_ZN5SDLib7SDClass4openEPKch+0x132>
  }

  // Open the file itself
  SdFile file;
   8ab18:	f107 0314 	add.w	r3, r7, #20
   8ab1c:	4618      	mov	r0, r3
   8ab1e:	4b3d      	ldr	r3, [pc, #244]	; (8ac14 <_ZN5SDLib7SDClass4openEPKch+0x14c>)
   8ab20:	4798      	blx	r3

  // failed to open a subdir!
  if (!parentdir.isOpen())
   8ab22:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   8ab26:	4618      	mov	r0, r3
   8ab28:	4b3b      	ldr	r3, [pc, #236]	; (8ac18 <_ZN5SDLib7SDClass4openEPKch+0x150>)
   8ab2a:	4798      	blx	r3
   8ab2c:	4603      	mov	r3, r0
   8ab2e:	2b00      	cmp	r3, #0
   8ab30:	bf0c      	ite	eq
   8ab32:	2301      	moveq	r3, #1
   8ab34:	2300      	movne	r3, #0
   8ab36:	b2db      	uxtb	r3, r3
   8ab38:	2b00      	cmp	r3, #0
   8ab3a:	d003      	beq.n	8ab44 <_ZN5SDLib7SDClass4openEPKch+0x7c>
    return File();
   8ab3c:	68f8      	ldr	r0, [r7, #12]
   8ab3e:	4b37      	ldr	r3, [pc, #220]	; (8ac1c <_ZN5SDLib7SDClass4openEPKch+0x154>)
   8ab40:	4798      	blx	r3
   8ab42:	e05a      	b.n	8abfa <_ZN5SDLib7SDClass4openEPKch+0x132>

  // there is a special case for the Root directory since its a static dir
  if (parentdir.isRoot()) {
   8ab44:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   8ab48:	4618      	mov	r0, r3
   8ab4a:	4b35      	ldr	r3, [pc, #212]	; (8ac20 <_ZN5SDLib7SDClass4openEPKch+0x158>)
   8ab4c:	4798      	blx	r3
   8ab4e:	4603      	mov	r3, r0
   8ab50:	2b00      	cmp	r3, #0
   8ab52:	bf14      	ite	ne
   8ab54:	2301      	movne	r3, #1
   8ab56:	2300      	moveq	r3, #0
   8ab58:	b2db      	uxtb	r3, r3
   8ab5a:	2b00      	cmp	r3, #0
   8ab5c:	d014      	beq.n	8ab88 <_ZN5SDLib7SDClass4openEPKch+0xc0>
    if ( ! file.open(root, filepath, mode)) {
   8ab5e:	68bb      	ldr	r3, [r7, #8]
   8ab60:	f103 0138 	add.w	r1, r3, #56	; 0x38
   8ab64:	78fb      	ldrb	r3, [r7, #3]
   8ab66:	f107 0014 	add.w	r0, r7, #20
   8ab6a:	687a      	ldr	r2, [r7, #4]
   8ab6c:	4c2d      	ldr	r4, [pc, #180]	; (8ac24 <_ZN5SDLib7SDClass4openEPKch+0x15c>)
   8ab6e:	47a0      	blx	r4
   8ab70:	4603      	mov	r3, r0
   8ab72:	2b00      	cmp	r3, #0
   8ab74:	bf0c      	ite	eq
   8ab76:	2301      	moveq	r3, #1
   8ab78:	2300      	movne	r3, #0
   8ab7a:	b2db      	uxtb	r3, r3
   8ab7c:	2b00      	cmp	r3, #0
   8ab7e:	d01c      	beq.n	8abba <_ZN5SDLib7SDClass4openEPKch+0xf2>
      // failed to open the file :(
      return File();
   8ab80:	68f8      	ldr	r0, [r7, #12]
   8ab82:	4b26      	ldr	r3, [pc, #152]	; (8ac1c <_ZN5SDLib7SDClass4openEPKch+0x154>)
   8ab84:	4798      	blx	r3
   8ab86:	e038      	b.n	8abfa <_ZN5SDLib7SDClass4openEPKch+0x132>
    }
    // dont close the root!
  } else {
    if ( ! file.open(parentdir, filepath, mode)) {
   8ab88:	78fb      	ldrb	r3, [r7, #3]
   8ab8a:	f107 013c 	add.w	r1, r7, #60	; 0x3c
   8ab8e:	f107 0014 	add.w	r0, r7, #20
   8ab92:	687a      	ldr	r2, [r7, #4]
   8ab94:	4c23      	ldr	r4, [pc, #140]	; (8ac24 <_ZN5SDLib7SDClass4openEPKch+0x15c>)
   8ab96:	47a0      	blx	r4
   8ab98:	4603      	mov	r3, r0
   8ab9a:	2b00      	cmp	r3, #0
   8ab9c:	bf0c      	ite	eq
   8ab9e:	2301      	moveq	r3, #1
   8aba0:	2300      	movne	r3, #0
   8aba2:	b2db      	uxtb	r3, r3
   8aba4:	2b00      	cmp	r3, #0
   8aba6:	d003      	beq.n	8abb0 <_ZN5SDLib7SDClass4openEPKch+0xe8>
      return File();
   8aba8:	68f8      	ldr	r0, [r7, #12]
   8abaa:	4b1c      	ldr	r3, [pc, #112]	; (8ac1c <_ZN5SDLib7SDClass4openEPKch+0x154>)
   8abac:	4798      	blx	r3
   8abae:	e024      	b.n	8abfa <_ZN5SDLib7SDClass4openEPKch+0x132>
    }
    // close the parent
    parentdir.close();
   8abb0:	f107 033c 	add.w	r3, r7, #60	; 0x3c
   8abb4:	4618      	mov	r0, r3
   8abb6:	4b1c      	ldr	r3, [pc, #112]	; (8ac28 <_ZN5SDLib7SDClass4openEPKch+0x160>)
   8abb8:	4798      	blx	r3
  }

  if (mode & (O_APPEND | O_WRITE)) 
   8abba:	78fb      	ldrb	r3, [r7, #3]
   8abbc:	f003 0306 	and.w	r3, r3, #6
   8abc0:	2b00      	cmp	r3, #0
   8abc2:	d00b      	beq.n	8abdc <_ZN5SDLib7SDClass4openEPKch+0x114>
    file.seekSet(file.fileSize());
   8abc4:	f107 0314 	add.w	r3, r7, #20
   8abc8:	4618      	mov	r0, r3
   8abca:	4b18      	ldr	r3, [pc, #96]	; (8ac2c <_ZN5SDLib7SDClass4openEPKch+0x164>)
   8abcc:	4798      	blx	r3
   8abce:	4602      	mov	r2, r0
   8abd0:	f107 0314 	add.w	r3, r7, #20
   8abd4:	4611      	mov	r1, r2
   8abd6:	4618      	mov	r0, r3
   8abd8:	4b15      	ldr	r3, [pc, #84]	; (8ac30 <_ZN5SDLib7SDClass4openEPKch+0x168>)
   8abda:	4798      	blx	r3
  return File(file, filepath);
   8abdc:	f107 0214 	add.w	r2, r7, #20
   8abe0:	f107 0390 	add.w	r3, r7, #144	; 0x90
   8abe4:	4611      	mov	r1, r2
   8abe6:	4618      	mov	r0, r3
   8abe8:	4b07      	ldr	r3, [pc, #28]	; (8ac08 <_ZN5SDLib7SDClass4openEPKch+0x140>)
   8abea:	4798      	blx	r3
   8abec:	f107 0390 	add.w	r3, r7, #144	; 0x90
   8abf0:	687a      	ldr	r2, [r7, #4]
   8abf2:	4619      	mov	r1, r3
   8abf4:	68f8      	ldr	r0, [r7, #12]
   8abf6:	4b06      	ldr	r3, [pc, #24]	; (8ac10 <_ZN5SDLib7SDClass4openEPKch+0x148>)
   8abf8:	4798      	blx	r3
}
   8abfa:	68f8      	ldr	r0, [r7, #12]
   8abfc:	37bc      	adds	r7, #188	; 0xbc
   8abfe:	46bd      	mov	sp, r7
   8ac00:	bd90      	pop	{r4, r7, pc}
   8ac02:	bf00      	nop
   8ac04:	0008a98d 	.word	0x0008a98d
   8ac08:	0008a915 	.word	0x0008a915
   8ac0c:	0009ae58 	.word	0x0009ae58
   8ac10:	0008a41d 	.word	0x0008a41d
   8ac14:	0008a74d 	.word	0x0008a74d
   8ac18:	0008a3a1 	.word	0x0008a3a1
   8ac1c:	0008a48d 	.word	0x0008a48d
   8ac20:	0008a77d 	.word	0x0008a77d
   8ac24:	0008a7c5 	.word	0x0008a7c5
   8ac28:	0008bc29 	.word	0x0008bc29
   8ac2c:	0008a369 	.word	0x0008a369
   8ac30:	0008c429 	.word	0x0008c429

0008ac34 <_ZN5SDLib7SDClassC1Ev>:
  void rewindDirectory(void);
  
  using Print::write;
};

class SDClass {
   8ac34:	b580      	push	{r7, lr}
   8ac36:	b082      	sub	sp, #8
   8ac38:	af00      	add	r7, sp, #0
   8ac3a:	6078      	str	r0, [r7, #4]
   8ac3c:	687b      	ldr	r3, [r7, #4]
   8ac3e:	4618      	mov	r0, r3
   8ac40:	4b08      	ldr	r3, [pc, #32]	; (8ac64 <_ZN5SDLib7SDClassC1Ev+0x30>)
   8ac42:	4798      	blx	r3
   8ac44:	687b      	ldr	r3, [r7, #4]
   8ac46:	3310      	adds	r3, #16
   8ac48:	4618      	mov	r0, r3
   8ac4a:	4b07      	ldr	r3, [pc, #28]	; (8ac68 <_ZN5SDLib7SDClassC1Ev+0x34>)
   8ac4c:	4798      	blx	r3
   8ac4e:	687b      	ldr	r3, [r7, #4]
   8ac50:	3338      	adds	r3, #56	; 0x38
   8ac52:	4618      	mov	r0, r3
   8ac54:	4b05      	ldr	r3, [pc, #20]	; (8ac6c <_ZN5SDLib7SDClassC1Ev+0x38>)
   8ac56:	4798      	blx	r3
   8ac58:	687b      	ldr	r3, [r7, #4]
   8ac5a:	4618      	mov	r0, r3
   8ac5c:	3708      	adds	r7, #8
   8ac5e:	46bd      	mov	sp, r7
   8ac60:	bd80      	pop	{r7, pc}
   8ac62:	bf00      	nop
   8ac64:	0008a721 	.word	0x0008a721
   8ac68:	0008a80d 	.word	0x0008a80d
   8ac6c:	0008a74d 	.word	0x0008a74d

0008ac70 <_Z41__static_initialization_and_destruction_0ii>:
    _file->rewind();
}

SDClass SD;

};
   8ac70:	b580      	push	{r7, lr}
   8ac72:	b082      	sub	sp, #8
   8ac74:	af00      	add	r7, sp, #0
   8ac76:	6078      	str	r0, [r7, #4]
   8ac78:	6039      	str	r1, [r7, #0]
   8ac7a:	687b      	ldr	r3, [r7, #4]
   8ac7c:	2b01      	cmp	r3, #1
   8ac7e:	d107      	bne.n	8ac90 <_Z41__static_initialization_and_destruction_0ii+0x20>
   8ac80:	683b      	ldr	r3, [r7, #0]
   8ac82:	f64f 72ff 	movw	r2, #65535	; 0xffff
   8ac86:	4293      	cmp	r3, r2
   8ac88:	d102      	bne.n	8ac90 <_Z41__static_initialization_and_destruction_0ii+0x20>
void File::rewindDirectory(void) {  
  if (isDirectory())
    _file->rewind();
}

SDClass SD;
   8ac8a:	4803      	ldr	r0, [pc, #12]	; (8ac98 <_Z41__static_initialization_and_destruction_0ii+0x28>)
   8ac8c:	4b03      	ldr	r3, [pc, #12]	; (8ac9c <_Z41__static_initialization_and_destruction_0ii+0x2c>)
   8ac8e:	4798      	blx	r3

};
   8ac90:	bf00      	nop
   8ac92:	3708      	adds	r7, #8
   8ac94:	46bd      	mov	sp, r7
   8ac96:	bd80      	pop	{r7, pc}
   8ac98:	200718a8 	.word	0x200718a8
   8ac9c:	0008ac35 	.word	0x0008ac35

0008aca0 <_GLOBAL__sub_I__ZN5SDLib20getNextPathComponentEPKcPjPc>:
   8aca0:	b580      	push	{r7, lr}
   8aca2:	af00      	add	r7, sp, #0
   8aca4:	f64f 71ff 	movw	r1, #65535	; 0xffff
   8aca8:	2001      	movs	r0, #1
   8acaa:	4b01      	ldr	r3, [pc, #4]	; (8acb0 <_GLOBAL__sub_I__ZN5SDLib20getNextPathComponentEPKcPjPc+0x10>)
   8acac:	4798      	blx	r3
   8acae:	bd80      	pop	{r7, pc}
   8acb0:	0008ac71 	.word	0x0008ac71

0008acb4 <_ZNK7Sd2Card4typeEv>:
    return readRegister(CMD9, csd);
  }
  void readEnd(void);
  uint8_t setSckRate(uint8_t sckRateID);
  /** Return the card type: SD V1, SD V2 or SDHC */
  uint8_t type(void) const {return type_;}
   8acb4:	b480      	push	{r7}
   8acb6:	b083      	sub	sp, #12
   8acb8:	af00      	add	r7, sp, #0
   8acba:	6078      	str	r0, [r7, #4]
   8acbc:	687b      	ldr	r3, [r7, #4]
   8acbe:	7b1b      	ldrb	r3, [r3, #12]
   8acc0:	4618      	mov	r0, r3
   8acc2:	370c      	adds	r7, #12
   8acc4:	46bd      	mov	sp, r7
   8acc6:	bc80      	pop	{r7}
   8acc8:	4770      	bx	lr
   8acca:	bf00      	nop

0008accc <_ZN7Sd2Card8cardAcmdEhm>:
  uint16_t offset_;
  uint8_t partialBlockRead_;
  uint8_t status_;
  uint8_t type_;
  // private functions
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
   8accc:	b580      	push	{r7, lr}
   8acce:	b084      	sub	sp, #16
   8acd0:	af00      	add	r7, sp, #0
   8acd2:	60f8      	str	r0, [r7, #12]
   8acd4:	460b      	mov	r3, r1
   8acd6:	607a      	str	r2, [r7, #4]
   8acd8:	72fb      	strb	r3, [r7, #11]
    cardCommand(CMD55, 0);
   8acda:	2200      	movs	r2, #0
   8acdc:	2137      	movs	r1, #55	; 0x37
   8acde:	68f8      	ldr	r0, [r7, #12]
   8ace0:	4b06      	ldr	r3, [pc, #24]	; (8acfc <_ZN7Sd2Card8cardAcmdEhm+0x30>)
   8ace2:	4798      	blx	r3
    return cardCommand(cmd, arg);
   8ace4:	7afb      	ldrb	r3, [r7, #11]
   8ace6:	687a      	ldr	r2, [r7, #4]
   8ace8:	4619      	mov	r1, r3
   8acea:	68f8      	ldr	r0, [r7, #12]
   8acec:	4b03      	ldr	r3, [pc, #12]	; (8acfc <_ZN7Sd2Card8cardAcmdEhm+0x30>)
   8acee:	4798      	blx	r3
   8acf0:	4603      	mov	r3, r0
  }
   8acf2:	4618      	mov	r0, r3
   8acf4:	3710      	adds	r7, #16
   8acf6:	46bd      	mov	sp, r7
   8acf8:	bd80      	pop	{r7, pc}
   8acfa:	bf00      	nop
   8acfc:	0008af09 	.word	0x0008af09

0008ad00 <_ZN7Sd2Card5errorEh>:
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  void error(uint8_t code) {errorCode_ = code;}
   8ad00:	b480      	push	{r7}
   8ad02:	b083      	sub	sp, #12
   8ad04:	af00      	add	r7, sp, #0
   8ad06:	6078      	str	r0, [r7, #4]
   8ad08:	460b      	mov	r3, r1
   8ad0a:	70fb      	strb	r3, [r7, #3]
   8ad0c:	687b      	ldr	r3, [r7, #4]
   8ad0e:	78fa      	ldrb	r2, [r7, #3]
   8ad10:	715a      	strb	r2, [r3, #5]
   8ad12:	bf00      	nop
   8ad14:	370c      	adds	r7, #12
   8ad16:	46bd      	mov	sp, r7
   8ad18:	bc80      	pop	{r7}
   8ad1a:	4770      	bx	lr

0008ad1c <_ZN7Sd2Card4typeEh>:
  uint8_t readRegister(uint8_t cmd, void* buf);
  uint8_t sendWriteCommand(uint32_t blockNumber, uint32_t eraseCount);
  void chipSelectHigh(void);
  void chipSelectLow(void);
  void type(uint8_t value) {type_ = value;}
   8ad1c:	b480      	push	{r7}
   8ad1e:	b083      	sub	sp, #12
   8ad20:	af00      	add	r7, sp, #0
   8ad22:	6078      	str	r0, [r7, #4]
   8ad24:	460b      	mov	r3, r1
   8ad26:	70fb      	strb	r3, [r7, #3]
   8ad28:	687b      	ldr	r3, [r7, #4]
   8ad2a:	78fa      	ldrb	r2, [r7, #3]
   8ad2c:	731a      	strb	r2, [r3, #12]
   8ad2e:	bf00      	nop
   8ad30:	370c      	adds	r7, #12
   8ad32:	46bd      	mov	sp, r7
   8ad34:	bc80      	pop	{r7}
   8ad36:	4770      	bx	lr

0008ad38 <_ZN11SPISettingsC1Em8BitOrderh>:
	SPI_LAST
};

class SPISettings {
public:
	SPISettings(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) {
   8ad38:	b590      	push	{r4, r7, lr}
   8ad3a:	b085      	sub	sp, #20
   8ad3c:	af00      	add	r7, sp, #0
   8ad3e:	60f8      	str	r0, [r7, #12]
   8ad40:	60b9      	str	r1, [r7, #8]
   8ad42:	4611      	mov	r1, r2
   8ad44:	461a      	mov	r2, r3
   8ad46:	460b      	mov	r3, r1
   8ad48:	71fb      	strb	r3, [r7, #7]
   8ad4a:	4613      	mov	r3, r2
   8ad4c:	71bb      	strb	r3, [r7, #6]
		if (__builtin_constant_p(clock)) {
			init_AlwaysInline(clock, bitOrder, dataMode);
		} else {
			init_MightInline(clock, bitOrder, dataMode);
   8ad4e:	79bb      	ldrb	r3, [r7, #6]
   8ad50:	79fa      	ldrb	r2, [r7, #7]
   8ad52:	68b9      	ldr	r1, [r7, #8]
   8ad54:	68f8      	ldr	r0, [r7, #12]
   8ad56:	4c03      	ldr	r4, [pc, #12]	; (8ad64 <_ZN11SPISettingsC1Em8BitOrderh+0x2c>)
   8ad58:	47a0      	blx	r4
		}
	}
   8ad5a:	68fb      	ldr	r3, [r7, #12]
   8ad5c:	4618      	mov	r0, r3
   8ad5e:	3714      	adds	r7, #20
   8ad60:	46bd      	mov	sp, r7
   8ad62:	bd90      	pop	{r4, r7, pc}
   8ad64:	0008ade9 	.word	0x0008ade9

0008ad68 <_ZN11SPISettingsC1Ev>:
	SPISettings() { init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0); }
   8ad68:	b480      	push	{r7}
   8ad6a:	b087      	sub	sp, #28
   8ad6c:	af00      	add	r7, sp, #0
   8ad6e:	6078      	str	r0, [r7, #4]
   8ad70:	687b      	ldr	r3, [r7, #4]
   8ad72:	617b      	str	r3, [r7, #20]
   8ad74:	4b18      	ldr	r3, [pc, #96]	; (8add8 <_ZN11SPISettingsC1Ev+0x70>)
   8ad76:	613b      	str	r3, [r7, #16]
   8ad78:	2301      	movs	r3, #1
   8ad7a:	73fb      	strb	r3, [r7, #15]
   8ad7c:	2302      	movs	r3, #2
   8ad7e:	73bb      	strb	r3, [r7, #14]
private:
	void init_MightInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) {
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) __attribute__((__always_inline__)) {
		border = bitOrder;
   8ad80:	697b      	ldr	r3, [r7, #20]
   8ad82:	7bfa      	ldrb	r2, [r7, #15]
   8ad84:	711a      	strb	r2, [r3, #4]
		uint8_t div;
		if (clock < (F_CPU / 255)) {
   8ad86:	693b      	ldr	r3, [r7, #16]
   8ad88:	4a14      	ldr	r2, [pc, #80]	; (8addc <_ZN11SPISettingsC1Ev+0x74>)
   8ad8a:	4293      	cmp	r3, r2
   8ad8c:	d802      	bhi.n	8ad94 <_ZN11SPISettingsC1Ev+0x2c>
			div = 255;
   8ad8e:	23ff      	movs	r3, #255	; 0xff
   8ad90:	737b      	strb	r3, [r7, #13]
   8ad92:	e00e      	b.n	8adb2 <_ZN11SPISettingsC1Ev+0x4a>
		} else if (clock >= (F_CPU / 2)) {
   8ad94:	693b      	ldr	r3, [r7, #16]
   8ad96:	4a12      	ldr	r2, [pc, #72]	; (8ade0 <_ZN11SPISettingsC1Ev+0x78>)
   8ad98:	4293      	cmp	r3, r2
   8ad9a:	d902      	bls.n	8ada2 <_ZN11SPISettingsC1Ev+0x3a>
			div = 2;
   8ad9c:	2302      	movs	r3, #2
   8ad9e:	737b      	strb	r3, [r7, #13]
   8ada0:	e007      	b.n	8adb2 <_ZN11SPISettingsC1Ev+0x4a>
		} else {
			div = (F_CPU / (clock + 1)) + 1;
   8ada2:	693b      	ldr	r3, [r7, #16]
   8ada4:	3301      	adds	r3, #1
   8ada6:	4a0f      	ldr	r2, [pc, #60]	; (8ade4 <_ZN11SPISettingsC1Ev+0x7c>)
   8ada8:	fbb2 f3f3 	udiv	r3, r2, r3
   8adac:	b2db      	uxtb	r3, r3
   8adae:	3301      	adds	r3, #1
   8adb0:	737b      	strb	r3, [r7, #13]
		}
		config = (dataMode & 3) | SPI_CSR_CSAAT | SPI_CSR_SCBR(div) | SPI_CSR_DLYBCT(1);
   8adb2:	7bbb      	ldrb	r3, [r7, #14]
   8adb4:	f003 0203 	and.w	r2, r3, #3
   8adb8:	7b7b      	ldrb	r3, [r7, #13]
   8adba:	021b      	lsls	r3, r3, #8
   8adbc:	b29b      	uxth	r3, r3
   8adbe:	4313      	orrs	r3, r2
   8adc0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   8adc4:	f043 0308 	orr.w	r3, r3, #8
   8adc8:	697a      	ldr	r2, [r7, #20]
   8adca:	6013      	str	r3, [r2, #0]
			init_AlwaysInline(clock, bitOrder, dataMode);
		} else {
			init_MightInline(clock, bitOrder, dataMode);
		}
	}
	SPISettings() { init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0); }
   8adcc:	687b      	ldr	r3, [r7, #4]
   8adce:	4618      	mov	r0, r3
   8add0:	371c      	adds	r7, #28
   8add2:	46bd      	mov	sp, r7
   8add4:	bc80      	pop	{r7}
   8add6:	4770      	bx	lr
   8add8:	003d0900 	.word	0x003d0900
   8addc:	000506c2 	.word	0x000506c2
   8ade0:	0280de7f 	.word	0x0280de7f
   8ade4:	0501bd00 	.word	0x0501bd00

0008ade8 <_ZN11SPISettings16init_MightInlineEm8BitOrderh>:
private:
	void init_MightInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) {
   8ade8:	b480      	push	{r7}
   8adea:	b089      	sub	sp, #36	; 0x24
   8adec:	af00      	add	r7, sp, #0
   8adee:	60f8      	str	r0, [r7, #12]
   8adf0:	60b9      	str	r1, [r7, #8]
   8adf2:	4611      	mov	r1, r2
   8adf4:	461a      	mov	r2, r3
   8adf6:	460b      	mov	r3, r1
   8adf8:	71fb      	strb	r3, [r7, #7]
   8adfa:	4613      	mov	r3, r2
   8adfc:	71bb      	strb	r3, [r7, #6]
   8adfe:	68fb      	ldr	r3, [r7, #12]
   8ae00:	61fb      	str	r3, [r7, #28]
   8ae02:	68bb      	ldr	r3, [r7, #8]
   8ae04:	61bb      	str	r3, [r7, #24]
   8ae06:	79fb      	ldrb	r3, [r7, #7]
   8ae08:	75fb      	strb	r3, [r7, #23]
   8ae0a:	79bb      	ldrb	r3, [r7, #6]
   8ae0c:	75bb      	strb	r3, [r7, #22]
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
	void init_AlwaysInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) __attribute__((__always_inline__)) {
		border = bitOrder;
   8ae0e:	69fb      	ldr	r3, [r7, #28]
   8ae10:	7dfa      	ldrb	r2, [r7, #23]
   8ae12:	711a      	strb	r2, [r3, #4]
		uint8_t div;
		if (clock < (F_CPU / 255)) {
   8ae14:	69bb      	ldr	r3, [r7, #24]
   8ae16:	4a13      	ldr	r2, [pc, #76]	; (8ae64 <_ZN11SPISettings16init_MightInlineEm8BitOrderh+0x7c>)
   8ae18:	4293      	cmp	r3, r2
   8ae1a:	d802      	bhi.n	8ae22 <_ZN11SPISettings16init_MightInlineEm8BitOrderh+0x3a>
			div = 255;
   8ae1c:	23ff      	movs	r3, #255	; 0xff
   8ae1e:	757b      	strb	r3, [r7, #21]
   8ae20:	e00e      	b.n	8ae40 <_ZN11SPISettings16init_MightInlineEm8BitOrderh+0x58>
		} else if (clock >= (F_CPU / 2)) {
   8ae22:	69bb      	ldr	r3, [r7, #24]
   8ae24:	4a10      	ldr	r2, [pc, #64]	; (8ae68 <_ZN11SPISettings16init_MightInlineEm8BitOrderh+0x80>)
   8ae26:	4293      	cmp	r3, r2
   8ae28:	d902      	bls.n	8ae30 <_ZN11SPISettings16init_MightInlineEm8BitOrderh+0x48>
			div = 2;
   8ae2a:	2302      	movs	r3, #2
   8ae2c:	757b      	strb	r3, [r7, #21]
   8ae2e:	e007      	b.n	8ae40 <_ZN11SPISettings16init_MightInlineEm8BitOrderh+0x58>
		} else {
			div = (F_CPU / (clock + 1)) + 1;
   8ae30:	69bb      	ldr	r3, [r7, #24]
   8ae32:	3301      	adds	r3, #1
   8ae34:	4a0d      	ldr	r2, [pc, #52]	; (8ae6c <_ZN11SPISettings16init_MightInlineEm8BitOrderh+0x84>)
   8ae36:	fbb2 f3f3 	udiv	r3, r2, r3
   8ae3a:	b2db      	uxtb	r3, r3
   8ae3c:	3301      	adds	r3, #1
   8ae3e:	757b      	strb	r3, [r7, #21]
		}
		config = (dataMode & 3) | SPI_CSR_CSAAT | SPI_CSR_SCBR(div) | SPI_CSR_DLYBCT(1);
   8ae40:	7dbb      	ldrb	r3, [r7, #22]
   8ae42:	f003 0203 	and.w	r2, r3, #3
   8ae46:	7d7b      	ldrb	r3, [r7, #21]
   8ae48:	021b      	lsls	r3, r3, #8
   8ae4a:	b29b      	uxth	r3, r3
   8ae4c:	4313      	orrs	r3, r2
   8ae4e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   8ae52:	f043 0308 	orr.w	r3, r3, #8
   8ae56:	69fa      	ldr	r2, [r7, #28]
   8ae58:	6013      	str	r3, [r2, #0]
	}
	SPISettings() { init_AlwaysInline(4000000, MSBFIRST, SPI_MODE0); }
private:
	void init_MightInline(uint32_t clock, BitOrder bitOrder, uint8_t dataMode) {
		init_AlwaysInline(clock, bitOrder, dataMode);
	}
   8ae5a:	bf00      	nop
   8ae5c:	3724      	adds	r7, #36	; 0x24
   8ae5e:	46bd      	mov	sp, r7
   8ae60:	bc80      	pop	{r7}
   8ae62:	4770      	bx	lr
   8ae64:	000506c2 	.word	0x000506c2
   8ae68:	0280de7f 	.word	0x0280de7f
   8ae6c:	0501bd00 	.word	0x0501bd00

0008ae70 <_ZN8SPIClass8transferEh15SPITransferMode>:
	// Transfer functions
	byte transfer(byte _pin, uint8_t _data, SPITransferMode _mode = SPI_LAST);
	uint16_t transfer16(byte _pin, uint16_t _data, SPITransferMode _mode = SPI_LAST);
	void transfer(byte _pin, void *_buf, size_t _count, SPITransferMode _mode = SPI_LAST);
	// Transfer functions on default pin BOARD_SPI_DEFAULT_SS
	byte transfer(uint8_t _data, SPITransferMode _mode = SPI_LAST) { return transfer(BOARD_SPI_DEFAULT_SS, _data, _mode); }
   8ae70:	b590      	push	{r4, r7, lr}
   8ae72:	b083      	sub	sp, #12
   8ae74:	af00      	add	r7, sp, #0
   8ae76:	6078      	str	r0, [r7, #4]
   8ae78:	460b      	mov	r3, r1
   8ae7a:	70fb      	strb	r3, [r7, #3]
   8ae7c:	4613      	mov	r3, r2
   8ae7e:	70bb      	strb	r3, [r7, #2]
   8ae80:	78bb      	ldrb	r3, [r7, #2]
   8ae82:	78fa      	ldrb	r2, [r7, #3]
   8ae84:	214e      	movs	r1, #78	; 0x4e
   8ae86:	6878      	ldr	r0, [r7, #4]
   8ae88:	4c03      	ldr	r4, [pc, #12]	; (8ae98 <_ZN8SPIClass8transferEh15SPITransferMode+0x28>)
   8ae8a:	47a0      	blx	r4
   8ae8c:	4603      	mov	r3, r0
   8ae8e:	4618      	mov	r0, r3
   8ae90:	370c      	adds	r7, #12
   8ae92:	46bd      	mov	sp, r7
   8ae94:	bd90      	pop	{r4, r7, pc}
   8ae96:	bf00      	nop
   8ae98:	0009029d 	.word	0x0009029d

0008ae9c <_ZN8SPIClass16beginTransactionE11SPISettings>:
	uint16_t transfer16(uint16_t _data, SPITransferMode _mode = SPI_LAST) { return transfer16(BOARD_SPI_DEFAULT_SS, _data, _mode); }
	void transfer(void *_buf, size_t _count, SPITransferMode _mode = SPI_LAST) { transfer(BOARD_SPI_DEFAULT_SS, _buf, _count, _mode); }

	// Transaction Functions
	void usingInterrupt(uint8_t interruptNumber);
	void beginTransaction(SPISettings settings) { beginTransaction(BOARD_SPI_DEFAULT_SS, settings); }
   8ae9c:	b590      	push	{r4, r7, lr}
   8ae9e:	b085      	sub	sp, #20
   8aea0:	af00      	add	r7, sp, #0
   8aea2:	60f8      	str	r0, [r7, #12]
   8aea4:	1d3b      	adds	r3, r7, #4
   8aea6:	e883 0006 	stmia.w	r3, {r1, r2}
   8aeaa:	1d3b      	adds	r3, r7, #4
   8aeac:	cb0c      	ldmia	r3, {r2, r3}
   8aeae:	214e      	movs	r1, #78	; 0x4e
   8aeb0:	68f8      	ldr	r0, [r7, #12]
   8aeb2:	4c03      	ldr	r4, [pc, #12]	; (8aec0 <_ZN8SPIClass16beginTransactionE11SPISettings+0x24>)
   8aeb4:	47a0      	blx	r4
   8aeb6:	bf00      	nop
   8aeb8:	3714      	adds	r7, #20
   8aeba:	46bd      	mov	sp, r7
   8aebc:	bd90      	pop	{r4, r7, pc}
   8aebe:	bf00      	nop
   8aec0:	0008ffd1 	.word	0x0008ffd1

0008aec4 <_ZL7spiSendh>:
#include "../SPIArduino.h"
static SPISettings settings;
#endif
// functions for hardware SPI
/** Send a byte to the card */
static void spiSend(uint8_t b) {
   8aec4:	b580      	push	{r7, lr}
   8aec6:	b082      	sub	sp, #8
   8aec8:	af00      	add	r7, sp, #0
   8aeca:	4603      	mov	r3, r0
   8aecc:	71fb      	strb	r3, [r7, #7]
#ifndef USE_SPI_LIB
  SPDR = b;
  while (!(SPSR & (1 << SPIF)))
    ;
#else
  SPI.transfer(b);
   8aece:	79fb      	ldrb	r3, [r7, #7]
   8aed0:	2201      	movs	r2, #1
   8aed2:	4619      	mov	r1, r3
   8aed4:	4803      	ldr	r0, [pc, #12]	; (8aee4 <_ZL7spiSendh+0x20>)
   8aed6:	4b04      	ldr	r3, [pc, #16]	; (8aee8 <_ZL7spiSendh+0x24>)
   8aed8:	4798      	blx	r3
#endif
}
   8aeda:	bf00      	nop
   8aedc:	3708      	adds	r7, #8
   8aede:	46bd      	mov	sp, r7
   8aee0:	bd80      	pop	{r7, pc}
   8aee2:	bf00      	nop
   8aee4:	20071c78 	.word	0x20071c78
   8aee8:	0008ae71 	.word	0x0008ae71

0008aeec <_ZL6spiRecv>:
/** Receive a byte from the card */
static  uint8_t spiRec(void) {
   8aeec:	b580      	push	{r7, lr}
   8aeee:	af00      	add	r7, sp, #0
#ifndef USE_SPI_LIB
  spiSend(0XFF);
  return SPDR;
#else
  return SPI.transfer(0xFF);
   8aef0:	2201      	movs	r2, #1
   8aef2:	21ff      	movs	r1, #255	; 0xff
   8aef4:	4802      	ldr	r0, [pc, #8]	; (8af00 <_ZL6spiRecv+0x14>)
   8aef6:	4b03      	ldr	r3, [pc, #12]	; (8af04 <_ZL6spiRecv+0x18>)
   8aef8:	4798      	blx	r3
   8aefa:	4603      	mov	r3, r0
#endif
}
   8aefc:	4618      	mov	r0, r3
   8aefe:	bd80      	pop	{r7, pc}
   8af00:	20071c78 	.word	0x20071c78
   8af04:	0008ae71 	.word	0x0008ae71

0008af08 <_ZN7Sd2Card11cardCommandEhm>:
  sei();
}
#endif  // SOFTWARE_SPI
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
   8af08:	b580      	push	{r7, lr}
   8af0a:	b086      	sub	sp, #24
   8af0c:	af00      	add	r7, sp, #0
   8af0e:	60f8      	str	r0, [r7, #12]
   8af10:	460b      	mov	r3, r1
   8af12:	607a      	str	r2, [r7, #4]
   8af14:	72fb      	strb	r3, [r7, #11]
  // end read if in partialBlockRead mode
  readEnd();
   8af16:	68f8      	ldr	r0, [r7, #12]
   8af18:	4b29      	ldr	r3, [pc, #164]	; (8afc0 <_ZN7Sd2Card11cardCommandEhm+0xb8>)
   8af1a:	4798      	blx	r3

  // select card
  chipSelectLow();
   8af1c:	68f8      	ldr	r0, [r7, #12]
   8af1e:	4b29      	ldr	r3, [pc, #164]	; (8afc4 <_ZN7Sd2Card11cardCommandEhm+0xbc>)
   8af20:	4798      	blx	r3

  // wait up to 300 ms if busy
  waitNotBusy(300);
   8af22:	f44f 7196 	mov.w	r1, #300	; 0x12c
   8af26:	68f8      	ldr	r0, [r7, #12]
   8af28:	4b27      	ldr	r3, [pc, #156]	; (8afc8 <_ZN7Sd2Card11cardCommandEhm+0xc0>)
   8af2a:	4798      	blx	r3

  // send command
  spiSend(cmd | 0x40);
   8af2c:	7afb      	ldrb	r3, [r7, #11]
   8af2e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   8af32:	b2db      	uxtb	r3, r3
   8af34:	4618      	mov	r0, r3
   8af36:	4b25      	ldr	r3, [pc, #148]	; (8afcc <_ZN7Sd2Card11cardCommandEhm+0xc4>)
   8af38:	4798      	blx	r3

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
   8af3a:	2318      	movs	r3, #24
   8af3c:	75fb      	strb	r3, [r7, #23]
   8af3e:	f997 3017 	ldrsb.w	r3, [r7, #23]
   8af42:	2b00      	cmp	r3, #0
   8af44:	db0d      	blt.n	8af62 <_ZN7Sd2Card11cardCommandEhm+0x5a>
   8af46:	f997 3017 	ldrsb.w	r3, [r7, #23]
   8af4a:	687a      	ldr	r2, [r7, #4]
   8af4c:	fa22 f303 	lsr.w	r3, r2, r3
   8af50:	b2db      	uxtb	r3, r3
   8af52:	4618      	mov	r0, r3
   8af54:	4b1d      	ldr	r3, [pc, #116]	; (8afcc <_ZN7Sd2Card11cardCommandEhm+0xc4>)
   8af56:	4798      	blx	r3
   8af58:	7dfb      	ldrb	r3, [r7, #23]
   8af5a:	3b08      	subs	r3, #8
   8af5c:	b2db      	uxtb	r3, r3
   8af5e:	75fb      	strb	r3, [r7, #23]
   8af60:	e7ed      	b.n	8af3e <_ZN7Sd2Card11cardCommandEhm+0x36>

  // send CRC
  uint8_t crc = 0XFF;
   8af62:	23ff      	movs	r3, #255	; 0xff
   8af64:	75bb      	strb	r3, [r7, #22]
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
   8af66:	7afb      	ldrb	r3, [r7, #11]
   8af68:	2b00      	cmp	r3, #0
   8af6a:	d101      	bne.n	8af70 <_ZN7Sd2Card11cardCommandEhm+0x68>
   8af6c:	2395      	movs	r3, #149	; 0x95
   8af6e:	75bb      	strb	r3, [r7, #22]
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
   8af70:	7afb      	ldrb	r3, [r7, #11]
   8af72:	2b08      	cmp	r3, #8
   8af74:	d101      	bne.n	8af7a <_ZN7Sd2Card11cardCommandEhm+0x72>
   8af76:	2387      	movs	r3, #135	; 0x87
   8af78:	75bb      	strb	r3, [r7, #22]
  spiSend(crc);
   8af7a:	7dbb      	ldrb	r3, [r7, #22]
   8af7c:	4618      	mov	r0, r3
   8af7e:	4b13      	ldr	r3, [pc, #76]	; (8afcc <_ZN7Sd2Card11cardCommandEhm+0xc4>)
   8af80:	4798      	blx	r3

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++)
   8af82:	2300      	movs	r3, #0
   8af84:	757b      	strb	r3, [r7, #21]
   8af86:	4b12      	ldr	r3, [pc, #72]	; (8afd0 <_ZN7Sd2Card11cardCommandEhm+0xc8>)
   8af88:	4798      	blx	r3
   8af8a:	4603      	mov	r3, r0
   8af8c:	461a      	mov	r2, r3
   8af8e:	68fb      	ldr	r3, [r7, #12]
   8af90:	72da      	strb	r2, [r3, #11]
   8af92:	68fb      	ldr	r3, [r7, #12]
   8af94:	7adb      	ldrb	r3, [r3, #11]
   8af96:	b25b      	sxtb	r3, r3
   8af98:	2b00      	cmp	r3, #0
   8af9a:	da04      	bge.n	8afa6 <_ZN7Sd2Card11cardCommandEhm+0x9e>
   8af9c:	7d7b      	ldrb	r3, [r7, #21]
   8af9e:	2bff      	cmp	r3, #255	; 0xff
   8afa0:	d001      	beq.n	8afa6 <_ZN7Sd2Card11cardCommandEhm+0x9e>
   8afa2:	2301      	movs	r3, #1
   8afa4:	e000      	b.n	8afa8 <_ZN7Sd2Card11cardCommandEhm+0xa0>
   8afa6:	2300      	movs	r3, #0
   8afa8:	2b00      	cmp	r3, #0
   8afaa:	d003      	beq.n	8afb4 <_ZN7Sd2Card11cardCommandEhm+0xac>
   8afac:	7d7b      	ldrb	r3, [r7, #21]
   8afae:	3301      	adds	r3, #1
   8afb0:	757b      	strb	r3, [r7, #21]
   8afb2:	e7e8      	b.n	8af86 <_ZN7Sd2Card11cardCommandEhm+0x7e>
    ;
  return status_;
   8afb4:	68fb      	ldr	r3, [r7, #12]
   8afb6:	7adb      	ldrb	r3, [r3, #11]
}
   8afb8:	4618      	mov	r0, r3
   8afba:	3718      	adds	r7, #24
   8afbc:	46bd      	mov	sp, r7
   8afbe:	bd80      	pop	{r7, pc}
   8afc0:	0008b475 	.word	0x0008b475
   8afc4:	0008b015 	.word	0x0008b015
   8afc8:	0008b619 	.word	0x0008b619
   8afcc:	0008aec5 	.word	0x0008aec5
   8afd0:	0008aeed 	.word	0x0008aeed

0008afd4 <_ZN7Sd2Card14chipSelectHighEv>:
  }
}
//------------------------------------------------------------------------------
static uint8_t chip_select_asserted = 0;

void Sd2Card::chipSelectHigh(void) {
   8afd4:	b580      	push	{r7, lr}
   8afd6:	b082      	sub	sp, #8
   8afd8:	af00      	add	r7, sp, #0
   8afda:	6078      	str	r0, [r7, #4]
  digitalWrite(chipSelectPin_, HIGH);
   8afdc:	687b      	ldr	r3, [r7, #4]
   8afde:	791b      	ldrb	r3, [r3, #4]
   8afe0:	2101      	movs	r1, #1
   8afe2:	4618      	mov	r0, r3
   8afe4:	4b07      	ldr	r3, [pc, #28]	; (8b004 <_ZN7Sd2Card14chipSelectHighEv+0x30>)
   8afe6:	4798      	blx	r3
#ifdef USE_SPI_LIB
  if (chip_select_asserted) {
   8afe8:	4b07      	ldr	r3, [pc, #28]	; (8b008 <_ZN7Sd2Card14chipSelectHighEv+0x34>)
   8afea:	781b      	ldrb	r3, [r3, #0]
   8afec:	2b00      	cmp	r3, #0
   8afee:	d005      	beq.n	8affc <_ZN7Sd2Card14chipSelectHighEv+0x28>
    chip_select_asserted = 0;
   8aff0:	4b05      	ldr	r3, [pc, #20]	; (8b008 <_ZN7Sd2Card14chipSelectHighEv+0x34>)
   8aff2:	2200      	movs	r2, #0
   8aff4:	701a      	strb	r2, [r3, #0]
    SPI.endTransaction();
   8aff6:	4805      	ldr	r0, [pc, #20]	; (8b00c <_ZN7Sd2Card14chipSelectHighEv+0x38>)
   8aff8:	4b05      	ldr	r3, [pc, #20]	; (8b010 <_ZN7Sd2Card14chipSelectHighEv+0x3c>)
   8affa:	4798      	blx	r3
  }
#endif
}
   8affc:	bf00      	nop
   8affe:	3708      	adds	r7, #8
   8b000:	46bd      	mov	sp, r7
   8b002:	bd80      	pop	{r7, pc}
   8b004:	00081f29 	.word	0x00081f29
   8b008:	20071914 	.word	0x20071914
   8b00c:	20071c78 	.word	0x20071c78
   8b010:	000900c9 	.word	0x000900c9

0008b014 <_ZN7Sd2Card13chipSelectLowEv>:
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
   8b014:	b580      	push	{r7, lr}
   8b016:	b082      	sub	sp, #8
   8b018:	af00      	add	r7, sp, #0
   8b01a:	6078      	str	r0, [r7, #4]
#ifdef USE_SPI_LIB
  if (!chip_select_asserted) {
   8b01c:	4b0b      	ldr	r3, [pc, #44]	; (8b04c <_ZN7Sd2Card13chipSelectLowEv+0x38>)
   8b01e:	781b      	ldrb	r3, [r3, #0]
   8b020:	2b00      	cmp	r3, #0
   8b022:	d108      	bne.n	8b036 <_ZN7Sd2Card13chipSelectLowEv+0x22>
    chip_select_asserted = 1;
   8b024:	4b09      	ldr	r3, [pc, #36]	; (8b04c <_ZN7Sd2Card13chipSelectLowEv+0x38>)
   8b026:	2201      	movs	r2, #1
   8b028:	701a      	strb	r2, [r3, #0]
    SPI.beginTransaction(settings);
   8b02a:	4b09      	ldr	r3, [pc, #36]	; (8b050 <_ZN7Sd2Card13chipSelectLowEv+0x3c>)
   8b02c:	e893 0006 	ldmia.w	r3, {r1, r2}
   8b030:	4808      	ldr	r0, [pc, #32]	; (8b054 <_ZN7Sd2Card13chipSelectLowEv+0x40>)
   8b032:	4b09      	ldr	r3, [pc, #36]	; (8b058 <_ZN7Sd2Card13chipSelectLowEv+0x44>)
   8b034:	4798      	blx	r3
  }
#endif
  digitalWrite(chipSelectPin_, LOW);
   8b036:	687b      	ldr	r3, [r7, #4]
   8b038:	791b      	ldrb	r3, [r3, #4]
   8b03a:	2100      	movs	r1, #0
   8b03c:	4618      	mov	r0, r3
   8b03e:	4b07      	ldr	r3, [pc, #28]	; (8b05c <_ZN7Sd2Card13chipSelectLowEv+0x48>)
   8b040:	4798      	blx	r3
}
   8b042:	bf00      	nop
   8b044:	3708      	adds	r7, #8
   8b046:	46bd      	mov	sp, r7
   8b048:	bd80      	pop	{r7, pc}
   8b04a:	bf00      	nop
   8b04c:	20071914 	.word	0x20071914
   8b050:	2007190c 	.word	0x2007190c
   8b054:	20071c78 	.word	0x20071c78
   8b058:	0008ae9d 	.word	0x0008ae9d
   8b05c:	00081f29 	.word	0x00081f29

0008b060 <_ZN7Sd2Card4initEhh>:
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  The reason for failure
 * can be determined by calling errorCode() and errorData().
 */
uint8_t Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {
   8b060:	b590      	push	{r4, r7, lr}
   8b062:	b089      	sub	sp, #36	; 0x24
   8b064:	af00      	add	r7, sp, #0
   8b066:	6078      	str	r0, [r7, #4]
   8b068:	460b      	mov	r3, r1
   8b06a:	70fb      	strb	r3, [r7, #3]
   8b06c:	4613      	mov	r3, r2
   8b06e:	70bb      	strb	r3, [r7, #2]
  errorCode_ = inBlock_ = partialBlockRead_ = type_ = 0;
   8b070:	687b      	ldr	r3, [r7, #4]
   8b072:	2200      	movs	r2, #0
   8b074:	731a      	strb	r2, [r3, #12]
   8b076:	687b      	ldr	r3, [r7, #4]
   8b078:	7b1a      	ldrb	r2, [r3, #12]
   8b07a:	687b      	ldr	r3, [r7, #4]
   8b07c:	729a      	strb	r2, [r3, #10]
   8b07e:	687b      	ldr	r3, [r7, #4]
   8b080:	7a9a      	ldrb	r2, [r3, #10]
   8b082:	687b      	ldr	r3, [r7, #4]
   8b084:	719a      	strb	r2, [r3, #6]
   8b086:	687b      	ldr	r3, [r7, #4]
   8b088:	799a      	ldrb	r2, [r3, #6]
   8b08a:	687b      	ldr	r3, [r7, #4]
   8b08c:	715a      	strb	r2, [r3, #5]
  chipSelectPin_ = chipSelectPin;
   8b08e:	687b      	ldr	r3, [r7, #4]
   8b090:	78ba      	ldrb	r2, [r7, #2]
   8b092:	711a      	strb	r2, [r3, #4]
  // 16-bit init start time allows over a minute
  uint16_t t0 = (uint16_t)millis();
   8b094:	4b85      	ldr	r3, [pc, #532]	; (8b2ac <_ZN7Sd2Card4initEhh+0x24c>)
   8b096:	4798      	blx	r3
   8b098:	4603      	mov	r3, r0
   8b09a:	837b      	strh	r3, [r7, #26]
  uint32_t arg;

  // set pin modes
  pinMode(chipSelectPin_, OUTPUT);
   8b09c:	687b      	ldr	r3, [r7, #4]
   8b09e:	791b      	ldrb	r3, [r3, #4]
   8b0a0:	2101      	movs	r1, #1
   8b0a2:	4618      	mov	r0, r3
   8b0a4:	4b82      	ldr	r3, [pc, #520]	; (8b2b0 <_ZN7Sd2Card4initEhh+0x250>)
   8b0a6:	4798      	blx	r3
  digitalWrite(chipSelectPin_, HIGH);
   8b0a8:	687b      	ldr	r3, [r7, #4]
   8b0aa:	791b      	ldrb	r3, [r3, #4]
   8b0ac:	2101      	movs	r1, #1
   8b0ae:	4618      	mov	r0, r3
   8b0b0:	4b80      	ldr	r3, [pc, #512]	; (8b2b4 <_ZN7Sd2Card4initEhh+0x254>)
   8b0b2:	4798      	blx	r3
  // Enable SPI, Master, clock rate f_osc/128
  SPCR = (1 << SPE) | (1 << MSTR) | (1 << SPR1) | (1 << SPR0);
  // clear double speed
  SPSR &= ~(1 << SPI2X);
#else // USE_SPI_LIB
  SPI.begin();
   8b0b4:	4880      	ldr	r0, [pc, #512]	; (8b2b8 <_ZN7Sd2Card4initEhh+0x258>)
   8b0b6:	4b81      	ldr	r3, [pc, #516]	; (8b2bc <_ZN7Sd2Card4initEhh+0x25c>)
   8b0b8:	4798      	blx	r3
  settings = SPISettings(250000, MSBFIRST, SPI_MODE0);
   8b0ba:	f107 000c 	add.w	r0, r7, #12
   8b0be:	2302      	movs	r3, #2
   8b0c0:	2201      	movs	r2, #1
   8b0c2:	497f      	ldr	r1, [pc, #508]	; (8b2c0 <_ZN7Sd2Card4initEhh+0x260>)
   8b0c4:	4c7f      	ldr	r4, [pc, #508]	; (8b2c4 <_ZN7Sd2Card4initEhh+0x264>)
   8b0c6:	47a0      	blx	r4
   8b0c8:	4b7f      	ldr	r3, [pc, #508]	; (8b2c8 <_ZN7Sd2Card4initEhh+0x268>)
   8b0ca:	f107 020c 	add.w	r2, r7, #12
   8b0ce:	e892 0003 	ldmia.w	r2, {r0, r1}
   8b0d2:	6018      	str	r0, [r3, #0]
   8b0d4:	3304      	adds	r3, #4
   8b0d6:	7019      	strb	r1, [r3, #0]
#endif // USE_SPI_LIB
#endif // SOFTWARE_SPI

  // must supply min of 74 clock cycles with CS high.
#ifdef USE_SPI_LIB
  SPI.beginTransaction(settings);
   8b0d8:	4b7b      	ldr	r3, [pc, #492]	; (8b2c8 <_ZN7Sd2Card4initEhh+0x268>)
   8b0da:	e893 0006 	ldmia.w	r3, {r1, r2}
   8b0de:	4876      	ldr	r0, [pc, #472]	; (8b2b8 <_ZN7Sd2Card4initEhh+0x258>)
   8b0e0:	4b7a      	ldr	r3, [pc, #488]	; (8b2cc <_ZN7Sd2Card4initEhh+0x26c>)
   8b0e2:	4798      	blx	r3
#endif
  for (uint8_t i = 0; i < 10; i++) spiSend(0XFF);
   8b0e4:	2300      	movs	r3, #0
   8b0e6:	77fb      	strb	r3, [r7, #31]
   8b0e8:	7ffb      	ldrb	r3, [r7, #31]
   8b0ea:	2b09      	cmp	r3, #9
   8b0ec:	d806      	bhi.n	8b0fc <_ZN7Sd2Card4initEhh+0x9c>
   8b0ee:	20ff      	movs	r0, #255	; 0xff
   8b0f0:	4b77      	ldr	r3, [pc, #476]	; (8b2d0 <_ZN7Sd2Card4initEhh+0x270>)
   8b0f2:	4798      	blx	r3
   8b0f4:	7ffb      	ldrb	r3, [r7, #31]
   8b0f6:	3301      	adds	r3, #1
   8b0f8:	77fb      	strb	r3, [r7, #31]
   8b0fa:	e7f5      	b.n	8b0e8 <_ZN7Sd2Card4initEhh+0x88>
#ifdef USE_SPI_LIB
  SPI.endTransaction();
   8b0fc:	486e      	ldr	r0, [pc, #440]	; (8b2b8 <_ZN7Sd2Card4initEhh+0x258>)
   8b0fe:	4b75      	ldr	r3, [pc, #468]	; (8b2d4 <_ZN7Sd2Card4initEhh+0x274>)
   8b100:	4798      	blx	r3
#endif

  chipSelectLow();
   8b102:	6878      	ldr	r0, [r7, #4]
   8b104:	4b74      	ldr	r3, [pc, #464]	; (8b2d8 <_ZN7Sd2Card4initEhh+0x278>)
   8b106:	4798      	blx	r3

  // command to go idle in SPI mode
  while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {
   8b108:	2200      	movs	r2, #0
   8b10a:	2100      	movs	r1, #0
   8b10c:	6878      	ldr	r0, [r7, #4]
   8b10e:	4b73      	ldr	r3, [pc, #460]	; (8b2dc <_ZN7Sd2Card4initEhh+0x27c>)
   8b110:	4798      	blx	r3
   8b112:	4603      	mov	r3, r0
   8b114:	461a      	mov	r2, r3
   8b116:	687b      	ldr	r3, [r7, #4]
   8b118:	72da      	strb	r2, [r3, #11]
   8b11a:	687b      	ldr	r3, [r7, #4]
   8b11c:	7adb      	ldrb	r3, [r3, #11]
   8b11e:	2b01      	cmp	r3, #1
   8b120:	bf14      	ite	ne
   8b122:	2301      	movne	r3, #1
   8b124:	2300      	moveq	r3, #0
   8b126:	b2db      	uxtb	r3, r3
   8b128:	2b00      	cmp	r3, #0
   8b12a:	d013      	beq.n	8b154 <_ZN7Sd2Card4initEhh+0xf4>
    if (((uint16_t)(millis() - t0)) > SD_INIT_TIMEOUT) {
   8b12c:	4b5f      	ldr	r3, [pc, #380]	; (8b2ac <_ZN7Sd2Card4initEhh+0x24c>)
   8b12e:	4798      	blx	r3
   8b130:	4603      	mov	r3, r0
   8b132:	b29a      	uxth	r2, r3
   8b134:	8b7b      	ldrh	r3, [r7, #26]
   8b136:	1ad3      	subs	r3, r2, r3
   8b138:	b29b      	uxth	r3, r3
   8b13a:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
   8b13e:	bf8c      	ite	hi
   8b140:	2301      	movhi	r3, #1
   8b142:	2300      	movls	r3, #0
   8b144:	b2db      	uxtb	r3, r3
   8b146:	2b00      	cmp	r3, #0
   8b148:	d0de      	beq.n	8b108 <_ZN7Sd2Card4initEhh+0xa8>
      error(SD_CARD_ERROR_CMD0);
   8b14a:	2101      	movs	r1, #1
   8b14c:	6878      	ldr	r0, [r7, #4]
   8b14e:	4b64      	ldr	r3, [pc, #400]	; (8b2e0 <_ZN7Sd2Card4initEhh+0x280>)
   8b150:	4798      	blx	r3
      goto fail;
   8b152:	e0a3      	b.n	8b29c <_ZN7Sd2Card4initEhh+0x23c>
    }
  }
  // check SD version
  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {
   8b154:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
   8b158:	2108      	movs	r1, #8
   8b15a:	6878      	ldr	r0, [r7, #4]
   8b15c:	4b5f      	ldr	r3, [pc, #380]	; (8b2dc <_ZN7Sd2Card4initEhh+0x27c>)
   8b15e:	4798      	blx	r3
   8b160:	4603      	mov	r3, r0
   8b162:	f003 0304 	and.w	r3, r3, #4
   8b166:	2b00      	cmp	r3, #0
   8b168:	bf14      	ite	ne
   8b16a:	2301      	movne	r3, #1
   8b16c:	2300      	moveq	r3, #0
   8b16e:	b2db      	uxtb	r3, r3
   8b170:	2b00      	cmp	r3, #0
   8b172:	d004      	beq.n	8b17e <_ZN7Sd2Card4initEhh+0x11e>
    type(SD_CARD_TYPE_SD1);
   8b174:	2101      	movs	r1, #1
   8b176:	6878      	ldr	r0, [r7, #4]
   8b178:	4b5a      	ldr	r3, [pc, #360]	; (8b2e4 <_ZN7Sd2Card4initEhh+0x284>)
   8b17a:	4798      	blx	r3
   8b17c:	e01b      	b.n	8b1b6 <_ZN7Sd2Card4initEhh+0x156>
  } else {
    // only need last byte of r7 response
    for (uint8_t i = 0; i < 4; i++) status_ = spiRec();
   8b17e:	2300      	movs	r3, #0
   8b180:	77bb      	strb	r3, [r7, #30]
   8b182:	7fbb      	ldrb	r3, [r7, #30]
   8b184:	2b03      	cmp	r3, #3
   8b186:	d809      	bhi.n	8b19c <_ZN7Sd2Card4initEhh+0x13c>
   8b188:	4b57      	ldr	r3, [pc, #348]	; (8b2e8 <_ZN7Sd2Card4initEhh+0x288>)
   8b18a:	4798      	blx	r3
   8b18c:	4603      	mov	r3, r0
   8b18e:	461a      	mov	r2, r3
   8b190:	687b      	ldr	r3, [r7, #4]
   8b192:	72da      	strb	r2, [r3, #11]
   8b194:	7fbb      	ldrb	r3, [r7, #30]
   8b196:	3301      	adds	r3, #1
   8b198:	77bb      	strb	r3, [r7, #30]
   8b19a:	e7f2      	b.n	8b182 <_ZN7Sd2Card4initEhh+0x122>
    if (status_ != 0XAA) {
   8b19c:	687b      	ldr	r3, [r7, #4]
   8b19e:	7adb      	ldrb	r3, [r3, #11]
   8b1a0:	2baa      	cmp	r3, #170	; 0xaa
   8b1a2:	d004      	beq.n	8b1ae <_ZN7Sd2Card4initEhh+0x14e>
      error(SD_CARD_ERROR_CMD8);
   8b1a4:	2102      	movs	r1, #2
   8b1a6:	6878      	ldr	r0, [r7, #4]
   8b1a8:	4b4d      	ldr	r3, [pc, #308]	; (8b2e0 <_ZN7Sd2Card4initEhh+0x280>)
   8b1aa:	4798      	blx	r3
      goto fail;
   8b1ac:	e076      	b.n	8b29c <_ZN7Sd2Card4initEhh+0x23c>
    }
    type(SD_CARD_TYPE_SD2);
   8b1ae:	2102      	movs	r1, #2
   8b1b0:	6878      	ldr	r0, [r7, #4]
   8b1b2:	4b4c      	ldr	r3, [pc, #304]	; (8b2e4 <_ZN7Sd2Card4initEhh+0x284>)
   8b1b4:	4798      	blx	r3
  }
  // initialize card and send host supports SDHC if SD2
  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;
   8b1b6:	6878      	ldr	r0, [r7, #4]
   8b1b8:	4b4c      	ldr	r3, [pc, #304]	; (8b2ec <_ZN7Sd2Card4initEhh+0x28c>)
   8b1ba:	4798      	blx	r3
   8b1bc:	4603      	mov	r3, r0
   8b1be:	2b02      	cmp	r3, #2
   8b1c0:	d102      	bne.n	8b1c8 <_ZN7Sd2Card4initEhh+0x168>
   8b1c2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   8b1c6:	e000      	b.n	8b1ca <_ZN7Sd2Card4initEhh+0x16a>
   8b1c8:	2300      	movs	r3, #0
   8b1ca:	617b      	str	r3, [r7, #20]

  while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {
   8b1cc:	697a      	ldr	r2, [r7, #20]
   8b1ce:	2129      	movs	r1, #41	; 0x29
   8b1d0:	6878      	ldr	r0, [r7, #4]
   8b1d2:	4b47      	ldr	r3, [pc, #284]	; (8b2f0 <_ZN7Sd2Card4initEhh+0x290>)
   8b1d4:	4798      	blx	r3
   8b1d6:	4603      	mov	r3, r0
   8b1d8:	461a      	mov	r2, r3
   8b1da:	687b      	ldr	r3, [r7, #4]
   8b1dc:	72da      	strb	r2, [r3, #11]
   8b1de:	687b      	ldr	r3, [r7, #4]
   8b1e0:	7adb      	ldrb	r3, [r3, #11]
   8b1e2:	2b00      	cmp	r3, #0
   8b1e4:	bf14      	ite	ne
   8b1e6:	2301      	movne	r3, #1
   8b1e8:	2300      	moveq	r3, #0
   8b1ea:	b2db      	uxtb	r3, r3
   8b1ec:	2b00      	cmp	r3, #0
   8b1ee:	d013      	beq.n	8b218 <_ZN7Sd2Card4initEhh+0x1b8>
    // check for timeout
    if (((uint16_t)(millis() - t0)) > SD_INIT_TIMEOUT) {
   8b1f0:	4b2e      	ldr	r3, [pc, #184]	; (8b2ac <_ZN7Sd2Card4initEhh+0x24c>)
   8b1f2:	4798      	blx	r3
   8b1f4:	4603      	mov	r3, r0
   8b1f6:	b29a      	uxth	r2, r3
   8b1f8:	8b7b      	ldrh	r3, [r7, #26]
   8b1fa:	1ad3      	subs	r3, r2, r3
   8b1fc:	b29b      	uxth	r3, r3
   8b1fe:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
   8b202:	bf8c      	ite	hi
   8b204:	2301      	movhi	r3, #1
   8b206:	2300      	movls	r3, #0
   8b208:	b2db      	uxtb	r3, r3
   8b20a:	2b00      	cmp	r3, #0
   8b20c:	d0de      	beq.n	8b1cc <_ZN7Sd2Card4initEhh+0x16c>
      error(SD_CARD_ERROR_ACMD41);
   8b20e:	2108      	movs	r1, #8
   8b210:	6878      	ldr	r0, [r7, #4]
   8b212:	4b33      	ldr	r3, [pc, #204]	; (8b2e0 <_ZN7Sd2Card4initEhh+0x280>)
   8b214:	4798      	blx	r3
      goto fail;
   8b216:	e041      	b.n	8b29c <_ZN7Sd2Card4initEhh+0x23c>
    }
  }
  // if SD2 read OCR register to check for SDHC card
  if (type() == SD_CARD_TYPE_SD2) {
   8b218:	6878      	ldr	r0, [r7, #4]
   8b21a:	4b34      	ldr	r3, [pc, #208]	; (8b2ec <_ZN7Sd2Card4initEhh+0x28c>)
   8b21c:	4798      	blx	r3
   8b21e:	4603      	mov	r3, r0
   8b220:	2b02      	cmp	r3, #2
   8b222:	bf0c      	ite	eq
   8b224:	2301      	moveq	r3, #1
   8b226:	2300      	movne	r3, #0
   8b228:	b2db      	uxtb	r3, r3
   8b22a:	2b00      	cmp	r3, #0
   8b22c:	d02c      	beq.n	8b288 <_ZN7Sd2Card4initEhh+0x228>
    if (cardCommand(CMD58, 0)) {
   8b22e:	2200      	movs	r2, #0
   8b230:	213a      	movs	r1, #58	; 0x3a
   8b232:	6878      	ldr	r0, [r7, #4]
   8b234:	4b29      	ldr	r3, [pc, #164]	; (8b2dc <_ZN7Sd2Card4initEhh+0x27c>)
   8b236:	4798      	blx	r3
   8b238:	4603      	mov	r3, r0
   8b23a:	2b00      	cmp	r3, #0
   8b23c:	bf14      	ite	ne
   8b23e:	2301      	movne	r3, #1
   8b240:	2300      	moveq	r3, #0
   8b242:	b2db      	uxtb	r3, r3
   8b244:	2b00      	cmp	r3, #0
   8b246:	d004      	beq.n	8b252 <_ZN7Sd2Card4initEhh+0x1f2>
      error(SD_CARD_ERROR_CMD58);
   8b248:	2106      	movs	r1, #6
   8b24a:	6878      	ldr	r0, [r7, #4]
   8b24c:	4b24      	ldr	r3, [pc, #144]	; (8b2e0 <_ZN7Sd2Card4initEhh+0x280>)
   8b24e:	4798      	blx	r3
      goto fail;
   8b250:	e024      	b.n	8b29c <_ZN7Sd2Card4initEhh+0x23c>
    }
    if ((spiRec() & 0XC0) == 0XC0) type(SD_CARD_TYPE_SDHC);
   8b252:	4b25      	ldr	r3, [pc, #148]	; (8b2e8 <_ZN7Sd2Card4initEhh+0x288>)
   8b254:	4798      	blx	r3
   8b256:	4603      	mov	r3, r0
   8b258:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   8b25c:	2bc0      	cmp	r3, #192	; 0xc0
   8b25e:	bf0c      	ite	eq
   8b260:	2301      	moveq	r3, #1
   8b262:	2300      	movne	r3, #0
   8b264:	b2db      	uxtb	r3, r3
   8b266:	2b00      	cmp	r3, #0
   8b268:	d003      	beq.n	8b272 <_ZN7Sd2Card4initEhh+0x212>
   8b26a:	2103      	movs	r1, #3
   8b26c:	6878      	ldr	r0, [r7, #4]
   8b26e:	4b1d      	ldr	r3, [pc, #116]	; (8b2e4 <_ZN7Sd2Card4initEhh+0x284>)
   8b270:	4798      	blx	r3
    // discard rest of ocr - contains allowed voltage range
    for (uint8_t i = 0; i < 3; i++) spiRec();
   8b272:	2300      	movs	r3, #0
   8b274:	777b      	strb	r3, [r7, #29]
   8b276:	7f7b      	ldrb	r3, [r7, #29]
   8b278:	2b02      	cmp	r3, #2
   8b27a:	d805      	bhi.n	8b288 <_ZN7Sd2Card4initEhh+0x228>
   8b27c:	4b1a      	ldr	r3, [pc, #104]	; (8b2e8 <_ZN7Sd2Card4initEhh+0x288>)
   8b27e:	4798      	blx	r3
   8b280:	7f7b      	ldrb	r3, [r7, #29]
   8b282:	3301      	adds	r3, #1
   8b284:	777b      	strb	r3, [r7, #29]
   8b286:	e7f6      	b.n	8b276 <_ZN7Sd2Card4initEhh+0x216>
  }
  chipSelectHigh();
   8b288:	6878      	ldr	r0, [r7, #4]
   8b28a:	4b1a      	ldr	r3, [pc, #104]	; (8b2f4 <_ZN7Sd2Card4initEhh+0x294>)
   8b28c:	4798      	blx	r3

#ifndef SOFTWARE_SPI
  return setSckRate(sckRateID);
   8b28e:	78fb      	ldrb	r3, [r7, #3]
   8b290:	4619      	mov	r1, r3
   8b292:	6878      	ldr	r0, [r7, #4]
   8b294:	4b18      	ldr	r3, [pc, #96]	; (8b2f8 <_ZN7Sd2Card4initEhh+0x298>)
   8b296:	4798      	blx	r3
   8b298:	4603      	mov	r3, r0
   8b29a:	e003      	b.n	8b2a4 <_ZN7Sd2Card4initEhh+0x244>
#else  // SOFTWARE_SPI
  return true;
#endif  // SOFTWARE_SPI

 fail:
  chipSelectHigh();
   8b29c:	6878      	ldr	r0, [r7, #4]
   8b29e:	4b15      	ldr	r3, [pc, #84]	; (8b2f4 <_ZN7Sd2Card4initEhh+0x294>)
   8b2a0:	4798      	blx	r3
  return false;
   8b2a2:	2300      	movs	r3, #0
}
   8b2a4:	4618      	mov	r0, r3
   8b2a6:	3724      	adds	r7, #36	; 0x24
   8b2a8:	46bd      	mov	sp, r7
   8b2aa:	bd90      	pop	{r4, r7, pc}
   8b2ac:	00081bb1 	.word	0x00081bb1
   8b2b0:	00081cc5 	.word	0x00081cc5
   8b2b4:	00081f29 	.word	0x00081f29
   8b2b8:	20071c78 	.word	0x20071c78
   8b2bc:	0008ff19 	.word	0x0008ff19
   8b2c0:	0003d090 	.word	0x0003d090
   8b2c4:	0008ad39 	.word	0x0008ad39
   8b2c8:	2007190c 	.word	0x2007190c
   8b2cc:	0008ae9d 	.word	0x0008ae9d
   8b2d0:	0008aec5 	.word	0x0008aec5
   8b2d4:	000900c9 	.word	0x000900c9
   8b2d8:	0008b015 	.word	0x0008b015
   8b2dc:	0008af09 	.word	0x0008af09
   8b2e0:	0008ad01 	.word	0x0008ad01
   8b2e4:	0008ad1d 	.word	0x0008ad1d
   8b2e8:	0008aeed 	.word	0x0008aeed
   8b2ec:	0008acb5 	.word	0x0008acb5
   8b2f0:	0008accd 	.word	0x0008accd
   8b2f4:	0008afd5 	.word	0x0008afd5
   8b2f8:	0008b4c5 	.word	0x0008b4c5

0008b2fc <_ZN7Sd2Card9readBlockEmPh>:
 * \param[out] dst Pointer to the location that will receive the data.

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::readBlock(uint32_t block, uint8_t* dst) {
   8b2fc:	b590      	push	{r4, r7, lr}
   8b2fe:	b087      	sub	sp, #28
   8b300:	af02      	add	r7, sp, #8
   8b302:	60f8      	str	r0, [r7, #12]
   8b304:	60b9      	str	r1, [r7, #8]
   8b306:	607a      	str	r2, [r7, #4]
  return readData(block, 0, 512, dst);
   8b308:	687b      	ldr	r3, [r7, #4]
   8b30a:	9300      	str	r3, [sp, #0]
   8b30c:	f44f 7300 	mov.w	r3, #512	; 0x200
   8b310:	2200      	movs	r2, #0
   8b312:	68b9      	ldr	r1, [r7, #8]
   8b314:	68f8      	ldr	r0, [r7, #12]
   8b316:	4c03      	ldr	r4, [pc, #12]	; (8b324 <_ZN7Sd2Card9readBlockEmPh+0x28>)
   8b318:	47a0      	blx	r4
   8b31a:	4603      	mov	r3, r0
}
   8b31c:	4618      	mov	r0, r3
   8b31e:	3714      	adds	r7, #20
   8b320:	46bd      	mov	sp, r7
   8b322:	bd90      	pop	{r4, r7, pc}
   8b324:	0008b329 	.word	0x0008b329

0008b328 <_ZN7Sd2Card8readDataEmttPh>:
 * \param[in] count Number of bytes to read
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::readData(uint32_t block,
        uint16_t offset, uint16_t count, uint8_t* dst) {
   8b328:	b590      	push	{r4, r7, lr}
   8b32a:	b087      	sub	sp, #28
   8b32c:	af00      	add	r7, sp, #0
   8b32e:	60f8      	str	r0, [r7, #12]
   8b330:	60b9      	str	r1, [r7, #8]
   8b332:	4611      	mov	r1, r2
   8b334:	461a      	mov	r2, r3
   8b336:	460b      	mov	r3, r1
   8b338:	80fb      	strh	r3, [r7, #6]
   8b33a:	4613      	mov	r3, r2
   8b33c:	80bb      	strh	r3, [r7, #4]
  uint16_t n;
  if (count == 0) return true;
   8b33e:	88bb      	ldrh	r3, [r7, #4]
   8b340:	2b00      	cmp	r3, #0
   8b342:	d101      	bne.n	8b348 <_ZN7Sd2Card8readDataEmttPh+0x20>
   8b344:	2301      	movs	r3, #1
   8b346:	e082      	b.n	8b44e <_ZN7Sd2Card8readDataEmttPh+0x126>
  if ((count + offset) > 512) {
   8b348:	88ba      	ldrh	r2, [r7, #4]
   8b34a:	88fb      	ldrh	r3, [r7, #6]
   8b34c:	4413      	add	r3, r2
   8b34e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   8b352:	dc75      	bgt.n	8b440 <_ZN7Sd2Card8readDataEmttPh+0x118>
    goto fail;
  }
  if (!inBlock_ || block != block_ || offset < offset_) {
   8b354:	68fb      	ldr	r3, [r7, #12]
   8b356:	799b      	ldrb	r3, [r3, #6]
   8b358:	2b00      	cmp	r3, #0
   8b35a:	d009      	beq.n	8b370 <_ZN7Sd2Card8readDataEmttPh+0x48>
   8b35c:	68fb      	ldr	r3, [r7, #12]
   8b35e:	681a      	ldr	r2, [r3, #0]
   8b360:	68bb      	ldr	r3, [r7, #8]
   8b362:	429a      	cmp	r2, r3
   8b364:	d104      	bne.n	8b370 <_ZN7Sd2Card8readDataEmttPh+0x48>
   8b366:	68fb      	ldr	r3, [r7, #12]
   8b368:	891b      	ldrh	r3, [r3, #8]
   8b36a:	88fa      	ldrh	r2, [r7, #6]
   8b36c:	429a      	cmp	r2, r3
   8b36e:	d233      	bcs.n	8b3d8 <_ZN7Sd2Card8readDataEmttPh+0xb0>
    block_ = block;
   8b370:	68fb      	ldr	r3, [r7, #12]
   8b372:	68ba      	ldr	r2, [r7, #8]
   8b374:	601a      	str	r2, [r3, #0]
    // use address if not SDHC card
    if (type()!= SD_CARD_TYPE_SDHC) block <<= 9;
   8b376:	68f8      	ldr	r0, [r7, #12]
   8b378:	4b37      	ldr	r3, [pc, #220]	; (8b458 <_ZN7Sd2Card8readDataEmttPh+0x130>)
   8b37a:	4798      	blx	r3
   8b37c:	4603      	mov	r3, r0
   8b37e:	2b03      	cmp	r3, #3
   8b380:	bf14      	ite	ne
   8b382:	2301      	movne	r3, #1
   8b384:	2300      	moveq	r3, #0
   8b386:	b2db      	uxtb	r3, r3
   8b388:	2b00      	cmp	r3, #0
   8b38a:	d002      	beq.n	8b392 <_ZN7Sd2Card8readDataEmttPh+0x6a>
   8b38c:	68bb      	ldr	r3, [r7, #8]
   8b38e:	025b      	lsls	r3, r3, #9
   8b390:	60bb      	str	r3, [r7, #8]
    if (cardCommand(CMD17, block)) {
   8b392:	68ba      	ldr	r2, [r7, #8]
   8b394:	2111      	movs	r1, #17
   8b396:	68f8      	ldr	r0, [r7, #12]
   8b398:	4b30      	ldr	r3, [pc, #192]	; (8b45c <_ZN7Sd2Card8readDataEmttPh+0x134>)
   8b39a:	4798      	blx	r3
   8b39c:	4603      	mov	r3, r0
   8b39e:	2b00      	cmp	r3, #0
   8b3a0:	bf14      	ite	ne
   8b3a2:	2301      	movne	r3, #1
   8b3a4:	2300      	moveq	r3, #0
   8b3a6:	b2db      	uxtb	r3, r3
   8b3a8:	2b00      	cmp	r3, #0
   8b3aa:	d004      	beq.n	8b3b6 <_ZN7Sd2Card8readDataEmttPh+0x8e>
      error(SD_CARD_ERROR_CMD17);
   8b3ac:	2103      	movs	r1, #3
   8b3ae:	68f8      	ldr	r0, [r7, #12]
   8b3b0:	4b2b      	ldr	r3, [pc, #172]	; (8b460 <_ZN7Sd2Card8readDataEmttPh+0x138>)
   8b3b2:	4798      	blx	r3
      goto fail;
   8b3b4:	e047      	b.n	8b446 <_ZN7Sd2Card8readDataEmttPh+0x11e>
    }
    if (!waitStartBlock()) {
   8b3b6:	68f8      	ldr	r0, [r7, #12]
   8b3b8:	4b2a      	ldr	r3, [pc, #168]	; (8b464 <_ZN7Sd2Card8readDataEmttPh+0x13c>)
   8b3ba:	4798      	blx	r3
   8b3bc:	4603      	mov	r3, r0
   8b3be:	2b00      	cmp	r3, #0
   8b3c0:	bf0c      	ite	eq
   8b3c2:	2301      	moveq	r3, #1
   8b3c4:	2300      	movne	r3, #0
   8b3c6:	b2db      	uxtb	r3, r3
   8b3c8:	2b00      	cmp	r3, #0
   8b3ca:	d13b      	bne.n	8b444 <_ZN7Sd2Card8readDataEmttPh+0x11c>
      goto fail;
    }
    offset_ = 0;
   8b3cc:	68fb      	ldr	r3, [r7, #12]
   8b3ce:	2200      	movs	r2, #0
   8b3d0:	811a      	strh	r2, [r3, #8]
    inBlock_ = 1;
   8b3d2:	68fb      	ldr	r3, [r7, #12]
   8b3d4:	2201      	movs	r2, #1
   8b3d6:	719a      	strb	r2, [r3, #6]
  dst[n] = SPDR;

#else  // OPTIMIZE_HARDWARE_SPI

  // skip data before offset
  for (;offset_ < offset; offset_++) {
   8b3d8:	68fb      	ldr	r3, [r7, #12]
   8b3da:	891b      	ldrh	r3, [r3, #8]
   8b3dc:	88fa      	ldrh	r2, [r7, #6]
   8b3de:	429a      	cmp	r2, r3
   8b3e0:	d908      	bls.n	8b3f4 <_ZN7Sd2Card8readDataEmttPh+0xcc>
    spiRec();
   8b3e2:	4b21      	ldr	r3, [pc, #132]	; (8b468 <_ZN7Sd2Card8readDataEmttPh+0x140>)
   8b3e4:	4798      	blx	r3
  dst[n] = SPDR;

#else  // OPTIMIZE_HARDWARE_SPI

  // skip data before offset
  for (;offset_ < offset; offset_++) {
   8b3e6:	68fb      	ldr	r3, [r7, #12]
   8b3e8:	891b      	ldrh	r3, [r3, #8]
   8b3ea:	3301      	adds	r3, #1
   8b3ec:	b29a      	uxth	r2, r3
   8b3ee:	68fb      	ldr	r3, [r7, #12]
   8b3f0:	811a      	strh	r2, [r3, #8]
   8b3f2:	e7f1      	b.n	8b3d8 <_ZN7Sd2Card8readDataEmttPh+0xb0>
    spiRec();
  }
  // transfer data
  for (uint16_t i = 0; i < count; i++) {
   8b3f4:	2300      	movs	r3, #0
   8b3f6:	82fb      	strh	r3, [r7, #22]
   8b3f8:	8afa      	ldrh	r2, [r7, #22]
   8b3fa:	88bb      	ldrh	r3, [r7, #4]
   8b3fc:	429a      	cmp	r2, r3
   8b3fe:	d20a      	bcs.n	8b416 <_ZN7Sd2Card8readDataEmttPh+0xee>
    dst[i] = spiRec();
   8b400:	8afb      	ldrh	r3, [r7, #22]
   8b402:	6aba      	ldr	r2, [r7, #40]	; 0x28
   8b404:	18d4      	adds	r4, r2, r3
   8b406:	4b18      	ldr	r3, [pc, #96]	; (8b468 <_ZN7Sd2Card8readDataEmttPh+0x140>)
   8b408:	4798      	blx	r3
   8b40a:	4603      	mov	r3, r0
   8b40c:	7023      	strb	r3, [r4, #0]
  // skip data before offset
  for (;offset_ < offset; offset_++) {
    spiRec();
  }
  // transfer data
  for (uint16_t i = 0; i < count; i++) {
   8b40e:	8afb      	ldrh	r3, [r7, #22]
   8b410:	3301      	adds	r3, #1
   8b412:	82fb      	strh	r3, [r7, #22]
   8b414:	e7f0      	b.n	8b3f8 <_ZN7Sd2Card8readDataEmttPh+0xd0>
    dst[i] = spiRec();
  }
#endif  // OPTIMIZE_HARDWARE_SPI

  offset_ += count;
   8b416:	68fb      	ldr	r3, [r7, #12]
   8b418:	891a      	ldrh	r2, [r3, #8]
   8b41a:	88bb      	ldrh	r3, [r7, #4]
   8b41c:	4413      	add	r3, r2
   8b41e:	b29a      	uxth	r2, r3
   8b420:	68fb      	ldr	r3, [r7, #12]
   8b422:	811a      	strh	r2, [r3, #8]
  if (!partialBlockRead_ || offset_ >= 512) {
   8b424:	68fb      	ldr	r3, [r7, #12]
   8b426:	7a9b      	ldrb	r3, [r3, #10]
   8b428:	2b00      	cmp	r3, #0
   8b42a:	d004      	beq.n	8b436 <_ZN7Sd2Card8readDataEmttPh+0x10e>
   8b42c:	68fb      	ldr	r3, [r7, #12]
   8b42e:	891b      	ldrh	r3, [r3, #8]
   8b430:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   8b434:	d302      	bcc.n	8b43c <_ZN7Sd2Card8readDataEmttPh+0x114>
    // read rest of data, checksum and set chip select high
    readEnd();
   8b436:	68f8      	ldr	r0, [r7, #12]
   8b438:	4b0c      	ldr	r3, [pc, #48]	; (8b46c <_ZN7Sd2Card8readDataEmttPh+0x144>)
   8b43a:	4798      	blx	r3
  }
  return true;
   8b43c:	2301      	movs	r3, #1
   8b43e:	e006      	b.n	8b44e <_ZN7Sd2Card8readDataEmttPh+0x126>
uint8_t Sd2Card::readData(uint32_t block,
        uint16_t offset, uint16_t count, uint8_t* dst) {
  uint16_t n;
  if (count == 0) return true;
  if ((count + offset) > 512) {
    goto fail;
   8b440:	bf00      	nop
   8b442:	e000      	b.n	8b446 <_ZN7Sd2Card8readDataEmttPh+0x11e>
    if (cardCommand(CMD17, block)) {
      error(SD_CARD_ERROR_CMD17);
      goto fail;
    }
    if (!waitStartBlock()) {
      goto fail;
   8b444:	bf00      	nop
    readEnd();
  }
  return true;

 fail:
  chipSelectHigh();
   8b446:	68f8      	ldr	r0, [r7, #12]
   8b448:	4b09      	ldr	r3, [pc, #36]	; (8b470 <_ZN7Sd2Card8readDataEmttPh+0x148>)
   8b44a:	4798      	blx	r3
  return false;
   8b44c:	2300      	movs	r3, #0
}
   8b44e:	4618      	mov	r0, r3
   8b450:	371c      	adds	r7, #28
   8b452:	46bd      	mov	sp, r7
   8b454:	bd90      	pop	{r4, r7, pc}
   8b456:	bf00      	nop
   8b458:	0008acb5 	.word	0x0008acb5
   8b45c:	0008af09 	.word	0x0008af09
   8b460:	0008ad01 	.word	0x0008ad01
   8b464:	0008b675 	.word	0x0008b675
   8b468:	0008aeed 	.word	0x0008aeed
   8b46c:	0008b475 	.word	0x0008b475
   8b470:	0008afd5 	.word	0x0008afd5

0008b474 <_ZN7Sd2Card7readEndEv>:
//------------------------------------------------------------------------------
/** Skip remaining data in a block when in partial block read mode. */
void Sd2Card::readEnd(void) {
   8b474:	b580      	push	{r7, lr}
   8b476:	b082      	sub	sp, #8
   8b478:	af00      	add	r7, sp, #0
   8b47a:	6078      	str	r0, [r7, #4]
  if (inBlock_) {
   8b47c:	687b      	ldr	r3, [r7, #4]
   8b47e:	799b      	ldrb	r3, [r3, #6]
   8b480:	2b00      	cmp	r3, #0
   8b482:	d017      	beq.n	8b4b4 <_ZN7Sd2Card7readEndEv+0x40>
    }
    // wait for last crc byte
    while (!(SPSR & (1 << SPIF)))
      ;
#else  // OPTIMIZE_HARDWARE_SPI
    while (offset_++ < 514) spiRec();
   8b484:	687b      	ldr	r3, [r7, #4]
   8b486:	891b      	ldrh	r3, [r3, #8]
   8b488:	1c5a      	adds	r2, r3, #1
   8b48a:	b291      	uxth	r1, r2
   8b48c:	687a      	ldr	r2, [r7, #4]
   8b48e:	8111      	strh	r1, [r2, #8]
   8b490:	f240 2201 	movw	r2, #513	; 0x201
   8b494:	4293      	cmp	r3, r2
   8b496:	bf94      	ite	ls
   8b498:	2301      	movls	r3, #1
   8b49a:	2300      	movhi	r3, #0
   8b49c:	b2db      	uxtb	r3, r3
   8b49e:	2b00      	cmp	r3, #0
   8b4a0:	d002      	beq.n	8b4a8 <_ZN7Sd2Card7readEndEv+0x34>
   8b4a2:	4b06      	ldr	r3, [pc, #24]	; (8b4bc <_ZN7Sd2Card7readEndEv+0x48>)
   8b4a4:	4798      	blx	r3
   8b4a6:	e7ed      	b.n	8b484 <_ZN7Sd2Card7readEndEv+0x10>
#endif  // OPTIMIZE_HARDWARE_SPI
    chipSelectHigh();
   8b4a8:	6878      	ldr	r0, [r7, #4]
   8b4aa:	4b05      	ldr	r3, [pc, #20]	; (8b4c0 <_ZN7Sd2Card7readEndEv+0x4c>)
   8b4ac:	4798      	blx	r3
    inBlock_ = 0;
   8b4ae:	687b      	ldr	r3, [r7, #4]
   8b4b0:	2200      	movs	r2, #0
   8b4b2:	719a      	strb	r2, [r3, #6]
  }
}
   8b4b4:	bf00      	nop
   8b4b6:	3708      	adds	r7, #8
   8b4b8:	46bd      	mov	sp, r7
   8b4ba:	bd80      	pop	{r7, pc}
   8b4bc:	0008aeed 	.word	0x0008aeed
   8b4c0:	0008afd5 	.word	0x0008afd5

0008b4c4 <_ZN7Sd2Card10setSckRateEh>:
 * for \a scsRateID = 6.
 *
 * \return The value one, true, is returned for success and the value zero,
 * false, is returned for an invalid value of \a sckRateID.
 */
uint8_t Sd2Card::setSckRate(uint8_t sckRateID) {
   8b4c4:	b590      	push	{r4, r7, lr}
   8b4c6:	b091      	sub	sp, #68	; 0x44
   8b4c8:	af00      	add	r7, sp, #0
   8b4ca:	6078      	str	r0, [r7, #4]
   8b4cc:	460b      	mov	r3, r1
   8b4ce:	70fb      	strb	r3, [r7, #3]
  if (sckRateID > 6) {
   8b4d0:	78fb      	ldrb	r3, [r7, #3]
   8b4d2:	2b06      	cmp	r3, #6
   8b4d4:	d905      	bls.n	8b4e2 <_ZN7Sd2Card10setSckRateEh+0x1e>
    error(SD_CARD_ERROR_SCK_RATE);
   8b4d6:	2116      	movs	r1, #22
   8b4d8:	6878      	ldr	r0, [r7, #4]
   8b4da:	4b45      	ldr	r3, [pc, #276]	; (8b5f0 <_ZN7Sd2Card10setSckRateEh+0x12c>)
   8b4dc:	4798      	blx	r3
    return false;
   8b4de:	2300      	movs	r3, #0
   8b4e0:	e082      	b.n	8b5e8 <_ZN7Sd2Card10setSckRateEh+0x124>
  }
  SPCR &= ~((1 <<SPR1) | (1 << SPR0));
  SPCR |= (sckRateID & 4 ? (1 << SPR1) : 0)
    | (sckRateID & 2 ? (1 << SPR0) : 0);
#else // USE_SPI_LIB
  switch (sckRateID) {
   8b4e2:	78fb      	ldrb	r3, [r7, #3]
   8b4e4:	2b05      	cmp	r3, #5
   8b4e6:	d86f      	bhi.n	8b5c8 <_ZN7Sd2Card10setSckRateEh+0x104>
   8b4e8:	a201      	add	r2, pc, #4	; (adr r2, 8b4f0 <_ZN7Sd2Card10setSckRateEh+0x2c>)
   8b4ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   8b4ee:	bf00      	nop
   8b4f0:	0008b509 	.word	0x0008b509
   8b4f4:	0008b529 	.word	0x0008b529
   8b4f8:	0008b549 	.word	0x0008b549
   8b4fc:	0008b569 	.word	0x0008b569
   8b500:	0008b589 	.word	0x0008b589
   8b504:	0008b5a9 	.word	0x0008b5a9
    case 0:  settings = SPISettings(25000000, MSBFIRST, SPI_MODE0); break;
   8b508:	f107 0008 	add.w	r0, r7, #8
   8b50c:	2302      	movs	r3, #2
   8b50e:	2201      	movs	r2, #1
   8b510:	4938      	ldr	r1, [pc, #224]	; (8b5f4 <_ZN7Sd2Card10setSckRateEh+0x130>)
   8b512:	4c39      	ldr	r4, [pc, #228]	; (8b5f8 <_ZN7Sd2Card10setSckRateEh+0x134>)
   8b514:	47a0      	blx	r4
   8b516:	4b39      	ldr	r3, [pc, #228]	; (8b5fc <_ZN7Sd2Card10setSckRateEh+0x138>)
   8b518:	f107 0208 	add.w	r2, r7, #8
   8b51c:	e892 0003 	ldmia.w	r2, {r0, r1}
   8b520:	6018      	str	r0, [r3, #0]
   8b522:	3304      	adds	r3, #4
   8b524:	7019      	strb	r1, [r3, #0]
   8b526:	e05e      	b.n	8b5e6 <_ZN7Sd2Card10setSckRateEh+0x122>
    case 1:  settings = SPISettings(4000000, MSBFIRST, SPI_MODE0); break;
   8b528:	f107 0010 	add.w	r0, r7, #16
   8b52c:	2302      	movs	r3, #2
   8b52e:	2201      	movs	r2, #1
   8b530:	4933      	ldr	r1, [pc, #204]	; (8b600 <_ZN7Sd2Card10setSckRateEh+0x13c>)
   8b532:	4c31      	ldr	r4, [pc, #196]	; (8b5f8 <_ZN7Sd2Card10setSckRateEh+0x134>)
   8b534:	47a0      	blx	r4
   8b536:	4b31      	ldr	r3, [pc, #196]	; (8b5fc <_ZN7Sd2Card10setSckRateEh+0x138>)
   8b538:	f107 0210 	add.w	r2, r7, #16
   8b53c:	e892 0003 	ldmia.w	r2, {r0, r1}
   8b540:	6018      	str	r0, [r3, #0]
   8b542:	3304      	adds	r3, #4
   8b544:	7019      	strb	r1, [r3, #0]
   8b546:	e04e      	b.n	8b5e6 <_ZN7Sd2Card10setSckRateEh+0x122>
    case 2:  settings = SPISettings(2000000, MSBFIRST, SPI_MODE0); break;
   8b548:	f107 0018 	add.w	r0, r7, #24
   8b54c:	2302      	movs	r3, #2
   8b54e:	2201      	movs	r2, #1
   8b550:	492c      	ldr	r1, [pc, #176]	; (8b604 <_ZN7Sd2Card10setSckRateEh+0x140>)
   8b552:	4c29      	ldr	r4, [pc, #164]	; (8b5f8 <_ZN7Sd2Card10setSckRateEh+0x134>)
   8b554:	47a0      	blx	r4
   8b556:	4b29      	ldr	r3, [pc, #164]	; (8b5fc <_ZN7Sd2Card10setSckRateEh+0x138>)
   8b558:	f107 0218 	add.w	r2, r7, #24
   8b55c:	e892 0003 	ldmia.w	r2, {r0, r1}
   8b560:	6018      	str	r0, [r3, #0]
   8b562:	3304      	adds	r3, #4
   8b564:	7019      	strb	r1, [r3, #0]
   8b566:	e03e      	b.n	8b5e6 <_ZN7Sd2Card10setSckRateEh+0x122>
    case 3:  settings = SPISettings(1000000, MSBFIRST, SPI_MODE0); break;
   8b568:	f107 0020 	add.w	r0, r7, #32
   8b56c:	2302      	movs	r3, #2
   8b56e:	2201      	movs	r2, #1
   8b570:	4925      	ldr	r1, [pc, #148]	; (8b608 <_ZN7Sd2Card10setSckRateEh+0x144>)
   8b572:	4c21      	ldr	r4, [pc, #132]	; (8b5f8 <_ZN7Sd2Card10setSckRateEh+0x134>)
   8b574:	47a0      	blx	r4
   8b576:	4b21      	ldr	r3, [pc, #132]	; (8b5fc <_ZN7Sd2Card10setSckRateEh+0x138>)
   8b578:	f107 0220 	add.w	r2, r7, #32
   8b57c:	e892 0003 	ldmia.w	r2, {r0, r1}
   8b580:	6018      	str	r0, [r3, #0]
   8b582:	3304      	adds	r3, #4
   8b584:	7019      	strb	r1, [r3, #0]
   8b586:	e02e      	b.n	8b5e6 <_ZN7Sd2Card10setSckRateEh+0x122>
    case 4:  settings = SPISettings(500000, MSBFIRST, SPI_MODE0); break;
   8b588:	f107 0028 	add.w	r0, r7, #40	; 0x28
   8b58c:	2302      	movs	r3, #2
   8b58e:	2201      	movs	r2, #1
   8b590:	491e      	ldr	r1, [pc, #120]	; (8b60c <_ZN7Sd2Card10setSckRateEh+0x148>)
   8b592:	4c19      	ldr	r4, [pc, #100]	; (8b5f8 <_ZN7Sd2Card10setSckRateEh+0x134>)
   8b594:	47a0      	blx	r4
   8b596:	4b19      	ldr	r3, [pc, #100]	; (8b5fc <_ZN7Sd2Card10setSckRateEh+0x138>)
   8b598:	f107 0228 	add.w	r2, r7, #40	; 0x28
   8b59c:	e892 0003 	ldmia.w	r2, {r0, r1}
   8b5a0:	6018      	str	r0, [r3, #0]
   8b5a2:	3304      	adds	r3, #4
   8b5a4:	7019      	strb	r1, [r3, #0]
   8b5a6:	e01e      	b.n	8b5e6 <_ZN7Sd2Card10setSckRateEh+0x122>
    case 5:  settings = SPISettings(250000, MSBFIRST, SPI_MODE0); break;
   8b5a8:	f107 0030 	add.w	r0, r7, #48	; 0x30
   8b5ac:	2302      	movs	r3, #2
   8b5ae:	2201      	movs	r2, #1
   8b5b0:	4917      	ldr	r1, [pc, #92]	; (8b610 <_ZN7Sd2Card10setSckRateEh+0x14c>)
   8b5b2:	4c11      	ldr	r4, [pc, #68]	; (8b5f8 <_ZN7Sd2Card10setSckRateEh+0x134>)
   8b5b4:	47a0      	blx	r4
   8b5b6:	4b11      	ldr	r3, [pc, #68]	; (8b5fc <_ZN7Sd2Card10setSckRateEh+0x138>)
   8b5b8:	f107 0230 	add.w	r2, r7, #48	; 0x30
   8b5bc:	e892 0003 	ldmia.w	r2, {r0, r1}
   8b5c0:	6018      	str	r0, [r3, #0]
   8b5c2:	3304      	adds	r3, #4
   8b5c4:	7019      	strb	r1, [r3, #0]
   8b5c6:	e00e      	b.n	8b5e6 <_ZN7Sd2Card10setSckRateEh+0x122>
    default: settings = SPISettings(125000, MSBFIRST, SPI_MODE0);
   8b5c8:	f107 0038 	add.w	r0, r7, #56	; 0x38
   8b5cc:	2302      	movs	r3, #2
   8b5ce:	2201      	movs	r2, #1
   8b5d0:	4910      	ldr	r1, [pc, #64]	; (8b614 <_ZN7Sd2Card10setSckRateEh+0x150>)
   8b5d2:	4c09      	ldr	r4, [pc, #36]	; (8b5f8 <_ZN7Sd2Card10setSckRateEh+0x134>)
   8b5d4:	47a0      	blx	r4
   8b5d6:	4b09      	ldr	r3, [pc, #36]	; (8b5fc <_ZN7Sd2Card10setSckRateEh+0x138>)
   8b5d8:	f107 0238 	add.w	r2, r7, #56	; 0x38
   8b5dc:	e892 0003 	ldmia.w	r2, {r0, r1}
   8b5e0:	6018      	str	r0, [r3, #0]
   8b5e2:	3304      	adds	r3, #4
   8b5e4:	7019      	strb	r1, [r3, #0]
  }
#endif // USE_SPI_LIB
  return true;
   8b5e6:	2301      	movs	r3, #1
}
   8b5e8:	4618      	mov	r0, r3
   8b5ea:	3744      	adds	r7, #68	; 0x44
   8b5ec:	46bd      	mov	sp, r7
   8b5ee:	bd90      	pop	{r4, r7, pc}
   8b5f0:	0008ad01 	.word	0x0008ad01
   8b5f4:	017d7840 	.word	0x017d7840
   8b5f8:	0008ad39 	.word	0x0008ad39
   8b5fc:	2007190c 	.word	0x2007190c
   8b600:	003d0900 	.word	0x003d0900
   8b604:	001e8480 	.word	0x001e8480
   8b608:	000f4240 	.word	0x000f4240
   8b60c:	0007a120 	.word	0x0007a120
   8b610:	0003d090 	.word	0x0003d090
   8b614:	0001e848 	.word	0x0001e848

0008b618 <_ZN7Sd2Card11waitNotBusyEt>:
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
   8b618:	b580      	push	{r7, lr}
   8b61a:	b084      	sub	sp, #16
   8b61c:	af00      	add	r7, sp, #0
   8b61e:	6078      	str	r0, [r7, #4]
   8b620:	460b      	mov	r3, r1
   8b622:	807b      	strh	r3, [r7, #2]
  uint16_t t0 = millis();
   8b624:	4b11      	ldr	r3, [pc, #68]	; (8b66c <_ZN7Sd2Card11waitNotBusyEt+0x54>)
   8b626:	4798      	blx	r3
   8b628:	4603      	mov	r3, r0
   8b62a:	81fb      	strh	r3, [r7, #14]
  do {
    if (spiRec() == 0XFF) return true;
   8b62c:	4b10      	ldr	r3, [pc, #64]	; (8b670 <_ZN7Sd2Card11waitNotBusyEt+0x58>)
   8b62e:	4798      	blx	r3
   8b630:	4603      	mov	r3, r0
   8b632:	2bff      	cmp	r3, #255	; 0xff
   8b634:	bf0c      	ite	eq
   8b636:	2301      	moveq	r3, #1
   8b638:	2300      	movne	r3, #0
   8b63a:	b2db      	uxtb	r3, r3
   8b63c:	2b00      	cmp	r3, #0
   8b63e:	d001      	beq.n	8b644 <_ZN7Sd2Card11waitNotBusyEt+0x2c>
   8b640:	2301      	movs	r3, #1
   8b642:	e00f      	b.n	8b664 <_ZN7Sd2Card11waitNotBusyEt+0x4c>
  }
  while (((uint16_t)millis() - t0) < timeoutMillis);
   8b644:	4b09      	ldr	r3, [pc, #36]	; (8b66c <_ZN7Sd2Card11waitNotBusyEt+0x54>)
   8b646:	4798      	blx	r3
   8b648:	4603      	mov	r3, r0
   8b64a:	b29a      	uxth	r2, r3
   8b64c:	89fb      	ldrh	r3, [r7, #14]
   8b64e:	1ad2      	subs	r2, r2, r3
   8b650:	887b      	ldrh	r3, [r7, #2]
}
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(uint16_t timeoutMillis) {
  uint16_t t0 = millis();
  do {
   8b652:	429a      	cmp	r2, r3
   8b654:	bfb4      	ite	lt
   8b656:	2301      	movlt	r3, #1
   8b658:	2300      	movge	r3, #0
   8b65a:	b2db      	uxtb	r3, r3
   8b65c:	2b00      	cmp	r3, #0
   8b65e:	d000      	beq.n	8b662 <_ZN7Sd2Card11waitNotBusyEt+0x4a>
   8b660:	e7e4      	b.n	8b62c <_ZN7Sd2Card11waitNotBusyEt+0x14>
    if (spiRec() == 0XFF) return true;
  }
  while (((uint16_t)millis() - t0) < timeoutMillis);
  return false;
   8b662:	2300      	movs	r3, #0
}
   8b664:	4618      	mov	r0, r3
   8b666:	3710      	adds	r7, #16
   8b668:	46bd      	mov	sp, r7
   8b66a:	bd80      	pop	{r7, pc}
   8b66c:	00081bb1 	.word	0x00081bb1
   8b670:	0008aeed 	.word	0x0008aeed

0008b674 <_ZN7Sd2Card14waitStartBlockEv>:
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
   8b674:	b580      	push	{r7, lr}
   8b676:	b084      	sub	sp, #16
   8b678:	af00      	add	r7, sp, #0
   8b67a:	6078      	str	r0, [r7, #4]
  uint16_t t0 = millis();
   8b67c:	4b1c      	ldr	r3, [pc, #112]	; (8b6f0 <_ZN7Sd2Card14waitStartBlockEv+0x7c>)
   8b67e:	4798      	blx	r3
   8b680:	4603      	mov	r3, r0
   8b682:	81fb      	strh	r3, [r7, #14]
  while ((status_ = spiRec()) == 0XFF) {
   8b684:	4b1b      	ldr	r3, [pc, #108]	; (8b6f4 <_ZN7Sd2Card14waitStartBlockEv+0x80>)
   8b686:	4798      	blx	r3
   8b688:	4603      	mov	r3, r0
   8b68a:	461a      	mov	r2, r3
   8b68c:	687b      	ldr	r3, [r7, #4]
   8b68e:	72da      	strb	r2, [r3, #11]
   8b690:	687b      	ldr	r3, [r7, #4]
   8b692:	7adb      	ldrb	r3, [r3, #11]
   8b694:	2bff      	cmp	r3, #255	; 0xff
   8b696:	bf0c      	ite	eq
   8b698:	2301      	moveq	r3, #1
   8b69a:	2300      	movne	r3, #0
   8b69c:	b2db      	uxtb	r3, r3
   8b69e:	2b00      	cmp	r3, #0
   8b6a0:	d012      	beq.n	8b6c8 <_ZN7Sd2Card14waitStartBlockEv+0x54>
    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
   8b6a2:	4b13      	ldr	r3, [pc, #76]	; (8b6f0 <_ZN7Sd2Card14waitStartBlockEv+0x7c>)
   8b6a4:	4798      	blx	r3
   8b6a6:	4603      	mov	r3, r0
   8b6a8:	b29a      	uxth	r2, r3
   8b6aa:	89fb      	ldrh	r3, [r7, #14]
   8b6ac:	1ad3      	subs	r3, r2, r3
   8b6ae:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   8b6b2:	bfcc      	ite	gt
   8b6b4:	2301      	movgt	r3, #1
   8b6b6:	2300      	movle	r3, #0
   8b6b8:	b2db      	uxtb	r3, r3
   8b6ba:	2b00      	cmp	r3, #0
   8b6bc:	d0e2      	beq.n	8b684 <_ZN7Sd2Card14waitStartBlockEv+0x10>
      error(SD_CARD_ERROR_READ_TIMEOUT);
   8b6be:	210f      	movs	r1, #15
   8b6c0:	6878      	ldr	r0, [r7, #4]
   8b6c2:	4b0d      	ldr	r3, [pc, #52]	; (8b6f8 <_ZN7Sd2Card14waitStartBlockEv+0x84>)
   8b6c4:	4798      	blx	r3
      goto fail;
   8b6c6:	e00a      	b.n	8b6de <_ZN7Sd2Card14waitStartBlockEv+0x6a>
    }
  }
  if (status_ != DATA_START_BLOCK) {
   8b6c8:	687b      	ldr	r3, [r7, #4]
   8b6ca:	7adb      	ldrb	r3, [r3, #11]
   8b6cc:	2bfe      	cmp	r3, #254	; 0xfe
   8b6ce:	d004      	beq.n	8b6da <_ZN7Sd2Card14waitStartBlockEv+0x66>
    error(SD_CARD_ERROR_READ);
   8b6d0:	210d      	movs	r1, #13
   8b6d2:	6878      	ldr	r0, [r7, #4]
   8b6d4:	4b08      	ldr	r3, [pc, #32]	; (8b6f8 <_ZN7Sd2Card14waitStartBlockEv+0x84>)
   8b6d6:	4798      	blx	r3
    goto fail;
   8b6d8:	e001      	b.n	8b6de <_ZN7Sd2Card14waitStartBlockEv+0x6a>
  }
  return true;
   8b6da:	2301      	movs	r3, #1
   8b6dc:	e003      	b.n	8b6e6 <_ZN7Sd2Card14waitStartBlockEv+0x72>

 fail:
  chipSelectHigh();
   8b6de:	6878      	ldr	r0, [r7, #4]
   8b6e0:	4b06      	ldr	r3, [pc, #24]	; (8b6fc <_ZN7Sd2Card14waitStartBlockEv+0x88>)
   8b6e2:	4798      	blx	r3
  return false;
   8b6e4:	2300      	movs	r3, #0
}
   8b6e6:	4618      	mov	r0, r3
   8b6e8:	3710      	adds	r7, #16
   8b6ea:	46bd      	mov	sp, r7
   8b6ec:	bd80      	pop	{r7, pc}
   8b6ee:	bf00      	nop
   8b6f0:	00081bb1 	.word	0x00081bb1
   8b6f4:	0008aeed 	.word	0x0008aeed
   8b6f8:	0008ad01 	.word	0x0008ad01
   8b6fc:	0008afd5 	.word	0x0008afd5

0008b700 <_ZN7Sd2Card10writeBlockEmPKh>:
 * \param[in] blockNumber Logical block to be written.
 * \param[in] src Pointer to the location of the data to be written.
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {
   8b700:	b580      	push	{r7, lr}
   8b702:	b084      	sub	sp, #16
   8b704:	af00      	add	r7, sp, #0
   8b706:	60f8      	str	r0, [r7, #12]
   8b708:	60b9      	str	r1, [r7, #8]
   8b70a:	607a      	str	r2, [r7, #4]
#if SD_PROTECT_BLOCK_ZERO
  // don't allow write to first block
  if (blockNumber == 0) {
   8b70c:	68bb      	ldr	r3, [r7, #8]
   8b70e:	2b00      	cmp	r3, #0
   8b710:	d104      	bne.n	8b71c <_ZN7Sd2Card10writeBlockEmPKh+0x1c>
    error(SD_CARD_ERROR_WRITE_BLOCK_ZERO);
   8b712:	2112      	movs	r1, #18
   8b714:	68f8      	ldr	r0, [r7, #12]
   8b716:	4b33      	ldr	r3, [pc, #204]	; (8b7e4 <_ZN7Sd2Card10writeBlockEmPKh+0xe4>)
   8b718:	4798      	blx	r3
    goto fail;
   8b71a:	e05b      	b.n	8b7d4 <_ZN7Sd2Card10writeBlockEmPKh+0xd4>
  }
#endif  // SD_PROTECT_BLOCK_ZERO

  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
   8b71c:	68f8      	ldr	r0, [r7, #12]
   8b71e:	4b32      	ldr	r3, [pc, #200]	; (8b7e8 <_ZN7Sd2Card10writeBlockEmPKh+0xe8>)
   8b720:	4798      	blx	r3
   8b722:	4603      	mov	r3, r0
   8b724:	2b03      	cmp	r3, #3
   8b726:	bf14      	ite	ne
   8b728:	2301      	movne	r3, #1
   8b72a:	2300      	moveq	r3, #0
   8b72c:	b2db      	uxtb	r3, r3
   8b72e:	2b00      	cmp	r3, #0
   8b730:	d002      	beq.n	8b738 <_ZN7Sd2Card10writeBlockEmPKh+0x38>
   8b732:	68bb      	ldr	r3, [r7, #8]
   8b734:	025b      	lsls	r3, r3, #9
   8b736:	60bb      	str	r3, [r7, #8]
  if (cardCommand(CMD24, blockNumber)) {
   8b738:	68ba      	ldr	r2, [r7, #8]
   8b73a:	2118      	movs	r1, #24
   8b73c:	68f8      	ldr	r0, [r7, #12]
   8b73e:	4b2b      	ldr	r3, [pc, #172]	; (8b7ec <_ZN7Sd2Card10writeBlockEmPKh+0xec>)
   8b740:	4798      	blx	r3
   8b742:	4603      	mov	r3, r0
   8b744:	2b00      	cmp	r3, #0
   8b746:	bf14      	ite	ne
   8b748:	2301      	movne	r3, #1
   8b74a:	2300      	moveq	r3, #0
   8b74c:	b2db      	uxtb	r3, r3
   8b74e:	2b00      	cmp	r3, #0
   8b750:	d004      	beq.n	8b75c <_ZN7Sd2Card10writeBlockEmPKh+0x5c>
    error(SD_CARD_ERROR_CMD24);
   8b752:	2104      	movs	r1, #4
   8b754:	68f8      	ldr	r0, [r7, #12]
   8b756:	4b23      	ldr	r3, [pc, #140]	; (8b7e4 <_ZN7Sd2Card10writeBlockEmPKh+0xe4>)
   8b758:	4798      	blx	r3
    goto fail;
   8b75a:	e03b      	b.n	8b7d4 <_ZN7Sd2Card10writeBlockEmPKh+0xd4>
  }
  if (!writeData(DATA_START_BLOCK, src)) goto fail;
   8b75c:	687a      	ldr	r2, [r7, #4]
   8b75e:	21fe      	movs	r1, #254	; 0xfe
   8b760:	68f8      	ldr	r0, [r7, #12]
   8b762:	4b23      	ldr	r3, [pc, #140]	; (8b7f0 <_ZN7Sd2Card10writeBlockEmPKh+0xf0>)
   8b764:	4798      	blx	r3
   8b766:	4603      	mov	r3, r0
   8b768:	2b00      	cmp	r3, #0
   8b76a:	bf0c      	ite	eq
   8b76c:	2301      	moveq	r3, #1
   8b76e:	2300      	movne	r3, #0
   8b770:	b2db      	uxtb	r3, r3
   8b772:	2b00      	cmp	r3, #0
   8b774:	d12d      	bne.n	8b7d2 <_ZN7Sd2Card10writeBlockEmPKh+0xd2>

  // wait for flash programming to complete
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
   8b776:	f44f 7116 	mov.w	r1, #600	; 0x258
   8b77a:	68f8      	ldr	r0, [r7, #12]
   8b77c:	4b1d      	ldr	r3, [pc, #116]	; (8b7f4 <_ZN7Sd2Card10writeBlockEmPKh+0xf4>)
   8b77e:	4798      	blx	r3
   8b780:	4603      	mov	r3, r0
   8b782:	2b00      	cmp	r3, #0
   8b784:	bf0c      	ite	eq
   8b786:	2301      	moveq	r3, #1
   8b788:	2300      	movne	r3, #0
   8b78a:	b2db      	uxtb	r3, r3
   8b78c:	2b00      	cmp	r3, #0
   8b78e:	d004      	beq.n	8b79a <_ZN7Sd2Card10writeBlockEmPKh+0x9a>
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
   8b790:	2115      	movs	r1, #21
   8b792:	68f8      	ldr	r0, [r7, #12]
   8b794:	4b13      	ldr	r3, [pc, #76]	; (8b7e4 <_ZN7Sd2Card10writeBlockEmPKh+0xe4>)
   8b796:	4798      	blx	r3
    goto fail;
   8b798:	e01c      	b.n	8b7d4 <_ZN7Sd2Card10writeBlockEmPKh+0xd4>
  }
  // response is r2 so get and check two bytes for nonzero
  if (cardCommand(CMD13, 0) || spiRec()) {
   8b79a:	2200      	movs	r2, #0
   8b79c:	210d      	movs	r1, #13
   8b79e:	68f8      	ldr	r0, [r7, #12]
   8b7a0:	4b12      	ldr	r3, [pc, #72]	; (8b7ec <_ZN7Sd2Card10writeBlockEmPKh+0xec>)
   8b7a2:	4798      	blx	r3
   8b7a4:	4603      	mov	r3, r0
   8b7a6:	2b00      	cmp	r3, #0
   8b7a8:	d104      	bne.n	8b7b4 <_ZN7Sd2Card10writeBlockEmPKh+0xb4>
   8b7aa:	4b13      	ldr	r3, [pc, #76]	; (8b7f8 <_ZN7Sd2Card10writeBlockEmPKh+0xf8>)
   8b7ac:	4798      	blx	r3
   8b7ae:	4603      	mov	r3, r0
   8b7b0:	2b00      	cmp	r3, #0
   8b7b2:	d001      	beq.n	8b7b8 <_ZN7Sd2Card10writeBlockEmPKh+0xb8>
   8b7b4:	2301      	movs	r3, #1
   8b7b6:	e000      	b.n	8b7ba <_ZN7Sd2Card10writeBlockEmPKh+0xba>
   8b7b8:	2300      	movs	r3, #0
   8b7ba:	2b00      	cmp	r3, #0
   8b7bc:	d004      	beq.n	8b7c8 <_ZN7Sd2Card10writeBlockEmPKh+0xc8>
    error(SD_CARD_ERROR_WRITE_PROGRAMMING);
   8b7be:	2114      	movs	r1, #20
   8b7c0:	68f8      	ldr	r0, [r7, #12]
   8b7c2:	4b08      	ldr	r3, [pc, #32]	; (8b7e4 <_ZN7Sd2Card10writeBlockEmPKh+0xe4>)
   8b7c4:	4798      	blx	r3
    goto fail;
   8b7c6:	e005      	b.n	8b7d4 <_ZN7Sd2Card10writeBlockEmPKh+0xd4>
  }
  chipSelectHigh();
   8b7c8:	68f8      	ldr	r0, [r7, #12]
   8b7ca:	4b0c      	ldr	r3, [pc, #48]	; (8b7fc <_ZN7Sd2Card10writeBlockEmPKh+0xfc>)
   8b7cc:	4798      	blx	r3
  return true;
   8b7ce:	2301      	movs	r3, #1
   8b7d0:	e004      	b.n	8b7dc <_ZN7Sd2Card10writeBlockEmPKh+0xdc>
  if (type() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
  if (cardCommand(CMD24, blockNumber)) {
    error(SD_CARD_ERROR_CMD24);
    goto fail;
  }
  if (!writeData(DATA_START_BLOCK, src)) goto fail;
   8b7d2:	bf00      	nop
  }
  chipSelectHigh();
  return true;

 fail:
  chipSelectHigh();
   8b7d4:	68f8      	ldr	r0, [r7, #12]
   8b7d6:	4b09      	ldr	r3, [pc, #36]	; (8b7fc <_ZN7Sd2Card10writeBlockEmPKh+0xfc>)
   8b7d8:	4798      	blx	r3
  return false;
   8b7da:	2300      	movs	r3, #0
}
   8b7dc:	4618      	mov	r0, r3
   8b7de:	3710      	adds	r7, #16
   8b7e0:	46bd      	mov	sp, r7
   8b7e2:	bd80      	pop	{r7, pc}
   8b7e4:	0008ad01 	.word	0x0008ad01
   8b7e8:	0008acb5 	.word	0x0008acb5
   8b7ec:	0008af09 	.word	0x0008af09
   8b7f0:	0008b801 	.word	0x0008b801
   8b7f4:	0008b619 	.word	0x0008b619
   8b7f8:	0008aeed 	.word	0x0008aeed
   8b7fc:	0008afd5 	.word	0x0008afd5

0008b800 <_ZN7Sd2Card9writeDataEhPKh>:
  }
  return writeData(WRITE_MULTIPLE_TOKEN, src);
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
   8b800:	b580      	push	{r7, lr}
   8b802:	b086      	sub	sp, #24
   8b804:	af00      	add	r7, sp, #0
   8b806:	60f8      	str	r0, [r7, #12]
   8b808:	460b      	mov	r3, r1
   8b80a:	607a      	str	r2, [r7, #4]
   8b80c:	72fb      	strb	r3, [r7, #11]
  // wait for last data byte
  while (!(SPSR & (1 << SPIF)))
    ;

#else  // OPTIMIZE_HARDWARE_SPI
  spiSend(token);
   8b80e:	7afb      	ldrb	r3, [r7, #11]
   8b810:	4618      	mov	r0, r3
   8b812:	4b19      	ldr	r3, [pc, #100]	; (8b878 <_ZN7Sd2Card9writeDataEhPKh+0x78>)
   8b814:	4798      	blx	r3
  for (uint16_t i = 0; i < 512; i++) {
   8b816:	2300      	movs	r3, #0
   8b818:	82fb      	strh	r3, [r7, #22]
   8b81a:	8afb      	ldrh	r3, [r7, #22]
   8b81c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   8b820:	d20a      	bcs.n	8b838 <_ZN7Sd2Card9writeDataEhPKh+0x38>
    spiSend(src[i]);
   8b822:	8afb      	ldrh	r3, [r7, #22]
   8b824:	687a      	ldr	r2, [r7, #4]
   8b826:	4413      	add	r3, r2
   8b828:	781b      	ldrb	r3, [r3, #0]
   8b82a:	4618      	mov	r0, r3
   8b82c:	4b12      	ldr	r3, [pc, #72]	; (8b878 <_ZN7Sd2Card9writeDataEhPKh+0x78>)
   8b82e:	4798      	blx	r3
  while (!(SPSR & (1 << SPIF)))
    ;

#else  // OPTIMIZE_HARDWARE_SPI
  spiSend(token);
  for (uint16_t i = 0; i < 512; i++) {
   8b830:	8afb      	ldrh	r3, [r7, #22]
   8b832:	3301      	adds	r3, #1
   8b834:	82fb      	strh	r3, [r7, #22]
   8b836:	e7f0      	b.n	8b81a <_ZN7Sd2Card9writeDataEhPKh+0x1a>
    spiSend(src[i]);
  }
#endif  // OPTIMIZE_HARDWARE_SPI
  spiSend(0xff);  // dummy crc
   8b838:	20ff      	movs	r0, #255	; 0xff
   8b83a:	4b0f      	ldr	r3, [pc, #60]	; (8b878 <_ZN7Sd2Card9writeDataEhPKh+0x78>)
   8b83c:	4798      	blx	r3
  spiSend(0xff);  // dummy crc
   8b83e:	20ff      	movs	r0, #255	; 0xff
   8b840:	4b0d      	ldr	r3, [pc, #52]	; (8b878 <_ZN7Sd2Card9writeDataEhPKh+0x78>)
   8b842:	4798      	blx	r3

  status_ = spiRec();
   8b844:	4b0d      	ldr	r3, [pc, #52]	; (8b87c <_ZN7Sd2Card9writeDataEhPKh+0x7c>)
   8b846:	4798      	blx	r3
   8b848:	4603      	mov	r3, r0
   8b84a:	461a      	mov	r2, r3
   8b84c:	68fb      	ldr	r3, [r7, #12]
   8b84e:	72da      	strb	r2, [r3, #11]
  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
   8b850:	68fb      	ldr	r3, [r7, #12]
   8b852:	7adb      	ldrb	r3, [r3, #11]
   8b854:	f003 031f 	and.w	r3, r3, #31
   8b858:	2b05      	cmp	r3, #5
   8b85a:	d008      	beq.n	8b86e <_ZN7Sd2Card9writeDataEhPKh+0x6e>
    error(SD_CARD_ERROR_WRITE);
   8b85c:	2111      	movs	r1, #17
   8b85e:	68f8      	ldr	r0, [r7, #12]
   8b860:	4b07      	ldr	r3, [pc, #28]	; (8b880 <_ZN7Sd2Card9writeDataEhPKh+0x80>)
   8b862:	4798      	blx	r3
    chipSelectHigh();
   8b864:	68f8      	ldr	r0, [r7, #12]
   8b866:	4b07      	ldr	r3, [pc, #28]	; (8b884 <_ZN7Sd2Card9writeDataEhPKh+0x84>)
   8b868:	4798      	blx	r3
    return false;
   8b86a:	2300      	movs	r3, #0
   8b86c:	e000      	b.n	8b870 <_ZN7Sd2Card9writeDataEhPKh+0x70>
  }
  return true;
   8b86e:	2301      	movs	r3, #1
}
   8b870:	4618      	mov	r0, r3
   8b872:	3718      	adds	r7, #24
   8b874:	46bd      	mov	sp, r7
   8b876:	bd80      	pop	{r7, pc}
   8b878:	0008aec5 	.word	0x0008aec5
   8b87c:	0008aeed 	.word	0x0008aeed
   8b880:	0008ad01 	.word	0x0008ad01
   8b884:	0008afd5 	.word	0x0008afd5

0008b888 <_Z41__static_initialization_and_destruction_0ii>:

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
   8b888:	b580      	push	{r7, lr}
   8b88a:	b082      	sub	sp, #8
   8b88c:	af00      	add	r7, sp, #0
   8b88e:	6078      	str	r0, [r7, #4]
   8b890:	6039      	str	r1, [r7, #0]
   8b892:	687b      	ldr	r3, [r7, #4]
   8b894:	2b01      	cmp	r3, #1
   8b896:	d107      	bne.n	8b8a8 <_Z41__static_initialization_and_destruction_0ii+0x20>
   8b898:	683b      	ldr	r3, [r7, #0]
   8b89a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   8b89e:	4293      	cmp	r3, r2
   8b8a0:	d102      	bne.n	8b8a8 <_Z41__static_initialization_and_destruction_0ii+0x20>
#include "Sd2Card.h"
//------------------------------------------------------------------------------
#ifndef SOFTWARE_SPI
#ifdef USE_SPI_LIB
#include "../SPIArduino.h"
static SPISettings settings;
   8b8a2:	4803      	ldr	r0, [pc, #12]	; (8b8b0 <_Z41__static_initialization_and_destruction_0ii+0x28>)
   8b8a4:	4b03      	ldr	r3, [pc, #12]	; (8b8b4 <_Z41__static_initialization_and_destruction_0ii+0x2c>)
   8b8a6:	4798      	blx	r3

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
   8b8a8:	bf00      	nop
   8b8aa:	3708      	adds	r7, #8
   8b8ac:	46bd      	mov	sp, r7
   8b8ae:	bd80      	pop	{r7, pc}
   8b8b0:	2007190c 	.word	0x2007190c
   8b8b4:	0008ad69 	.word	0x0008ad69

0008b8b8 <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm>:
   8b8b8:	b580      	push	{r7, lr}
   8b8ba:	af00      	add	r7, sp, #0
   8b8bc:	f64f 71ff 	movw	r1, #65535	; 0xffff
   8b8c0:	2001      	movs	r0, #1
   8b8c2:	4b01      	ldr	r3, [pc, #4]	; (8b8c8 <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm+0x10>)
   8b8c4:	4798      	blx	r3
   8b8c6:	bd80      	pop	{r7, pc}
   8b8c8:	0008b889 	.word	0x0008b889

0008b8cc <_ZL11DIR_IS_FILEPK14directoryEntry>:
  return (dir->attributes & DIR_ATT_LONG_NAME_MASK) == DIR_ATT_LONG_NAME;
}
/** Mask for file/subdirectory tests */
uint8_t const DIR_ATT_FILE_TYPE_MASK = (DIR_ATT_VOLUME_ID | DIR_ATT_DIRECTORY);
/** Directory entry is for a file */
static inline uint8_t DIR_IS_FILE(const dir_t* dir) {
   8b8cc:	b480      	push	{r7}
   8b8ce:	b083      	sub	sp, #12
   8b8d0:	af00      	add	r7, sp, #0
   8b8d2:	6078      	str	r0, [r7, #4]
  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == 0;
   8b8d4:	687b      	ldr	r3, [r7, #4]
   8b8d6:	7adb      	ldrb	r3, [r3, #11]
   8b8d8:	f003 0318 	and.w	r3, r3, #24
   8b8dc:	2b00      	cmp	r3, #0
   8b8de:	bf0c      	ite	eq
   8b8e0:	2301      	moveq	r3, #1
   8b8e2:	2300      	movne	r3, #0
   8b8e4:	b2db      	uxtb	r3, r3
}
   8b8e6:	4618      	mov	r0, r3
   8b8e8:	370c      	adds	r7, #12
   8b8ea:	46bd      	mov	sp, r7
   8b8ec:	bc80      	pop	{r7}
   8b8ee:	4770      	bx	lr

0008b8f0 <_ZL13DIR_IS_SUBDIRPK14directoryEntry>:
/** Directory entry is for a subdirectory */
static inline uint8_t DIR_IS_SUBDIR(const dir_t* dir) {
   8b8f0:	b480      	push	{r7}
   8b8f2:	b083      	sub	sp, #12
   8b8f4:	af00      	add	r7, sp, #0
   8b8f6:	6078      	str	r0, [r7, #4]
  return (dir->attributes & DIR_ATT_FILE_TYPE_MASK) == DIR_ATT_DIRECTORY;
   8b8f8:	687b      	ldr	r3, [r7, #4]
   8b8fa:	7adb      	ldrb	r3, [r3, #11]
   8b8fc:	f003 0318 	and.w	r3, r3, #24
   8b900:	2b10      	cmp	r3, #16
   8b902:	bf0c      	ite	eq
   8b904:	2301      	moveq	r3, #1
   8b906:	2300      	movne	r3, #0
   8b908:	b2db      	uxtb	r3, r3
}
   8b90a:	4618      	mov	r0, r3
   8b90c:	370c      	adds	r7, #12
   8b90e:	46bd      	mov	sp, r7
   8b910:	bc80      	pop	{r7}
   8b912:	4770      	bx	lr

0008b914 <_ZNK6SdFile6isFileEv>:
  /** \return The first cluster number for a file or directory. */
  uint32_t firstCluster(void) const {return firstCluster_;}
  /** \return True if this is a SdFile for a directory else false. */
  uint8_t isDir(void) const {return type_ >= FAT_FILE_TYPE_MIN_DIR;}
  /** \return True if this is a SdFile for a file else false. */
  uint8_t isFile(void) const {return type_ == FAT_FILE_TYPE_NORMAL;}
   8b914:	b480      	push	{r7}
   8b916:	b083      	sub	sp, #12
   8b918:	af00      	add	r7, sp, #0
   8b91a:	6078      	str	r0, [r7, #4]
   8b91c:	687b      	ldr	r3, [r7, #4]
   8b91e:	7a5b      	ldrb	r3, [r3, #9]
   8b920:	2b01      	cmp	r3, #1
   8b922:	bf0c      	ite	eq
   8b924:	2301      	moveq	r3, #1
   8b926:	2300      	movne	r3, #0
   8b928:	b2db      	uxtb	r3, r3
   8b92a:	4618      	mov	r0, r3
   8b92c:	370c      	adds	r7, #12
   8b92e:	46bd      	mov	sp, r7
   8b930:	bc80      	pop	{r7}
   8b932:	4770      	bx	lr

0008b934 <_ZN6SdFile7seekEndEv>:
  }
  /**
   *  Set the files current position to end of file.  Useful to position
   *  a file for append. See seekSet().
   */
  uint8_t seekEnd(void) {return seekSet(fileSize_);}
   8b934:	b580      	push	{r7, lr}
   8b936:	b082      	sub	sp, #8
   8b938:	af00      	add	r7, sp, #0
   8b93a:	6078      	str	r0, [r7, #4]
   8b93c:	687b      	ldr	r3, [r7, #4]
   8b93e:	69db      	ldr	r3, [r3, #28]
   8b940:	4619      	mov	r1, r3
   8b942:	6878      	ldr	r0, [r7, #4]
   8b944:	4b03      	ldr	r3, [pc, #12]	; (8b954 <_ZN6SdFile7seekEndEv+0x20>)
   8b946:	4798      	blx	r3
   8b948:	4603      	mov	r3, r0
   8b94a:	4618      	mov	r0, r3
   8b94c:	3708      	adds	r7, #8
   8b94e:	46bd      	mov	sp, r7
   8b950:	bd80      	pop	{r7, pc}
   8b952:	bf00      	nop
   8b954:	0008c429 	.word	0x0008c429

0008b958 <_ZNK6SdFile14unbufferedReadEv>:
   * \return The file or directory type.
   */
  uint8_t type(void) const {return type_;}
  uint8_t truncate(uint32_t size);
  /** \return Unbuffered read flag. */
  uint8_t unbufferedRead(void) const {
   8b958:	b480      	push	{r7}
   8b95a:	b083      	sub	sp, #12
   8b95c:	af00      	add	r7, sp, #0
   8b95e:	6078      	str	r0, [r7, #4]
    return flags_ & F_FILE_UNBUFFERED_READ;
   8b960:	687b      	ldr	r3, [r7, #4]
   8b962:	7a1b      	ldrb	r3, [r3, #8]
   8b964:	f003 0340 	and.w	r3, r3, #64	; 0x40
   8b968:	b2db      	uxtb	r3, r3
  }
   8b96a:	4618      	mov	r0, r3
   8b96c:	370c      	adds	r7, #12
   8b96e:	46bd      	mov	sp, r7
   8b970:	bc80      	pop	{r7}
   8b972:	4770      	bx	lr

0008b974 <_ZNK8SdVolume7fatTypeEv>:
  /** \return The number of FAT structures on the volume. */
  uint8_t fatCount(void) const {return fatCount_;}
  /** \return The logical block number for the start of the first FAT. */
  uint32_t fatStartBlock(void) const {return fatStartBlock_;}
  /** \return The FAT type of the volume. Values are 12, 16 or 32. */
  uint8_t fatType(void) const {return fatType_;}
   8b974:	b480      	push	{r7}
   8b976:	b083      	sub	sp, #12
   8b978:	af00      	add	r7, sp, #0
   8b97a:	6078      	str	r0, [r7, #4]
   8b97c:	687b      	ldr	r3, [r7, #4]
   8b97e:	f893 3020 	ldrb.w	r3, [r3, #32]
   8b982:	4618      	mov	r0, r3
   8b984:	370c      	adds	r7, #12
   8b986:	46bd      	mov	sp, r7
   8b988:	bc80      	pop	{r7}
   8b98a:	4770      	bx	lr

0008b98c <_ZNK8SdVolume17rootDirEntryCountEv>:
  /** \return The number of entries in the root directory for FAT16 volumes. */
  uint32_t rootDirEntryCount(void) const {return rootDirEntryCount_;}
   8b98c:	b480      	push	{r7}
   8b98e:	b083      	sub	sp, #12
   8b990:	af00      	add	r7, sp, #0
   8b992:	6078      	str	r0, [r7, #4]
   8b994:	687b      	ldr	r3, [r7, #4]
   8b996:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
   8b998:	4618      	mov	r0, r3
   8b99a:	370c      	adds	r7, #12
   8b99c:	46bd      	mov	sp, r7
   8b99e:	bc80      	pop	{r7}
   8b9a0:	4770      	bx	lr
   8b9a2:	bf00      	nop

0008b9a4 <_ZNK8SdVolume12rootDirStartEv>:
  /** \return The logical block number for the start of the root directory
       on FAT16 volumes or the first cluster number on FAT32 volumes. */
  uint32_t rootDirStart(void) const {return rootDirStart_;}
   8b9a4:	b480      	push	{r7}
   8b9a6:	b083      	sub	sp, #12
   8b9a8:	af00      	add	r7, sp, #0
   8b9aa:	6078      	str	r0, [r7, #4]
   8b9ac:	687b      	ldr	r3, [r7, #4]
   8b9ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8b9b0:	4618      	mov	r0, r3
   8b9b2:	370c      	adds	r7, #12
   8b9b4:	46bd      	mov	sp, r7
   8b9b6:	bc80      	pop	{r7}
   8b9b8:	4770      	bx	lr
   8b9ba:	bf00      	nop

0008b9bc <_ZNK8SdVolume14blockOfClusterEm>:
  uint8_t fatType_;             // volume type (12, 16, OR 32)
  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
   8b9bc:	b480      	push	{r7}
   8b9be:	b083      	sub	sp, #12
   8b9c0:	af00      	add	r7, sp, #0
   8b9c2:	6078      	str	r0, [r7, #4]
   8b9c4:	6039      	str	r1, [r7, #0]
          return (position >> 9) & (blocksPerCluster_ - 1);}
   8b9c6:	683b      	ldr	r3, [r7, #0]
   8b9c8:	0a5b      	lsrs	r3, r3, #9
   8b9ca:	b2da      	uxtb	r2, r3
   8b9cc:	687b      	ldr	r3, [r7, #4]
   8b9ce:	791b      	ldrb	r3, [r3, #4]
   8b9d0:	3b01      	subs	r3, #1
   8b9d2:	b2db      	uxtb	r3, r3
   8b9d4:	4013      	ands	r3, r2
   8b9d6:	b2db      	uxtb	r3, r3
   8b9d8:	4618      	mov	r0, r3
   8b9da:	370c      	adds	r7, #12
   8b9dc:	46bd      	mov	sp, r7
   8b9de:	bc80      	pop	{r7}
   8b9e0:	4770      	bx	lr
   8b9e2:	bf00      	nop

0008b9e4 <_ZNK8SdVolume17clusterStartBlockEm>:
  uint32_t clusterStartBlock(uint32_t cluster) const {
   8b9e4:	b480      	push	{r7}
   8b9e6:	b083      	sub	sp, #12
   8b9e8:	af00      	add	r7, sp, #0
   8b9ea:	6078      	str	r0, [r7, #4]
   8b9ec:	6039      	str	r1, [r7, #0]
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
   8b9ee:	687b      	ldr	r3, [r7, #4]
   8b9f0:	695a      	ldr	r2, [r3, #20]
   8b9f2:	683b      	ldr	r3, [r7, #0]
   8b9f4:	3b02      	subs	r3, #2
   8b9f6:	6879      	ldr	r1, [r7, #4]
   8b9f8:	7c09      	ldrb	r1, [r1, #16]
   8b9fa:	408b      	lsls	r3, r1
   8b9fc:	4413      	add	r3, r2
   8b9fe:	4618      	mov	r0, r3
   8ba00:	370c      	adds	r7, #12
   8ba02:	46bd      	mov	sp, r7
   8ba04:	bc80      	pop	{r7}
   8ba06:	4770      	bx	lr

0008ba08 <_ZN8SdVolume13cacheSetDirtyEv>:
  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
           return clusterStartBlock(cluster) + blockOfCluster(position);}
  static uint8_t cacheFlush(void);
  static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
  static void cacheSetDirty(void) {cacheDirty_ |= CACHE_FOR_WRITE;}
   8ba08:	b480      	push	{r7}
   8ba0a:	af00      	add	r7, sp, #0
   8ba0c:	4b05      	ldr	r3, [pc, #20]	; (8ba24 <_ZN8SdVolume13cacheSetDirtyEv+0x1c>)
   8ba0e:	781b      	ldrb	r3, [r3, #0]
   8ba10:	2201      	movs	r2, #1
   8ba12:	4313      	orrs	r3, r2
   8ba14:	b2da      	uxtb	r2, r3
   8ba16:	4b03      	ldr	r3, [pc, #12]	; (8ba24 <_ZN8SdVolume13cacheSetDirtyEv+0x1c>)
   8ba18:	701a      	strb	r2, [r3, #0]
   8ba1a:	bf00      	nop
   8ba1c:	46bd      	mov	sp, r7
   8ba1e:	bc80      	pop	{r7}
   8ba20:	4770      	bx	lr
   8ba22:	bf00      	nop
   8ba24:	20071b20 	.word	0x20071b20

0008ba28 <_ZN8SdVolume9fatPutEOCEm>:
  static uint8_t cacheZeroBlock(uint32_t blockNumber);
  uint8_t chainSize(uint32_t beginCluster, uint32_t* size) const;
  uint8_t fatGet(uint32_t cluster, uint32_t* value) const;
  uint8_t fatPut(uint32_t cluster, uint32_t value);
  uint8_t fatPutEOC(uint32_t cluster) {
   8ba28:	b580      	push	{r7, lr}
   8ba2a:	b082      	sub	sp, #8
   8ba2c:	af00      	add	r7, sp, #0
   8ba2e:	6078      	str	r0, [r7, #4]
   8ba30:	6039      	str	r1, [r7, #0]
    return fatPut(cluster, 0x0FFFFFFF);
   8ba32:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
   8ba36:	6839      	ldr	r1, [r7, #0]
   8ba38:	6878      	ldr	r0, [r7, #4]
   8ba3a:	4b03      	ldr	r3, [pc, #12]	; (8ba48 <_ZN8SdVolume9fatPutEOCEm+0x20>)
   8ba3c:	4798      	blx	r3
   8ba3e:	4603      	mov	r3, r0
  }
   8ba40:	4618      	mov	r0, r3
   8ba42:	3708      	adds	r7, #8
   8ba44:	46bd      	mov	sp, r7
   8ba46:	bd80      	pop	{r7, pc}
   8ba48:	0008ce8d 	.word	0x0008ce8d

0008ba4c <_ZNK8SdVolume5isEOCEm>:
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
   8ba4c:	b480      	push	{r7}
   8ba4e:	b083      	sub	sp, #12
   8ba50:	af00      	add	r7, sp, #0
   8ba52:	6078      	str	r0, [r7, #4]
   8ba54:	6039      	str	r1, [r7, #0]
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
   8ba56:	687b      	ldr	r3, [r7, #4]
   8ba58:	f893 3020 	ldrb.w	r3, [r3, #32]
   8ba5c:	2b10      	cmp	r3, #16
   8ba5e:	d102      	bne.n	8ba66 <_ZNK8SdVolume5isEOCEm+0x1a>
   8ba60:	f64f 72f8 	movw	r2, #65528	; 0xfff8
   8ba64:	e000      	b.n	8ba68 <_ZNK8SdVolume5isEOCEm+0x1c>
   8ba66:	4a06      	ldr	r2, [pc, #24]	; (8ba80 <_ZNK8SdVolume5isEOCEm+0x34>)
   8ba68:	683b      	ldr	r3, [r7, #0]
   8ba6a:	429a      	cmp	r2, r3
   8ba6c:	bf94      	ite	ls
   8ba6e:	2301      	movls	r3, #1
   8ba70:	2300      	movhi	r3, #0
   8ba72:	b2db      	uxtb	r3, r3
  }
   8ba74:	4618      	mov	r0, r3
   8ba76:	370c      	adds	r7, #12
   8ba78:	46bd      	mov	sp, r7
   8ba7a:	bc80      	pop	{r7}
   8ba7c:	4770      	bx	lr
   8ba7e:	bf00      	nop
   8ba80:	0ffffff8 	.word	0x0ffffff8

0008ba84 <_ZN8SdVolume8readDataEmttPh>:
  uint8_t readBlock(uint32_t block, uint8_t* dst) {
    return sdCard_->readBlock(block, dst);}
  uint8_t readData(uint32_t block, uint16_t offset,
   8ba84:	b590      	push	{r4, r7, lr}
   8ba86:	b087      	sub	sp, #28
   8ba88:	af02      	add	r7, sp, #8
   8ba8a:	60f8      	str	r0, [r7, #12]
   8ba8c:	60b9      	str	r1, [r7, #8]
   8ba8e:	4611      	mov	r1, r2
   8ba90:	461a      	mov	r2, r3
   8ba92:	460b      	mov	r3, r1
   8ba94:	80fb      	strh	r3, [r7, #6]
   8ba96:	4613      	mov	r3, r2
   8ba98:	80bb      	strh	r3, [r7, #4]
    uint16_t count, uint8_t* dst) {
      return sdCard_->readData(block, offset, count, dst);
   8ba9a:	4b07      	ldr	r3, [pc, #28]	; (8bab8 <_ZN8SdVolume8readDataEmttPh+0x34>)
   8ba9c:	6818      	ldr	r0, [r3, #0]
   8ba9e:	88b9      	ldrh	r1, [r7, #4]
   8baa0:	88fa      	ldrh	r2, [r7, #6]
   8baa2:	6a3b      	ldr	r3, [r7, #32]
   8baa4:	9300      	str	r3, [sp, #0]
   8baa6:	460b      	mov	r3, r1
   8baa8:	68b9      	ldr	r1, [r7, #8]
   8baaa:	4c04      	ldr	r4, [pc, #16]	; (8babc <_ZN8SdVolume8readDataEmttPh+0x38>)
   8baac:	47a0      	blx	r4
   8baae:	4603      	mov	r3, r0
  }
   8bab0:	4618      	mov	r0, r3
   8bab2:	3714      	adds	r7, #20
   8bab4:	46bd      	mov	sp, r7
   8bab6:	bd90      	pop	{r4, r7, pc}
   8bab8:	20071b1c 	.word	0x20071b1c
   8babc:	0008b329 	.word	0x0008b329

0008bac0 <_ZN8SdVolume10writeBlockEmPKh>:
  uint8_t writeBlock(uint32_t block, const uint8_t* dst) {
   8bac0:	b580      	push	{r7, lr}
   8bac2:	b084      	sub	sp, #16
   8bac4:	af00      	add	r7, sp, #0
   8bac6:	60f8      	str	r0, [r7, #12]
   8bac8:	60b9      	str	r1, [r7, #8]
   8baca:	607a      	str	r2, [r7, #4]
    return sdCard_->writeBlock(block, dst);
   8bacc:	4b05      	ldr	r3, [pc, #20]	; (8bae4 <_ZN8SdVolume10writeBlockEmPKh+0x24>)
   8bace:	681b      	ldr	r3, [r3, #0]
   8bad0:	687a      	ldr	r2, [r7, #4]
   8bad2:	68b9      	ldr	r1, [r7, #8]
   8bad4:	4618      	mov	r0, r3
   8bad6:	4b04      	ldr	r3, [pc, #16]	; (8bae8 <_ZN8SdVolume10writeBlockEmPKh+0x28>)
   8bad8:	4798      	blx	r3
   8bada:	4603      	mov	r3, r0
  }
   8badc:	4618      	mov	r0, r3
   8bade:	3710      	adds	r7, #16
   8bae0:	46bd      	mov	sp, r7
   8bae2:	bd80      	pop	{r7, pc}
   8bae4:	20071b1c 	.word	0x20071b1c
   8bae8:	0008b701 	.word	0x0008b701

0008baec <_ZN6SdFile10addClusterEv>:
// suppress cpplint warnings with NOLINT comment
void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
   8baec:	b580      	push	{r7, lr}
   8baee:	b082      	sub	sp, #8
   8baf0:	af00      	add	r7, sp, #0
   8baf2:	6078      	str	r0, [r7, #4]
  if (!vol_->allocContiguous(1, &curCluster_)) return false;
   8baf4:	687b      	ldr	r3, [r7, #4]
   8baf6:	6a58      	ldr	r0, [r3, #36]	; 0x24
   8baf8:	687b      	ldr	r3, [r7, #4]
   8bafa:	330c      	adds	r3, #12
   8bafc:	461a      	mov	r2, r3
   8bafe:	2101      	movs	r1, #1
   8bb00:	4b0f      	ldr	r3, [pc, #60]	; (8bb40 <_ZN6SdFile10addClusterEv+0x54>)
   8bb02:	4798      	blx	r3
   8bb04:	4603      	mov	r3, r0
   8bb06:	2b00      	cmp	r3, #0
   8bb08:	bf0c      	ite	eq
   8bb0a:	2301      	moveq	r3, #1
   8bb0c:	2300      	movne	r3, #0
   8bb0e:	b2db      	uxtb	r3, r3
   8bb10:	2b00      	cmp	r3, #0
   8bb12:	d001      	beq.n	8bb18 <_ZN6SdFile10addClusterEv+0x2c>
   8bb14:	2300      	movs	r3, #0
   8bb16:	e00f      	b.n	8bb38 <_ZN6SdFile10addClusterEv+0x4c>

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
   8bb18:	687b      	ldr	r3, [r7, #4]
   8bb1a:	6a1b      	ldr	r3, [r3, #32]
   8bb1c:	2b00      	cmp	r3, #0
   8bb1e:	d10a      	bne.n	8bb36 <_ZN6SdFile10addClusterEv+0x4a>
    firstCluster_ = curCluster_;
   8bb20:	687b      	ldr	r3, [r7, #4]
   8bb22:	68da      	ldr	r2, [r3, #12]
   8bb24:	687b      	ldr	r3, [r7, #4]
   8bb26:	621a      	str	r2, [r3, #32]
    flags_ |= F_FILE_DIR_DIRTY;
   8bb28:	687b      	ldr	r3, [r7, #4]
   8bb2a:	7a1b      	ldrb	r3, [r3, #8]
   8bb2c:	2280      	movs	r2, #128	; 0x80
   8bb2e:	4313      	orrs	r3, r2
   8bb30:	b2da      	uxtb	r2, r3
   8bb32:	687b      	ldr	r3, [r7, #4]
   8bb34:	721a      	strb	r2, [r3, #8]
  }
  return true;
   8bb36:	2301      	movs	r3, #1
}
   8bb38:	4618      	mov	r0, r3
   8bb3a:	3708      	adds	r7, #8
   8bb3c:	46bd      	mov	sp, r7
   8bb3e:	bd80      	pop	{r7, pc}
   8bb40:	0008caa1 	.word	0x0008caa1

0008bb44 <_ZN6SdFile13addDirClusterEv>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// return with first block of cluster in the cache
uint8_t SdFile::addDirCluster(void) {
   8bb44:	b580      	push	{r7, lr}
   8bb46:	b084      	sub	sp, #16
   8bb48:	af00      	add	r7, sp, #0
   8bb4a:	6078      	str	r0, [r7, #4]
  if (!addCluster()) return false;
   8bb4c:	6878      	ldr	r0, [r7, #4]
   8bb4e:	4b21      	ldr	r3, [pc, #132]	; (8bbd4 <_ZN6SdFile13addDirClusterEv+0x90>)
   8bb50:	4798      	blx	r3
   8bb52:	4603      	mov	r3, r0
   8bb54:	2b00      	cmp	r3, #0
   8bb56:	bf0c      	ite	eq
   8bb58:	2301      	moveq	r3, #1
   8bb5a:	2300      	movne	r3, #0
   8bb5c:	b2db      	uxtb	r3, r3
   8bb5e:	2b00      	cmp	r3, #0
   8bb60:	d001      	beq.n	8bb66 <_ZN6SdFile13addDirClusterEv+0x22>
   8bb62:	2300      	movs	r3, #0
   8bb64:	e031      	b.n	8bbca <_ZN6SdFile13addDirClusterEv+0x86>

  // zero data in cluster insure first cluster is in cache
  uint32_t block = vol_->clusterStartBlock(curCluster_);
   8bb66:	687b      	ldr	r3, [r7, #4]
   8bb68:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   8bb6a:	687b      	ldr	r3, [r7, #4]
   8bb6c:	68db      	ldr	r3, [r3, #12]
   8bb6e:	4619      	mov	r1, r3
   8bb70:	4610      	mov	r0, r2
   8bb72:	4b19      	ldr	r3, [pc, #100]	; (8bbd8 <_ZN6SdFile13addDirClusterEv+0x94>)
   8bb74:	4798      	blx	r3
   8bb76:	60b8      	str	r0, [r7, #8]
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
   8bb78:	687b      	ldr	r3, [r7, #4]
   8bb7a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8bb7c:	791b      	ldrb	r3, [r3, #4]
   8bb7e:	73fb      	strb	r3, [r7, #15]
   8bb80:	7bfb      	ldrb	r3, [r7, #15]
   8bb82:	2b00      	cmp	r3, #0
   8bb84:	d014      	beq.n	8bbb0 <_ZN6SdFile13addDirClusterEv+0x6c>
    if (!SdVolume::cacheZeroBlock(block + i - 1)) return false;
   8bb86:	7bfa      	ldrb	r2, [r7, #15]
   8bb88:	68bb      	ldr	r3, [r7, #8]
   8bb8a:	4413      	add	r3, r2
   8bb8c:	3b01      	subs	r3, #1
   8bb8e:	4618      	mov	r0, r3
   8bb90:	4b12      	ldr	r3, [pc, #72]	; (8bbdc <_ZN6SdFile13addDirClusterEv+0x98>)
   8bb92:	4798      	blx	r3
   8bb94:	4603      	mov	r3, r0
   8bb96:	2b00      	cmp	r3, #0
   8bb98:	bf0c      	ite	eq
   8bb9a:	2301      	moveq	r3, #1
   8bb9c:	2300      	movne	r3, #0
   8bb9e:	b2db      	uxtb	r3, r3
   8bba0:	2b00      	cmp	r3, #0
   8bba2:	d001      	beq.n	8bba8 <_ZN6SdFile13addDirClusterEv+0x64>
   8bba4:	2300      	movs	r3, #0
   8bba6:	e010      	b.n	8bbca <_ZN6SdFile13addDirClusterEv+0x86>
uint8_t SdFile::addDirCluster(void) {
  if (!addCluster()) return false;

  // zero data in cluster insure first cluster is in cache
  uint32_t block = vol_->clusterStartBlock(curCluster_);
  for (uint8_t i = vol_->blocksPerCluster_; i != 0; i--) {
   8bba8:	7bfb      	ldrb	r3, [r7, #15]
   8bbaa:	3b01      	subs	r3, #1
   8bbac:	73fb      	strb	r3, [r7, #15]
   8bbae:	e7e7      	b.n	8bb80 <_ZN6SdFile13addDirClusterEv+0x3c>
    if (!SdVolume::cacheZeroBlock(block + i - 1)) return false;
  }
  // Increase directory file size by cluster size
  fileSize_ += 512UL << vol_->clusterSizeShift_;
   8bbb0:	687b      	ldr	r3, [r7, #4]
   8bbb2:	69da      	ldr	r2, [r3, #28]
   8bbb4:	687b      	ldr	r3, [r7, #4]
   8bbb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8bbb8:	7c1b      	ldrb	r3, [r3, #16]
   8bbba:	4619      	mov	r1, r3
   8bbbc:	f44f 7300 	mov.w	r3, #512	; 0x200
   8bbc0:	408b      	lsls	r3, r1
   8bbc2:	441a      	add	r2, r3
   8bbc4:	687b      	ldr	r3, [r7, #4]
   8bbc6:	61da      	str	r2, [r3, #28]
  return true;
   8bbc8:	2301      	movs	r3, #1
}
   8bbca:	4618      	mov	r0, r3
   8bbcc:	3710      	adds	r7, #16
   8bbce:	46bd      	mov	sp, r7
   8bbd0:	bd80      	pop	{r7, pc}
   8bbd2:	bf00      	nop
   8bbd4:	0008baed 	.word	0x0008baed
   8bbd8:	0008b9e5 	.word	0x0008b9e5
   8bbdc:	0008cd0d 	.word	0x0008cd0d

0008bbe0 <_ZN6SdFile13cacheDirEntryEh>:
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
   8bbe0:	b580      	push	{r7, lr}
   8bbe2:	b082      	sub	sp, #8
   8bbe4:	af00      	add	r7, sp, #0
   8bbe6:	6078      	str	r0, [r7, #4]
   8bbe8:	460b      	mov	r3, r1
   8bbea:	70fb      	strb	r3, [r7, #3]
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) return NULL;
   8bbec:	687b      	ldr	r3, [r7, #4]
   8bbee:	695b      	ldr	r3, [r3, #20]
   8bbf0:	78fa      	ldrb	r2, [r7, #3]
   8bbf2:	4611      	mov	r1, r2
   8bbf4:	4618      	mov	r0, r3
   8bbf6:	4b0a      	ldr	r3, [pc, #40]	; (8bc20 <_ZN6SdFile13cacheDirEntryEh+0x40>)
   8bbf8:	4798      	blx	r3
   8bbfa:	4603      	mov	r3, r0
   8bbfc:	2b00      	cmp	r3, #0
   8bbfe:	bf0c      	ite	eq
   8bc00:	2301      	moveq	r3, #1
   8bc02:	2300      	movne	r3, #0
   8bc04:	b2db      	uxtb	r3, r3
   8bc06:	2b00      	cmp	r3, #0
   8bc08:	d001      	beq.n	8bc0e <_ZN6SdFile13cacheDirEntryEh+0x2e>
   8bc0a:	2300      	movs	r3, #0
   8bc0c:	e004      	b.n	8bc18 <_ZN6SdFile13cacheDirEntryEh+0x38>
  return SdVolume::cacheBuffer_.dir + dirIndex_;
   8bc0e:	687b      	ldr	r3, [r7, #4]
   8bc10:	7e1b      	ldrb	r3, [r3, #24]
   8bc12:	015b      	lsls	r3, r3, #5
   8bc14:	4a03      	ldr	r2, [pc, #12]	; (8bc24 <_ZN6SdFile13cacheDirEntryEh+0x44>)
   8bc16:	4413      	add	r3, r2
}
   8bc18:	4618      	mov	r0, r3
   8bc1a:	3708      	adds	r7, #8
   8bc1c:	46bd      	mov	sp, r7
   8bc1e:	bd80      	pop	{r7, pc}
   8bc20:	0008cc85 	.word	0x0008cc85
   8bc24:	2007191c 	.word	0x2007191c

0008bc28 <_ZN6SdFile5closeEv>:
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include no file is open or an I/O error.
 */
uint8_t SdFile::close(void) {
   8bc28:	b580      	push	{r7, lr}
   8bc2a:	b082      	sub	sp, #8
   8bc2c:	af00      	add	r7, sp, #0
   8bc2e:	6078      	str	r0, [r7, #4]
  if (!sync())return false;
   8bc30:	6878      	ldr	r0, [r7, #4]
   8bc32:	4b0a      	ldr	r3, [pc, #40]	; (8bc5c <_ZN6SdFile5closeEv+0x34>)
   8bc34:	4798      	blx	r3
   8bc36:	4603      	mov	r3, r0
   8bc38:	2b00      	cmp	r3, #0
   8bc3a:	bf0c      	ite	eq
   8bc3c:	2301      	moveq	r3, #1
   8bc3e:	2300      	movne	r3, #0
   8bc40:	b2db      	uxtb	r3, r3
   8bc42:	2b00      	cmp	r3, #0
   8bc44:	d001      	beq.n	8bc4a <_ZN6SdFile5closeEv+0x22>
   8bc46:	2300      	movs	r3, #0
   8bc48:	e003      	b.n	8bc52 <_ZN6SdFile5closeEv+0x2a>
  type_ = FAT_FILE_TYPE_CLOSED;
   8bc4a:	687b      	ldr	r3, [r7, #4]
   8bc4c:	2200      	movs	r2, #0
   8bc4e:	725a      	strb	r2, [r3, #9]
  return true;
   8bc50:	2301      	movs	r3, #1
}
   8bc52:	4618      	mov	r0, r3
   8bc54:	3708      	adds	r7, #8
   8bc56:	46bd      	mov	sp, r7
   8bc58:	bd80      	pop	{r7, pc}
   8bc5a:	bf00      	nop
   8bc5c:	0008c519 	.word	0x0008c519

0008bc60 <_ZN6SdFile10make83NameEPKcPh>:
    }
  }
}
//------------------------------------------------------------------------------
// format directory name field from a 8.3 name string
uint8_t SdFile::make83Name(const char* str, uint8_t* name) {
   8bc60:	b490      	push	{r4, r7}
   8bc62:	b08a      	sub	sp, #40	; 0x28
   8bc64:	af00      	add	r7, sp, #0
   8bc66:	6078      	str	r0, [r7, #4]
   8bc68:	6039      	str	r1, [r7, #0]
  uint8_t c;
  uint8_t n = 7;  // max index for part before dot
   8bc6a:	2307      	movs	r3, #7
   8bc6c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  uint8_t i = 0;
   8bc70:	2300      	movs	r3, #0
   8bc72:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  // blank fill name and extension
  while (i < 11) name[i++] = ' ';
   8bc76:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
   8bc7a:	2b0a      	cmp	r3, #10
   8bc7c:	d80a      	bhi.n	8bc94 <_ZN6SdFile10make83NameEPKcPh+0x34>
   8bc7e:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
   8bc82:	1c5a      	adds	r2, r3, #1
   8bc84:	f887 2026 	strb.w	r2, [r7, #38]	; 0x26
   8bc88:	461a      	mov	r2, r3
   8bc8a:	683b      	ldr	r3, [r7, #0]
   8bc8c:	4413      	add	r3, r2
   8bc8e:	2220      	movs	r2, #32
   8bc90:	701a      	strb	r2, [r3, #0]
   8bc92:	e7f0      	b.n	8bc76 <_ZN6SdFile10make83NameEPKcPh+0x16>
  i = 0;
   8bc94:	2300      	movs	r3, #0
   8bc96:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  while ((c = *str++) != '\0') {
   8bc9a:	687b      	ldr	r3, [r7, #4]
   8bc9c:	1c5a      	adds	r2, r3, #1
   8bc9e:	607a      	str	r2, [r7, #4]
   8bca0:	781b      	ldrb	r3, [r3, #0]
   8bca2:	77fb      	strb	r3, [r7, #31]
   8bca4:	7ffb      	ldrb	r3, [r7, #31]
   8bca6:	2b00      	cmp	r3, #0
   8bca8:	bf14      	ite	ne
   8bcaa:	2301      	movne	r3, #1
   8bcac:	2300      	moveq	r3, #0
   8bcae:	b2db      	uxtb	r3, r3
   8bcb0:	2b00      	cmp	r3, #0
   8bcb2:	d04e      	beq.n	8bd52 <_ZN6SdFile10make83NameEPKcPh+0xf2>
    if (c == '.') {
   8bcb4:	7ffb      	ldrb	r3, [r7, #31]
   8bcb6:	2b2e      	cmp	r3, #46	; 0x2e
   8bcb8:	d10c      	bne.n	8bcd4 <_ZN6SdFile10make83NameEPKcPh+0x74>
      if (n == 10) return false;  // only one dot allowed
   8bcba:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   8bcbe:	2b0a      	cmp	r3, #10
   8bcc0:	d101      	bne.n	8bcc6 <_ZN6SdFile10make83NameEPKcPh+0x66>
   8bcc2:	2300      	movs	r3, #0
   8bcc4:	e04c      	b.n	8bd60 <_ZN6SdFile10make83NameEPKcPh+0x100>
      n = 10;  // max index for full 8.3 name
   8bcc6:	230a      	movs	r3, #10
   8bcc8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
      i = 8;   // place for extension
   8bccc:	2308      	movs	r3, #8
   8bcce:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
   8bcd2:	e7e2      	b.n	8bc9a <_ZN6SdFile10make83NameEPKcPh+0x3a>
      uint8_t b;
#if defined(__AVR__)
      PGM_P p = PSTR("|<>^+=?/[];,*\"\\");
      while ((b = pgm_read_byte(p++))) if (b == c) return false;
#elif defined(__arm__)
      const uint8_t valid[] = "|<>^+=?/[];,*\"\\";
   8bcd4:	4b25      	ldr	r3, [pc, #148]	; (8bd6c <_ZN6SdFile10make83NameEPKcPh+0x10c>)
   8bcd6:	f107 040c 	add.w	r4, r7, #12
   8bcda:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   8bcdc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
      const uint8_t *p = valid;
   8bce0:	f107 030c 	add.w	r3, r7, #12
   8bce4:	623b      	str	r3, [r7, #32]
      while ((b = *p++)) if (b == c) return false;
   8bce6:	6a3b      	ldr	r3, [r7, #32]
   8bce8:	1c5a      	adds	r2, r3, #1
   8bcea:	623a      	str	r2, [r7, #32]
   8bcec:	781b      	ldrb	r3, [r3, #0]
   8bcee:	77bb      	strb	r3, [r7, #30]
   8bcf0:	7fbb      	ldrb	r3, [r7, #30]
   8bcf2:	2b00      	cmp	r3, #0
   8bcf4:	bf14      	ite	ne
   8bcf6:	2301      	movne	r3, #1
   8bcf8:	2300      	moveq	r3, #0
   8bcfa:	b2db      	uxtb	r3, r3
   8bcfc:	2b00      	cmp	r3, #0
   8bcfe:	d005      	beq.n	8bd0c <_ZN6SdFile10make83NameEPKcPh+0xac>
   8bd00:	7fba      	ldrb	r2, [r7, #30]
   8bd02:	7ffb      	ldrb	r3, [r7, #31]
   8bd04:	429a      	cmp	r2, r3
   8bd06:	d1ee      	bne.n	8bce6 <_ZN6SdFile10make83NameEPKcPh+0x86>
   8bd08:	2300      	movs	r3, #0
   8bd0a:	e029      	b.n	8bd60 <_ZN6SdFile10make83NameEPKcPh+0x100>
#endif
      // check size and only allow ASCII printable characters
      if (i > n || c < 0X21 || c > 0X7E)return false;
   8bd0c:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
   8bd10:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   8bd14:	429a      	cmp	r2, r3
   8bd16:	d805      	bhi.n	8bd24 <_ZN6SdFile10make83NameEPKcPh+0xc4>
   8bd18:	7ffb      	ldrb	r3, [r7, #31]
   8bd1a:	2b20      	cmp	r3, #32
   8bd1c:	d902      	bls.n	8bd24 <_ZN6SdFile10make83NameEPKcPh+0xc4>
   8bd1e:	7ffb      	ldrb	r3, [r7, #31]
   8bd20:	2b7e      	cmp	r3, #126	; 0x7e
   8bd22:	d901      	bls.n	8bd28 <_ZN6SdFile10make83NameEPKcPh+0xc8>
   8bd24:	2300      	movs	r3, #0
   8bd26:	e01b      	b.n	8bd60 <_ZN6SdFile10make83NameEPKcPh+0x100>
      // only upper case allowed in 8.3 names - convert lower to upper
      name[i++] = c < 'a' || c > 'z' ?  c : c + ('A' - 'a');
   8bd28:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
   8bd2c:	1c5a      	adds	r2, r3, #1
   8bd2e:	f887 2026 	strb.w	r2, [r7, #38]	; 0x26
   8bd32:	461a      	mov	r2, r3
   8bd34:	683b      	ldr	r3, [r7, #0]
   8bd36:	441a      	add	r2, r3
   8bd38:	7ffb      	ldrb	r3, [r7, #31]
   8bd3a:	2b60      	cmp	r3, #96	; 0x60
   8bd3c:	d906      	bls.n	8bd4c <_ZN6SdFile10make83NameEPKcPh+0xec>
   8bd3e:	7ffb      	ldrb	r3, [r7, #31]
   8bd40:	2b7a      	cmp	r3, #122	; 0x7a
   8bd42:	d803      	bhi.n	8bd4c <_ZN6SdFile10make83NameEPKcPh+0xec>
   8bd44:	7ffb      	ldrb	r3, [r7, #31]
   8bd46:	3b20      	subs	r3, #32
   8bd48:	b2db      	uxtb	r3, r3
   8bd4a:	e000      	b.n	8bd4e <_ZN6SdFile10make83NameEPKcPh+0xee>
   8bd4c:	7ffb      	ldrb	r3, [r7, #31]
   8bd4e:	7013      	strb	r3, [r2, #0]
  uint8_t n = 7;  // max index for part before dot
  uint8_t i = 0;
  // blank fill name and extension
  while (i < 11) name[i++] = ' ';
  i = 0;
  while ((c = *str++) != '\0') {
   8bd50:	e7a3      	b.n	8bc9a <_ZN6SdFile10make83NameEPKcPh+0x3a>
      // only upper case allowed in 8.3 names - convert lower to upper
      name[i++] = c < 'a' || c > 'z' ?  c : c + ('A' - 'a');
    }
  }
  // must have a file name, extension is optional
  return name[0] != ' ';
   8bd52:	683b      	ldr	r3, [r7, #0]
   8bd54:	781b      	ldrb	r3, [r3, #0]
   8bd56:	2b20      	cmp	r3, #32
   8bd58:	bf14      	ite	ne
   8bd5a:	2301      	movne	r3, #1
   8bd5c:	2300      	moveq	r3, #0
   8bd5e:	b2db      	uxtb	r3, r3
}
   8bd60:	4618      	mov	r0, r3
   8bd62:	3728      	adds	r7, #40	; 0x28
   8bd64:	46bd      	mov	sp, r7
   8bd66:	bc90      	pop	{r4, r7}
   8bd68:	4770      	bx	lr
   8bd6a:	bf00      	nop
   8bd6c:	0009ae5c 	.word	0x0009ae5c

0008bd70 <_ZN6SdFile4openEPS_PKch>:
 * the value zero, false, is returned for failure.
 * Reasons for failure include this SdFile is already open, \a difFile is not
 * a directory, \a fileName is invalid, the file does not exist
 * or can't be opened in the access mode specified by oflag.
 */
uint8_t SdFile::open(SdFile* dirFile, const char* fileName, uint8_t oflag) {
   8bd70:	b580      	push	{r7, lr}
   8bd72:	b08a      	sub	sp, #40	; 0x28
   8bd74:	af00      	add	r7, sp, #0
   8bd76:	60f8      	str	r0, [r7, #12]
   8bd78:	60b9      	str	r1, [r7, #8]
   8bd7a:	607a      	str	r2, [r7, #4]
   8bd7c:	70fb      	strb	r3, [r7, #3]
  uint8_t dname[11];
  dir_t* p;

  // error if already open
  if (isOpen())return false;
   8bd7e:	68f8      	ldr	r0, [r7, #12]
   8bd80:	4b7c      	ldr	r3, [pc, #496]	; (8bf74 <_ZN6SdFile4openEPS_PKch+0x204>)
   8bd82:	4798      	blx	r3
   8bd84:	4603      	mov	r3, r0
   8bd86:	2b00      	cmp	r3, #0
   8bd88:	bf14      	ite	ne
   8bd8a:	2301      	movne	r3, #1
   8bd8c:	2300      	moveq	r3, #0
   8bd8e:	b2db      	uxtb	r3, r3
   8bd90:	2b00      	cmp	r3, #0
   8bd92:	d001      	beq.n	8bd98 <_ZN6SdFile4openEPS_PKch+0x28>
   8bd94:	2300      	movs	r3, #0
   8bd96:	e0e8      	b.n	8bf6a <_ZN6SdFile4openEPS_PKch+0x1fa>

  if (!make83Name(fileName, dname)) return false;
   8bd98:	f107 0314 	add.w	r3, r7, #20
   8bd9c:	4619      	mov	r1, r3
   8bd9e:	6878      	ldr	r0, [r7, #4]
   8bda0:	4b75      	ldr	r3, [pc, #468]	; (8bf78 <_ZN6SdFile4openEPS_PKch+0x208>)
   8bda2:	4798      	blx	r3
   8bda4:	4603      	mov	r3, r0
   8bda6:	2b00      	cmp	r3, #0
   8bda8:	bf0c      	ite	eq
   8bdaa:	2301      	moveq	r3, #1
   8bdac:	2300      	movne	r3, #0
   8bdae:	b2db      	uxtb	r3, r3
   8bdb0:	2b00      	cmp	r3, #0
   8bdb2:	d001      	beq.n	8bdb8 <_ZN6SdFile4openEPS_PKch+0x48>
   8bdb4:	2300      	movs	r3, #0
   8bdb6:	e0d8      	b.n	8bf6a <_ZN6SdFile4openEPS_PKch+0x1fa>
  vol_ = dirFile->vol_;
   8bdb8:	68bb      	ldr	r3, [r7, #8]
   8bdba:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   8bdbc:	68fb      	ldr	r3, [r7, #12]
   8bdbe:	625a      	str	r2, [r3, #36]	; 0x24
  dirFile->rewind();
   8bdc0:	68b8      	ldr	r0, [r7, #8]
   8bdc2:	4b6e      	ldr	r3, [pc, #440]	; (8bf7c <_ZN6SdFile4openEPS_PKch+0x20c>)
   8bdc4:	4798      	blx	r3

  // bool for empty entry found
  uint8_t emptyFound = false;
   8bdc6:	2300      	movs	r3, #0
   8bdc8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

  // search for file
  while (dirFile->curPosition_ < dirFile->fileSize_) {
   8bdcc:	68bb      	ldr	r3, [r7, #8]
   8bdce:	691a      	ldr	r2, [r3, #16]
   8bdd0:	68bb      	ldr	r3, [r7, #8]
   8bdd2:	69db      	ldr	r3, [r3, #28]
   8bdd4:	429a      	cmp	r2, r3
   8bdd6:	d24a      	bcs.n	8be6e <_ZN6SdFile4openEPS_PKch+0xfe>
    uint8_t index = 0XF & (dirFile->curPosition_ >> 5);
   8bdd8:	68bb      	ldr	r3, [r7, #8]
   8bdda:	691b      	ldr	r3, [r3, #16]
   8bddc:	095b      	lsrs	r3, r3, #5
   8bdde:	b2db      	uxtb	r3, r3
   8bde0:	f003 030f 	and.w	r3, r3, #15
   8bde4:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    p = dirFile->readDirCache();
   8bde8:	68b8      	ldr	r0, [r7, #8]
   8bdea:	4b65      	ldr	r3, [pc, #404]	; (8bf80 <_ZN6SdFile4openEPS_PKch+0x210>)
   8bdec:	4798      	blx	r3
   8bdee:	6278      	str	r0, [r7, #36]	; 0x24
    if (p == NULL) return false;
   8bdf0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bdf2:	2b00      	cmp	r3, #0
   8bdf4:	d101      	bne.n	8bdfa <_ZN6SdFile4openEPS_PKch+0x8a>
   8bdf6:	2300      	movs	r3, #0
   8bdf8:	e0b7      	b.n	8bf6a <_ZN6SdFile4openEPS_PKch+0x1fa>

    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
   8bdfa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bdfc:	781b      	ldrb	r3, [r3, #0]
   8bdfe:	2b00      	cmp	r3, #0
   8be00:	d003      	beq.n	8be0a <_ZN6SdFile4openEPS_PKch+0x9a>
   8be02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8be04:	781b      	ldrb	r3, [r3, #0]
   8be06:	2be5      	cmp	r3, #229	; 0xe5
   8be08:	d113      	bne.n	8be32 <_ZN6SdFile4openEPS_PKch+0xc2>
      // remember first empty slot
      if (!emptyFound) {
   8be0a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   8be0e:	2b00      	cmp	r3, #0
   8be10:	d10a      	bne.n	8be28 <_ZN6SdFile4openEPS_PKch+0xb8>
        emptyFound = true;
   8be12:	2301      	movs	r3, #1
   8be14:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        dirIndex_ = index;
   8be18:	68fb      	ldr	r3, [r7, #12]
   8be1a:	f897 2022 	ldrb.w	r2, [r7, #34]	; 0x22
   8be1e:	761a      	strb	r2, [r3, #24]
        dirBlock_ = SdVolume::cacheBlockNumber_;
   8be20:	4b58      	ldr	r3, [pc, #352]	; (8bf84 <_ZN6SdFile4openEPS_PKch+0x214>)
   8be22:	681a      	ldr	r2, [r3, #0]
   8be24:	68fb      	ldr	r3, [r7, #12]
   8be26:	615a      	str	r2, [r3, #20]
      }
      // done if no entries follow
      if (p->name[0] == DIR_NAME_FREE) break;
   8be28:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8be2a:	781b      	ldrb	r3, [r3, #0]
   8be2c:	2b00      	cmp	r3, #0
   8be2e:	d11d      	bne.n	8be6c <_ZN6SdFile4openEPS_PKch+0xfc>
   8be30:	e01d      	b.n	8be6e <_ZN6SdFile4openEPS_PKch+0xfe>
    } else if (!memcmp(dname, p->name, 11)) {
   8be32:	6a79      	ldr	r1, [r7, #36]	; 0x24
   8be34:	f107 0314 	add.w	r3, r7, #20
   8be38:	220b      	movs	r2, #11
   8be3a:	4618      	mov	r0, r3
   8be3c:	4b52      	ldr	r3, [pc, #328]	; (8bf88 <_ZN6SdFile4openEPS_PKch+0x218>)
   8be3e:	4798      	blx	r3
   8be40:	4603      	mov	r3, r0
   8be42:	2b00      	cmp	r3, #0
   8be44:	d1c2      	bne.n	8bdcc <_ZN6SdFile4openEPS_PKch+0x5c>
      // don't open existing file if O_CREAT and O_EXCL
      if ((oflag & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL)) return false;
   8be46:	78fb      	ldrb	r3, [r7, #3]
   8be48:	f003 0330 	and.w	r3, r3, #48	; 0x30
   8be4c:	2b30      	cmp	r3, #48	; 0x30
   8be4e:	d101      	bne.n	8be54 <_ZN6SdFile4openEPS_PKch+0xe4>
   8be50:	2300      	movs	r3, #0
   8be52:	e08a      	b.n	8bf6a <_ZN6SdFile4openEPS_PKch+0x1fa>

      // open found file
      return openCachedEntry(0XF & index, oflag);
   8be54:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
   8be58:	f003 030f 	and.w	r3, r3, #15
   8be5c:	b2db      	uxtb	r3, r3
   8be5e:	78fa      	ldrb	r2, [r7, #3]
   8be60:	4619      	mov	r1, r3
   8be62:	68f8      	ldr	r0, [r7, #12]
   8be64:	4b49      	ldr	r3, [pc, #292]	; (8bf8c <_ZN6SdFile4openEPS_PKch+0x21c>)
   8be66:	4798      	blx	r3
   8be68:	4603      	mov	r3, r0
   8be6a:	e07e      	b.n	8bf6a <_ZN6SdFile4openEPS_PKch+0x1fa>

  // bool for empty entry found
  uint8_t emptyFound = false;

  // search for file
  while (dirFile->curPosition_ < dirFile->fileSize_) {
   8be6c:	e7ae      	b.n	8bdcc <_ZN6SdFile4openEPS_PKch+0x5c>
      // open found file
      return openCachedEntry(0XF & index, oflag);
    }
  }
  // only create file if O_CREAT and O_WRITE
  if ((oflag & (O_CREAT | O_WRITE)) != (O_CREAT | O_WRITE)) return false;
   8be6e:	78fb      	ldrb	r3, [r7, #3]
   8be70:	f003 0312 	and.w	r3, r3, #18
   8be74:	2b12      	cmp	r3, #18
   8be76:	d001      	beq.n	8be7c <_ZN6SdFile4openEPS_PKch+0x10c>
   8be78:	2300      	movs	r3, #0
   8be7a:	e076      	b.n	8bf6a <_ZN6SdFile4openEPS_PKch+0x1fa>

  // cache found slot or add cluster if end of file
  if (emptyFound) {
   8be7c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   8be80:	2b00      	cmp	r3, #0
   8be82:	d009      	beq.n	8be98 <_ZN6SdFile4openEPS_PKch+0x128>
    p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   8be84:	2101      	movs	r1, #1
   8be86:	68f8      	ldr	r0, [r7, #12]
   8be88:	4b41      	ldr	r3, [pc, #260]	; (8bf90 <_ZN6SdFile4openEPS_PKch+0x220>)
   8be8a:	4798      	blx	r3
   8be8c:	6278      	str	r0, [r7, #36]	; 0x24
    if (!p) return false;
   8be8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8be90:	2b00      	cmp	r3, #0
   8be92:	d119      	bne.n	8bec8 <_ZN6SdFile4openEPS_PKch+0x158>
   8be94:	2300      	movs	r3, #0
   8be96:	e068      	b.n	8bf6a <_ZN6SdFile4openEPS_PKch+0x1fa>
  } else {
    if (dirFile->type_ == FAT_FILE_TYPE_ROOT16) return false;
   8be98:	68bb      	ldr	r3, [r7, #8]
   8be9a:	7a5b      	ldrb	r3, [r3, #9]
   8be9c:	2b02      	cmp	r3, #2
   8be9e:	d101      	bne.n	8bea4 <_ZN6SdFile4openEPS_PKch+0x134>
   8bea0:	2300      	movs	r3, #0
   8bea2:	e062      	b.n	8bf6a <_ZN6SdFile4openEPS_PKch+0x1fa>

    // add and zero cluster for dirFile - first cluster is in cache for write
    if (!dirFile->addDirCluster()) return false;
   8bea4:	68b8      	ldr	r0, [r7, #8]
   8bea6:	4b3b      	ldr	r3, [pc, #236]	; (8bf94 <_ZN6SdFile4openEPS_PKch+0x224>)
   8bea8:	4798      	blx	r3
   8beaa:	4603      	mov	r3, r0
   8beac:	2b00      	cmp	r3, #0
   8beae:	bf0c      	ite	eq
   8beb0:	2301      	moveq	r3, #1
   8beb2:	2300      	movne	r3, #0
   8beb4:	b2db      	uxtb	r3, r3
   8beb6:	2b00      	cmp	r3, #0
   8beb8:	d001      	beq.n	8bebe <_ZN6SdFile4openEPS_PKch+0x14e>
   8beba:	2300      	movs	r3, #0
   8bebc:	e055      	b.n	8bf6a <_ZN6SdFile4openEPS_PKch+0x1fa>

    // use first entry in cluster
    dirIndex_ = 0;
   8bebe:	68fb      	ldr	r3, [r7, #12]
   8bec0:	2200      	movs	r2, #0
   8bec2:	761a      	strb	r2, [r3, #24]
    p = SdVolume::cacheBuffer_.dir;
   8bec4:	4b34      	ldr	r3, [pc, #208]	; (8bf98 <_ZN6SdFile4openEPS_PKch+0x228>)
   8bec6:	627b      	str	r3, [r7, #36]	; 0x24
  }
  // initialize as empty file
  memset(p, 0, sizeof(dir_t));
   8bec8:	2220      	movs	r2, #32
   8beca:	2100      	movs	r1, #0
   8becc:	6a78      	ldr	r0, [r7, #36]	; 0x24
   8bece:	4b33      	ldr	r3, [pc, #204]	; (8bf9c <_ZN6SdFile4openEPS_PKch+0x22c>)
   8bed0:	4798      	blx	r3
  memcpy(p->name, dname, 11);
   8bed2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bed4:	461a      	mov	r2, r3
   8bed6:	f107 0314 	add.w	r3, r7, #20
   8beda:	cb03      	ldmia	r3!, {r0, r1}
   8bedc:	6010      	str	r0, [r2, #0]
   8bede:	6051      	str	r1, [r2, #4]
   8bee0:	8819      	ldrh	r1, [r3, #0]
   8bee2:	789b      	ldrb	r3, [r3, #2]
   8bee4:	8111      	strh	r1, [r2, #8]
   8bee6:	7293      	strb	r3, [r2, #10]

  // set timestamps
  if (dateTime_) {
   8bee8:	4b2d      	ldr	r3, [pc, #180]	; (8bfa0 <_ZN6SdFile4openEPS_PKch+0x230>)
   8beea:	681b      	ldr	r3, [r3, #0]
   8beec:	2b00      	cmp	r3, #0
   8beee:	d009      	beq.n	8bf04 <_ZN6SdFile4openEPS_PKch+0x194>
    // call user function
    dateTime_(&p->creationDate, &p->creationTime);
   8bef0:	4b2b      	ldr	r3, [pc, #172]	; (8bfa0 <_ZN6SdFile4openEPS_PKch+0x230>)
   8bef2:	681b      	ldr	r3, [r3, #0]
   8bef4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   8bef6:	f102 0010 	add.w	r0, r2, #16
   8befa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   8befc:	320e      	adds	r2, #14
   8befe:	4611      	mov	r1, r2
   8bf00:	4798      	blx	r3
   8bf02:	e00f      	b.n	8bf24 <_ZN6SdFile4openEPS_PKch+0x1b4>
  } else {
    // use default date/time
    p->creationDate = FAT_DEFAULT_DATE;
   8bf04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bf06:	2200      	movs	r2, #0
   8bf08:	f042 0221 	orr.w	r2, r2, #33	; 0x21
   8bf0c:	741a      	strb	r2, [r3, #16]
   8bf0e:	2200      	movs	r2, #0
   8bf10:	f042 0228 	orr.w	r2, r2, #40	; 0x28
   8bf14:	745a      	strb	r2, [r3, #17]
    p->creationTime = FAT_DEFAULT_TIME;
   8bf16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bf18:	2200      	movs	r2, #0
   8bf1a:	739a      	strb	r2, [r3, #14]
   8bf1c:	2200      	movs	r2, #0
   8bf1e:	f042 0208 	orr.w	r2, r2, #8
   8bf22:	73da      	strb	r2, [r3, #15]
  }
  p->lastAccessDate = p->creationDate;
   8bf24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bf26:	8a1b      	ldrh	r3, [r3, #16]
   8bf28:	b29a      	uxth	r2, r3
   8bf2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bf2c:	825a      	strh	r2, [r3, #18]
  p->lastWriteDate = p->creationDate;
   8bf2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bf30:	8a1b      	ldrh	r3, [r3, #16]
   8bf32:	b29a      	uxth	r2, r3
   8bf34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bf36:	831a      	strh	r2, [r3, #24]
  p->lastWriteTime = p->creationTime;
   8bf38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bf3a:	89db      	ldrh	r3, [r3, #14]
   8bf3c:	b29a      	uxth	r2, r3
   8bf3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8bf40:	82da      	strh	r2, [r3, #22]

  // force write of entry to SD
  if (!SdVolume::cacheFlush()) return false;
   8bf42:	4b18      	ldr	r3, [pc, #96]	; (8bfa4 <_ZN6SdFile4openEPS_PKch+0x234>)
   8bf44:	4798      	blx	r3
   8bf46:	4603      	mov	r3, r0
   8bf48:	2b00      	cmp	r3, #0
   8bf4a:	bf0c      	ite	eq
   8bf4c:	2301      	moveq	r3, #1
   8bf4e:	2300      	movne	r3, #0
   8bf50:	b2db      	uxtb	r3, r3
   8bf52:	2b00      	cmp	r3, #0
   8bf54:	d001      	beq.n	8bf5a <_ZN6SdFile4openEPS_PKch+0x1ea>
   8bf56:	2300      	movs	r3, #0
   8bf58:	e007      	b.n	8bf6a <_ZN6SdFile4openEPS_PKch+0x1fa>

  // open entry in cache
  return openCachedEntry(dirIndex_, oflag);
   8bf5a:	68fb      	ldr	r3, [r7, #12]
   8bf5c:	7e1b      	ldrb	r3, [r3, #24]
   8bf5e:	78fa      	ldrb	r2, [r7, #3]
   8bf60:	4619      	mov	r1, r3
   8bf62:	68f8      	ldr	r0, [r7, #12]
   8bf64:	4b09      	ldr	r3, [pc, #36]	; (8bf8c <_ZN6SdFile4openEPS_PKch+0x21c>)
   8bf66:	4798      	blx	r3
   8bf68:	4603      	mov	r3, r0
}
   8bf6a:	4618      	mov	r0, r3
   8bf6c:	3728      	adds	r7, #40	; 0x28
   8bf6e:	46bd      	mov	sp, r7
   8bf70:	bd80      	pop	{r7, pc}
   8bf72:	bf00      	nop
   8bf74:	0008a3a1 	.word	0x0008a3a1
   8bf78:	0008bc61 	.word	0x0008bc61
   8bf7c:	0008a7a5 	.word	0x0008a7a5
   8bf80:	0008c3b9 	.word	0x0008c3b9
   8bf84:	20070114 	.word	0x20070114
   8bf88:	00093aad 	.word	0x00093aad
   8bf8c:	0008bfa9 	.word	0x0008bfa9
   8bf90:	0008bbe1 	.word	0x0008bbe1
   8bf94:	0008bb45 	.word	0x0008bb45
   8bf98:	2007191c 	.word	0x2007191c
   8bf9c:	00093cc5 	.word	0x00093cc5
   8bfa0:	20071918 	.word	0x20071918
   8bfa4:	0008cbfd 	.word	0x0008cbfd

0008bfa8 <_ZN6SdFile15openCachedEntryEhh>:
  // open cached entry
  return openCachedEntry(index & 0XF, oflag);
}
//------------------------------------------------------------------------------
// open a cached directory entry. Assumes vol_ is initializes
uint8_t SdFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
   8bfa8:	b580      	push	{r7, lr}
   8bfaa:	b084      	sub	sp, #16
   8bfac:	af00      	add	r7, sp, #0
   8bfae:	6078      	str	r0, [r7, #4]
   8bfb0:	460b      	mov	r3, r1
   8bfb2:	70fb      	strb	r3, [r7, #3]
   8bfb4:	4613      	mov	r3, r2
   8bfb6:	70bb      	strb	r3, [r7, #2]
  // location of entry in cache
  dir_t* p = SdVolume::cacheBuffer_.dir + dirIndex;
   8bfb8:	78fb      	ldrb	r3, [r7, #3]
   8bfba:	015b      	lsls	r3, r3, #5
   8bfbc:	4a3b      	ldr	r2, [pc, #236]	; (8c0ac <_ZN6SdFile15openCachedEntryEhh+0x104>)
   8bfbe:	4413      	add	r3, r2
   8bfc0:	60fb      	str	r3, [r7, #12]

  // write or truncate is an error for a directory or read-only file
  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
   8bfc2:	68fb      	ldr	r3, [r7, #12]
   8bfc4:	7adb      	ldrb	r3, [r3, #11]
   8bfc6:	f003 0311 	and.w	r3, r3, #17
   8bfca:	2b00      	cmp	r3, #0
   8bfcc:	d006      	beq.n	8bfdc <_ZN6SdFile15openCachedEntryEhh+0x34>
    if (oflag & (O_WRITE | O_TRUNC)) return false;
   8bfce:	78bb      	ldrb	r3, [r7, #2]
   8bfd0:	f003 0342 	and.w	r3, r3, #66	; 0x42
   8bfd4:	2b00      	cmp	r3, #0
   8bfd6:	d001      	beq.n	8bfdc <_ZN6SdFile15openCachedEntryEhh+0x34>
   8bfd8:	2300      	movs	r3, #0
   8bfda:	e063      	b.n	8c0a4 <_ZN6SdFile15openCachedEntryEhh+0xfc>
  }
  // remember location of directory entry on SD
  dirIndex_ = dirIndex;
   8bfdc:	687b      	ldr	r3, [r7, #4]
   8bfde:	78fa      	ldrb	r2, [r7, #3]
   8bfe0:	761a      	strb	r2, [r3, #24]
  dirBlock_ = SdVolume::cacheBlockNumber_;
   8bfe2:	4b33      	ldr	r3, [pc, #204]	; (8c0b0 <_ZN6SdFile15openCachedEntryEhh+0x108>)
   8bfe4:	681a      	ldr	r2, [r3, #0]
   8bfe6:	687b      	ldr	r3, [r7, #4]
   8bfe8:	615a      	str	r2, [r3, #20]

  // copy first cluster number for directory fields
  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
   8bfea:	68fb      	ldr	r3, [r7, #12]
   8bfec:	8a9b      	ldrh	r3, [r3, #20]
   8bfee:	b29b      	uxth	r3, r3
   8bff0:	041a      	lsls	r2, r3, #16
   8bff2:	687b      	ldr	r3, [r7, #4]
   8bff4:	621a      	str	r2, [r3, #32]
  firstCluster_ |= p->firstClusterLow;
   8bff6:	687b      	ldr	r3, [r7, #4]
   8bff8:	6a1b      	ldr	r3, [r3, #32]
   8bffa:	68fa      	ldr	r2, [r7, #12]
   8bffc:	8b52      	ldrh	r2, [r2, #26]
   8bffe:	b292      	uxth	r2, r2
   8c000:	431a      	orrs	r2, r3
   8c002:	687b      	ldr	r3, [r7, #4]
   8c004:	621a      	str	r2, [r3, #32]

  // make sure it is a normal file or subdirectory
  if (DIR_IS_FILE(p)) {
   8c006:	68f8      	ldr	r0, [r7, #12]
   8c008:	4b2a      	ldr	r3, [pc, #168]	; (8c0b4 <_ZN6SdFile15openCachedEntryEhh+0x10c>)
   8c00a:	4798      	blx	r3
   8c00c:	4603      	mov	r3, r0
   8c00e:	2b00      	cmp	r3, #0
   8c010:	bf14      	ite	ne
   8c012:	2301      	movne	r3, #1
   8c014:	2300      	moveq	r3, #0
   8c016:	b2db      	uxtb	r3, r3
   8c018:	2b00      	cmp	r3, #0
   8c01a:	d007      	beq.n	8c02c <_ZN6SdFile15openCachedEntryEhh+0x84>
    fileSize_ = p->fileSize;
   8c01c:	68fb      	ldr	r3, [r7, #12]
   8c01e:	69da      	ldr	r2, [r3, #28]
   8c020:	687b      	ldr	r3, [r7, #4]
   8c022:	61da      	str	r2, [r3, #28]
    type_ = FAT_FILE_TYPE_NORMAL;
   8c024:	687b      	ldr	r3, [r7, #4]
   8c026:	2201      	movs	r2, #1
   8c028:	725a      	strb	r2, [r3, #9]
   8c02a:	e023      	b.n	8c074 <_ZN6SdFile15openCachedEntryEhh+0xcc>
  } else if (DIR_IS_SUBDIR(p)) {
   8c02c:	68f8      	ldr	r0, [r7, #12]
   8c02e:	4b22      	ldr	r3, [pc, #136]	; (8c0b8 <_ZN6SdFile15openCachedEntryEhh+0x110>)
   8c030:	4798      	blx	r3
   8c032:	4603      	mov	r3, r0
   8c034:	2b00      	cmp	r3, #0
   8c036:	bf14      	ite	ne
   8c038:	2301      	movne	r3, #1
   8c03a:	2300      	moveq	r3, #0
   8c03c:	b2db      	uxtb	r3, r3
   8c03e:	2b00      	cmp	r3, #0
   8c040:	d016      	beq.n	8c070 <_ZN6SdFile15openCachedEntryEhh+0xc8>
    if (!vol_->chainSize(firstCluster_, &fileSize_)) return false;
   8c042:	687b      	ldr	r3, [r7, #4]
   8c044:	6a58      	ldr	r0, [r3, #36]	; 0x24
   8c046:	687b      	ldr	r3, [r7, #4]
   8c048:	6a19      	ldr	r1, [r3, #32]
   8c04a:	687b      	ldr	r3, [r7, #4]
   8c04c:	331c      	adds	r3, #28
   8c04e:	461a      	mov	r2, r3
   8c050:	4b1a      	ldr	r3, [pc, #104]	; (8c0bc <_ZN6SdFile15openCachedEntryEhh+0x114>)
   8c052:	4798      	blx	r3
   8c054:	4603      	mov	r3, r0
   8c056:	2b00      	cmp	r3, #0
   8c058:	bf0c      	ite	eq
   8c05a:	2301      	moveq	r3, #1
   8c05c:	2300      	movne	r3, #0
   8c05e:	b2db      	uxtb	r3, r3
   8c060:	2b00      	cmp	r3, #0
   8c062:	d001      	beq.n	8c068 <_ZN6SdFile15openCachedEntryEhh+0xc0>
   8c064:	2300      	movs	r3, #0
   8c066:	e01d      	b.n	8c0a4 <_ZN6SdFile15openCachedEntryEhh+0xfc>
    type_ = FAT_FILE_TYPE_SUBDIR;
   8c068:	687b      	ldr	r3, [r7, #4]
   8c06a:	2204      	movs	r2, #4
   8c06c:	725a      	strb	r2, [r3, #9]
   8c06e:	e001      	b.n	8c074 <_ZN6SdFile15openCachedEntryEhh+0xcc>
  } else {
    return false;
   8c070:	2300      	movs	r3, #0
   8c072:	e017      	b.n	8c0a4 <_ZN6SdFile15openCachedEntryEhh+0xfc>
  }
  // save open flags for read/write
  flags_ = oflag & (O_ACCMODE | O_SYNC | O_APPEND);
   8c074:	78bb      	ldrb	r3, [r7, #2]
   8c076:	f003 030f 	and.w	r3, r3, #15
   8c07a:	b2da      	uxtb	r2, r3
   8c07c:	687b      	ldr	r3, [r7, #4]
   8c07e:	721a      	strb	r2, [r3, #8]

  // set to start of file
  curCluster_ = 0;
   8c080:	687b      	ldr	r3, [r7, #4]
   8c082:	2200      	movs	r2, #0
   8c084:	60da      	str	r2, [r3, #12]
  curPosition_ = 0;
   8c086:	687b      	ldr	r3, [r7, #4]
   8c088:	2200      	movs	r2, #0
   8c08a:	611a      	str	r2, [r3, #16]

  // truncate file to zero length if requested
  if (oflag & O_TRUNC) return truncate(0);
   8c08c:	78bb      	ldrb	r3, [r7, #2]
   8c08e:	f003 0340 	and.w	r3, r3, #64	; 0x40
   8c092:	2b00      	cmp	r3, #0
   8c094:	d005      	beq.n	8c0a2 <_ZN6SdFile15openCachedEntryEhh+0xfa>
   8c096:	2100      	movs	r1, #0
   8c098:	6878      	ldr	r0, [r7, #4]
   8c09a:	4b09      	ldr	r3, [pc, #36]	; (8c0c0 <_ZN6SdFile15openCachedEntryEhh+0x118>)
   8c09c:	4798      	blx	r3
   8c09e:	4603      	mov	r3, r0
   8c0a0:	e000      	b.n	8c0a4 <_ZN6SdFile15openCachedEntryEhh+0xfc>
  return true;
   8c0a2:	2301      	movs	r3, #1
}
   8c0a4:	4618      	mov	r0, r3
   8c0a6:	3710      	adds	r7, #16
   8c0a8:	46bd      	mov	sp, r7
   8c0aa:	bd80      	pop	{r7, pc}
   8c0ac:	2007191c 	.word	0x2007191c
   8c0b0:	20070114 	.word	0x20070114
   8c0b4:	0008b8cd 	.word	0x0008b8cd
   8c0b8:	0008b8f1 	.word	0x0008b8f1
   8c0bc:	0008cd6d 	.word	0x0008cd6d
   8c0c0:	0008c5e1 	.word	0x0008c5e1

0008c0c4 <_ZN6SdFile8openRootEP8SdVolume>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include the FAT volume has not been initialized
 * or it a FAT12 volume.
 */
uint8_t SdFile::openRoot(SdVolume* vol) {
   8c0c4:	b580      	push	{r7, lr}
   8c0c6:	b082      	sub	sp, #8
   8c0c8:	af00      	add	r7, sp, #0
   8c0ca:	6078      	str	r0, [r7, #4]
   8c0cc:	6039      	str	r1, [r7, #0]
  // error if file is already open
  if (isOpen()) return false;
   8c0ce:	6878      	ldr	r0, [r7, #4]
   8c0d0:	4b31      	ldr	r3, [pc, #196]	; (8c198 <_ZN6SdFile8openRootEP8SdVolume+0xd4>)
   8c0d2:	4798      	blx	r3
   8c0d4:	4603      	mov	r3, r0
   8c0d6:	2b00      	cmp	r3, #0
   8c0d8:	bf14      	ite	ne
   8c0da:	2301      	movne	r3, #1
   8c0dc:	2300      	moveq	r3, #0
   8c0de:	b2db      	uxtb	r3, r3
   8c0e0:	2b00      	cmp	r3, #0
   8c0e2:	d001      	beq.n	8c0e8 <_ZN6SdFile8openRootEP8SdVolume+0x24>
   8c0e4:	2300      	movs	r3, #0
   8c0e6:	e053      	b.n	8c190 <_ZN6SdFile8openRootEP8SdVolume+0xcc>

  if (vol->fatType() == 16) {
   8c0e8:	6838      	ldr	r0, [r7, #0]
   8c0ea:	4b2c      	ldr	r3, [pc, #176]	; (8c19c <_ZN6SdFile8openRootEP8SdVolume+0xd8>)
   8c0ec:	4798      	blx	r3
   8c0ee:	4603      	mov	r3, r0
   8c0f0:	2b10      	cmp	r3, #16
   8c0f2:	bf0c      	ite	eq
   8c0f4:	2301      	moveq	r3, #1
   8c0f6:	2300      	movne	r3, #0
   8c0f8:	b2db      	uxtb	r3, r3
   8c0fa:	2b00      	cmp	r3, #0
   8c0fc:	d00d      	beq.n	8c11a <_ZN6SdFile8openRootEP8SdVolume+0x56>
    type_ = FAT_FILE_TYPE_ROOT16;
   8c0fe:	687b      	ldr	r3, [r7, #4]
   8c100:	2202      	movs	r2, #2
   8c102:	725a      	strb	r2, [r3, #9]
    firstCluster_ = 0;
   8c104:	687b      	ldr	r3, [r7, #4]
   8c106:	2200      	movs	r2, #0
   8c108:	621a      	str	r2, [r3, #32]
    fileSize_ = 32 * vol->rootDirEntryCount();
   8c10a:	6838      	ldr	r0, [r7, #0]
   8c10c:	4b24      	ldr	r3, [pc, #144]	; (8c1a0 <_ZN6SdFile8openRootEP8SdVolume+0xdc>)
   8c10e:	4798      	blx	r3
   8c110:	4603      	mov	r3, r0
   8c112:	015a      	lsls	r2, r3, #5
   8c114:	687b      	ldr	r3, [r7, #4]
   8c116:	61da      	str	r2, [r3, #28]
   8c118:	e027      	b.n	8c16a <_ZN6SdFile8openRootEP8SdVolume+0xa6>
  } else if (vol->fatType() == 32) {
   8c11a:	6838      	ldr	r0, [r7, #0]
   8c11c:	4b1f      	ldr	r3, [pc, #124]	; (8c19c <_ZN6SdFile8openRootEP8SdVolume+0xd8>)
   8c11e:	4798      	blx	r3
   8c120:	4603      	mov	r3, r0
   8c122:	2b20      	cmp	r3, #32
   8c124:	bf0c      	ite	eq
   8c126:	2301      	moveq	r3, #1
   8c128:	2300      	movne	r3, #0
   8c12a:	b2db      	uxtb	r3, r3
   8c12c:	2b00      	cmp	r3, #0
   8c12e:	d01a      	beq.n	8c166 <_ZN6SdFile8openRootEP8SdVolume+0xa2>
    type_ = FAT_FILE_TYPE_ROOT32;
   8c130:	687b      	ldr	r3, [r7, #4]
   8c132:	2203      	movs	r2, #3
   8c134:	725a      	strb	r2, [r3, #9]
    firstCluster_ = vol->rootDirStart();
   8c136:	6838      	ldr	r0, [r7, #0]
   8c138:	4b1a      	ldr	r3, [pc, #104]	; (8c1a4 <_ZN6SdFile8openRootEP8SdVolume+0xe0>)
   8c13a:	4798      	blx	r3
   8c13c:	4602      	mov	r2, r0
   8c13e:	687b      	ldr	r3, [r7, #4]
   8c140:	621a      	str	r2, [r3, #32]
    if (!vol->chainSize(firstCluster_, &fileSize_)) return false;
   8c142:	687b      	ldr	r3, [r7, #4]
   8c144:	6a19      	ldr	r1, [r3, #32]
   8c146:	687b      	ldr	r3, [r7, #4]
   8c148:	331c      	adds	r3, #28
   8c14a:	461a      	mov	r2, r3
   8c14c:	6838      	ldr	r0, [r7, #0]
   8c14e:	4b16      	ldr	r3, [pc, #88]	; (8c1a8 <_ZN6SdFile8openRootEP8SdVolume+0xe4>)
   8c150:	4798      	blx	r3
   8c152:	4603      	mov	r3, r0
   8c154:	2b00      	cmp	r3, #0
   8c156:	bf0c      	ite	eq
   8c158:	2301      	moveq	r3, #1
   8c15a:	2300      	movne	r3, #0
   8c15c:	b2db      	uxtb	r3, r3
   8c15e:	2b00      	cmp	r3, #0
   8c160:	d003      	beq.n	8c16a <_ZN6SdFile8openRootEP8SdVolume+0xa6>
   8c162:	2300      	movs	r3, #0
   8c164:	e014      	b.n	8c190 <_ZN6SdFile8openRootEP8SdVolume+0xcc>
  } else {
    // volume is not initialized or FAT12
    return false;
   8c166:	2300      	movs	r3, #0
   8c168:	e012      	b.n	8c190 <_ZN6SdFile8openRootEP8SdVolume+0xcc>
  }
  vol_ = vol;
   8c16a:	687b      	ldr	r3, [r7, #4]
   8c16c:	683a      	ldr	r2, [r7, #0]
   8c16e:	625a      	str	r2, [r3, #36]	; 0x24
  // read only
  flags_ = O_READ;
   8c170:	687b      	ldr	r3, [r7, #4]
   8c172:	2201      	movs	r2, #1
   8c174:	721a      	strb	r2, [r3, #8]

  // set to start of file
  curCluster_ = 0;
   8c176:	687b      	ldr	r3, [r7, #4]
   8c178:	2200      	movs	r2, #0
   8c17a:	60da      	str	r2, [r3, #12]
  curPosition_ = 0;
   8c17c:	687b      	ldr	r3, [r7, #4]
   8c17e:	2200      	movs	r2, #0
   8c180:	611a      	str	r2, [r3, #16]

  // root has no directory entry
  dirBlock_ = 0;
   8c182:	687b      	ldr	r3, [r7, #4]
   8c184:	2200      	movs	r2, #0
   8c186:	615a      	str	r2, [r3, #20]
  dirIndex_ = 0;
   8c188:	687b      	ldr	r3, [r7, #4]
   8c18a:	2200      	movs	r2, #0
   8c18c:	761a      	strb	r2, [r3, #24]
  return true;
   8c18e:	2301      	movs	r3, #1
}
   8c190:	4618      	mov	r0, r3
   8c192:	3708      	adds	r7, #8
   8c194:	46bd      	mov	sp, r7
   8c196:	bd80      	pop	{r7, pc}
   8c198:	0008a3a1 	.word	0x0008a3a1
   8c19c:	0008b975 	.word	0x0008b975
   8c1a0:	0008b98d 	.word	0x0008b98d
   8c1a4:	0008b9a5 	.word	0x0008b9a5
   8c1a8:	0008cd6d 	.word	0x0008cd6d

0008c1ac <_ZN6SdFile4readEPvt>:
 * if end of file is reached.
 * If an error occurs, read() returns -1.  Possible errors include
 * read() called before a file has been opened, corrupt file system
 * or an I/O error occurred.
 */
int16_t SdFile::read(void* buf, uint16_t nbyte) {
   8c1ac:	b590      	push	{r4, r7, lr}
   8c1ae:	b08f      	sub	sp, #60	; 0x3c
   8c1b0:	af02      	add	r7, sp, #8
   8c1b2:	60f8      	str	r0, [r7, #12]
   8c1b4:	60b9      	str	r1, [r7, #8]
   8c1b6:	4613      	mov	r3, r2
   8c1b8:	80fb      	strh	r3, [r7, #6]
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
   8c1ba:	68bb      	ldr	r3, [r7, #8]
   8c1bc:	62fb      	str	r3, [r7, #44]	; 0x2c

  // error if not open or write only
  if (!isOpen() || !(flags_ & O_READ)) return -1;
   8c1be:	68f8      	ldr	r0, [r7, #12]
   8c1c0:	4b73      	ldr	r3, [pc, #460]	; (8c390 <_ZN6SdFile4readEPvt+0x1e4>)
   8c1c2:	4798      	blx	r3
   8c1c4:	4603      	mov	r3, r0
   8c1c6:	2b00      	cmp	r3, #0
   8c1c8:	d005      	beq.n	8c1d6 <_ZN6SdFile4readEPvt+0x2a>
   8c1ca:	68fb      	ldr	r3, [r7, #12]
   8c1cc:	7a1b      	ldrb	r3, [r3, #8]
   8c1ce:	f003 0301 	and.w	r3, r3, #1
   8c1d2:	2b00      	cmp	r3, #0
   8c1d4:	d101      	bne.n	8c1da <_ZN6SdFile4readEPvt+0x2e>
   8c1d6:	2301      	movs	r3, #1
   8c1d8:	e000      	b.n	8c1dc <_ZN6SdFile4readEPvt+0x30>
   8c1da:	2300      	movs	r3, #0
   8c1dc:	2b00      	cmp	r3, #0
   8c1de:	d002      	beq.n	8c1e6 <_ZN6SdFile4readEPvt+0x3a>
   8c1e0:	f04f 33ff 	mov.w	r3, #4294967295
   8c1e4:	e0cf      	b.n	8c386 <_ZN6SdFile4readEPvt+0x1da>

  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) nbyte = fileSize_ - curPosition_;
   8c1e6:	88fa      	ldrh	r2, [r7, #6]
   8c1e8:	68fb      	ldr	r3, [r7, #12]
   8c1ea:	69d9      	ldr	r1, [r3, #28]
   8c1ec:	68fb      	ldr	r3, [r7, #12]
   8c1ee:	691b      	ldr	r3, [r3, #16]
   8c1f0:	1acb      	subs	r3, r1, r3
   8c1f2:	429a      	cmp	r2, r3
   8c1f4:	d907      	bls.n	8c206 <_ZN6SdFile4readEPvt+0x5a>
   8c1f6:	68fb      	ldr	r3, [r7, #12]
   8c1f8:	69db      	ldr	r3, [r3, #28]
   8c1fa:	b29a      	uxth	r2, r3
   8c1fc:	68fb      	ldr	r3, [r7, #12]
   8c1fe:	691b      	ldr	r3, [r3, #16]
   8c200:	b29b      	uxth	r3, r3
   8c202:	1ad3      	subs	r3, r2, r3
   8c204:	80fb      	strh	r3, [r7, #6]

  // amount left to read
  uint16_t toRead = nbyte;
   8c206:	88fb      	ldrh	r3, [r7, #6]
   8c208:	857b      	strh	r3, [r7, #42]	; 0x2a
  while (toRead > 0) {
   8c20a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   8c20c:	2b00      	cmp	r3, #0
   8c20e:	f000 80b8 	beq.w	8c382 <_ZN6SdFile4readEPvt+0x1d6>
    uint32_t block;  // raw device block number
    uint16_t offset = curPosition_ & 0X1FF;  // offset in block
   8c212:	68fb      	ldr	r3, [r7, #12]
   8c214:	691b      	ldr	r3, [r3, #16]
   8c216:	b29b      	uxth	r3, r3
   8c218:	f3c3 0308 	ubfx	r3, r3, #0, #9
   8c21c:	837b      	strh	r3, [r7, #26]
    if (type_ == FAT_FILE_TYPE_ROOT16) {
   8c21e:	68fb      	ldr	r3, [r7, #12]
   8c220:	7a5b      	ldrb	r3, [r3, #9]
   8c222:	2b02      	cmp	r3, #2
   8c224:	d10b      	bne.n	8c23e <_ZN6SdFile4readEPvt+0x92>
      block = vol_->rootDirStart() + (curPosition_ >> 9);
   8c226:	68fb      	ldr	r3, [r7, #12]
   8c228:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8c22a:	4618      	mov	r0, r3
   8c22c:	4b59      	ldr	r3, [pc, #356]	; (8c394 <_ZN6SdFile4readEPvt+0x1e8>)
   8c22e:	4798      	blx	r3
   8c230:	4602      	mov	r2, r0
   8c232:	68fb      	ldr	r3, [r7, #12]
   8c234:	691b      	ldr	r3, [r3, #16]
   8c236:	0a5b      	lsrs	r3, r3, #9
   8c238:	4413      	add	r3, r2
   8c23a:	627b      	str	r3, [r7, #36]	; 0x24
   8c23c:	e038      	b.n	8c2b0 <_ZN6SdFile4readEPvt+0x104>
    } else {
      uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
   8c23e:	68fb      	ldr	r3, [r7, #12]
   8c240:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   8c242:	68fb      	ldr	r3, [r7, #12]
   8c244:	691b      	ldr	r3, [r3, #16]
   8c246:	4619      	mov	r1, r3
   8c248:	4610      	mov	r0, r2
   8c24a:	4b53      	ldr	r3, [pc, #332]	; (8c398 <_ZN6SdFile4readEPvt+0x1ec>)
   8c24c:	4798      	blx	r3
   8c24e:	4603      	mov	r3, r0
   8c250:	74fb      	strb	r3, [r7, #19]
      if (offset == 0 && blockOfCluster == 0) {
   8c252:	8b7b      	ldrh	r3, [r7, #26]
   8c254:	2b00      	cmp	r3, #0
   8c256:	d11f      	bne.n	8c298 <_ZN6SdFile4readEPvt+0xec>
   8c258:	7cfb      	ldrb	r3, [r7, #19]
   8c25a:	2b00      	cmp	r3, #0
   8c25c:	d11c      	bne.n	8c298 <_ZN6SdFile4readEPvt+0xec>
        // start of new cluster
        if (curPosition_ == 0) {
   8c25e:	68fb      	ldr	r3, [r7, #12]
   8c260:	691b      	ldr	r3, [r3, #16]
   8c262:	2b00      	cmp	r3, #0
   8c264:	d104      	bne.n	8c270 <_ZN6SdFile4readEPvt+0xc4>
          // use first cluster in file
          curCluster_ = firstCluster_;
   8c266:	68fb      	ldr	r3, [r7, #12]
   8c268:	6a1a      	ldr	r2, [r3, #32]
   8c26a:	68fb      	ldr	r3, [r7, #12]
   8c26c:	60da      	str	r2, [r3, #12]
   8c26e:	e013      	b.n	8c298 <_ZN6SdFile4readEPvt+0xec>
        } else {
          // get next cluster from FAT
          if (!vol_->fatGet(curCluster_, &curCluster_)) return -1;
   8c270:	68fb      	ldr	r3, [r7, #12]
   8c272:	6a58      	ldr	r0, [r3, #36]	; 0x24
   8c274:	68fb      	ldr	r3, [r7, #12]
   8c276:	68d9      	ldr	r1, [r3, #12]
   8c278:	68fb      	ldr	r3, [r7, #12]
   8c27a:	330c      	adds	r3, #12
   8c27c:	461a      	mov	r2, r3
   8c27e:	4b47      	ldr	r3, [pc, #284]	; (8c39c <_ZN6SdFile4readEPvt+0x1f0>)
   8c280:	4798      	blx	r3
   8c282:	4603      	mov	r3, r0
   8c284:	2b00      	cmp	r3, #0
   8c286:	bf0c      	ite	eq
   8c288:	2301      	moveq	r3, #1
   8c28a:	2300      	movne	r3, #0
   8c28c:	b2db      	uxtb	r3, r3
   8c28e:	2b00      	cmp	r3, #0
   8c290:	d002      	beq.n	8c298 <_ZN6SdFile4readEPvt+0xec>
   8c292:	f04f 33ff 	mov.w	r3, #4294967295
   8c296:	e076      	b.n	8c386 <_ZN6SdFile4readEPvt+0x1da>
        }
      }
      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   8c298:	68fb      	ldr	r3, [r7, #12]
   8c29a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   8c29c:	68fb      	ldr	r3, [r7, #12]
   8c29e:	68db      	ldr	r3, [r3, #12]
   8c2a0:	4619      	mov	r1, r3
   8c2a2:	4610      	mov	r0, r2
   8c2a4:	4b3e      	ldr	r3, [pc, #248]	; (8c3a0 <_ZN6SdFile4readEPvt+0x1f4>)
   8c2a6:	4798      	blx	r3
   8c2a8:	4602      	mov	r2, r0
   8c2aa:	7cfb      	ldrb	r3, [r7, #19]
   8c2ac:	4413      	add	r3, r2
   8c2ae:	627b      	str	r3, [r7, #36]	; 0x24
    }
    uint16_t n = toRead;
   8c2b0:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   8c2b2:	847b      	strh	r3, [r7, #34]	; 0x22

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;
   8c2b4:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   8c2b6:	8b7b      	ldrh	r3, [r7, #26]
   8c2b8:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
   8c2bc:	429a      	cmp	r2, r3
   8c2be:	dd03      	ble.n	8c2c8 <_ZN6SdFile4readEPvt+0x11c>
   8c2c0:	8b7b      	ldrh	r3, [r7, #26]
   8c2c2:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
   8c2c6:	847b      	strh	r3, [r7, #34]	; 0x22

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
   8c2c8:	68f8      	ldr	r0, [r7, #12]
   8c2ca:	4b36      	ldr	r3, [pc, #216]	; (8c3a4 <_ZN6SdFile4readEPvt+0x1f8>)
   8c2cc:	4798      	blx	r3
   8c2ce:	4603      	mov	r3, r0
   8c2d0:	2b00      	cmp	r3, #0
   8c2d2:	d103      	bne.n	8c2dc <_ZN6SdFile4readEPvt+0x130>
   8c2d4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   8c2d6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   8c2da:	d106      	bne.n	8c2ea <_ZN6SdFile4readEPvt+0x13e>
      block != SdVolume::cacheBlockNumber_) {
   8c2dc:	4b32      	ldr	r3, [pc, #200]	; (8c3a8 <_ZN6SdFile4readEPvt+0x1fc>)
   8c2de:	681b      	ldr	r3, [r3, #0]

    // amount to be read from current block
    if (n > (512 - offset)) n = 512 - offset;

    // no buffering needed if n == 512 or user requests no buffering
    if ((unbufferedRead() || n == 512) &&
   8c2e0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   8c2e2:	429a      	cmp	r2, r3
   8c2e4:	d001      	beq.n	8c2ea <_ZN6SdFile4readEPvt+0x13e>
   8c2e6:	2301      	movs	r3, #1
   8c2e8:	e000      	b.n	8c2ec <_ZN6SdFile4readEPvt+0x140>
   8c2ea:	2300      	movs	r3, #0
   8c2ec:	2b00      	cmp	r3, #0
   8c2ee:	d019      	beq.n	8c324 <_ZN6SdFile4readEPvt+0x178>
      block != SdVolume::cacheBlockNumber_) {
      if (!vol_->readData(block, offset, n, dst)) return -1;
   8c2f0:	68fb      	ldr	r3, [r7, #12]
   8c2f2:	6a58      	ldr	r0, [r3, #36]	; 0x24
   8c2f4:	8c79      	ldrh	r1, [r7, #34]	; 0x22
   8c2f6:	8b7a      	ldrh	r2, [r7, #26]
   8c2f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   8c2fa:	9300      	str	r3, [sp, #0]
   8c2fc:	460b      	mov	r3, r1
   8c2fe:	6a79      	ldr	r1, [r7, #36]	; 0x24
   8c300:	4c2a      	ldr	r4, [pc, #168]	; (8c3ac <_ZN6SdFile4readEPvt+0x200>)
   8c302:	47a0      	blx	r4
   8c304:	4603      	mov	r3, r0
   8c306:	2b00      	cmp	r3, #0
   8c308:	bf0c      	ite	eq
   8c30a:	2301      	moveq	r3, #1
   8c30c:	2300      	movne	r3, #0
   8c30e:	b2db      	uxtb	r3, r3
   8c310:	2b00      	cmp	r3, #0
   8c312:	d002      	beq.n	8c31a <_ZN6SdFile4readEPvt+0x16e>
   8c314:	f04f 33ff 	mov.w	r3, #4294967295
   8c318:	e035      	b.n	8c386 <_ZN6SdFile4readEPvt+0x1da>
      dst += n;
   8c31a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   8c31c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   8c31e:	4413      	add	r3, r2
   8c320:	62fb      	str	r3, [r7, #44]	; 0x2c
   8c322:	e023      	b.n	8c36c <_ZN6SdFile4readEPvt+0x1c0>
    } else {
      // read block to cache and copy data to caller
      if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
   8c324:	2100      	movs	r1, #0
   8c326:	6a78      	ldr	r0, [r7, #36]	; 0x24
   8c328:	4b21      	ldr	r3, [pc, #132]	; (8c3b0 <_ZN6SdFile4readEPvt+0x204>)
   8c32a:	4798      	blx	r3
   8c32c:	4603      	mov	r3, r0
   8c32e:	2b00      	cmp	r3, #0
   8c330:	bf0c      	ite	eq
   8c332:	2301      	moveq	r3, #1
   8c334:	2300      	movne	r3, #0
   8c336:	b2db      	uxtb	r3, r3
   8c338:	2b00      	cmp	r3, #0
   8c33a:	d002      	beq.n	8c342 <_ZN6SdFile4readEPvt+0x196>
   8c33c:	f04f 33ff 	mov.w	r3, #4294967295
   8c340:	e021      	b.n	8c386 <_ZN6SdFile4readEPvt+0x1da>
      uint8_t* src = SdVolume::cacheBuffer_.data + offset;
   8c342:	8b7b      	ldrh	r3, [r7, #26]
   8c344:	4a1b      	ldr	r2, [pc, #108]	; (8c3b4 <_ZN6SdFile4readEPvt+0x208>)
   8c346:	4413      	add	r3, r2
   8c348:	61fb      	str	r3, [r7, #28]
      uint8_t* end = src + n;
   8c34a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   8c34c:	69fa      	ldr	r2, [r7, #28]
   8c34e:	4413      	add	r3, r2
   8c350:	617b      	str	r3, [r7, #20]
      while (src != end) *dst++ = *src++;
   8c352:	69fa      	ldr	r2, [r7, #28]
   8c354:	697b      	ldr	r3, [r7, #20]
   8c356:	429a      	cmp	r2, r3
   8c358:	d008      	beq.n	8c36c <_ZN6SdFile4readEPvt+0x1c0>
   8c35a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   8c35c:	1c5a      	adds	r2, r3, #1
   8c35e:	62fa      	str	r2, [r7, #44]	; 0x2c
   8c360:	69fa      	ldr	r2, [r7, #28]
   8c362:	1c51      	adds	r1, r2, #1
   8c364:	61f9      	str	r1, [r7, #28]
   8c366:	7812      	ldrb	r2, [r2, #0]
   8c368:	701a      	strb	r2, [r3, #0]
   8c36a:	e7f2      	b.n	8c352 <_ZN6SdFile4readEPvt+0x1a6>
    }
    curPosition_ += n;
   8c36c:	68fb      	ldr	r3, [r7, #12]
   8c36e:	691a      	ldr	r2, [r3, #16]
   8c370:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   8c372:	441a      	add	r2, r3
   8c374:	68fb      	ldr	r3, [r7, #12]
   8c376:	611a      	str	r2, [r3, #16]
    toRead -= n;
   8c378:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
   8c37a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   8c37c:	1ad3      	subs	r3, r2, r3
   8c37e:	857b      	strh	r3, [r7, #42]	; 0x2a
  // max bytes left in file
  if (nbyte > (fileSize_ - curPosition_)) nbyte = fileSize_ - curPosition_;

  // amount left to read
  uint16_t toRead = nbyte;
  while (toRead > 0) {
   8c380:	e743      	b.n	8c20a <_ZN6SdFile4readEPvt+0x5e>
      while (src != end) *dst++ = *src++;
    }
    curPosition_ += n;
    toRead -= n;
  }
  return nbyte;
   8c382:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
}
   8c386:	4618      	mov	r0, r3
   8c388:	3734      	adds	r7, #52	; 0x34
   8c38a:	46bd      	mov	sp, r7
   8c38c:	bd90      	pop	{r4, r7, pc}
   8c38e:	bf00      	nop
   8c390:	0008a3a1 	.word	0x0008a3a1
   8c394:	0008b9a5 	.word	0x0008b9a5
   8c398:	0008b9bd 	.word	0x0008b9bd
   8c39c:	0008cde5 	.word	0x0008cde5
   8c3a0:	0008b9e5 	.word	0x0008b9e5
   8c3a4:	0008b959 	.word	0x0008b959
   8c3a8:	20070114 	.word	0x20070114
   8c3ac:	0008ba85 	.word	0x0008ba85
   8c3b0:	0008cc85 	.word	0x0008cc85
   8c3b4:	2007191c 	.word	0x2007191c

0008c3b8 <_ZN6SdFile12readDirCacheEv>:
  return n < 0 ? -1 : 0;
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
dir_t* SdFile::readDirCache(void) {
   8c3b8:	b580      	push	{r7, lr}
   8c3ba:	b084      	sub	sp, #16
   8c3bc:	af00      	add	r7, sp, #0
   8c3be:	6078      	str	r0, [r7, #4]
  // error if not directory
  if (!isDir()) return NULL;
   8c3c0:	6878      	ldr	r0, [r7, #4]
   8c3c2:	4b16      	ldr	r3, [pc, #88]	; (8c41c <_ZN6SdFile12readDirCacheEv+0x64>)
   8c3c4:	4798      	blx	r3
   8c3c6:	4603      	mov	r3, r0
   8c3c8:	2b00      	cmp	r3, #0
   8c3ca:	bf0c      	ite	eq
   8c3cc:	2301      	moveq	r3, #1
   8c3ce:	2300      	movne	r3, #0
   8c3d0:	b2db      	uxtb	r3, r3
   8c3d2:	2b00      	cmp	r3, #0
   8c3d4:	d001      	beq.n	8c3da <_ZN6SdFile12readDirCacheEv+0x22>
   8c3d6:	2300      	movs	r3, #0
   8c3d8:	e01b      	b.n	8c412 <_ZN6SdFile12readDirCacheEv+0x5a>

  // index of entry in cache
  uint8_t i = (curPosition_ >> 5) & 0XF;
   8c3da:	687b      	ldr	r3, [r7, #4]
   8c3dc:	691b      	ldr	r3, [r3, #16]
   8c3de:	095b      	lsrs	r3, r3, #5
   8c3e0:	b2db      	uxtb	r3, r3
   8c3e2:	f003 030f 	and.w	r3, r3, #15
   8c3e6:	73fb      	strb	r3, [r7, #15]

  // use read to locate and cache block
  if (read() < 0) return NULL;
   8c3e8:	6878      	ldr	r0, [r7, #4]
   8c3ea:	4b0d      	ldr	r3, [pc, #52]	; (8c420 <_ZN6SdFile12readDirCacheEv+0x68>)
   8c3ec:	4798      	blx	r3
   8c3ee:	4603      	mov	r3, r0
   8c3f0:	b29b      	uxth	r3, r3
   8c3f2:	0bdb      	lsrs	r3, r3, #15
   8c3f4:	b2db      	uxtb	r3, r3
   8c3f6:	2b00      	cmp	r3, #0
   8c3f8:	d001      	beq.n	8c3fe <_ZN6SdFile12readDirCacheEv+0x46>
   8c3fa:	2300      	movs	r3, #0
   8c3fc:	e009      	b.n	8c412 <_ZN6SdFile12readDirCacheEv+0x5a>

  // advance to next entry
  curPosition_ += 31;
   8c3fe:	687b      	ldr	r3, [r7, #4]
   8c400:	691b      	ldr	r3, [r3, #16]
   8c402:	f103 021f 	add.w	r2, r3, #31
   8c406:	687b      	ldr	r3, [r7, #4]
   8c408:	611a      	str	r2, [r3, #16]

  // return pointer to entry
  return (SdVolume::cacheBuffer_.dir + i);
   8c40a:	7bfb      	ldrb	r3, [r7, #15]
   8c40c:	015b      	lsls	r3, r3, #5
   8c40e:	4a05      	ldr	r2, [pc, #20]	; (8c424 <_ZN6SdFile12readDirCacheEv+0x6c>)
   8c410:	4413      	add	r3, r2
}
   8c412:	4618      	mov	r0, r3
   8c414:	3710      	adds	r7, #16
   8c416:	46bd      	mov	sp, r7
   8c418:	bd80      	pop	{r7, pc}
   8c41a:	bf00      	nop
   8c41c:	0008a381 	.word	0x0008a381
   8c420:	0008a3c1 	.word	0x0008a3c1
   8c424:	2007191c 	.word	0x2007191c

0008c428 <_ZN6SdFile7seekSetEm>:
 * \param[in] pos The new position in bytes from the beginning of the file.
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t SdFile::seekSet(uint32_t pos) {
   8c428:	b580      	push	{r7, lr}
   8c42a:	b084      	sub	sp, #16
   8c42c:	af00      	add	r7, sp, #0
   8c42e:	6078      	str	r0, [r7, #4]
   8c430:	6039      	str	r1, [r7, #0]
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) return false;
   8c432:	6878      	ldr	r0, [r7, #4]
   8c434:	4b36      	ldr	r3, [pc, #216]	; (8c510 <_ZN6SdFile7seekSetEm+0xe8>)
   8c436:	4798      	blx	r3
   8c438:	4603      	mov	r3, r0
   8c43a:	2b00      	cmp	r3, #0
   8c43c:	d004      	beq.n	8c448 <_ZN6SdFile7seekSetEm+0x20>
   8c43e:	687b      	ldr	r3, [r7, #4]
   8c440:	69da      	ldr	r2, [r3, #28]
   8c442:	683b      	ldr	r3, [r7, #0]
   8c444:	429a      	cmp	r2, r3
   8c446:	d201      	bcs.n	8c44c <_ZN6SdFile7seekSetEm+0x24>
   8c448:	2301      	movs	r3, #1
   8c44a:	e000      	b.n	8c44e <_ZN6SdFile7seekSetEm+0x26>
   8c44c:	2300      	movs	r3, #0
   8c44e:	2b00      	cmp	r3, #0
   8c450:	d001      	beq.n	8c456 <_ZN6SdFile7seekSetEm+0x2e>
   8c452:	2300      	movs	r3, #0
   8c454:	e058      	b.n	8c508 <_ZN6SdFile7seekSetEm+0xe0>

  if (type_ == FAT_FILE_TYPE_ROOT16) {
   8c456:	687b      	ldr	r3, [r7, #4]
   8c458:	7a5b      	ldrb	r3, [r3, #9]
   8c45a:	2b02      	cmp	r3, #2
   8c45c:	d104      	bne.n	8c468 <_ZN6SdFile7seekSetEm+0x40>
    curPosition_ = pos;
   8c45e:	687b      	ldr	r3, [r7, #4]
   8c460:	683a      	ldr	r2, [r7, #0]
   8c462:	611a      	str	r2, [r3, #16]
    return true;
   8c464:	2301      	movs	r3, #1
   8c466:	e04f      	b.n	8c508 <_ZN6SdFile7seekSetEm+0xe0>
  }
  if (pos == 0) {
   8c468:	683b      	ldr	r3, [r7, #0]
   8c46a:	2b00      	cmp	r3, #0
   8c46c:	d107      	bne.n	8c47e <_ZN6SdFile7seekSetEm+0x56>
    // set position to start of file
    curCluster_ = 0;
   8c46e:	687b      	ldr	r3, [r7, #4]
   8c470:	2200      	movs	r2, #0
   8c472:	60da      	str	r2, [r3, #12]
    curPosition_ = 0;
   8c474:	687b      	ldr	r3, [r7, #4]
   8c476:	2200      	movs	r2, #0
   8c478:	611a      	str	r2, [r3, #16]
    return true;
   8c47a:	2301      	movs	r3, #1
   8c47c:	e044      	b.n	8c508 <_ZN6SdFile7seekSetEm+0xe0>
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
   8c47e:	687b      	ldr	r3, [r7, #4]
   8c480:	691b      	ldr	r3, [r3, #16]
   8c482:	1e5a      	subs	r2, r3, #1
   8c484:	687b      	ldr	r3, [r7, #4]
   8c486:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8c488:	7c1b      	ldrb	r3, [r3, #16]
   8c48a:	3309      	adds	r3, #9
   8c48c:	fa22 f303 	lsr.w	r3, r2, r3
   8c490:	60bb      	str	r3, [r7, #8]
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
   8c492:	683b      	ldr	r3, [r7, #0]
   8c494:	1e5a      	subs	r2, r3, #1
   8c496:	687b      	ldr	r3, [r7, #4]
   8c498:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8c49a:	7c1b      	ldrb	r3, [r3, #16]
   8c49c:	3309      	adds	r3, #9
   8c49e:	fa22 f303 	lsr.w	r3, r2, r3
   8c4a2:	60fb      	str	r3, [r7, #12]

  if (nNew < nCur || curPosition_ == 0) {
   8c4a4:	68fa      	ldr	r2, [r7, #12]
   8c4a6:	68bb      	ldr	r3, [r7, #8]
   8c4a8:	429a      	cmp	r2, r3
   8c4aa:	d303      	bcc.n	8c4b4 <_ZN6SdFile7seekSetEm+0x8c>
   8c4ac:	687b      	ldr	r3, [r7, #4]
   8c4ae:	691b      	ldr	r3, [r3, #16]
   8c4b0:	2b00      	cmp	r3, #0
   8c4b2:	d104      	bne.n	8c4be <_ZN6SdFile7seekSetEm+0x96>
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
   8c4b4:	687b      	ldr	r3, [r7, #4]
   8c4b6:	6a1a      	ldr	r2, [r3, #32]
   8c4b8:	687b      	ldr	r3, [r7, #4]
   8c4ba:	60da      	str	r2, [r3, #12]
   8c4bc:	e003      	b.n	8c4c6 <_ZN6SdFile7seekSetEm+0x9e>
  } else {
    // advance from curPosition
    nNew -= nCur;
   8c4be:	68fa      	ldr	r2, [r7, #12]
   8c4c0:	68bb      	ldr	r3, [r7, #8]
   8c4c2:	1ad3      	subs	r3, r2, r3
   8c4c4:	60fb      	str	r3, [r7, #12]
  }
  while (nNew--) {
   8c4c6:	68fb      	ldr	r3, [r7, #12]
   8c4c8:	1e5a      	subs	r2, r3, #1
   8c4ca:	60fa      	str	r2, [r7, #12]
   8c4cc:	2b00      	cmp	r3, #0
   8c4ce:	bf14      	ite	ne
   8c4d0:	2301      	movne	r3, #1
   8c4d2:	2300      	moveq	r3, #0
   8c4d4:	b2db      	uxtb	r3, r3
   8c4d6:	2b00      	cmp	r3, #0
   8c4d8:	d012      	beq.n	8c500 <_ZN6SdFile7seekSetEm+0xd8>
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
   8c4da:	687b      	ldr	r3, [r7, #4]
   8c4dc:	6a58      	ldr	r0, [r3, #36]	; 0x24
   8c4de:	687b      	ldr	r3, [r7, #4]
   8c4e0:	68d9      	ldr	r1, [r3, #12]
   8c4e2:	687b      	ldr	r3, [r7, #4]
   8c4e4:	330c      	adds	r3, #12
   8c4e6:	461a      	mov	r2, r3
   8c4e8:	4b0a      	ldr	r3, [pc, #40]	; (8c514 <_ZN6SdFile7seekSetEm+0xec>)
   8c4ea:	4798      	blx	r3
   8c4ec:	4603      	mov	r3, r0
   8c4ee:	2b00      	cmp	r3, #0
   8c4f0:	bf0c      	ite	eq
   8c4f2:	2301      	moveq	r3, #1
   8c4f4:	2300      	movne	r3, #0
   8c4f6:	b2db      	uxtb	r3, r3
   8c4f8:	2b00      	cmp	r3, #0
   8c4fa:	d0e4      	beq.n	8c4c6 <_ZN6SdFile7seekSetEm+0x9e>
   8c4fc:	2300      	movs	r3, #0
   8c4fe:	e003      	b.n	8c508 <_ZN6SdFile7seekSetEm+0xe0>
  }
  curPosition_ = pos;
   8c500:	687b      	ldr	r3, [r7, #4]
   8c502:	683a      	ldr	r2, [r7, #0]
   8c504:	611a      	str	r2, [r3, #16]
  return true;
   8c506:	2301      	movs	r3, #1
}
   8c508:	4618      	mov	r0, r3
   8c50a:	3710      	adds	r7, #16
   8c50c:	46bd      	mov	sp, r7
   8c50e:	bd80      	pop	{r7, pc}
   8c510:	0008a3a1 	.word	0x0008a3a1
   8c514:	0008cde5 	.word	0x0008cde5

0008c518 <_ZN6SdFile4syncEv>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include a call to sync() before a file has been
 * opened or an I/O error.
 */
uint8_t SdFile::sync(void) {
   8c518:	b580      	push	{r7, lr}
   8c51a:	b084      	sub	sp, #16
   8c51c:	af00      	add	r7, sp, #0
   8c51e:	6078      	str	r0, [r7, #4]
  // only allow open files and directories
  if (!isOpen()) return false;
   8c520:	6878      	ldr	r0, [r7, #4]
   8c522:	4b2a      	ldr	r3, [pc, #168]	; (8c5cc <_ZN6SdFile4syncEv+0xb4>)
   8c524:	4798      	blx	r3
   8c526:	4603      	mov	r3, r0
   8c528:	2b00      	cmp	r3, #0
   8c52a:	bf0c      	ite	eq
   8c52c:	2301      	moveq	r3, #1
   8c52e:	2300      	movne	r3, #0
   8c530:	b2db      	uxtb	r3, r3
   8c532:	2b00      	cmp	r3, #0
   8c534:	d001      	beq.n	8c53a <_ZN6SdFile4syncEv+0x22>
   8c536:	2300      	movs	r3, #0
   8c538:	e044      	b.n	8c5c4 <_ZN6SdFile4syncEv+0xac>

  if (flags_ & F_FILE_DIR_DIRTY) {
   8c53a:	687b      	ldr	r3, [r7, #4]
   8c53c:	7a1b      	ldrb	r3, [r3, #8]
   8c53e:	b25b      	sxtb	r3, r3
   8c540:	2b00      	cmp	r3, #0
   8c542:	da3c      	bge.n	8c5be <_ZN6SdFile4syncEv+0xa6>
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   8c544:	2101      	movs	r1, #1
   8c546:	6878      	ldr	r0, [r7, #4]
   8c548:	4b21      	ldr	r3, [pc, #132]	; (8c5d0 <_ZN6SdFile4syncEv+0xb8>)
   8c54a:	4798      	blx	r3
   8c54c:	60f8      	str	r0, [r7, #12]
    if (!d) return false;
   8c54e:	68fb      	ldr	r3, [r7, #12]
   8c550:	2b00      	cmp	r3, #0
   8c552:	d101      	bne.n	8c558 <_ZN6SdFile4syncEv+0x40>
   8c554:	2300      	movs	r3, #0
   8c556:	e035      	b.n	8c5c4 <_ZN6SdFile4syncEv+0xac>

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;
   8c558:	6878      	ldr	r0, [r7, #4]
   8c55a:	4b1e      	ldr	r3, [pc, #120]	; (8c5d4 <_ZN6SdFile4syncEv+0xbc>)
   8c55c:	4798      	blx	r3
   8c55e:	4603      	mov	r3, r0
   8c560:	2b00      	cmp	r3, #0
   8c562:	bf0c      	ite	eq
   8c564:	2301      	moveq	r3, #1
   8c566:	2300      	movne	r3, #0
   8c568:	b2db      	uxtb	r3, r3
   8c56a:	2b00      	cmp	r3, #0
   8c56c:	d003      	beq.n	8c576 <_ZN6SdFile4syncEv+0x5e>
   8c56e:	687b      	ldr	r3, [r7, #4]
   8c570:	69da      	ldr	r2, [r3, #28]
   8c572:	68fb      	ldr	r3, [r7, #12]
   8c574:	61da      	str	r2, [r3, #28]

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
   8c576:	687b      	ldr	r3, [r7, #4]
   8c578:	6a1b      	ldr	r3, [r3, #32]
   8c57a:	b29a      	uxth	r2, r3
   8c57c:	68fb      	ldr	r3, [r7, #12]
   8c57e:	835a      	strh	r2, [r3, #26]
    d->firstClusterHigh = firstCluster_ >> 16;
   8c580:	687b      	ldr	r3, [r7, #4]
   8c582:	6a1b      	ldr	r3, [r3, #32]
   8c584:	0c1b      	lsrs	r3, r3, #16
   8c586:	b29a      	uxth	r2, r3
   8c588:	68fb      	ldr	r3, [r7, #12]
   8c58a:	829a      	strh	r2, [r3, #20]

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
   8c58c:	4b12      	ldr	r3, [pc, #72]	; (8c5d8 <_ZN6SdFile4syncEv+0xc0>)
   8c58e:	681b      	ldr	r3, [r3, #0]
   8c590:	2b00      	cmp	r3, #0
   8c592:	d00d      	beq.n	8c5b0 <_ZN6SdFile4syncEv+0x98>
      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
   8c594:	4b10      	ldr	r3, [pc, #64]	; (8c5d8 <_ZN6SdFile4syncEv+0xc0>)
   8c596:	681b      	ldr	r3, [r3, #0]
   8c598:	68fa      	ldr	r2, [r7, #12]
   8c59a:	f102 0018 	add.w	r0, r2, #24
   8c59e:	68fa      	ldr	r2, [r7, #12]
   8c5a0:	3216      	adds	r2, #22
   8c5a2:	4611      	mov	r1, r2
   8c5a4:	4798      	blx	r3
      d->lastAccessDate = d->lastWriteDate;
   8c5a6:	68fb      	ldr	r3, [r7, #12]
   8c5a8:	8b1b      	ldrh	r3, [r3, #24]
   8c5aa:	b29a      	uxth	r2, r3
   8c5ac:	68fb      	ldr	r3, [r7, #12]
   8c5ae:	825a      	strh	r2, [r3, #18]
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
   8c5b0:	687b      	ldr	r3, [r7, #4]
   8c5b2:	7a1b      	ldrb	r3, [r3, #8]
   8c5b4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   8c5b8:	b2da      	uxtb	r2, r3
   8c5ba:	687b      	ldr	r3, [r7, #4]
   8c5bc:	721a      	strb	r2, [r3, #8]
  }
  return SdVolume::cacheFlush();
   8c5be:	4b07      	ldr	r3, [pc, #28]	; (8c5dc <_ZN6SdFile4syncEv+0xc4>)
   8c5c0:	4798      	blx	r3
   8c5c2:	4603      	mov	r3, r0
}
   8c5c4:	4618      	mov	r0, r3
   8c5c6:	3710      	adds	r7, #16
   8c5c8:	46bd      	mov	sp, r7
   8c5ca:	bd80      	pop	{r7, pc}
   8c5cc:	0008a3a1 	.word	0x0008a3a1
   8c5d0:	0008bbe1 	.word	0x0008bbe1
   8c5d4:	0008a381 	.word	0x0008a381
   8c5d8:	20071918 	.word	0x20071918
   8c5dc:	0008cbfd 	.word	0x0008cbfd

0008c5e0 <_ZN6SdFile8truncateEm>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include file is read only, file is a directory,
 * \a length is greater than the current file size or an I/O error occurs.
 */
uint8_t SdFile::truncate(uint32_t length) {
   8c5e0:	b580      	push	{r7, lr}
   8c5e2:	b084      	sub	sp, #16
   8c5e4:	af00      	add	r7, sp, #0
   8c5e6:	6078      	str	r0, [r7, #4]
   8c5e8:	6039      	str	r1, [r7, #0]
// error if not a normal file or read-only
  if (!isFile() || !(flags_ & O_WRITE)) return false;
   8c5ea:	6878      	ldr	r0, [r7, #4]
   8c5ec:	4b5a      	ldr	r3, [pc, #360]	; (8c758 <_ZN6SdFile8truncateEm+0x178>)
   8c5ee:	4798      	blx	r3
   8c5f0:	4603      	mov	r3, r0
   8c5f2:	2b00      	cmp	r3, #0
   8c5f4:	d005      	beq.n	8c602 <_ZN6SdFile8truncateEm+0x22>
   8c5f6:	687b      	ldr	r3, [r7, #4]
   8c5f8:	7a1b      	ldrb	r3, [r3, #8]
   8c5fa:	f003 0302 	and.w	r3, r3, #2
   8c5fe:	2b00      	cmp	r3, #0
   8c600:	d101      	bne.n	8c606 <_ZN6SdFile8truncateEm+0x26>
   8c602:	2301      	movs	r3, #1
   8c604:	e000      	b.n	8c608 <_ZN6SdFile8truncateEm+0x28>
   8c606:	2300      	movs	r3, #0
   8c608:	2b00      	cmp	r3, #0
   8c60a:	d001      	beq.n	8c610 <_ZN6SdFile8truncateEm+0x30>
   8c60c:	2300      	movs	r3, #0
   8c60e:	e09e      	b.n	8c74e <_ZN6SdFile8truncateEm+0x16e>

  // error if length is greater than current size
  if (length > fileSize_) return false;
   8c610:	687b      	ldr	r3, [r7, #4]
   8c612:	69da      	ldr	r2, [r3, #28]
   8c614:	683b      	ldr	r3, [r7, #0]
   8c616:	429a      	cmp	r2, r3
   8c618:	d201      	bcs.n	8c61e <_ZN6SdFile8truncateEm+0x3e>
   8c61a:	2300      	movs	r3, #0
   8c61c:	e097      	b.n	8c74e <_ZN6SdFile8truncateEm+0x16e>

  // fileSize and length are zero - nothing to do
  if (fileSize_ == 0) return true;
   8c61e:	687b      	ldr	r3, [r7, #4]
   8c620:	69db      	ldr	r3, [r3, #28]
   8c622:	2b00      	cmp	r3, #0
   8c624:	d101      	bne.n	8c62a <_ZN6SdFile8truncateEm+0x4a>
   8c626:	2301      	movs	r3, #1
   8c628:	e091      	b.n	8c74e <_ZN6SdFile8truncateEm+0x16e>

  // remember position for seek after truncation
  uint32_t newPos = curPosition_ > length ? length : curPosition_;
   8c62a:	687b      	ldr	r3, [r7, #4]
   8c62c:	691a      	ldr	r2, [r3, #16]
   8c62e:	683b      	ldr	r3, [r7, #0]
   8c630:	429a      	cmp	r2, r3
   8c632:	d802      	bhi.n	8c63a <_ZN6SdFile8truncateEm+0x5a>
   8c634:	687b      	ldr	r3, [r7, #4]
   8c636:	691b      	ldr	r3, [r3, #16]
   8c638:	e000      	b.n	8c63c <_ZN6SdFile8truncateEm+0x5c>
   8c63a:	683b      	ldr	r3, [r7, #0]
   8c63c:	60fb      	str	r3, [r7, #12]

  // position to last cluster in truncated file
  if (!seekSet(length)) return false;
   8c63e:	6839      	ldr	r1, [r7, #0]
   8c640:	6878      	ldr	r0, [r7, #4]
   8c642:	4b46      	ldr	r3, [pc, #280]	; (8c75c <_ZN6SdFile8truncateEm+0x17c>)
   8c644:	4798      	blx	r3
   8c646:	4603      	mov	r3, r0
   8c648:	2b00      	cmp	r3, #0
   8c64a:	bf0c      	ite	eq
   8c64c:	2301      	moveq	r3, #1
   8c64e:	2300      	movne	r3, #0
   8c650:	b2db      	uxtb	r3, r3
   8c652:	2b00      	cmp	r3, #0
   8c654:	d001      	beq.n	8c65a <_ZN6SdFile8truncateEm+0x7a>
   8c656:	2300      	movs	r3, #0
   8c658:	e079      	b.n	8c74e <_ZN6SdFile8truncateEm+0x16e>

  if (length == 0) {
   8c65a:	683b      	ldr	r3, [r7, #0]
   8c65c:	2b00      	cmp	r3, #0
   8c65e:	d115      	bne.n	8c68c <_ZN6SdFile8truncateEm+0xac>
    // free all clusters
    if (!vol_->freeChain(firstCluster_)) return false;
   8c660:	687b      	ldr	r3, [r7, #4]
   8c662:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   8c664:	687b      	ldr	r3, [r7, #4]
   8c666:	6a1b      	ldr	r3, [r3, #32]
   8c668:	4619      	mov	r1, r3
   8c66a:	4610      	mov	r0, r2
   8c66c:	4b3c      	ldr	r3, [pc, #240]	; (8c760 <_ZN6SdFile8truncateEm+0x180>)
   8c66e:	4798      	blx	r3
   8c670:	4603      	mov	r3, r0
   8c672:	2b00      	cmp	r3, #0
   8c674:	bf0c      	ite	eq
   8c676:	2301      	moveq	r3, #1
   8c678:	2300      	movne	r3, #0
   8c67a:	b2db      	uxtb	r3, r3
   8c67c:	2b00      	cmp	r3, #0
   8c67e:	d001      	beq.n	8c684 <_ZN6SdFile8truncateEm+0xa4>
   8c680:	2300      	movs	r3, #0
   8c682:	e064      	b.n	8c74e <_ZN6SdFile8truncateEm+0x16e>
    firstCluster_ = 0;
   8c684:	687b      	ldr	r3, [r7, #4]
   8c686:	2200      	movs	r2, #0
   8c688:	621a      	str	r2, [r3, #32]
   8c68a:	e044      	b.n	8c716 <_ZN6SdFile8truncateEm+0x136>
  } else {
    uint32_t toFree;
    if (!vol_->fatGet(curCluster_, &toFree)) return false;
   8c68c:	687b      	ldr	r3, [r7, #4]
   8c68e:	6a58      	ldr	r0, [r3, #36]	; 0x24
   8c690:	687b      	ldr	r3, [r7, #4]
   8c692:	68db      	ldr	r3, [r3, #12]
   8c694:	f107 0208 	add.w	r2, r7, #8
   8c698:	4619      	mov	r1, r3
   8c69a:	4b32      	ldr	r3, [pc, #200]	; (8c764 <_ZN6SdFile8truncateEm+0x184>)
   8c69c:	4798      	blx	r3
   8c69e:	4603      	mov	r3, r0
   8c6a0:	2b00      	cmp	r3, #0
   8c6a2:	bf0c      	ite	eq
   8c6a4:	2301      	moveq	r3, #1
   8c6a6:	2300      	movne	r3, #0
   8c6a8:	b2db      	uxtb	r3, r3
   8c6aa:	2b00      	cmp	r3, #0
   8c6ac:	d001      	beq.n	8c6b2 <_ZN6SdFile8truncateEm+0xd2>
   8c6ae:	2300      	movs	r3, #0
   8c6b0:	e04d      	b.n	8c74e <_ZN6SdFile8truncateEm+0x16e>

    if (!vol_->isEOC(toFree)) {
   8c6b2:	687b      	ldr	r3, [r7, #4]
   8c6b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8c6b6:	68ba      	ldr	r2, [r7, #8]
   8c6b8:	4611      	mov	r1, r2
   8c6ba:	4618      	mov	r0, r3
   8c6bc:	4b2a      	ldr	r3, [pc, #168]	; (8c768 <_ZN6SdFile8truncateEm+0x188>)
   8c6be:	4798      	blx	r3
   8c6c0:	4603      	mov	r3, r0
   8c6c2:	2b00      	cmp	r3, #0
   8c6c4:	bf0c      	ite	eq
   8c6c6:	2301      	moveq	r3, #1
   8c6c8:	2300      	movne	r3, #0
   8c6ca:	b2db      	uxtb	r3, r3
   8c6cc:	2b00      	cmp	r3, #0
   8c6ce:	d022      	beq.n	8c716 <_ZN6SdFile8truncateEm+0x136>
      // free extra clusters
      if (!vol_->freeChain(toFree)) return false;
   8c6d0:	687b      	ldr	r3, [r7, #4]
   8c6d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8c6d4:	68ba      	ldr	r2, [r7, #8]
   8c6d6:	4611      	mov	r1, r2
   8c6d8:	4618      	mov	r0, r3
   8c6da:	4b21      	ldr	r3, [pc, #132]	; (8c760 <_ZN6SdFile8truncateEm+0x180>)
   8c6dc:	4798      	blx	r3
   8c6de:	4603      	mov	r3, r0
   8c6e0:	2b00      	cmp	r3, #0
   8c6e2:	bf0c      	ite	eq
   8c6e4:	2301      	moveq	r3, #1
   8c6e6:	2300      	movne	r3, #0
   8c6e8:	b2db      	uxtb	r3, r3
   8c6ea:	2b00      	cmp	r3, #0
   8c6ec:	d001      	beq.n	8c6f2 <_ZN6SdFile8truncateEm+0x112>
   8c6ee:	2300      	movs	r3, #0
   8c6f0:	e02d      	b.n	8c74e <_ZN6SdFile8truncateEm+0x16e>

      // current cluster is end of chain
      if (!vol_->fatPutEOC(curCluster_)) return false;
   8c6f2:	687b      	ldr	r3, [r7, #4]
   8c6f4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   8c6f6:	687b      	ldr	r3, [r7, #4]
   8c6f8:	68db      	ldr	r3, [r3, #12]
   8c6fa:	4619      	mov	r1, r3
   8c6fc:	4610      	mov	r0, r2
   8c6fe:	4b1b      	ldr	r3, [pc, #108]	; (8c76c <_ZN6SdFile8truncateEm+0x18c>)
   8c700:	4798      	blx	r3
   8c702:	4603      	mov	r3, r0
   8c704:	2b00      	cmp	r3, #0
   8c706:	bf0c      	ite	eq
   8c708:	2301      	moveq	r3, #1
   8c70a:	2300      	movne	r3, #0
   8c70c:	b2db      	uxtb	r3, r3
   8c70e:	2b00      	cmp	r3, #0
   8c710:	d001      	beq.n	8c716 <_ZN6SdFile8truncateEm+0x136>
   8c712:	2300      	movs	r3, #0
   8c714:	e01b      	b.n	8c74e <_ZN6SdFile8truncateEm+0x16e>
    }
  }
  fileSize_ = length;
   8c716:	687b      	ldr	r3, [r7, #4]
   8c718:	683a      	ldr	r2, [r7, #0]
   8c71a:	61da      	str	r2, [r3, #28]

  // need to update directory entry
  flags_ |= F_FILE_DIR_DIRTY;
   8c71c:	687b      	ldr	r3, [r7, #4]
   8c71e:	7a1b      	ldrb	r3, [r3, #8]
   8c720:	2280      	movs	r2, #128	; 0x80
   8c722:	4313      	orrs	r3, r2
   8c724:	b2da      	uxtb	r2, r3
   8c726:	687b      	ldr	r3, [r7, #4]
   8c728:	721a      	strb	r2, [r3, #8]

  if (!sync()) return false;
   8c72a:	6878      	ldr	r0, [r7, #4]
   8c72c:	4b10      	ldr	r3, [pc, #64]	; (8c770 <_ZN6SdFile8truncateEm+0x190>)
   8c72e:	4798      	blx	r3
   8c730:	4603      	mov	r3, r0
   8c732:	2b00      	cmp	r3, #0
   8c734:	bf0c      	ite	eq
   8c736:	2301      	moveq	r3, #1
   8c738:	2300      	movne	r3, #0
   8c73a:	b2db      	uxtb	r3, r3
   8c73c:	2b00      	cmp	r3, #0
   8c73e:	d001      	beq.n	8c744 <_ZN6SdFile8truncateEm+0x164>
   8c740:	2300      	movs	r3, #0
   8c742:	e004      	b.n	8c74e <_ZN6SdFile8truncateEm+0x16e>

  // set file to correct position
  return seekSet(newPos);
   8c744:	68f9      	ldr	r1, [r7, #12]
   8c746:	6878      	ldr	r0, [r7, #4]
   8c748:	4b04      	ldr	r3, [pc, #16]	; (8c75c <_ZN6SdFile8truncateEm+0x17c>)
   8c74a:	4798      	blx	r3
   8c74c:	4603      	mov	r3, r0
}
   8c74e:	4618      	mov	r0, r3
   8c750:	3710      	adds	r7, #16
   8c752:	46bd      	mov	sp, r7
   8c754:	bd80      	pop	{r7, pc}
   8c756:	bf00      	nop
   8c758:	0008b915 	.word	0x0008b915
   8c75c:	0008c429 	.word	0x0008c429
   8c760:	0008cf59 	.word	0x0008cf59
   8c764:	0008cde5 	.word	0x0008cde5
   8c768:	0008ba4d 	.word	0x0008ba4d
   8c76c:	0008ba29 	.word	0x0008ba29
   8c770:	0008c519 	.word	0x0008c519

0008c774 <_ZN6SdFile5writeEPKvt>:
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, uint16_t nbyte) {
   8c774:	b580      	push	{r7, lr}
   8c776:	b08c      	sub	sp, #48	; 0x30
   8c778:	af00      	add	r7, sp, #0
   8c77a:	60f8      	str	r0, [r7, #12]
   8c77c:	60b9      	str	r1, [r7, #8]
   8c77e:	4613      	mov	r3, r2
   8c780:	80fb      	strh	r3, [r7, #6]
  // convert void* to uint8_t*  -  must be before goto statements
  const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
   8c782:	68bb      	ldr	r3, [r7, #8]
   8c784:	62fb      	str	r3, [r7, #44]	; 0x2c

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;
   8c786:	88fb      	ldrh	r3, [r7, #6]
   8c788:	857b      	strh	r3, [r7, #42]	; 0x2a

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
   8c78a:	68f8      	ldr	r0, [r7, #12]
   8c78c:	4b8f      	ldr	r3, [pc, #572]	; (8c9cc <_ZN6SdFile5writeEPKvt+0x258>)
   8c78e:	4798      	blx	r3
   8c790:	4603      	mov	r3, r0
   8c792:	2b00      	cmp	r3, #0
   8c794:	d005      	beq.n	8c7a2 <_ZN6SdFile5writeEPKvt+0x2e>
   8c796:	68fb      	ldr	r3, [r7, #12]
   8c798:	7a1b      	ldrb	r3, [r3, #8]
   8c79a:	f003 0302 	and.w	r3, r3, #2
   8c79e:	2b00      	cmp	r3, #0
   8c7a0:	d101      	bne.n	8c7a6 <_ZN6SdFile5writeEPKvt+0x32>
   8c7a2:	2301      	movs	r3, #1
   8c7a4:	e000      	b.n	8c7a8 <_ZN6SdFile5writeEPKvt+0x34>
   8c7a6:	2300      	movs	r3, #0
   8c7a8:	2b00      	cmp	r3, #0
   8c7aa:	f040 814a 	bne.w	8ca42 <_ZN6SdFile5writeEPKvt+0x2ce>

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
   8c7ae:	68fb      	ldr	r3, [r7, #12]
   8c7b0:	7a1b      	ldrb	r3, [r3, #8]
   8c7b2:	f003 0304 	and.w	r3, r3, #4
   8c7b6:	2b00      	cmp	r3, #0
   8c7b8:	d011      	beq.n	8c7de <_ZN6SdFile5writeEPKvt+0x6a>
   8c7ba:	68fb      	ldr	r3, [r7, #12]
   8c7bc:	691a      	ldr	r2, [r3, #16]
   8c7be:	68fb      	ldr	r3, [r7, #12]
   8c7c0:	69db      	ldr	r3, [r3, #28]
   8c7c2:	429a      	cmp	r2, r3
   8c7c4:	d00b      	beq.n	8c7de <_ZN6SdFile5writeEPKvt+0x6a>
    if (!seekEnd()) goto writeErrorReturn;
   8c7c6:	68f8      	ldr	r0, [r7, #12]
   8c7c8:	4b81      	ldr	r3, [pc, #516]	; (8c9d0 <_ZN6SdFile5writeEPKvt+0x25c>)
   8c7ca:	4798      	blx	r3
   8c7cc:	4603      	mov	r3, r0
   8c7ce:	2b00      	cmp	r3, #0
   8c7d0:	bf0c      	ite	eq
   8c7d2:	2301      	moveq	r3, #1
   8c7d4:	2300      	movne	r3, #0
   8c7d6:	b2db      	uxtb	r3, r3
   8c7d8:	2b00      	cmp	r3, #0
   8c7da:	f040 8134 	bne.w	8ca46 <_ZN6SdFile5writeEPKvt+0x2d2>
  }

  while (nToWrite > 0) {
   8c7de:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   8c7e0:	2b00      	cmp	r3, #0
   8c7e2:	f000 80e1 	beq.w	8c9a8 <_ZN6SdFile5writeEPKvt+0x234>
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
   8c7e6:	68fb      	ldr	r3, [r7, #12]
   8c7e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   8c7ea:	68fb      	ldr	r3, [r7, #12]
   8c7ec:	691b      	ldr	r3, [r3, #16]
   8c7ee:	4619      	mov	r1, r3
   8c7f0:	4610      	mov	r0, r2
   8c7f2:	4b78      	ldr	r3, [pc, #480]	; (8c9d4 <_ZN6SdFile5writeEPKvt+0x260>)
   8c7f4:	4798      	blx	r3
   8c7f6:	4603      	mov	r3, r0
   8c7f8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    uint16_t blockOffset = curPosition_ & 0X1FF;
   8c7fc:	68fb      	ldr	r3, [r7, #12]
   8c7fe:	691b      	ldr	r3, [r3, #16]
   8c800:	b29b      	uxth	r3, r3
   8c802:	f3c3 0308 	ubfx	r3, r3, #0, #9
   8c806:	843b      	strh	r3, [r7, #32]
    if (blockOfCluster == 0 && blockOffset == 0) {
   8c808:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   8c80c:	2b00      	cmp	r3, #0
   8c80e:	d14c      	bne.n	8c8aa <_ZN6SdFile5writeEPKvt+0x136>
   8c810:	8c3b      	ldrh	r3, [r7, #32]
   8c812:	2b00      	cmp	r3, #0
   8c814:	d149      	bne.n	8c8aa <_ZN6SdFile5writeEPKvt+0x136>
      // start of new cluster
      if (curCluster_ == 0) {
   8c816:	68fb      	ldr	r3, [r7, #12]
   8c818:	68db      	ldr	r3, [r3, #12]
   8c81a:	2b00      	cmp	r3, #0
   8c81c:	d114      	bne.n	8c848 <_ZN6SdFile5writeEPKvt+0xd4>
        if (firstCluster_ == 0) {
   8c81e:	68fb      	ldr	r3, [r7, #12]
   8c820:	6a1b      	ldr	r3, [r3, #32]
   8c822:	2b00      	cmp	r3, #0
   8c824:	d10b      	bne.n	8c83e <_ZN6SdFile5writeEPKvt+0xca>
          // allocate first cluster of file
          if (!addCluster()) goto writeErrorReturn;
   8c826:	68f8      	ldr	r0, [r7, #12]
   8c828:	4b6b      	ldr	r3, [pc, #428]	; (8c9d8 <_ZN6SdFile5writeEPKvt+0x264>)
   8c82a:	4798      	blx	r3
   8c82c:	4603      	mov	r3, r0
   8c82e:	2b00      	cmp	r3, #0
   8c830:	bf0c      	ite	eq
   8c832:	2301      	moveq	r3, #1
   8c834:	2300      	movne	r3, #0
   8c836:	b2db      	uxtb	r3, r3
   8c838:	2b00      	cmp	r3, #0
   8c83a:	d036      	beq.n	8c8aa <_ZN6SdFile5writeEPKvt+0x136>
   8c83c:	e10c      	b.n	8ca58 <_ZN6SdFile5writeEPKvt+0x2e4>
        } else {
          curCluster_ = firstCluster_;
   8c83e:	68fb      	ldr	r3, [r7, #12]
   8c840:	6a1a      	ldr	r2, [r3, #32]
   8c842:	68fb      	ldr	r3, [r7, #12]
   8c844:	60da      	str	r2, [r3, #12]
   8c846:	e030      	b.n	8c8aa <_ZN6SdFile5writeEPKvt+0x136>
        }
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) return false;
   8c848:	68fb      	ldr	r3, [r7, #12]
   8c84a:	6a58      	ldr	r0, [r3, #36]	; 0x24
   8c84c:	68fb      	ldr	r3, [r7, #12]
   8c84e:	68db      	ldr	r3, [r3, #12]
   8c850:	f107 0214 	add.w	r2, r7, #20
   8c854:	4619      	mov	r1, r3
   8c856:	4b61      	ldr	r3, [pc, #388]	; (8c9dc <_ZN6SdFile5writeEPKvt+0x268>)
   8c858:	4798      	blx	r3
   8c85a:	4603      	mov	r3, r0
   8c85c:	2b00      	cmp	r3, #0
   8c85e:	bf0c      	ite	eq
   8c860:	2301      	moveq	r3, #1
   8c862:	2300      	movne	r3, #0
   8c864:	b2db      	uxtb	r3, r3
   8c866:	2b00      	cmp	r3, #0
   8c868:	d001      	beq.n	8c86e <_ZN6SdFile5writeEPKvt+0xfa>
   8c86a:	2300      	movs	r3, #0
   8c86c:	e0fa      	b.n	8ca64 <_ZN6SdFile5writeEPKvt+0x2f0>
        if (vol_->isEOC(next)) {
   8c86e:	68fb      	ldr	r3, [r7, #12]
   8c870:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8c872:	697a      	ldr	r2, [r7, #20]
   8c874:	4611      	mov	r1, r2
   8c876:	4618      	mov	r0, r3
   8c878:	4b59      	ldr	r3, [pc, #356]	; (8c9e0 <_ZN6SdFile5writeEPKvt+0x26c>)
   8c87a:	4798      	blx	r3
   8c87c:	4603      	mov	r3, r0
   8c87e:	2b00      	cmp	r3, #0
   8c880:	bf14      	ite	ne
   8c882:	2301      	movne	r3, #1
   8c884:	2300      	moveq	r3, #0
   8c886:	b2db      	uxtb	r3, r3
   8c888:	2b00      	cmp	r3, #0
   8c88a:	d00b      	beq.n	8c8a4 <_ZN6SdFile5writeEPKvt+0x130>
          // add cluster if at end of chain
          if (!addCluster()) goto writeErrorReturn;
   8c88c:	68f8      	ldr	r0, [r7, #12]
   8c88e:	4b52      	ldr	r3, [pc, #328]	; (8c9d8 <_ZN6SdFile5writeEPKvt+0x264>)
   8c890:	4798      	blx	r3
   8c892:	4603      	mov	r3, r0
   8c894:	2b00      	cmp	r3, #0
   8c896:	bf0c      	ite	eq
   8c898:	2301      	moveq	r3, #1
   8c89a:	2300      	movne	r3, #0
   8c89c:	b2db      	uxtb	r3, r3
   8c89e:	2b00      	cmp	r3, #0
   8c8a0:	d003      	beq.n	8c8aa <_ZN6SdFile5writeEPKvt+0x136>
   8c8a2:	e0d9      	b.n	8ca58 <_ZN6SdFile5writeEPKvt+0x2e4>
        } else {
          curCluster_ = next;
   8c8a4:	697a      	ldr	r2, [r7, #20]
   8c8a6:	68fb      	ldr	r3, [r7, #12]
   8c8a8:	60da      	str	r2, [r3, #12]
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
   8c8aa:	8c3b      	ldrh	r3, [r7, #32]
   8c8ac:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
   8c8b0:	853b      	strh	r3, [r7, #40]	; 0x28

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
   8c8b2:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   8c8b4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   8c8b6:	429a      	cmp	r2, r3
   8c8b8:	d901      	bls.n	8c8be <_ZN6SdFile5writeEPKvt+0x14a>
   8c8ba:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   8c8bc:	853b      	strh	r3, [r7, #40]	; 0x28

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
   8c8be:	68fb      	ldr	r3, [r7, #12]
   8c8c0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   8c8c2:	68fb      	ldr	r3, [r7, #12]
   8c8c4:	68db      	ldr	r3, [r3, #12]
   8c8c6:	4619      	mov	r1, r3
   8c8c8:	4610      	mov	r0, r2
   8c8ca:	4b46      	ldr	r3, [pc, #280]	; (8c9e4 <_ZN6SdFile5writeEPKvt+0x270>)
   8c8cc:	4798      	blx	r3
   8c8ce:	4602      	mov	r2, r0
   8c8d0:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   8c8d4:	4413      	add	r3, r2
   8c8d6:	61fb      	str	r3, [r7, #28]
    if (n == 512) {
   8c8d8:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   8c8da:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   8c8de:	d11d      	bne.n	8c91c <_ZN6SdFile5writeEPKvt+0x1a8>
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
   8c8e0:	4b41      	ldr	r3, [pc, #260]	; (8c9e8 <_ZN6SdFile5writeEPKvt+0x274>)
   8c8e2:	681a      	ldr	r2, [r3, #0]
   8c8e4:	69fb      	ldr	r3, [r7, #28]
   8c8e6:	429a      	cmp	r2, r3
   8c8e8:	d103      	bne.n	8c8f2 <_ZN6SdFile5writeEPKvt+0x17e>
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
   8c8ea:	4b3f      	ldr	r3, [pc, #252]	; (8c9e8 <_ZN6SdFile5writeEPKvt+0x274>)
   8c8ec:	f04f 32ff 	mov.w	r2, #4294967295
   8c8f0:	601a      	str	r2, [r3, #0]
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
   8c8f2:	68fb      	ldr	r3, [r7, #12]
   8c8f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8c8f6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   8c8f8:	69f9      	ldr	r1, [r7, #28]
   8c8fa:	4618      	mov	r0, r3
   8c8fc:	4b3b      	ldr	r3, [pc, #236]	; (8c9ec <_ZN6SdFile5writeEPKvt+0x278>)
   8c8fe:	4798      	blx	r3
   8c900:	4603      	mov	r3, r0
   8c902:	2b00      	cmp	r3, #0
   8c904:	bf0c      	ite	eq
   8c906:	2301      	moveq	r3, #1
   8c908:	2300      	movne	r3, #0
   8c90a:	b2db      	uxtb	r3, r3
   8c90c:	2b00      	cmp	r3, #0
   8c90e:	f040 809c 	bne.w	8ca4a <_ZN6SdFile5writeEPKvt+0x2d6>
      src += 512;
   8c912:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   8c914:	f503 7300 	add.w	r3, r3, #512	; 0x200
   8c918:	62fb      	str	r3, [r7, #44]	; 0x2c
   8c91a:	e03a      	b.n	8c992 <_ZN6SdFile5writeEPKvt+0x21e>
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
   8c91c:	8c3b      	ldrh	r3, [r7, #32]
   8c91e:	2b00      	cmp	r3, #0
   8c920:	d116      	bne.n	8c950 <_ZN6SdFile5writeEPKvt+0x1dc>
   8c922:	68fb      	ldr	r3, [r7, #12]
   8c924:	691a      	ldr	r2, [r3, #16]
   8c926:	68fb      	ldr	r3, [r7, #12]
   8c928:	69db      	ldr	r3, [r3, #28]
   8c92a:	429a      	cmp	r2, r3
   8c92c:	d310      	bcc.n	8c950 <_ZN6SdFile5writeEPKvt+0x1dc>
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
   8c92e:	4b30      	ldr	r3, [pc, #192]	; (8c9f0 <_ZN6SdFile5writeEPKvt+0x27c>)
   8c930:	4798      	blx	r3
   8c932:	4603      	mov	r3, r0
   8c934:	2b00      	cmp	r3, #0
   8c936:	bf0c      	ite	eq
   8c938:	2301      	moveq	r3, #1
   8c93a:	2300      	movne	r3, #0
   8c93c:	b2db      	uxtb	r3, r3
   8c93e:	2b00      	cmp	r3, #0
   8c940:	f040 8085 	bne.w	8ca4e <_ZN6SdFile5writeEPKvt+0x2da>
        SdVolume::cacheBlockNumber_ = block;
   8c944:	4a28      	ldr	r2, [pc, #160]	; (8c9e8 <_ZN6SdFile5writeEPKvt+0x274>)
   8c946:	69fb      	ldr	r3, [r7, #28]
   8c948:	6013      	str	r3, [r2, #0]
        SdVolume::cacheSetDirty();
   8c94a:	4b2a      	ldr	r3, [pc, #168]	; (8c9f4 <_ZN6SdFile5writeEPKvt+0x280>)
   8c94c:	4798      	blx	r3
   8c94e:	e00b      	b.n	8c968 <_ZN6SdFile5writeEPKvt+0x1f4>
      } else {
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
   8c950:	2101      	movs	r1, #1
   8c952:	69f8      	ldr	r0, [r7, #28]
   8c954:	4b28      	ldr	r3, [pc, #160]	; (8c9f8 <_ZN6SdFile5writeEPKvt+0x284>)
   8c956:	4798      	blx	r3
   8c958:	4603      	mov	r3, r0
   8c95a:	2b00      	cmp	r3, #0
   8c95c:	bf0c      	ite	eq
   8c95e:	2301      	moveq	r3, #1
   8c960:	2300      	movne	r3, #0
   8c962:	b2db      	uxtb	r3, r3
   8c964:	2b00      	cmp	r3, #0
   8c966:	d174      	bne.n	8ca52 <_ZN6SdFile5writeEPKvt+0x2de>
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
   8c968:	8c3b      	ldrh	r3, [r7, #32]
   8c96a:	4a24      	ldr	r2, [pc, #144]	; (8c9fc <_ZN6SdFile5writeEPKvt+0x288>)
   8c96c:	4413      	add	r3, r2
   8c96e:	627b      	str	r3, [r7, #36]	; 0x24
      uint8_t* end = dst + n;
   8c970:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   8c972:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   8c974:	4413      	add	r3, r2
   8c976:	61bb      	str	r3, [r7, #24]
      while (dst != end) *dst++ = *src++;
   8c978:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   8c97a:	69bb      	ldr	r3, [r7, #24]
   8c97c:	429a      	cmp	r2, r3
   8c97e:	d008      	beq.n	8c992 <_ZN6SdFile5writeEPKvt+0x21e>
   8c980:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8c982:	1c5a      	adds	r2, r3, #1
   8c984:	627a      	str	r2, [r7, #36]	; 0x24
   8c986:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   8c988:	1c51      	adds	r1, r2, #1
   8c98a:	62f9      	str	r1, [r7, #44]	; 0x2c
   8c98c:	7812      	ldrb	r2, [r2, #0]
   8c98e:	701a      	strb	r2, [r3, #0]
   8c990:	e7f2      	b.n	8c978 <_ZN6SdFile5writeEPKvt+0x204>
    }
    nToWrite -= n;
   8c992:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
   8c994:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   8c996:	1ad3      	subs	r3, r2, r3
   8c998:	857b      	strh	r3, [r7, #42]	; 0x2a
    curPosition_ += n;
   8c99a:	68fb      	ldr	r3, [r7, #12]
   8c99c:	691a      	ldr	r2, [r3, #16]
   8c99e:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   8c9a0:	441a      	add	r2, r3
   8c9a2:	68fb      	ldr	r3, [r7, #12]
   8c9a4:	611a      	str	r2, [r3, #16]
  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
   8c9a6:	e71a      	b.n	8c7de <_ZN6SdFile5writeEPKvt+0x6a>
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
   8c9a8:	68fb      	ldr	r3, [r7, #12]
   8c9aa:	691a      	ldr	r2, [r3, #16]
   8c9ac:	68fb      	ldr	r3, [r7, #12]
   8c9ae:	69db      	ldr	r3, [r3, #28]
   8c9b0:	429a      	cmp	r2, r3
   8c9b2:	d925      	bls.n	8ca00 <_ZN6SdFile5writeEPKvt+0x28c>
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
   8c9b4:	68fb      	ldr	r3, [r7, #12]
   8c9b6:	691a      	ldr	r2, [r3, #16]
   8c9b8:	68fb      	ldr	r3, [r7, #12]
   8c9ba:	61da      	str	r2, [r3, #28]
    flags_ |= F_FILE_DIR_DIRTY;
   8c9bc:	68fb      	ldr	r3, [r7, #12]
   8c9be:	7a1b      	ldrb	r3, [r3, #8]
   8c9c0:	2280      	movs	r2, #128	; 0x80
   8c9c2:	4313      	orrs	r3, r2
   8c9c4:	b2da      	uxtb	r2, r3
   8c9c6:	68fb      	ldr	r3, [r7, #12]
   8c9c8:	721a      	strb	r2, [r3, #8]
   8c9ca:	e027      	b.n	8ca1c <_ZN6SdFile5writeEPKvt+0x2a8>
   8c9cc:	0008b915 	.word	0x0008b915
   8c9d0:	0008b935 	.word	0x0008b935
   8c9d4:	0008b9bd 	.word	0x0008b9bd
   8c9d8:	0008baed 	.word	0x0008baed
   8c9dc:	0008cde5 	.word	0x0008cde5
   8c9e0:	0008ba4d 	.word	0x0008ba4d
   8c9e4:	0008b9e5 	.word	0x0008b9e5
   8c9e8:	20070114 	.word	0x20070114
   8c9ec:	0008bac1 	.word	0x0008bac1
   8c9f0:	0008cbfd 	.word	0x0008cbfd
   8c9f4:	0008ba09 	.word	0x0008ba09
   8c9f8:	0008cc85 	.word	0x0008cc85
   8c9fc:	2007191c 	.word	0x2007191c
  } else if (dateTime_ && nbyte) {
   8ca00:	4b1a      	ldr	r3, [pc, #104]	; (8ca6c <_ZN6SdFile5writeEPKvt+0x2f8>)
   8ca02:	681b      	ldr	r3, [r3, #0]
   8ca04:	2b00      	cmp	r3, #0
   8ca06:	d009      	beq.n	8ca1c <_ZN6SdFile5writeEPKvt+0x2a8>
   8ca08:	88fb      	ldrh	r3, [r7, #6]
   8ca0a:	2b00      	cmp	r3, #0
   8ca0c:	d006      	beq.n	8ca1c <_ZN6SdFile5writeEPKvt+0x2a8>
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
   8ca0e:	68fb      	ldr	r3, [r7, #12]
   8ca10:	7a1b      	ldrb	r3, [r3, #8]
   8ca12:	2280      	movs	r2, #128	; 0x80
   8ca14:	4313      	orrs	r3, r2
   8ca16:	b2da      	uxtb	r2, r3
   8ca18:	68fb      	ldr	r3, [r7, #12]
   8ca1a:	721a      	strb	r2, [r3, #8]
  }

  if (flags_ & O_SYNC) {
   8ca1c:	68fb      	ldr	r3, [r7, #12]
   8ca1e:	7a1b      	ldrb	r3, [r3, #8]
   8ca20:	f003 0308 	and.w	r3, r3, #8
   8ca24:	2b00      	cmp	r3, #0
   8ca26:	d00a      	beq.n	8ca3e <_ZN6SdFile5writeEPKvt+0x2ca>
    if (!sync()) goto writeErrorReturn;
   8ca28:	68f8      	ldr	r0, [r7, #12]
   8ca2a:	4b11      	ldr	r3, [pc, #68]	; (8ca70 <_ZN6SdFile5writeEPKvt+0x2fc>)
   8ca2c:	4798      	blx	r3
   8ca2e:	4603      	mov	r3, r0
   8ca30:	2b00      	cmp	r3, #0
   8ca32:	bf0c      	ite	eq
   8ca34:	2301      	moveq	r3, #1
   8ca36:	2300      	movne	r3, #0
   8ca38:	b2db      	uxtb	r3, r3
   8ca3a:	2b00      	cmp	r3, #0
   8ca3c:	d10b      	bne.n	8ca56 <_ZN6SdFile5writeEPKvt+0x2e2>
  }
  return nbyte;
   8ca3e:	88fb      	ldrh	r3, [r7, #6]
   8ca40:	e010      	b.n	8ca64 <_ZN6SdFile5writeEPKvt+0x2f0>

  // number of bytes left to write  -  must be before goto statements
  uint16_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
   8ca42:	bf00      	nop
   8ca44:	e008      	b.n	8ca58 <_ZN6SdFile5writeEPKvt+0x2e4>

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
   8ca46:	bf00      	nop
   8ca48:	e006      	b.n	8ca58 <_ZN6SdFile5writeEPKvt+0x2e4>
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
   8ca4a:	bf00      	nop
   8ca4c:	e004      	b.n	8ca58 <_ZN6SdFile5writeEPKvt+0x2e4>
      src += 512;
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
   8ca4e:	bf00      	nop
   8ca50:	e002      	b.n	8ca58 <_ZN6SdFile5writeEPKvt+0x2e4>
        SdVolume::cacheBlockNumber_ = block;
        SdVolume::cacheSetDirty();
      } else {
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
          goto writeErrorReturn;
   8ca52:	bf00      	nop
   8ca54:	e000      	b.n	8ca58 <_ZN6SdFile5writeEPKvt+0x2e4>
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
  }

  if (flags_ & O_SYNC) {
    if (!sync()) goto writeErrorReturn;
   8ca56:	bf00      	nop
  return nbyte;

 writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
   8ca58:	68fb      	ldr	r3, [r7, #12]
   8ca5a:	2101      	movs	r1, #1
   8ca5c:	4618      	mov	r0, r3
   8ca5e:	4b05      	ldr	r3, [pc, #20]	; (8ca74 <_ZN6SdFile5writeEPKvt+0x300>)
   8ca60:	4798      	blx	r3
  return 0;
   8ca62:	2300      	movs	r3, #0
}
   8ca64:	4618      	mov	r0, r3
   8ca66:	3730      	adds	r7, #48	; 0x30
   8ca68:	46bd      	mov	sp, r7
   8ca6a:	bd80      	pop	{r7, pc}
   8ca6c:	20071918 	.word	0x20071918
   8ca70:	0008c519 	.word	0x0008c519
   8ca74:	00088a51 	.word	0x00088a51

0008ca78 <_ZN6SdFile5writeEh>:
/**
 * Write a byte to a file. Required by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
size_t SdFile::write(uint8_t b) {
   8ca78:	b580      	push	{r7, lr}
   8ca7a:	b082      	sub	sp, #8
   8ca7c:	af00      	add	r7, sp, #0
   8ca7e:	6078      	str	r0, [r7, #4]
   8ca80:	460b      	mov	r3, r1
   8ca82:	70fb      	strb	r3, [r7, #3]
  return write(&b, 1);
   8ca84:	1cfb      	adds	r3, r7, #3
   8ca86:	2201      	movs	r2, #1
   8ca88:	4619      	mov	r1, r3
   8ca8a:	6878      	ldr	r0, [r7, #4]
   8ca8c:	4b03      	ldr	r3, [pc, #12]	; (8ca9c <_ZN6SdFile5writeEh+0x24>)
   8ca8e:	4798      	blx	r3
   8ca90:	4603      	mov	r3, r0
}
   8ca92:	4618      	mov	r0, r3
   8ca94:	3708      	adds	r7, #8
   8ca96:	46bd      	mov	sp, r7
   8ca98:	bd80      	pop	{r7, pc}
   8ca9a:	bf00      	nop
   8ca9c:	0008c775 	.word	0x0008c775

0008caa0 <_ZN8SdVolume15allocContiguousEmPm>:
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
   8caa0:	b580      	push	{r7, lr}
   8caa2:	b08a      	sub	sp, #40	; 0x28
   8caa4:	af00      	add	r7, sp, #0
   8caa6:	60f8      	str	r0, [r7, #12]
   8caa8:	60b9      	str	r1, [r7, #8]
   8caaa:	607a      	str	r2, [r7, #4]

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
   8caac:	687b      	ldr	r3, [r7, #4]
   8caae:	681b      	ldr	r3, [r3, #0]
   8cab0:	2b00      	cmp	r3, #0
   8cab2:	d007      	beq.n	8cac4 <_ZN8SdVolume15allocContiguousEmPm+0x24>
    // try to make file contiguous
    bgnCluster = *curCluster + 1;
   8cab4:	687b      	ldr	r3, [r7, #4]
   8cab6:	681b      	ldr	r3, [r3, #0]
   8cab8:	3301      	adds	r3, #1
   8caba:	627b      	str	r3, [r7, #36]	; 0x24

    // don't save new start location
    setStart = false;
   8cabc:	2300      	movs	r3, #0
   8cabe:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   8cac2:	e00a      	b.n	8cada <_ZN8SdVolume15allocContiguousEmPm+0x3a>
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;
   8cac4:	68fb      	ldr	r3, [r7, #12]
   8cac6:	681b      	ldr	r3, [r3, #0]
   8cac8:	627b      	str	r3, [r7, #36]	; 0x24

    // save next search start if one cluster
    setStart = 1 == count;
   8caca:	68bb      	ldr	r3, [r7, #8]
   8cacc:	2b01      	cmp	r3, #1
   8cace:	bf0c      	ite	eq
   8cad0:	2301      	moveq	r3, #1
   8cad2:	2300      	movne	r3, #0
   8cad4:	b2db      	uxtb	r3, r3
   8cad6:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  }
  // end of group
  uint32_t endCluster = bgnCluster;
   8cada:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8cadc:	61fb      	str	r3, [r7, #28]

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;
   8cade:	68fb      	ldr	r3, [r7, #12]
   8cae0:	68db      	ldr	r3, [r3, #12]
   8cae2:	3301      	adds	r3, #1
   8cae4:	617b      	str	r3, [r7, #20]

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
   8cae6:	2300      	movs	r3, #0
   8cae8:	61bb      	str	r3, [r7, #24]
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
   8caea:	68fb      	ldr	r3, [r7, #12]
   8caec:	68da      	ldr	r2, [r3, #12]
   8caee:	69bb      	ldr	r3, [r7, #24]
   8caf0:	429a      	cmp	r2, r3
   8caf2:	d801      	bhi.n	8caf8 <_ZN8SdVolume15allocContiguousEmPm+0x58>
   8caf4:	2300      	movs	r3, #0
   8caf6:	e076      	b.n	8cbe6 <_ZN8SdVolume15allocContiguousEmPm+0x146>

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
   8caf8:	69fa      	ldr	r2, [r7, #28]
   8cafa:	697b      	ldr	r3, [r7, #20]
   8cafc:	429a      	cmp	r2, r3
   8cafe:	d903      	bls.n	8cb08 <_ZN8SdVolume15allocContiguousEmPm+0x68>
      bgnCluster = endCluster = 2;
   8cb00:	2302      	movs	r3, #2
   8cb02:	61fb      	str	r3, [r7, #28]
   8cb04:	69fb      	ldr	r3, [r7, #28]
   8cb06:	627b      	str	r3, [r7, #36]	; 0x24
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
   8cb08:	f107 0310 	add.w	r3, r7, #16
   8cb0c:	461a      	mov	r2, r3
   8cb0e:	69f9      	ldr	r1, [r7, #28]
   8cb10:	68f8      	ldr	r0, [r7, #12]
   8cb12:	4b37      	ldr	r3, [pc, #220]	; (8cbf0 <_ZN8SdVolume15allocContiguousEmPm+0x150>)
   8cb14:	4798      	blx	r3
   8cb16:	4603      	mov	r3, r0
   8cb18:	2b00      	cmp	r3, #0
   8cb1a:	bf0c      	ite	eq
   8cb1c:	2301      	moveq	r3, #1
   8cb1e:	2300      	movne	r3, #0
   8cb20:	b2db      	uxtb	r3, r3
   8cb22:	2b00      	cmp	r3, #0
   8cb24:	d001      	beq.n	8cb2a <_ZN8SdVolume15allocContiguousEmPm+0x8a>
   8cb26:	2300      	movs	r3, #0
   8cb28:	e05d      	b.n	8cbe6 <_ZN8SdVolume15allocContiguousEmPm+0x146>

    if (f != 0) {
   8cb2a:	693b      	ldr	r3, [r7, #16]
   8cb2c:	2b00      	cmp	r3, #0
   8cb2e:	d003      	beq.n	8cb38 <_ZN8SdVolume15allocContiguousEmPm+0x98>
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
   8cb30:	69fb      	ldr	r3, [r7, #28]
   8cb32:	3301      	adds	r3, #1
   8cb34:	627b      	str	r3, [r7, #36]	; 0x24
   8cb36:	e013      	b.n	8cb60 <_ZN8SdVolume15allocContiguousEmPm+0xc0>
    } else if ((endCluster - bgnCluster + 1) == count) {
   8cb38:	69fa      	ldr	r2, [r7, #28]
   8cb3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8cb3c:	1ad3      	subs	r3, r2, r3
   8cb3e:	1c5a      	adds	r2, r3, #1
   8cb40:	68bb      	ldr	r3, [r7, #8]
   8cb42:	429a      	cmp	r2, r3
   8cb44:	d10c      	bne.n	8cb60 <_ZN8SdVolume15allocContiguousEmPm+0xc0>
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;
   8cb46:	69f9      	ldr	r1, [r7, #28]
   8cb48:	68f8      	ldr	r0, [r7, #12]
   8cb4a:	4b2a      	ldr	r3, [pc, #168]	; (8cbf4 <_ZN8SdVolume15allocContiguousEmPm+0x154>)
   8cb4c:	4798      	blx	r3
   8cb4e:	4603      	mov	r3, r0
   8cb50:	2b00      	cmp	r3, #0
   8cb52:	bf0c      	ite	eq
   8cb54:	2301      	moveq	r3, #1
   8cb56:	2300      	movne	r3, #0
   8cb58:	b2db      	uxtb	r3, r3
   8cb5a:	2b00      	cmp	r3, #0
   8cb5c:	d107      	bne.n	8cb6e <_ZN8SdVolume15allocContiguousEmPm+0xce>
   8cb5e:	e008      	b.n	8cb72 <_ZN8SdVolume15allocContiguousEmPm+0xd2>

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
   8cb60:	69bb      	ldr	r3, [r7, #24]
   8cb62:	3301      	adds	r3, #1
   8cb64:	61bb      	str	r3, [r7, #24]
   8cb66:	69fb      	ldr	r3, [r7, #28]
   8cb68:	3301      	adds	r3, #1
   8cb6a:	61fb      	str	r3, [r7, #28]
   8cb6c:	e7bd      	b.n	8caea <_ZN8SdVolume15allocContiguousEmPm+0x4a>
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;
   8cb6e:	2300      	movs	r3, #0
   8cb70:	e039      	b.n	8cbe6 <_ZN8SdVolume15allocContiguousEmPm+0x146>

  // link clusters
  while (endCluster > bgnCluster) {
   8cb72:	69fa      	ldr	r2, [r7, #28]
   8cb74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8cb76:	429a      	cmp	r2, r3
   8cb78:	d914      	bls.n	8cba4 <_ZN8SdVolume15allocContiguousEmPm+0x104>
    if (!fatPut(endCluster - 1, endCluster)) return false;
   8cb7a:	69fb      	ldr	r3, [r7, #28]
   8cb7c:	3b01      	subs	r3, #1
   8cb7e:	69fa      	ldr	r2, [r7, #28]
   8cb80:	4619      	mov	r1, r3
   8cb82:	68f8      	ldr	r0, [r7, #12]
   8cb84:	4b1c      	ldr	r3, [pc, #112]	; (8cbf8 <_ZN8SdVolume15allocContiguousEmPm+0x158>)
   8cb86:	4798      	blx	r3
   8cb88:	4603      	mov	r3, r0
   8cb8a:	2b00      	cmp	r3, #0
   8cb8c:	bf0c      	ite	eq
   8cb8e:	2301      	moveq	r3, #1
   8cb90:	2300      	movne	r3, #0
   8cb92:	b2db      	uxtb	r3, r3
   8cb94:	2b00      	cmp	r3, #0
   8cb96:	d001      	beq.n	8cb9c <_ZN8SdVolume15allocContiguousEmPm+0xfc>
   8cb98:	2300      	movs	r3, #0
   8cb9a:	e024      	b.n	8cbe6 <_ZN8SdVolume15allocContiguousEmPm+0x146>
    endCluster--;
   8cb9c:	69fb      	ldr	r3, [r7, #28]
   8cb9e:	3b01      	subs	r3, #1
   8cba0:	61fb      	str	r3, [r7, #28]
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;

  // link clusters
  while (endCluster > bgnCluster) {
   8cba2:	e7e6      	b.n	8cb72 <_ZN8SdVolume15allocContiguousEmPm+0xd2>
    if (!fatPut(endCluster - 1, endCluster)) return false;
    endCluster--;
  }
  if (*curCluster != 0) {
   8cba4:	687b      	ldr	r3, [r7, #4]
   8cba6:	681b      	ldr	r3, [r3, #0]
   8cba8:	2b00      	cmp	r3, #0
   8cbaa:	d010      	beq.n	8cbce <_ZN8SdVolume15allocContiguousEmPm+0x12e>
    // connect chains
    if (!fatPut(*curCluster, bgnCluster)) return false;
   8cbac:	687b      	ldr	r3, [r7, #4]
   8cbae:	681b      	ldr	r3, [r3, #0]
   8cbb0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   8cbb2:	4619      	mov	r1, r3
   8cbb4:	68f8      	ldr	r0, [r7, #12]
   8cbb6:	4b10      	ldr	r3, [pc, #64]	; (8cbf8 <_ZN8SdVolume15allocContiguousEmPm+0x158>)
   8cbb8:	4798      	blx	r3
   8cbba:	4603      	mov	r3, r0
   8cbbc:	2b00      	cmp	r3, #0
   8cbbe:	bf0c      	ite	eq
   8cbc0:	2301      	moveq	r3, #1
   8cbc2:	2300      	movne	r3, #0
   8cbc4:	b2db      	uxtb	r3, r3
   8cbc6:	2b00      	cmp	r3, #0
   8cbc8:	d001      	beq.n	8cbce <_ZN8SdVolume15allocContiguousEmPm+0x12e>
   8cbca:	2300      	movs	r3, #0
   8cbcc:	e00b      	b.n	8cbe6 <_ZN8SdVolume15allocContiguousEmPm+0x146>
  }
  // return first cluster number to caller
  *curCluster = bgnCluster;
   8cbce:	687b      	ldr	r3, [r7, #4]
   8cbd0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   8cbd2:	601a      	str	r2, [r3, #0]

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;
   8cbd4:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   8cbd8:	2b00      	cmp	r3, #0
   8cbda:	d003      	beq.n	8cbe4 <_ZN8SdVolume15allocContiguousEmPm+0x144>
   8cbdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8cbde:	1c5a      	adds	r2, r3, #1
   8cbe0:	68fb      	ldr	r3, [r7, #12]
   8cbe2:	601a      	str	r2, [r3, #0]

  return true;
   8cbe4:	2301      	movs	r3, #1
}
   8cbe6:	4618      	mov	r0, r3
   8cbe8:	3728      	adds	r7, #40	; 0x28
   8cbea:	46bd      	mov	sp, r7
   8cbec:	bd80      	pop	{r7, pc}
   8cbee:	bf00      	nop
   8cbf0:	0008cde5 	.word	0x0008cde5
   8cbf4:	0008ba29 	.word	0x0008ba29
   8cbf8:	0008ce8d 	.word	0x0008ce8d

0008cbfc <_ZN8SdVolume10cacheFlushEv>:
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
   8cbfc:	b580      	push	{r7, lr}
   8cbfe:	af00      	add	r7, sp, #0
  if (cacheDirty_) {
   8cc00:	4b1a      	ldr	r3, [pc, #104]	; (8cc6c <_ZN8SdVolume10cacheFlushEv+0x70>)
   8cc02:	781b      	ldrb	r3, [r3, #0]
   8cc04:	2b00      	cmp	r3, #0
   8cc06:	d02d      	beq.n	8cc64 <_ZN8SdVolume10cacheFlushEv+0x68>
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
   8cc08:	4b19      	ldr	r3, [pc, #100]	; (8cc70 <_ZN8SdVolume10cacheFlushEv+0x74>)
   8cc0a:	6818      	ldr	r0, [r3, #0]
   8cc0c:	4b19      	ldr	r3, [pc, #100]	; (8cc74 <_ZN8SdVolume10cacheFlushEv+0x78>)
   8cc0e:	681b      	ldr	r3, [r3, #0]
   8cc10:	4a19      	ldr	r2, [pc, #100]	; (8cc78 <_ZN8SdVolume10cacheFlushEv+0x7c>)
   8cc12:	4619      	mov	r1, r3
   8cc14:	4b19      	ldr	r3, [pc, #100]	; (8cc7c <_ZN8SdVolume10cacheFlushEv+0x80>)
   8cc16:	4798      	blx	r3
   8cc18:	4603      	mov	r3, r0
   8cc1a:	2b00      	cmp	r3, #0
   8cc1c:	bf0c      	ite	eq
   8cc1e:	2301      	moveq	r3, #1
   8cc20:	2300      	movne	r3, #0
   8cc22:	b2db      	uxtb	r3, r3
   8cc24:	2b00      	cmp	r3, #0
   8cc26:	d001      	beq.n	8cc2c <_ZN8SdVolume10cacheFlushEv+0x30>
      return false;
   8cc28:	2300      	movs	r3, #0
   8cc2a:	e01c      	b.n	8cc66 <_ZN8SdVolume10cacheFlushEv+0x6a>
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
   8cc2c:	4b14      	ldr	r3, [pc, #80]	; (8cc80 <_ZN8SdVolume10cacheFlushEv+0x84>)
   8cc2e:	681b      	ldr	r3, [r3, #0]
   8cc30:	2b00      	cmp	r3, #0
   8cc32:	d014      	beq.n	8cc5e <_ZN8SdVolume10cacheFlushEv+0x62>
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
   8cc34:	4b0e      	ldr	r3, [pc, #56]	; (8cc70 <_ZN8SdVolume10cacheFlushEv+0x74>)
   8cc36:	6818      	ldr	r0, [r3, #0]
   8cc38:	4b11      	ldr	r3, [pc, #68]	; (8cc80 <_ZN8SdVolume10cacheFlushEv+0x84>)
   8cc3a:	681b      	ldr	r3, [r3, #0]
   8cc3c:	4a0e      	ldr	r2, [pc, #56]	; (8cc78 <_ZN8SdVolume10cacheFlushEv+0x7c>)
   8cc3e:	4619      	mov	r1, r3
   8cc40:	4b0e      	ldr	r3, [pc, #56]	; (8cc7c <_ZN8SdVolume10cacheFlushEv+0x80>)
   8cc42:	4798      	blx	r3
   8cc44:	4603      	mov	r3, r0
   8cc46:	2b00      	cmp	r3, #0
   8cc48:	bf0c      	ite	eq
   8cc4a:	2301      	moveq	r3, #1
   8cc4c:	2300      	movne	r3, #0
   8cc4e:	b2db      	uxtb	r3, r3
   8cc50:	2b00      	cmp	r3, #0
   8cc52:	d001      	beq.n	8cc58 <_ZN8SdVolume10cacheFlushEv+0x5c>
        return false;
   8cc54:	2300      	movs	r3, #0
   8cc56:	e006      	b.n	8cc66 <_ZN8SdVolume10cacheFlushEv+0x6a>
      }
      cacheMirrorBlock_ = 0;
   8cc58:	4b09      	ldr	r3, [pc, #36]	; (8cc80 <_ZN8SdVolume10cacheFlushEv+0x84>)
   8cc5a:	2200      	movs	r2, #0
   8cc5c:	601a      	str	r2, [r3, #0]
    }
    cacheDirty_ = 0;
   8cc5e:	4b03      	ldr	r3, [pc, #12]	; (8cc6c <_ZN8SdVolume10cacheFlushEv+0x70>)
   8cc60:	2200      	movs	r2, #0
   8cc62:	701a      	strb	r2, [r3, #0]
  }
  return true;
   8cc64:	2301      	movs	r3, #1
}
   8cc66:	4618      	mov	r0, r3
   8cc68:	bd80      	pop	{r7, pc}
   8cc6a:	bf00      	nop
   8cc6c:	20071b20 	.word	0x20071b20
   8cc70:	20071b1c 	.word	0x20071b1c
   8cc74:	20070114 	.word	0x20070114
   8cc78:	2007191c 	.word	0x2007191c
   8cc7c:	0008b701 	.word	0x0008b701
   8cc80:	20071b24 	.word	0x20071b24

0008cc84 <_ZN8SdVolume13cacheRawBlockEmh>:
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
   8cc84:	b580      	push	{r7, lr}
   8cc86:	b082      	sub	sp, #8
   8cc88:	af00      	add	r7, sp, #0
   8cc8a:	6078      	str	r0, [r7, #4]
   8cc8c:	460b      	mov	r3, r1
   8cc8e:	70fb      	strb	r3, [r7, #3]
  if (cacheBlockNumber_ != blockNumber) {
   8cc90:	4b18      	ldr	r3, [pc, #96]	; (8ccf4 <_ZN8SdVolume13cacheRawBlockEmh+0x70>)
   8cc92:	681a      	ldr	r2, [r3, #0]
   8cc94:	687b      	ldr	r3, [r7, #4]
   8cc96:	429a      	cmp	r2, r3
   8cc98:	d01f      	beq.n	8ccda <_ZN8SdVolume13cacheRawBlockEmh+0x56>
    if (!cacheFlush()) return false;
   8cc9a:	4b17      	ldr	r3, [pc, #92]	; (8ccf8 <_ZN8SdVolume13cacheRawBlockEmh+0x74>)
   8cc9c:	4798      	blx	r3
   8cc9e:	4603      	mov	r3, r0
   8cca0:	2b00      	cmp	r3, #0
   8cca2:	bf0c      	ite	eq
   8cca4:	2301      	moveq	r3, #1
   8cca6:	2300      	movne	r3, #0
   8cca8:	b2db      	uxtb	r3, r3
   8ccaa:	2b00      	cmp	r3, #0
   8ccac:	d001      	beq.n	8ccb2 <_ZN8SdVolume13cacheRawBlockEmh+0x2e>
   8ccae:	2300      	movs	r3, #0
   8ccb0:	e01b      	b.n	8ccea <_ZN8SdVolume13cacheRawBlockEmh+0x66>
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) return false;
   8ccb2:	4b12      	ldr	r3, [pc, #72]	; (8ccfc <_ZN8SdVolume13cacheRawBlockEmh+0x78>)
   8ccb4:	681b      	ldr	r3, [r3, #0]
   8ccb6:	4a12      	ldr	r2, [pc, #72]	; (8cd00 <_ZN8SdVolume13cacheRawBlockEmh+0x7c>)
   8ccb8:	6879      	ldr	r1, [r7, #4]
   8ccba:	4618      	mov	r0, r3
   8ccbc:	4b11      	ldr	r3, [pc, #68]	; (8cd04 <_ZN8SdVolume13cacheRawBlockEmh+0x80>)
   8ccbe:	4798      	blx	r3
   8ccc0:	4603      	mov	r3, r0
   8ccc2:	2b00      	cmp	r3, #0
   8ccc4:	bf0c      	ite	eq
   8ccc6:	2301      	moveq	r3, #1
   8ccc8:	2300      	movne	r3, #0
   8ccca:	b2db      	uxtb	r3, r3
   8cccc:	2b00      	cmp	r3, #0
   8ccce:	d001      	beq.n	8ccd4 <_ZN8SdVolume13cacheRawBlockEmh+0x50>
   8ccd0:	2300      	movs	r3, #0
   8ccd2:	e00a      	b.n	8ccea <_ZN8SdVolume13cacheRawBlockEmh+0x66>
    cacheBlockNumber_ = blockNumber;
   8ccd4:	4a07      	ldr	r2, [pc, #28]	; (8ccf4 <_ZN8SdVolume13cacheRawBlockEmh+0x70>)
   8ccd6:	687b      	ldr	r3, [r7, #4]
   8ccd8:	6013      	str	r3, [r2, #0]
  }
  cacheDirty_ |= action;
   8ccda:	4b0b      	ldr	r3, [pc, #44]	; (8cd08 <_ZN8SdVolume13cacheRawBlockEmh+0x84>)
   8ccdc:	781a      	ldrb	r2, [r3, #0]
   8ccde:	78fb      	ldrb	r3, [r7, #3]
   8cce0:	4313      	orrs	r3, r2
   8cce2:	b2da      	uxtb	r2, r3
   8cce4:	4b08      	ldr	r3, [pc, #32]	; (8cd08 <_ZN8SdVolume13cacheRawBlockEmh+0x84>)
   8cce6:	701a      	strb	r2, [r3, #0]
  return true;
   8cce8:	2301      	movs	r3, #1
}
   8ccea:	4618      	mov	r0, r3
   8ccec:	3708      	adds	r7, #8
   8ccee:	46bd      	mov	sp, r7
   8ccf0:	bd80      	pop	{r7, pc}
   8ccf2:	bf00      	nop
   8ccf4:	20070114 	.word	0x20070114
   8ccf8:	0008cbfd 	.word	0x0008cbfd
   8ccfc:	20071b1c 	.word	0x20071b1c
   8cd00:	2007191c 	.word	0x2007191c
   8cd04:	0008b2fd 	.word	0x0008b2fd
   8cd08:	20071b20 	.word	0x20071b20

0008cd0c <_ZN8SdVolume14cacheZeroBlockEm>:
//------------------------------------------------------------------------------
// cache a zero block for blockNumber
uint8_t SdVolume::cacheZeroBlock(uint32_t blockNumber) {
   8cd0c:	b580      	push	{r7, lr}
   8cd0e:	b084      	sub	sp, #16
   8cd10:	af00      	add	r7, sp, #0
   8cd12:	6078      	str	r0, [r7, #4]
  if (!cacheFlush()) return false;
   8cd14:	4b11      	ldr	r3, [pc, #68]	; (8cd5c <_ZN8SdVolume14cacheZeroBlockEm+0x50>)
   8cd16:	4798      	blx	r3
   8cd18:	4603      	mov	r3, r0
   8cd1a:	2b00      	cmp	r3, #0
   8cd1c:	bf0c      	ite	eq
   8cd1e:	2301      	moveq	r3, #1
   8cd20:	2300      	movne	r3, #0
   8cd22:	b2db      	uxtb	r3, r3
   8cd24:	2b00      	cmp	r3, #0
   8cd26:	d001      	beq.n	8cd2c <_ZN8SdVolume14cacheZeroBlockEm+0x20>
   8cd28:	2300      	movs	r3, #0
   8cd2a:	e013      	b.n	8cd54 <_ZN8SdVolume14cacheZeroBlockEm+0x48>

  // loop take less flash than memset(cacheBuffer_.data, 0, 512);
  for (uint16_t i = 0; i < 512; i++) {
   8cd2c:	2300      	movs	r3, #0
   8cd2e:	81fb      	strh	r3, [r7, #14]
   8cd30:	89fb      	ldrh	r3, [r7, #14]
   8cd32:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   8cd36:	d207      	bcs.n	8cd48 <_ZN8SdVolume14cacheZeroBlockEm+0x3c>
    cacheBuffer_.data[i] = 0;
   8cd38:	89fb      	ldrh	r3, [r7, #14]
   8cd3a:	4a09      	ldr	r2, [pc, #36]	; (8cd60 <_ZN8SdVolume14cacheZeroBlockEm+0x54>)
   8cd3c:	2100      	movs	r1, #0
   8cd3e:	54d1      	strb	r1, [r2, r3]
// cache a zero block for blockNumber
uint8_t SdVolume::cacheZeroBlock(uint32_t blockNumber) {
  if (!cacheFlush()) return false;

  // loop take less flash than memset(cacheBuffer_.data, 0, 512);
  for (uint16_t i = 0; i < 512; i++) {
   8cd40:	89fb      	ldrh	r3, [r7, #14]
   8cd42:	3301      	adds	r3, #1
   8cd44:	81fb      	strh	r3, [r7, #14]
   8cd46:	e7f3      	b.n	8cd30 <_ZN8SdVolume14cacheZeroBlockEm+0x24>
    cacheBuffer_.data[i] = 0;
  }
  cacheBlockNumber_ = blockNumber;
   8cd48:	4a06      	ldr	r2, [pc, #24]	; (8cd64 <_ZN8SdVolume14cacheZeroBlockEm+0x58>)
   8cd4a:	687b      	ldr	r3, [r7, #4]
   8cd4c:	6013      	str	r3, [r2, #0]
  cacheSetDirty();
   8cd4e:	4b06      	ldr	r3, [pc, #24]	; (8cd68 <_ZN8SdVolume14cacheZeroBlockEm+0x5c>)
   8cd50:	4798      	blx	r3
  return true;
   8cd52:	2301      	movs	r3, #1
}
   8cd54:	4618      	mov	r0, r3
   8cd56:	3710      	adds	r7, #16
   8cd58:	46bd      	mov	sp, r7
   8cd5a:	bd80      	pop	{r7, pc}
   8cd5c:	0008cbfd 	.word	0x0008cbfd
   8cd60:	2007191c 	.word	0x2007191c
   8cd64:	20070114 	.word	0x20070114
   8cd68:	0008ba09 	.word	0x0008ba09

0008cd6c <_ZNK8SdVolume9chainSizeEmPm>:
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
   8cd6c:	b580      	push	{r7, lr}
   8cd6e:	b086      	sub	sp, #24
   8cd70:	af00      	add	r7, sp, #0
   8cd72:	60f8      	str	r0, [r7, #12]
   8cd74:	60b9      	str	r1, [r7, #8]
   8cd76:	607a      	str	r2, [r7, #4]
  uint32_t s = 0;
   8cd78:	2300      	movs	r3, #0
   8cd7a:	617b      	str	r3, [r7, #20]
  do {
    if (!fatGet(cluster, &cluster)) return false;
   8cd7c:	68bb      	ldr	r3, [r7, #8]
   8cd7e:	f107 0208 	add.w	r2, r7, #8
   8cd82:	4619      	mov	r1, r3
   8cd84:	68f8      	ldr	r0, [r7, #12]
   8cd86:	4b15      	ldr	r3, [pc, #84]	; (8cddc <_ZNK8SdVolume9chainSizeEmPm+0x70>)
   8cd88:	4798      	blx	r3
   8cd8a:	4603      	mov	r3, r0
   8cd8c:	2b00      	cmp	r3, #0
   8cd8e:	bf0c      	ite	eq
   8cd90:	2301      	moveq	r3, #1
   8cd92:	2300      	movne	r3, #0
   8cd94:	b2db      	uxtb	r3, r3
   8cd96:	2b00      	cmp	r3, #0
   8cd98:	d001      	beq.n	8cd9e <_ZNK8SdVolume9chainSizeEmPm+0x32>
   8cd9a:	2300      	movs	r3, #0
   8cd9c:	e01a      	b.n	8cdd4 <_ZNK8SdVolume9chainSizeEmPm+0x68>
    s += 512UL << clusterSizeShift_;
   8cd9e:	68fb      	ldr	r3, [r7, #12]
   8cda0:	7c1b      	ldrb	r3, [r3, #16]
   8cda2:	461a      	mov	r2, r3
   8cda4:	f44f 7300 	mov.w	r3, #512	; 0x200
   8cda8:	4093      	lsls	r3, r2
   8cdaa:	697a      	ldr	r2, [r7, #20]
   8cdac:	4413      	add	r3, r2
   8cdae:	617b      	str	r3, [r7, #20]
  } while (!isEOC(cluster));
   8cdb0:	68bb      	ldr	r3, [r7, #8]
   8cdb2:	4619      	mov	r1, r3
   8cdb4:	68f8      	ldr	r0, [r7, #12]
   8cdb6:	4b0a      	ldr	r3, [pc, #40]	; (8cde0 <_ZNK8SdVolume9chainSizeEmPm+0x74>)
   8cdb8:	4798      	blx	r3
   8cdba:	4603      	mov	r3, r0
}
//------------------------------------------------------------------------------
// return the size in bytes of a cluster chain
uint8_t SdVolume::chainSize(uint32_t cluster, uint32_t* size) const {
  uint32_t s = 0;
  do {
   8cdbc:	2b00      	cmp	r3, #0
   8cdbe:	bf0c      	ite	eq
   8cdc0:	2301      	moveq	r3, #1
   8cdc2:	2300      	movne	r3, #0
   8cdc4:	b2db      	uxtb	r3, r3
   8cdc6:	2b00      	cmp	r3, #0
   8cdc8:	d000      	beq.n	8cdcc <_ZNK8SdVolume9chainSizeEmPm+0x60>
   8cdca:	e7d7      	b.n	8cd7c <_ZNK8SdVolume9chainSizeEmPm+0x10>
    if (!fatGet(cluster, &cluster)) return false;
    s += 512UL << clusterSizeShift_;
  } while (!isEOC(cluster));
  *size = s;
   8cdcc:	687b      	ldr	r3, [r7, #4]
   8cdce:	697a      	ldr	r2, [r7, #20]
   8cdd0:	601a      	str	r2, [r3, #0]
  return true;
   8cdd2:	2301      	movs	r3, #1
}
   8cdd4:	4618      	mov	r0, r3
   8cdd6:	3718      	adds	r7, #24
   8cdd8:	46bd      	mov	sp, r7
   8cdda:	bd80      	pop	{r7, pc}
   8cddc:	0008cde5 	.word	0x0008cde5
   8cde0:	0008ba4d 	.word	0x0008ba4d

0008cde4 <_ZNK8SdVolume6fatGetEmPm>:
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
   8cde4:	b580      	push	{r7, lr}
   8cde6:	b086      	sub	sp, #24
   8cde8:	af00      	add	r7, sp, #0
   8cdea:	60f8      	str	r0, [r7, #12]
   8cdec:	60b9      	str	r1, [r7, #8]
   8cdee:	607a      	str	r2, [r7, #4]
  if (cluster > (clusterCount_ + 1)) return false;
   8cdf0:	68fb      	ldr	r3, [r7, #12]
   8cdf2:	68db      	ldr	r3, [r3, #12]
   8cdf4:	1c5a      	adds	r2, r3, #1
   8cdf6:	68bb      	ldr	r3, [r7, #8]
   8cdf8:	429a      	cmp	r2, r3
   8cdfa:	d201      	bcs.n	8ce00 <_ZNK8SdVolume6fatGetEmPm+0x1c>
   8cdfc:	2300      	movs	r3, #0
   8cdfe:	e03b      	b.n	8ce78 <_ZNK8SdVolume6fatGetEmPm+0x94>
  uint32_t lba = fatStartBlock_;
   8ce00:	68fb      	ldr	r3, [r7, #12]
   8ce02:	69db      	ldr	r3, [r3, #28]
   8ce04:	617b      	str	r3, [r7, #20]
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   8ce06:	68fb      	ldr	r3, [r7, #12]
   8ce08:	f893 3020 	ldrb.w	r3, [r3, #32]
   8ce0c:	2b10      	cmp	r3, #16
   8ce0e:	d102      	bne.n	8ce16 <_ZNK8SdVolume6fatGetEmPm+0x32>
   8ce10:	68bb      	ldr	r3, [r7, #8]
   8ce12:	0a1b      	lsrs	r3, r3, #8
   8ce14:	e001      	b.n	8ce1a <_ZNK8SdVolume6fatGetEmPm+0x36>
   8ce16:	68bb      	ldr	r3, [r7, #8]
   8ce18:	09db      	lsrs	r3, r3, #7
   8ce1a:	697a      	ldr	r2, [r7, #20]
   8ce1c:	4413      	add	r3, r2
   8ce1e:	617b      	str	r3, [r7, #20]
  if (lba != cacheBlockNumber_) {
   8ce20:	4b17      	ldr	r3, [pc, #92]	; (8ce80 <_ZNK8SdVolume6fatGetEmPm+0x9c>)
   8ce22:	681b      	ldr	r3, [r3, #0]
   8ce24:	697a      	ldr	r2, [r7, #20]
   8ce26:	429a      	cmp	r2, r3
   8ce28:	d00d      	beq.n	8ce46 <_ZNK8SdVolume6fatGetEmPm+0x62>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
   8ce2a:	2100      	movs	r1, #0
   8ce2c:	6978      	ldr	r0, [r7, #20]
   8ce2e:	4b15      	ldr	r3, [pc, #84]	; (8ce84 <_ZNK8SdVolume6fatGetEmPm+0xa0>)
   8ce30:	4798      	blx	r3
   8ce32:	4603      	mov	r3, r0
   8ce34:	2b00      	cmp	r3, #0
   8ce36:	bf0c      	ite	eq
   8ce38:	2301      	moveq	r3, #1
   8ce3a:	2300      	movne	r3, #0
   8ce3c:	b2db      	uxtb	r3, r3
   8ce3e:	2b00      	cmp	r3, #0
   8ce40:	d001      	beq.n	8ce46 <_ZNK8SdVolume6fatGetEmPm+0x62>
   8ce42:	2300      	movs	r3, #0
   8ce44:	e018      	b.n	8ce78 <_ZNK8SdVolume6fatGetEmPm+0x94>
  }
  if (fatType_ == 16) {
   8ce46:	68fb      	ldr	r3, [r7, #12]
   8ce48:	f893 3020 	ldrb.w	r3, [r3, #32]
   8ce4c:	2b10      	cmp	r3, #16
   8ce4e:	d108      	bne.n	8ce62 <_ZNK8SdVolume6fatGetEmPm+0x7e>
    *value = cacheBuffer_.fat16[cluster & 0XFF];
   8ce50:	68bb      	ldr	r3, [r7, #8]
   8ce52:	b2db      	uxtb	r3, r3
   8ce54:	4a0c      	ldr	r2, [pc, #48]	; (8ce88 <_ZNK8SdVolume6fatGetEmPm+0xa4>)
   8ce56:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   8ce5a:	461a      	mov	r2, r3
   8ce5c:	687b      	ldr	r3, [r7, #4]
   8ce5e:	601a      	str	r2, [r3, #0]
   8ce60:	e009      	b.n	8ce76 <_ZNK8SdVolume6fatGetEmPm+0x92>
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
   8ce62:	68bb      	ldr	r3, [r7, #8]
   8ce64:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   8ce68:	4a07      	ldr	r2, [pc, #28]	; (8ce88 <_ZNK8SdVolume6fatGetEmPm+0xa4>)
   8ce6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   8ce6e:	f023 4270 	bic.w	r2, r3, #4026531840	; 0xf0000000
   8ce72:	687b      	ldr	r3, [r7, #4]
   8ce74:	601a      	str	r2, [r3, #0]
  }
  return true;
   8ce76:	2301      	movs	r3, #1
}
   8ce78:	4618      	mov	r0, r3
   8ce7a:	3718      	adds	r7, #24
   8ce7c:	46bd      	mov	sp, r7
   8ce7e:	bd80      	pop	{r7, pc}
   8ce80:	20070114 	.word	0x20070114
   8ce84:	0008cc85 	.word	0x0008cc85
   8ce88:	2007191c 	.word	0x2007191c

0008ce8c <_ZN8SdVolume6fatPutEmm>:
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
   8ce8c:	b580      	push	{r7, lr}
   8ce8e:	b086      	sub	sp, #24
   8ce90:	af00      	add	r7, sp, #0
   8ce92:	60f8      	str	r0, [r7, #12]
   8ce94:	60b9      	str	r1, [r7, #8]
   8ce96:	607a      	str	r2, [r7, #4]
  // error if reserved cluster
  if (cluster < 2) return false;
   8ce98:	68bb      	ldr	r3, [r7, #8]
   8ce9a:	2b01      	cmp	r3, #1
   8ce9c:	d801      	bhi.n	8cea2 <_ZN8SdVolume6fatPutEmm+0x16>
   8ce9e:	2300      	movs	r3, #0
   8cea0:	e04b      	b.n	8cf3a <_ZN8SdVolume6fatPutEmm+0xae>

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
   8cea2:	68fb      	ldr	r3, [r7, #12]
   8cea4:	68db      	ldr	r3, [r3, #12]
   8cea6:	1c5a      	adds	r2, r3, #1
   8cea8:	68bb      	ldr	r3, [r7, #8]
   8ceaa:	429a      	cmp	r2, r3
   8ceac:	d201      	bcs.n	8ceb2 <_ZN8SdVolume6fatPutEmm+0x26>
   8ceae:	2300      	movs	r3, #0
   8ceb0:	e043      	b.n	8cf3a <_ZN8SdVolume6fatPutEmm+0xae>

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
   8ceb2:	68fb      	ldr	r3, [r7, #12]
   8ceb4:	69db      	ldr	r3, [r3, #28]
   8ceb6:	617b      	str	r3, [r7, #20]
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
   8ceb8:	68fb      	ldr	r3, [r7, #12]
   8ceba:	f893 3020 	ldrb.w	r3, [r3, #32]
   8cebe:	2b10      	cmp	r3, #16
   8cec0:	d102      	bne.n	8cec8 <_ZN8SdVolume6fatPutEmm+0x3c>
   8cec2:	68bb      	ldr	r3, [r7, #8]
   8cec4:	0a1b      	lsrs	r3, r3, #8
   8cec6:	e001      	b.n	8cecc <_ZN8SdVolume6fatPutEmm+0x40>
   8cec8:	68bb      	ldr	r3, [r7, #8]
   8ceca:	09db      	lsrs	r3, r3, #7
   8cecc:	697a      	ldr	r2, [r7, #20]
   8cece:	4413      	add	r3, r2
   8ced0:	617b      	str	r3, [r7, #20]

  if (lba != cacheBlockNumber_) {
   8ced2:	4b1c      	ldr	r3, [pc, #112]	; (8cf44 <_ZN8SdVolume6fatPutEmm+0xb8>)
   8ced4:	681b      	ldr	r3, [r3, #0]
   8ced6:	697a      	ldr	r2, [r7, #20]
   8ced8:	429a      	cmp	r2, r3
   8ceda:	d00d      	beq.n	8cef8 <_ZN8SdVolume6fatPutEmm+0x6c>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
   8cedc:	2100      	movs	r1, #0
   8cede:	6978      	ldr	r0, [r7, #20]
   8cee0:	4b19      	ldr	r3, [pc, #100]	; (8cf48 <_ZN8SdVolume6fatPutEmm+0xbc>)
   8cee2:	4798      	blx	r3
   8cee4:	4603      	mov	r3, r0
   8cee6:	2b00      	cmp	r3, #0
   8cee8:	bf0c      	ite	eq
   8ceea:	2301      	moveq	r3, #1
   8ceec:	2300      	movne	r3, #0
   8ceee:	b2db      	uxtb	r3, r3
   8cef0:	2b00      	cmp	r3, #0
   8cef2:	d001      	beq.n	8cef8 <_ZN8SdVolume6fatPutEmm+0x6c>
   8cef4:	2300      	movs	r3, #0
   8cef6:	e020      	b.n	8cf3a <_ZN8SdVolume6fatPutEmm+0xae>
  }
  // store entry
  if (fatType_ == 16) {
   8cef8:	68fb      	ldr	r3, [r7, #12]
   8cefa:	f893 3020 	ldrb.w	r3, [r3, #32]
   8cefe:	2b10      	cmp	r3, #16
   8cf00:	d107      	bne.n	8cf12 <_ZN8SdVolume6fatPutEmm+0x86>
    cacheBuffer_.fat16[cluster & 0XFF] = value;
   8cf02:	68bb      	ldr	r3, [r7, #8]
   8cf04:	b2db      	uxtb	r3, r3
   8cf06:	687a      	ldr	r2, [r7, #4]
   8cf08:	b291      	uxth	r1, r2
   8cf0a:	4a10      	ldr	r2, [pc, #64]	; (8cf4c <_ZN8SdVolume6fatPutEmm+0xc0>)
   8cf0c:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
   8cf10:	e006      	b.n	8cf20 <_ZN8SdVolume6fatPutEmm+0x94>
  } else {
    cacheBuffer_.fat32[cluster & 0X7F] = value;
   8cf12:	68bb      	ldr	r3, [r7, #8]
   8cf14:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   8cf18:	490c      	ldr	r1, [pc, #48]	; (8cf4c <_ZN8SdVolume6fatPutEmm+0xc0>)
   8cf1a:	687a      	ldr	r2, [r7, #4]
   8cf1c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
  cacheSetDirty();
   8cf20:	4b0b      	ldr	r3, [pc, #44]	; (8cf50 <_ZN8SdVolume6fatPutEmm+0xc4>)
   8cf22:	4798      	blx	r3

  // mirror second FAT
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
   8cf24:	68fb      	ldr	r3, [r7, #12]
   8cf26:	7e1b      	ldrb	r3, [r3, #24]
   8cf28:	2b01      	cmp	r3, #1
   8cf2a:	d905      	bls.n	8cf38 <_ZN8SdVolume6fatPutEmm+0xac>
   8cf2c:	68fb      	ldr	r3, [r7, #12]
   8cf2e:	689a      	ldr	r2, [r3, #8]
   8cf30:	697b      	ldr	r3, [r7, #20]
   8cf32:	4413      	add	r3, r2
   8cf34:	4a07      	ldr	r2, [pc, #28]	; (8cf54 <_ZN8SdVolume6fatPutEmm+0xc8>)
   8cf36:	6013      	str	r3, [r2, #0]
  return true;
   8cf38:	2301      	movs	r3, #1
}
   8cf3a:	4618      	mov	r0, r3
   8cf3c:	3718      	adds	r7, #24
   8cf3e:	46bd      	mov	sp, r7
   8cf40:	bd80      	pop	{r7, pc}
   8cf42:	bf00      	nop
   8cf44:	20070114 	.word	0x20070114
   8cf48:	0008cc85 	.word	0x0008cc85
   8cf4c:	2007191c 	.word	0x2007191c
   8cf50:	0008ba09 	.word	0x0008ba09
   8cf54:	20071b24 	.word	0x20071b24

0008cf58 <_ZN8SdVolume9freeChainEm>:
//------------------------------------------------------------------------------
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
   8cf58:	b580      	push	{r7, lr}
   8cf5a:	b084      	sub	sp, #16
   8cf5c:	af00      	add	r7, sp, #0
   8cf5e:	6078      	str	r0, [r7, #4]
   8cf60:	6039      	str	r1, [r7, #0]
  // clear free cluster location
  allocSearchStart_ = 2;
   8cf62:	687b      	ldr	r3, [r7, #4]
   8cf64:	2202      	movs	r2, #2
   8cf66:	601a      	str	r2, [r3, #0]

  do {
    uint32_t next;
    if (!fatGet(cluster, &next)) return false;
   8cf68:	f107 030c 	add.w	r3, r7, #12
   8cf6c:	461a      	mov	r2, r3
   8cf6e:	6839      	ldr	r1, [r7, #0]
   8cf70:	6878      	ldr	r0, [r7, #4]
   8cf72:	4b17      	ldr	r3, [pc, #92]	; (8cfd0 <_ZN8SdVolume9freeChainEm+0x78>)
   8cf74:	4798      	blx	r3
   8cf76:	4603      	mov	r3, r0
   8cf78:	2b00      	cmp	r3, #0
   8cf7a:	bf0c      	ite	eq
   8cf7c:	2301      	moveq	r3, #1
   8cf7e:	2300      	movne	r3, #0
   8cf80:	b2db      	uxtb	r3, r3
   8cf82:	2b00      	cmp	r3, #0
   8cf84:	d001      	beq.n	8cf8a <_ZN8SdVolume9freeChainEm+0x32>
   8cf86:	2300      	movs	r3, #0
   8cf88:	e01e      	b.n	8cfc8 <_ZN8SdVolume9freeChainEm+0x70>

    // free cluster
    if (!fatPut(cluster, 0)) return false;
   8cf8a:	2200      	movs	r2, #0
   8cf8c:	6839      	ldr	r1, [r7, #0]
   8cf8e:	6878      	ldr	r0, [r7, #4]
   8cf90:	4b10      	ldr	r3, [pc, #64]	; (8cfd4 <_ZN8SdVolume9freeChainEm+0x7c>)
   8cf92:	4798      	blx	r3
   8cf94:	4603      	mov	r3, r0
   8cf96:	2b00      	cmp	r3, #0
   8cf98:	bf0c      	ite	eq
   8cf9a:	2301      	moveq	r3, #1
   8cf9c:	2300      	movne	r3, #0
   8cf9e:	b2db      	uxtb	r3, r3
   8cfa0:	2b00      	cmp	r3, #0
   8cfa2:	d001      	beq.n	8cfa8 <_ZN8SdVolume9freeChainEm+0x50>
   8cfa4:	2300      	movs	r3, #0
   8cfa6:	e00f      	b.n	8cfc8 <_ZN8SdVolume9freeChainEm+0x70>

    cluster = next;
   8cfa8:	68fb      	ldr	r3, [r7, #12]
   8cfaa:	603b      	str	r3, [r7, #0]
  } while (!isEOC(cluster));
   8cfac:	6839      	ldr	r1, [r7, #0]
   8cfae:	6878      	ldr	r0, [r7, #4]
   8cfb0:	4b09      	ldr	r3, [pc, #36]	; (8cfd8 <_ZN8SdVolume9freeChainEm+0x80>)
   8cfb2:	4798      	blx	r3
   8cfb4:	4603      	mov	r3, r0
// free a cluster chain
uint8_t SdVolume::freeChain(uint32_t cluster) {
  // clear free cluster location
  allocSearchStart_ = 2;

  do {
   8cfb6:	2b00      	cmp	r3, #0
   8cfb8:	bf0c      	ite	eq
   8cfba:	2301      	moveq	r3, #1
   8cfbc:	2300      	movne	r3, #0
   8cfbe:	b2db      	uxtb	r3, r3
   8cfc0:	2b00      	cmp	r3, #0
   8cfc2:	d000      	beq.n	8cfc6 <_ZN8SdVolume9freeChainEm+0x6e>
   8cfc4:	e7d0      	b.n	8cf68 <_ZN8SdVolume9freeChainEm+0x10>
    if (!fatPut(cluster, 0)) return false;

    cluster = next;
  } while (!isEOC(cluster));

  return true;
   8cfc6:	2301      	movs	r3, #1
}
   8cfc8:	4618      	mov	r0, r3
   8cfca:	3710      	adds	r7, #16
   8cfcc:	46bd      	mov	sp, r7
   8cfce:	bd80      	pop	{r7, pc}
   8cfd0:	0008cde5 	.word	0x0008cde5
   8cfd4:	0008ce8d 	.word	0x0008ce8d
   8cfd8:	0008ba4d 	.word	0x0008ba4d

0008cfdc <_ZN8SdVolume4initEP7Sd2Cardh>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   8cfdc:	b580      	push	{r7, lr}
   8cfde:	b088      	sub	sp, #32
   8cfe0:	af00      	add	r7, sp, #0
   8cfe2:	60f8      	str	r0, [r7, #12]
   8cfe4:	60b9      	str	r1, [r7, #8]
   8cfe6:	4613      	mov	r3, r2
   8cfe8:	71fb      	strb	r3, [r7, #7]
  uint32_t volumeStartBlock = 0;
   8cfea:	2300      	movs	r3, #0
   8cfec:	61fb      	str	r3, [r7, #28]
  sdCard_ = dev;
   8cfee:	4a7d      	ldr	r2, [pc, #500]	; (8d1e4 <_ZN8SdVolume4initEP7Sd2Cardh+0x208>)
   8cff0:	68bb      	ldr	r3, [r7, #8]
   8cff2:	6013      	str	r3, [r2, #0]
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
   8cff4:	79fb      	ldrb	r3, [r7, #7]
   8cff6:	2b00      	cmp	r3, #0
   8cff8:	d02e      	beq.n	8d058 <_ZN8SdVolume4initEP7Sd2Cardh+0x7c>
    if (part > 4)return false;
   8cffa:	79fb      	ldrb	r3, [r7, #7]
   8cffc:	2b04      	cmp	r3, #4
   8cffe:	d901      	bls.n	8d004 <_ZN8SdVolume4initEP7Sd2Cardh+0x28>
   8d000:	2300      	movs	r3, #0
   8d002:	e0ea      	b.n	8d1da <_ZN8SdVolume4initEP7Sd2Cardh+0x1fe>
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
   8d004:	2100      	movs	r1, #0
   8d006:	69f8      	ldr	r0, [r7, #28]
   8d008:	4b77      	ldr	r3, [pc, #476]	; (8d1e8 <_ZN8SdVolume4initEP7Sd2Cardh+0x20c>)
   8d00a:	4798      	blx	r3
   8d00c:	4603      	mov	r3, r0
   8d00e:	2b00      	cmp	r3, #0
   8d010:	bf0c      	ite	eq
   8d012:	2301      	moveq	r3, #1
   8d014:	2300      	movne	r3, #0
   8d016:	b2db      	uxtb	r3, r3
   8d018:	2b00      	cmp	r3, #0
   8d01a:	d001      	beq.n	8d020 <_ZN8SdVolume4initEP7Sd2Cardh+0x44>
   8d01c:	2300      	movs	r3, #0
   8d01e:	e0dc      	b.n	8d1da <_ZN8SdVolume4initEP7Sd2Cardh+0x1fe>
    part_t* p = &cacheBuffer_.mbr.part[part-1];
   8d020:	79fb      	ldrb	r3, [r7, #7]
   8d022:	3b01      	subs	r3, #1
   8d024:	011b      	lsls	r3, r3, #4
   8d026:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
   8d02a:	4a70      	ldr	r2, [pc, #448]	; (8d1ec <_ZN8SdVolume4initEP7Sd2Cardh+0x210>)
   8d02c:	4413      	add	r3, r2
   8d02e:	3306      	adds	r3, #6
   8d030:	61bb      	str	r3, [r7, #24]
    if ((p->boot & 0X7F) !=0  ||
   8d032:	69bb      	ldr	r3, [r7, #24]
   8d034:	781b      	ldrb	r3, [r3, #0]
   8d036:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   8d03a:	2b00      	cmp	r3, #0
   8d03c:	d107      	bne.n	8d04e <_ZN8SdVolume4initEP7Sd2Cardh+0x72>
      p->totalSectors < 100 ||
   8d03e:	69bb      	ldr	r3, [r7, #24]
   8d040:	68db      	ldr	r3, [r3, #12]
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
   8d042:	2b63      	cmp	r3, #99	; 0x63
   8d044:	d903      	bls.n	8d04e <_ZN8SdVolume4initEP7Sd2Cardh+0x72>
      p->totalSectors < 100 ||
      p->firstSector == 0) {
   8d046:	69bb      	ldr	r3, [r7, #24]
   8d048:	689b      	ldr	r3, [r3, #8]
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
      p->totalSectors < 100 ||
   8d04a:	2b00      	cmp	r3, #0
   8d04c:	d101      	bne.n	8d052 <_ZN8SdVolume4initEP7Sd2Cardh+0x76>
      p->firstSector == 0) {
      // not a valid partition
      return false;
   8d04e:	2300      	movs	r3, #0
   8d050:	e0c3      	b.n	8d1da <_ZN8SdVolume4initEP7Sd2Cardh+0x1fe>
    }
    volumeStartBlock = p->firstSector;
   8d052:	69bb      	ldr	r3, [r7, #24]
   8d054:	689b      	ldr	r3, [r3, #8]
   8d056:	61fb      	str	r3, [r7, #28]
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
   8d058:	2100      	movs	r1, #0
   8d05a:	69f8      	ldr	r0, [r7, #28]
   8d05c:	4b62      	ldr	r3, [pc, #392]	; (8d1e8 <_ZN8SdVolume4initEP7Sd2Cardh+0x20c>)
   8d05e:	4798      	blx	r3
   8d060:	4603      	mov	r3, r0
   8d062:	2b00      	cmp	r3, #0
   8d064:	bf0c      	ite	eq
   8d066:	2301      	moveq	r3, #1
   8d068:	2300      	movne	r3, #0
   8d06a:	b2db      	uxtb	r3, r3
   8d06c:	2b00      	cmp	r3, #0
   8d06e:	d001      	beq.n	8d074 <_ZN8SdVolume4initEP7Sd2Cardh+0x98>
   8d070:	2300      	movs	r3, #0
   8d072:	e0b2      	b.n	8d1da <_ZN8SdVolume4initEP7Sd2Cardh+0x1fe>
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
   8d074:	4b5e      	ldr	r3, [pc, #376]	; (8d1f0 <_ZN8SdVolume4initEP7Sd2Cardh+0x214>)
   8d076:	617b      	str	r3, [r7, #20]
  if (bpb->bytesPerSector != 512 ||
   8d078:	697b      	ldr	r3, [r7, #20]
   8d07a:	881b      	ldrh	r3, [r3, #0]
   8d07c:	b29b      	uxth	r3, r3
   8d07e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   8d082:	d10d      	bne.n	8d0a0 <_ZN8SdVolume4initEP7Sd2Cardh+0xc4>
    bpb->fatCount == 0 ||
   8d084:	697b      	ldr	r3, [r7, #20]
   8d086:	795b      	ldrb	r3, [r3, #5]
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
   8d088:	2b00      	cmp	r3, #0
   8d08a:	d009      	beq.n	8d0a0 <_ZN8SdVolume4initEP7Sd2Cardh+0xc4>
    bpb->fatCount == 0 ||
    bpb->reservedSectorCount == 0 ||
   8d08c:	697b      	ldr	r3, [r7, #20]
   8d08e:	f8b3 3003 	ldrh.w	r3, [r3, #3]
   8d092:	b29b      	uxth	r3, r3
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
    bpb->fatCount == 0 ||
   8d094:	2b00      	cmp	r3, #0
   8d096:	d003      	beq.n	8d0a0 <_ZN8SdVolume4initEP7Sd2Cardh+0xc4>
    bpb->reservedSectorCount == 0 ||
    bpb->sectorsPerCluster == 0) {
   8d098:	697b      	ldr	r3, [r7, #20]
   8d09a:	789b      	ldrb	r3, [r3, #2]
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
    bpb->fatCount == 0 ||
    bpb->reservedSectorCount == 0 ||
   8d09c:	2b00      	cmp	r3, #0
   8d09e:	d101      	bne.n	8d0a4 <_ZN8SdVolume4initEP7Sd2Cardh+0xc8>
    bpb->sectorsPerCluster == 0) {
       // not valid FAT volume
      return false;
   8d0a0:	2300      	movs	r3, #0
   8d0a2:	e09a      	b.n	8d1da <_ZN8SdVolume4initEP7Sd2Cardh+0x1fe>
  }
  fatCount_ = bpb->fatCount;
   8d0a4:	697b      	ldr	r3, [r7, #20]
   8d0a6:	795a      	ldrb	r2, [r3, #5]
   8d0a8:	68fb      	ldr	r3, [r7, #12]
   8d0aa:	761a      	strb	r2, [r3, #24]
  blocksPerCluster_ = bpb->sectorsPerCluster;
   8d0ac:	697b      	ldr	r3, [r7, #20]
   8d0ae:	789a      	ldrb	r2, [r3, #2]
   8d0b0:	68fb      	ldr	r3, [r7, #12]
   8d0b2:	711a      	strb	r2, [r3, #4]

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
   8d0b4:	68fb      	ldr	r3, [r7, #12]
   8d0b6:	2200      	movs	r2, #0
   8d0b8:	741a      	strb	r2, [r3, #16]
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
   8d0ba:	68fb      	ldr	r3, [r7, #12]
   8d0bc:	791b      	ldrb	r3, [r3, #4]
   8d0be:	461a      	mov	r2, r3
   8d0c0:	68fb      	ldr	r3, [r7, #12]
   8d0c2:	7c1b      	ldrb	r3, [r3, #16]
   8d0c4:	4619      	mov	r1, r3
   8d0c6:	2301      	movs	r3, #1
   8d0c8:	408b      	lsls	r3, r1
   8d0ca:	429a      	cmp	r2, r3
   8d0cc:	d00e      	beq.n	8d0ec <_ZN8SdVolume4initEP7Sd2Cardh+0x110>
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
   8d0ce:	68fb      	ldr	r3, [r7, #12]
   8d0d0:	7c1b      	ldrb	r3, [r3, #16]
   8d0d2:	1c5a      	adds	r2, r3, #1
   8d0d4:	b2d1      	uxtb	r1, r2
   8d0d6:	68fa      	ldr	r2, [r7, #12]
   8d0d8:	7411      	strb	r1, [r2, #16]
   8d0da:	2b07      	cmp	r3, #7
   8d0dc:	bf8c      	ite	hi
   8d0de:	2301      	movhi	r3, #1
   8d0e0:	2300      	movls	r3, #0
   8d0e2:	b2db      	uxtb	r3, r3
   8d0e4:	2b00      	cmp	r3, #0
   8d0e6:	d0e8      	beq.n	8d0ba <_ZN8SdVolume4initEP7Sd2Cardh+0xde>
   8d0e8:	2300      	movs	r3, #0
   8d0ea:	e076      	b.n	8d1da <_ZN8SdVolume4initEP7Sd2Cardh+0x1fe>
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
   8d0ec:	697b      	ldr	r3, [r7, #20]
   8d0ee:	f8b3 300b 	ldrh.w	r3, [r3, #11]
   8d0f2:	b29b      	uxth	r3, r3
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;
   8d0f4:	2b00      	cmp	r3, #0
   8d0f6:	d004      	beq.n	8d102 <_ZN8SdVolume4initEP7Sd2Cardh+0x126>
   8d0f8:	697b      	ldr	r3, [r7, #20]
   8d0fa:	f8b3 300b 	ldrh.w	r3, [r3, #11]
   8d0fe:	b29b      	uxth	r3, r3
   8d100:	e002      	b.n	8d108 <_ZN8SdVolume4initEP7Sd2Cardh+0x12c>
   8d102:	697b      	ldr	r3, [r7, #20]
   8d104:	f8d3 3019 	ldr.w	r3, [r3, #25]
   8d108:	68fa      	ldr	r2, [r7, #12]
   8d10a:	6093      	str	r3, [r2, #8]

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;
   8d10c:	697b      	ldr	r3, [r7, #20]
   8d10e:	f8b3 3003 	ldrh.w	r3, [r3, #3]
   8d112:	b29b      	uxth	r3, r3
   8d114:	461a      	mov	r2, r3
   8d116:	69fb      	ldr	r3, [r7, #28]
   8d118:	441a      	add	r2, r3
   8d11a:	68fb      	ldr	r3, [r7, #12]
   8d11c:	61da      	str	r2, [r3, #28]

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;
   8d11e:	697b      	ldr	r3, [r7, #20]
   8d120:	88db      	ldrh	r3, [r3, #6]
   8d122:	b29a      	uxth	r2, r3
   8d124:	68fb      	ldr	r3, [r7, #12]
   8d126:	845a      	strh	r2, [r3, #34]	; 0x22

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
   8d128:	68fb      	ldr	r3, [r7, #12]
   8d12a:	69da      	ldr	r2, [r3, #28]
   8d12c:	697b      	ldr	r3, [r7, #20]
   8d12e:	795b      	ldrb	r3, [r3, #5]
   8d130:	4619      	mov	r1, r3
   8d132:	68fb      	ldr	r3, [r7, #12]
   8d134:	689b      	ldr	r3, [r3, #8]
   8d136:	fb03 f301 	mul.w	r3, r3, r1
   8d13a:	441a      	add	r2, r3
   8d13c:	68fb      	ldr	r3, [r7, #12]
   8d13e:	625a      	str	r2, [r3, #36]	; 0x24

  // data start for FAT16 and FAT32
  dataStartBlock_ = rootDirStart_ + ((32 * bpb->rootDirEntryCount + 511)/512);
   8d140:	68fb      	ldr	r3, [r7, #12]
   8d142:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   8d144:	697b      	ldr	r3, [r7, #20]
   8d146:	88db      	ldrh	r3, [r3, #6]
   8d148:	b29b      	uxth	r3, r3
   8d14a:	015b      	lsls	r3, r3, #5
   8d14c:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
   8d150:	2b00      	cmp	r3, #0
   8d152:	da01      	bge.n	8d158 <_ZN8SdVolume4initEP7Sd2Cardh+0x17c>
   8d154:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
   8d158:	125b      	asrs	r3, r3, #9
   8d15a:	441a      	add	r2, r3
   8d15c:	68fb      	ldr	r3, [r7, #12]
   8d15e:	615a      	str	r2, [r3, #20]

  // total blocks for FAT16 or FAT32
  uint32_t totalBlocks = bpb->totalSectors16 ?
   8d160:	697b      	ldr	r3, [r7, #20]
   8d162:	891b      	ldrh	r3, [r3, #8]
   8d164:	b29b      	uxth	r3, r3
                           bpb->totalSectors16 : bpb->totalSectors32;
   8d166:	2b00      	cmp	r3, #0
   8d168:	d003      	beq.n	8d172 <_ZN8SdVolume4initEP7Sd2Cardh+0x196>
   8d16a:	697b      	ldr	r3, [r7, #20]
   8d16c:	891b      	ldrh	r3, [r3, #8]
   8d16e:	b29b      	uxth	r3, r3
   8d170:	e002      	b.n	8d178 <_ZN8SdVolume4initEP7Sd2Cardh+0x19c>
   8d172:	697b      	ldr	r3, [r7, #20]
   8d174:	f8d3 3015 	ldr.w	r3, [r3, #21]
   8d178:	613b      	str	r3, [r7, #16]
  // total data blocks
  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);
   8d17a:	68fb      	ldr	r3, [r7, #12]
   8d17c:	695b      	ldr	r3, [r3, #20]
   8d17e:	69fa      	ldr	r2, [r7, #28]
   8d180:	1ad2      	subs	r2, r2, r3
   8d182:	693b      	ldr	r3, [r7, #16]
   8d184:	441a      	add	r2, r3
   8d186:	68fb      	ldr	r3, [r7, #12]
   8d188:	60da      	str	r2, [r3, #12]

  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;
   8d18a:	68fb      	ldr	r3, [r7, #12]
   8d18c:	68db      	ldr	r3, [r3, #12]
   8d18e:	68fa      	ldr	r2, [r7, #12]
   8d190:	7c12      	ldrb	r2, [r2, #16]
   8d192:	fa23 f202 	lsr.w	r2, r3, r2
   8d196:	68fb      	ldr	r3, [r7, #12]
   8d198:	60da      	str	r2, [r3, #12]

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
   8d19a:	68fb      	ldr	r3, [r7, #12]
   8d19c:	68db      	ldr	r3, [r3, #12]
   8d19e:	f640 72f4 	movw	r2, #4084	; 0xff4
   8d1a2:	4293      	cmp	r3, r2
   8d1a4:	d804      	bhi.n	8d1b0 <_ZN8SdVolume4initEP7Sd2Cardh+0x1d4>
    fatType_ = 12;
   8d1a6:	68fb      	ldr	r3, [r7, #12]
   8d1a8:	220c      	movs	r2, #12
   8d1aa:	f883 2020 	strb.w	r2, [r3, #32]
   8d1ae:	e013      	b.n	8d1d8 <_ZN8SdVolume4initEP7Sd2Cardh+0x1fc>
  } else if (clusterCount_ < 65525) {
   8d1b0:	68fb      	ldr	r3, [r7, #12]
   8d1b2:	68db      	ldr	r3, [r3, #12]
   8d1b4:	f64f 72f4 	movw	r2, #65524	; 0xfff4
   8d1b8:	4293      	cmp	r3, r2
   8d1ba:	d804      	bhi.n	8d1c6 <_ZN8SdVolume4initEP7Sd2Cardh+0x1ea>
    fatType_ = 16;
   8d1bc:	68fb      	ldr	r3, [r7, #12]
   8d1be:	2210      	movs	r2, #16
   8d1c0:	f883 2020 	strb.w	r2, [r3, #32]
   8d1c4:	e008      	b.n	8d1d8 <_ZN8SdVolume4initEP7Sd2Cardh+0x1fc>
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
   8d1c6:	697b      	ldr	r3, [r7, #20]
   8d1c8:	f8d3 2021 	ldr.w	r2, [r3, #33]	; 0x21
   8d1cc:	68fb      	ldr	r3, [r7, #12]
   8d1ce:	625a      	str	r2, [r3, #36]	; 0x24
    fatType_ = 32;
   8d1d0:	68fb      	ldr	r3, [r7, #12]
   8d1d2:	2220      	movs	r2, #32
   8d1d4:	f883 2020 	strb.w	r2, [r3, #32]
  }
  return true;
   8d1d8:	2301      	movs	r3, #1
}
   8d1da:	4618      	mov	r0, r3
   8d1dc:	3720      	adds	r7, #32
   8d1de:	46bd      	mov	sp, r7
   8d1e0:	bd80      	pop	{r7, pc}
   8d1e2:	bf00      	nop
   8d1e4:	20071b1c 	.word	0x20071b1c
   8d1e8:	0008cc85 	.word	0x0008cc85
   8d1ec:	2007191c 	.word	0x2007191c
   8d1f0:	20071927 	.word	0x20071927

0008d1f4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
   8d1f4:	b580      	push	{r7, lr}
   8d1f6:	b084      	sub	sp, #16
   8d1f8:	af00      	add	r7, sp, #0
   8d1fa:	6078      	str	r0, [r7, #4]
   8d1fc:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   8d1fe:	687b      	ldr	r3, [r7, #4]
   8d200:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
   8d202:	68fb      	ldr	r3, [r7, #12]
   8d204:	2b00      	cmp	r3, #0
   8d206:	d101      	bne.n	8d20c <xQueueGenericReset+0x18>
   8d208:	4b26      	ldr	r3, [pc, #152]	; (8d2a4 <xQueueGenericReset+0xb0>)
   8d20a:	4798      	blx	r3

	taskENTER_CRITICAL();
   8d20c:	4b26      	ldr	r3, [pc, #152]	; (8d2a8 <xQueueGenericReset+0xb4>)
   8d20e:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   8d210:	68fb      	ldr	r3, [r7, #12]
   8d212:	681a      	ldr	r2, [r3, #0]
   8d214:	68fb      	ldr	r3, [r7, #12]
   8d216:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   8d218:	68f9      	ldr	r1, [r7, #12]
   8d21a:	6c09      	ldr	r1, [r1, #64]	; 0x40
   8d21c:	fb01 f303 	mul.w	r3, r1, r3
   8d220:	441a      	add	r2, r3
   8d222:	68fb      	ldr	r3, [r7, #12]
   8d224:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   8d226:	68fb      	ldr	r3, [r7, #12]
   8d228:	2200      	movs	r2, #0
   8d22a:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   8d22c:	68fb      	ldr	r3, [r7, #12]
   8d22e:	681a      	ldr	r2, [r3, #0]
   8d230:	68fb      	ldr	r3, [r7, #12]
   8d232:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   8d234:	68fb      	ldr	r3, [r7, #12]
   8d236:	681a      	ldr	r2, [r3, #0]
   8d238:	68fb      	ldr	r3, [r7, #12]
   8d23a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   8d23c:	3b01      	subs	r3, #1
   8d23e:	68f9      	ldr	r1, [r7, #12]
   8d240:	6c09      	ldr	r1, [r1, #64]	; 0x40
   8d242:	fb01 f303 	mul.w	r3, r1, r3
   8d246:	441a      	add	r2, r3
   8d248:	68fb      	ldr	r3, [r7, #12]
   8d24a:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
   8d24c:	68fb      	ldr	r3, [r7, #12]
   8d24e:	f04f 32ff 	mov.w	r2, #4294967295
   8d252:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
   8d254:	68fb      	ldr	r3, [r7, #12]
   8d256:	f04f 32ff 	mov.w	r2, #4294967295
   8d25a:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
   8d25c:	683b      	ldr	r3, [r7, #0]
   8d25e:	2b00      	cmp	r3, #0
   8d260:	d10e      	bne.n	8d280 <xQueueGenericReset+0x8c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   8d262:	68fb      	ldr	r3, [r7, #12]
   8d264:	691b      	ldr	r3, [r3, #16]
   8d266:	2b00      	cmp	r3, #0
   8d268:	d014      	beq.n	8d294 <xQueueGenericReset+0xa0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   8d26a:	68fb      	ldr	r3, [r7, #12]
   8d26c:	3310      	adds	r3, #16
   8d26e:	4618      	mov	r0, r3
   8d270:	4b0e      	ldr	r3, [pc, #56]	; (8d2ac <xQueueGenericReset+0xb8>)
   8d272:	4798      	blx	r3
   8d274:	4603      	mov	r3, r0
   8d276:	2b01      	cmp	r3, #1
   8d278:	d10c      	bne.n	8d294 <xQueueGenericReset+0xa0>
				{
					queueYIELD_IF_USING_PREEMPTION();
   8d27a:	4b0d      	ldr	r3, [pc, #52]	; (8d2b0 <xQueueGenericReset+0xbc>)
   8d27c:	4798      	blx	r3
   8d27e:	e009      	b.n	8d294 <xQueueGenericReset+0xa0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   8d280:	68fb      	ldr	r3, [r7, #12]
   8d282:	3310      	adds	r3, #16
   8d284:	4618      	mov	r0, r3
   8d286:	4b0b      	ldr	r3, [pc, #44]	; (8d2b4 <xQueueGenericReset+0xc0>)
   8d288:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   8d28a:	68fb      	ldr	r3, [r7, #12]
   8d28c:	3324      	adds	r3, #36	; 0x24
   8d28e:	4618      	mov	r0, r3
   8d290:	4b08      	ldr	r3, [pc, #32]	; (8d2b4 <xQueueGenericReset+0xc0>)
   8d292:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
   8d294:	4b08      	ldr	r3, [pc, #32]	; (8d2b8 <xQueueGenericReset+0xc4>)
   8d296:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
   8d298:	2301      	movs	r3, #1
}
   8d29a:	4618      	mov	r0, r3
   8d29c:	3710      	adds	r7, #16
   8d29e:	46bd      	mov	sp, r7
   8d2a0:	bd80      	pop	{r7, pc}
   8d2a2:	bf00      	nop
   8d2a4:	00082eed 	.word	0x00082eed
   8d2a8:	0009088d 	.word	0x0009088d
   8d2ac:	0008e6a9 	.word	0x0008e6a9
   8d2b0:	0009086d 	.word	0x0009086d
   8d2b4:	00090559 	.word	0x00090559
   8d2b8:	000908d1 	.word	0x000908d1

0008d2bc <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
   8d2bc:	b580      	push	{r7, lr}
   8d2be:	b088      	sub	sp, #32
   8d2c0:	af00      	add	r7, sp, #0
   8d2c2:	60f8      	str	r0, [r7, #12]
   8d2c4:	60b9      	str	r1, [r7, #8]
   8d2c6:	4613      	mov	r3, r2
   8d2c8:	71fb      	strb	r3, [r7, #7]
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
   8d2ca:	2300      	movs	r3, #0
   8d2cc:	61bb      	str	r3, [r7, #24]

	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   8d2ce:	68fb      	ldr	r3, [r7, #12]
   8d2d0:	2b00      	cmp	r3, #0
   8d2d2:	d101      	bne.n	8d2d8 <xQueueGenericCreate+0x1c>
   8d2d4:	4b1f      	ldr	r3, [pc, #124]	; (8d354 <xQueueGenericCreate+0x98>)
   8d2d6:	4798      	blx	r3

	if( uxItemSize == ( UBaseType_t ) 0 )
   8d2d8:	68bb      	ldr	r3, [r7, #8]
   8d2da:	2b00      	cmp	r3, #0
   8d2dc:	d102      	bne.n	8d2e4 <xQueueGenericCreate+0x28>
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
   8d2de:	2300      	movs	r3, #0
   8d2e0:	61fb      	str	r3, [r7, #28]
   8d2e2:	e005      	b.n	8d2f0 <xQueueGenericCreate+0x34>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   8d2e4:	68fb      	ldr	r3, [r7, #12]
   8d2e6:	68ba      	ldr	r2, [r7, #8]
   8d2e8:	fb02 f303 	mul.w	r3, r2, r3
   8d2ec:	3301      	adds	r3, #1
   8d2ee:	61fb      	str	r3, [r7, #28]
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
   8d2f0:	69fb      	ldr	r3, [r7, #28]
   8d2f2:	3358      	adds	r3, #88	; 0x58
   8d2f4:	4618      	mov	r0, r3
   8d2f6:	4b18      	ldr	r3, [pc, #96]	; (8d358 <xQueueGenericCreate+0x9c>)
   8d2f8:	4798      	blx	r3
   8d2fa:	6178      	str	r0, [r7, #20]

	if( pxNewQueue != NULL )
   8d2fc:	697b      	ldr	r3, [r7, #20]
   8d2fe:	2b00      	cmp	r3, #0
   8d300:	d01e      	beq.n	8d340 <xQueueGenericCreate+0x84>
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
   8d302:	68bb      	ldr	r3, [r7, #8]
   8d304:	2b00      	cmp	r3, #0
   8d306:	d103      	bne.n	8d310 <xQueueGenericCreate+0x54>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   8d308:	697b      	ldr	r3, [r7, #20]
   8d30a:	697a      	ldr	r2, [r7, #20]
   8d30c:	601a      	str	r2, [r3, #0]
   8d30e:	e004      	b.n	8d31a <xQueueGenericCreate+0x5e>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
   8d310:	697b      	ldr	r3, [r7, #20]
   8d312:	f103 0258 	add.w	r2, r3, #88	; 0x58
   8d316:	697b      	ldr	r3, [r7, #20]
   8d318:	601a      	str	r2, [r3, #0]
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
   8d31a:	697b      	ldr	r3, [r7, #20]
   8d31c:	68fa      	ldr	r2, [r7, #12]
   8d31e:	63da      	str	r2, [r3, #60]	; 0x3c
		pxNewQueue->uxItemSize = uxItemSize;
   8d320:	697b      	ldr	r3, [r7, #20]
   8d322:	68ba      	ldr	r2, [r7, #8]
   8d324:	641a      	str	r2, [r3, #64]	; 0x40
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   8d326:	2101      	movs	r1, #1
   8d328:	6978      	ldr	r0, [r7, #20]
   8d32a:	4b0c      	ldr	r3, [pc, #48]	; (8d35c <xQueueGenericCreate+0xa0>)
   8d32c:	4798      	blx	r3

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			pxNewQueue->ucQueueType = ucQueueType;
   8d32e:	697b      	ldr	r3, [r7, #20]
   8d330:	79fa      	ldrb	r2, [r7, #7]
   8d332:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
		}
		#endif /* configUSE_TRACE_FACILITY */

		#if( configUSE_QUEUE_SETS == 1 )
		{
			pxNewQueue->pxQueueSetContainer = NULL;
   8d336:	697b      	ldr	r3, [r7, #20]
   8d338:	2200      	movs	r2, #0
   8d33a:	655a      	str	r2, [r3, #84]	; 0x54
		}
		#endif /* configUSE_QUEUE_SETS */

		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
   8d33c:	697b      	ldr	r3, [r7, #20]
   8d33e:	61bb      	str	r3, [r7, #24]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
   8d340:	69bb      	ldr	r3, [r7, #24]
   8d342:	2b00      	cmp	r3, #0
   8d344:	d101      	bne.n	8d34a <xQueueGenericCreate+0x8e>
   8d346:	4b03      	ldr	r3, [pc, #12]	; (8d354 <xQueueGenericCreate+0x98>)
   8d348:	4798      	blx	r3

	return xReturn;
   8d34a:	69bb      	ldr	r3, [r7, #24]
}
   8d34c:	4618      	mov	r0, r3
   8d34e:	3720      	adds	r7, #32
   8d350:	46bd      	mov	sp, r7
   8d352:	bd80      	pop	{r7, pc}
   8d354:	00082eed 	.word	0x00082eed
   8d358:	000904e9 	.word	0x000904e9
   8d35c:	0008d1f5 	.word	0x0008d1f5

0008d360 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
   8d360:	b590      	push	{r4, r7, lr}
   8d362:	b085      	sub	sp, #20
   8d364:	af00      	add	r7, sp, #0
   8d366:	4603      	mov	r3, r0
   8d368:	71fb      	strb	r3, [r7, #7]
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
   8d36a:	2058      	movs	r0, #88	; 0x58
   8d36c:	4b1f      	ldr	r3, [pc, #124]	; (8d3ec <xQueueCreateMutex+0x8c>)
   8d36e:	4798      	blx	r3
   8d370:	60f8      	str	r0, [r7, #12]
		if( pxNewQueue != NULL )
   8d372:	68fb      	ldr	r3, [r7, #12]
   8d374:	2b00      	cmp	r3, #0
   8d376:	d033      	beq.n	8d3e0 <xQueueCreateMutex+0x80>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
   8d378:	68fb      	ldr	r3, [r7, #12]
   8d37a:	2200      	movs	r2, #0
   8d37c:	605a      	str	r2, [r3, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   8d37e:	68fb      	ldr	r3, [r7, #12]
   8d380:	2200      	movs	r2, #0
   8d382:	601a      	str	r2, [r3, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
   8d384:	68fb      	ldr	r3, [r7, #12]
   8d386:	2200      	movs	r2, #0
   8d388:	609a      	str	r2, [r3, #8]
			pxNewQueue->u.pcReadFrom = NULL;
   8d38a:	68fb      	ldr	r3, [r7, #12]
   8d38c:	2200      	movs	r2, #0
   8d38e:	60da      	str	r2, [r3, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   8d390:	68fb      	ldr	r3, [r7, #12]
   8d392:	2200      	movs	r2, #0
   8d394:	639a      	str	r2, [r3, #56]	; 0x38
			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
   8d396:	68fb      	ldr	r3, [r7, #12]
   8d398:	2201      	movs	r2, #1
   8d39a:	63da      	str	r2, [r3, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
   8d39c:	68fb      	ldr	r3, [r7, #12]
   8d39e:	2200      	movs	r2, #0
   8d3a0:	641a      	str	r2, [r3, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
   8d3a2:	68fb      	ldr	r3, [r7, #12]
   8d3a4:	f04f 32ff 	mov.w	r2, #4294967295
   8d3a8:	645a      	str	r2, [r3, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
   8d3aa:	68fb      	ldr	r3, [r7, #12]
   8d3ac:	f04f 32ff 	mov.w	r2, #4294967295
   8d3b0:	649a      	str	r2, [r3, #72]	; 0x48

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				pxNewQueue->ucQueueType = ucQueueType;
   8d3b2:	68fb      	ldr	r3, [r7, #12]
   8d3b4:	79fa      	ldrb	r2, [r7, #7]
   8d3b6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
			}
			#endif

			#if ( configUSE_QUEUE_SETS == 1 )
			{
				pxNewQueue->pxQueueSetContainer = NULL;
   8d3ba:	68fb      	ldr	r3, [r7, #12]
   8d3bc:	2200      	movs	r2, #0
   8d3be:	655a      	str	r2, [r3, #84]	; 0x54
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
   8d3c0:	68fb      	ldr	r3, [r7, #12]
   8d3c2:	3310      	adds	r3, #16
   8d3c4:	4618      	mov	r0, r3
   8d3c6:	4b0a      	ldr	r3, [pc, #40]	; (8d3f0 <xQueueCreateMutex+0x90>)
   8d3c8:	4798      	blx	r3
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
   8d3ca:	68fb      	ldr	r3, [r7, #12]
   8d3cc:	3324      	adds	r3, #36	; 0x24
   8d3ce:	4618      	mov	r0, r3
   8d3d0:	4b07      	ldr	r3, [pc, #28]	; (8d3f0 <xQueueCreateMutex+0x90>)
   8d3d2:	4798      	blx	r3

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
   8d3d4:	2300      	movs	r3, #0
   8d3d6:	2200      	movs	r2, #0
   8d3d8:	2100      	movs	r1, #0
   8d3da:	68f8      	ldr	r0, [r7, #12]
   8d3dc:	4c05      	ldr	r4, [pc, #20]	; (8d3f4 <xQueueCreateMutex+0x94>)
   8d3de:	47a0      	blx	r4
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		return pxNewQueue;
   8d3e0:	68fb      	ldr	r3, [r7, #12]
	}
   8d3e2:	4618      	mov	r0, r3
   8d3e4:	3714      	adds	r7, #20
   8d3e6:	46bd      	mov	sp, r7
   8d3e8:	bd90      	pop	{r4, r7, pc}
   8d3ea:	bf00      	nop
   8d3ec:	000904e9 	.word	0x000904e9
   8d3f0:	00090559 	.word	0x00090559
   8d3f4:	0008d44d 	.word	0x0008d44d

0008d3f8 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if ( configUSE_COUNTING_SEMAPHORES == 1 )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
   8d3f8:	b580      	push	{r7, lr}
   8d3fa:	b084      	sub	sp, #16
   8d3fc:	af00      	add	r7, sp, #0
   8d3fe:	6078      	str	r0, [r7, #4]
   8d400:	6039      	str	r1, [r7, #0]
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
   8d402:	687b      	ldr	r3, [r7, #4]
   8d404:	2b00      	cmp	r3, #0
   8d406:	d101      	bne.n	8d40c <xQueueCreateCountingSemaphore+0x14>
   8d408:	4b0e      	ldr	r3, [pc, #56]	; (8d444 <xQueueCreateCountingSemaphore+0x4c>)
   8d40a:	4798      	blx	r3
		configASSERT( uxInitialCount <= uxMaxCount );
   8d40c:	683a      	ldr	r2, [r7, #0]
   8d40e:	687b      	ldr	r3, [r7, #4]
   8d410:	429a      	cmp	r2, r3
   8d412:	d901      	bls.n	8d418 <xQueueCreateCountingSemaphore+0x20>
   8d414:	4b0b      	ldr	r3, [pc, #44]	; (8d444 <xQueueCreateCountingSemaphore+0x4c>)
   8d416:	4798      	blx	r3

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   8d418:	2202      	movs	r2, #2
   8d41a:	2100      	movs	r1, #0
   8d41c:	6878      	ldr	r0, [r7, #4]
   8d41e:	4b0a      	ldr	r3, [pc, #40]	; (8d448 <xQueueCreateCountingSemaphore+0x50>)
   8d420:	4798      	blx	r3
   8d422:	60f8      	str	r0, [r7, #12]

		if( xHandle != NULL )
   8d424:	68fb      	ldr	r3, [r7, #12]
   8d426:	2b00      	cmp	r3, #0
   8d428:	d002      	beq.n	8d430 <xQueueCreateCountingSemaphore+0x38>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   8d42a:	68fb      	ldr	r3, [r7, #12]
   8d42c:	683a      	ldr	r2, [r7, #0]
   8d42e:	639a      	str	r2, [r3, #56]	; 0x38
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( xHandle );
   8d430:	68fb      	ldr	r3, [r7, #12]
   8d432:	2b00      	cmp	r3, #0
   8d434:	d101      	bne.n	8d43a <xQueueCreateCountingSemaphore+0x42>
   8d436:	4b03      	ldr	r3, [pc, #12]	; (8d444 <xQueueCreateCountingSemaphore+0x4c>)
   8d438:	4798      	blx	r3
		return xHandle;
   8d43a:	68fb      	ldr	r3, [r7, #12]
	}
   8d43c:	4618      	mov	r0, r3
   8d43e:	3710      	adds	r7, #16
   8d440:	46bd      	mov	sp, r7
   8d442:	bd80      	pop	{r7, pc}
   8d444:	00082eed 	.word	0x00082eed
   8d448:	0008d2bd 	.word	0x0008d2bd

0008d44c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
   8d44c:	b580      	push	{r7, lr}
   8d44e:	b08a      	sub	sp, #40	; 0x28
   8d450:	af00      	add	r7, sp, #0
   8d452:	60f8      	str	r0, [r7, #12]
   8d454:	60b9      	str	r1, [r7, #8]
   8d456:	607a      	str	r2, [r7, #4]
   8d458:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   8d45a:	2300      	movs	r3, #0
   8d45c:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   8d45e:	68fb      	ldr	r3, [r7, #12]
   8d460:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
   8d462:	6a3b      	ldr	r3, [r7, #32]
   8d464:	2b00      	cmp	r3, #0
   8d466:	d101      	bne.n	8d46c <xQueueGenericSend+0x20>
   8d468:	4b5f      	ldr	r3, [pc, #380]	; (8d5e8 <xQueueGenericSend+0x19c>)
   8d46a:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   8d46c:	68bb      	ldr	r3, [r7, #8]
   8d46e:	2b00      	cmp	r3, #0
   8d470:	d103      	bne.n	8d47a <xQueueGenericSend+0x2e>
   8d472:	6a3b      	ldr	r3, [r7, #32]
   8d474:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8d476:	2b00      	cmp	r3, #0
   8d478:	d101      	bne.n	8d47e <xQueueGenericSend+0x32>
   8d47a:	2301      	movs	r3, #1
   8d47c:	e000      	b.n	8d480 <xQueueGenericSend+0x34>
   8d47e:	2300      	movs	r3, #0
   8d480:	2b00      	cmp	r3, #0
   8d482:	d101      	bne.n	8d488 <xQueueGenericSend+0x3c>
   8d484:	4b58      	ldr	r3, [pc, #352]	; (8d5e8 <xQueueGenericSend+0x19c>)
   8d486:	4798      	blx	r3
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   8d488:	683b      	ldr	r3, [r7, #0]
   8d48a:	2b02      	cmp	r3, #2
   8d48c:	d103      	bne.n	8d496 <xQueueGenericSend+0x4a>
   8d48e:	6a3b      	ldr	r3, [r7, #32]
   8d490:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   8d492:	2b01      	cmp	r3, #1
   8d494:	d101      	bne.n	8d49a <xQueueGenericSend+0x4e>
   8d496:	2301      	movs	r3, #1
   8d498:	e000      	b.n	8d49c <xQueueGenericSend+0x50>
   8d49a:	2300      	movs	r3, #0
   8d49c:	2b00      	cmp	r3, #0
   8d49e:	d101      	bne.n	8d4a4 <xQueueGenericSend+0x58>
   8d4a0:	4b51      	ldr	r3, [pc, #324]	; (8d5e8 <xQueueGenericSend+0x19c>)
   8d4a2:	4798      	blx	r3
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   8d4a4:	4b51      	ldr	r3, [pc, #324]	; (8d5ec <xQueueGenericSend+0x1a0>)
   8d4a6:	4798      	blx	r3
   8d4a8:	4603      	mov	r3, r0
   8d4aa:	2b00      	cmp	r3, #0
   8d4ac:	d102      	bne.n	8d4b4 <xQueueGenericSend+0x68>
   8d4ae:	687b      	ldr	r3, [r7, #4]
   8d4b0:	2b00      	cmp	r3, #0
   8d4b2:	d101      	bne.n	8d4b8 <xQueueGenericSend+0x6c>
   8d4b4:	2301      	movs	r3, #1
   8d4b6:	e000      	b.n	8d4ba <xQueueGenericSend+0x6e>
   8d4b8:	2300      	movs	r3, #0
   8d4ba:	2b00      	cmp	r3, #0
   8d4bc:	d101      	bne.n	8d4c2 <xQueueGenericSend+0x76>
   8d4be:	4b4a      	ldr	r3, [pc, #296]	; (8d5e8 <xQueueGenericSend+0x19c>)
   8d4c0:	4798      	blx	r3
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   8d4c2:	4b4b      	ldr	r3, [pc, #300]	; (8d5f0 <xQueueGenericSend+0x1a4>)
   8d4c4:	4798      	blx	r3
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   8d4c6:	6a3b      	ldr	r3, [r7, #32]
   8d4c8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   8d4ca:	6a3b      	ldr	r3, [r7, #32]
   8d4cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   8d4ce:	429a      	cmp	r2, r3
   8d4d0:	d302      	bcc.n	8d4d8 <xQueueGenericSend+0x8c>
   8d4d2:	683b      	ldr	r3, [r7, #0]
   8d4d4:	2b02      	cmp	r3, #2
   8d4d6:	d12b      	bne.n	8d530 <xQueueGenericSend+0xe4>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   8d4d8:	683a      	ldr	r2, [r7, #0]
   8d4da:	68b9      	ldr	r1, [r7, #8]
   8d4dc:	6a38      	ldr	r0, [r7, #32]
   8d4de:	4b45      	ldr	r3, [pc, #276]	; (8d5f4 <xQueueGenericSend+0x1a8>)
   8d4e0:	4798      	blx	r3
   8d4e2:	61f8      	str	r0, [r7, #28]

				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
   8d4e4:	6a3b      	ldr	r3, [r7, #32]
   8d4e6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   8d4e8:	2b00      	cmp	r3, #0
   8d4ea:	d009      	beq.n	8d500 <xQueueGenericSend+0xb4>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
   8d4ec:	6839      	ldr	r1, [r7, #0]
   8d4ee:	6a38      	ldr	r0, [r7, #32]
   8d4f0:	4b41      	ldr	r3, [pc, #260]	; (8d5f8 <xQueueGenericSend+0x1ac>)
   8d4f2:	4798      	blx	r3
   8d4f4:	4603      	mov	r3, r0
   8d4f6:	2b01      	cmp	r3, #1
   8d4f8:	d116      	bne.n	8d528 <xQueueGenericSend+0xdc>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock. A context switch is required. */
							queueYIELD_IF_USING_PREEMPTION();
   8d4fa:	4b40      	ldr	r3, [pc, #256]	; (8d5fc <xQueueGenericSend+0x1b0>)
   8d4fc:	4798      	blx	r3
   8d4fe:	e013      	b.n	8d528 <xQueueGenericSend+0xdc>
					}
					else
					{
						/* If there was a task waiting for data to arrive on the
						queue then unblock it now. */
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   8d500:	6a3b      	ldr	r3, [r7, #32]
   8d502:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8d504:	2b00      	cmp	r3, #0
   8d506:	d00a      	beq.n	8d51e <xQueueGenericSend+0xd2>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
   8d508:	6a3b      	ldr	r3, [r7, #32]
   8d50a:	3324      	adds	r3, #36	; 0x24
   8d50c:	4618      	mov	r0, r3
   8d50e:	4b3c      	ldr	r3, [pc, #240]	; (8d600 <xQueueGenericSend+0x1b4>)
   8d510:	4798      	blx	r3
   8d512:	4603      	mov	r3, r0
   8d514:	2b01      	cmp	r3, #1
   8d516:	d107      	bne.n	8d528 <xQueueGenericSend+0xdc>
							{
								/* The unblocked task has a priority higher than
								our own so yield immediately.  Yes it is ok to
								do this from within the critical section - the
								kernel takes care of that. */
								queueYIELD_IF_USING_PREEMPTION();
   8d518:	4b38      	ldr	r3, [pc, #224]	; (8d5fc <xQueueGenericSend+0x1b0>)
   8d51a:	4798      	blx	r3
   8d51c:	e004      	b.n	8d528 <xQueueGenericSend+0xdc>
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
						}
						else if( xYieldRequired != pdFALSE )
   8d51e:	69fb      	ldr	r3, [r7, #28]
   8d520:	2b00      	cmp	r3, #0
   8d522:	d001      	beq.n	8d528 <xQueueGenericSend+0xdc>
						{
							/* This path is a special case that will only get
							executed if the task was holding multiple mutexes
							and the mutexes were given back in an order that is
							different to that in which they were taken. */
							queueYIELD_IF_USING_PREEMPTION();
   8d524:	4b35      	ldr	r3, [pc, #212]	; (8d5fc <xQueueGenericSend+0x1b0>)
   8d526:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
   8d528:	4b36      	ldr	r3, [pc, #216]	; (8d604 <xQueueGenericSend+0x1b8>)
   8d52a:	4798      	blx	r3
				return pdPASS;
   8d52c:	2301      	movs	r3, #1
   8d52e:	e056      	b.n	8d5de <xQueueGenericSend+0x192>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   8d530:	687b      	ldr	r3, [r7, #4]
   8d532:	2b00      	cmp	r3, #0
   8d534:	d103      	bne.n	8d53e <xQueueGenericSend+0xf2>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   8d536:	4b33      	ldr	r3, [pc, #204]	; (8d604 <xQueueGenericSend+0x1b8>)
   8d538:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
   8d53a:	2300      	movs	r3, #0
   8d53c:	e04f      	b.n	8d5de <xQueueGenericSend+0x192>
				}
				else if( xEntryTimeSet == pdFALSE )
   8d53e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8d540:	2b00      	cmp	r3, #0
   8d542:	d106      	bne.n	8d552 <xQueueGenericSend+0x106>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   8d544:	f107 0314 	add.w	r3, r7, #20
   8d548:	4618      	mov	r0, r3
   8d54a:	4b2f      	ldr	r3, [pc, #188]	; (8d608 <xQueueGenericSend+0x1bc>)
   8d54c:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
   8d54e:	2301      	movs	r3, #1
   8d550:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   8d552:	4b2c      	ldr	r3, [pc, #176]	; (8d604 <xQueueGenericSend+0x1b8>)
   8d554:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   8d556:	4b2d      	ldr	r3, [pc, #180]	; (8d60c <xQueueGenericSend+0x1c0>)
   8d558:	4798      	blx	r3
		prvLockQueue( pxQueue );
   8d55a:	4b25      	ldr	r3, [pc, #148]	; (8d5f0 <xQueueGenericSend+0x1a4>)
   8d55c:	4798      	blx	r3
   8d55e:	6a3b      	ldr	r3, [r7, #32]
   8d560:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   8d562:	f1b3 3fff 	cmp.w	r3, #4294967295
   8d566:	d102      	bne.n	8d56e <xQueueGenericSend+0x122>
   8d568:	6a3b      	ldr	r3, [r7, #32]
   8d56a:	2200      	movs	r2, #0
   8d56c:	645a      	str	r2, [r3, #68]	; 0x44
   8d56e:	6a3b      	ldr	r3, [r7, #32]
   8d570:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   8d572:	f1b3 3fff 	cmp.w	r3, #4294967295
   8d576:	d102      	bne.n	8d57e <xQueueGenericSend+0x132>
   8d578:	6a3b      	ldr	r3, [r7, #32]
   8d57a:	2200      	movs	r2, #0
   8d57c:	649a      	str	r2, [r3, #72]	; 0x48
   8d57e:	4b21      	ldr	r3, [pc, #132]	; (8d604 <xQueueGenericSend+0x1b8>)
   8d580:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   8d582:	1d3a      	adds	r2, r7, #4
   8d584:	f107 0314 	add.w	r3, r7, #20
   8d588:	4611      	mov	r1, r2
   8d58a:	4618      	mov	r0, r3
   8d58c:	4b20      	ldr	r3, [pc, #128]	; (8d610 <xQueueGenericSend+0x1c4>)
   8d58e:	4798      	blx	r3
   8d590:	4603      	mov	r3, r0
   8d592:	2b00      	cmp	r3, #0
   8d594:	d11d      	bne.n	8d5d2 <xQueueGenericSend+0x186>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   8d596:	6a38      	ldr	r0, [r7, #32]
   8d598:	4b1e      	ldr	r3, [pc, #120]	; (8d614 <xQueueGenericSend+0x1c8>)
   8d59a:	4798      	blx	r3
   8d59c:	4603      	mov	r3, r0
   8d59e:	2b00      	cmp	r3, #0
   8d5a0:	d011      	beq.n	8d5c6 <xQueueGenericSend+0x17a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   8d5a2:	6a3b      	ldr	r3, [r7, #32]
   8d5a4:	3310      	adds	r3, #16
   8d5a6:	687a      	ldr	r2, [r7, #4]
   8d5a8:	4611      	mov	r1, r2
   8d5aa:	4618      	mov	r0, r3
   8d5ac:	4b1a      	ldr	r3, [pc, #104]	; (8d618 <xQueueGenericSend+0x1cc>)
   8d5ae:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
   8d5b0:	6a38      	ldr	r0, [r7, #32]
   8d5b2:	4b1a      	ldr	r3, [pc, #104]	; (8d61c <xQueueGenericSend+0x1d0>)
   8d5b4:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
   8d5b6:	4b1a      	ldr	r3, [pc, #104]	; (8d620 <xQueueGenericSend+0x1d4>)
   8d5b8:	4798      	blx	r3
   8d5ba:	4603      	mov	r3, r0
   8d5bc:	2b00      	cmp	r3, #0
   8d5be:	d180      	bne.n	8d4c2 <xQueueGenericSend+0x76>
				{
					portYIELD_WITHIN_API();
   8d5c0:	4b0e      	ldr	r3, [pc, #56]	; (8d5fc <xQueueGenericSend+0x1b0>)
   8d5c2:	4798      	blx	r3
   8d5c4:	e77d      	b.n	8d4c2 <xQueueGenericSend+0x76>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   8d5c6:	6a38      	ldr	r0, [r7, #32]
   8d5c8:	4b14      	ldr	r3, [pc, #80]	; (8d61c <xQueueGenericSend+0x1d0>)
   8d5ca:	4798      	blx	r3
				( void ) xTaskResumeAll();
   8d5cc:	4b14      	ldr	r3, [pc, #80]	; (8d620 <xQueueGenericSend+0x1d4>)
   8d5ce:	4798      	blx	r3
   8d5d0:	e777      	b.n	8d4c2 <xQueueGenericSend+0x76>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
   8d5d2:	6a38      	ldr	r0, [r7, #32]
   8d5d4:	4b11      	ldr	r3, [pc, #68]	; (8d61c <xQueueGenericSend+0x1d0>)
   8d5d6:	4798      	blx	r3
			( void ) xTaskResumeAll();
   8d5d8:	4b11      	ldr	r3, [pc, #68]	; (8d620 <xQueueGenericSend+0x1d4>)
   8d5da:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
   8d5dc:	2300      	movs	r3, #0
		}
	}
}
   8d5de:	4618      	mov	r0, r3
   8d5e0:	3728      	adds	r7, #40	; 0x28
   8d5e2:	46bd      	mov	sp, r7
   8d5e4:	bd80      	pop	{r7, pc}
   8d5e6:	bf00      	nop
   8d5e8:	00082eed 	.word	0x00082eed
   8d5ec:	0008ed19 	.word	0x0008ed19
   8d5f0:	0009088d 	.word	0x0009088d
   8d5f4:	0008d925 	.word	0x0008d925
   8d5f8:	0008dbf5 	.word	0x0008dbf5
   8d5fc:	0009086d 	.word	0x0009086d
   8d600:	0008e6a9 	.word	0x0008e6a9
   8d604:	000908d1 	.word	0x000908d1
   8d608:	0008e769 	.word	0x0008e769
   8d60c:	0008e031 	.word	0x0008e031
   8d610:	0008e7a1 	.word	0x0008e7a1
   8d614:	0008db51 	.word	0x0008db51
   8d618:	0008e56d 	.word	0x0008e56d
   8d61c:	0008da55 	.word	0x0008da55
   8d620:	0008e04d 	.word	0x0008e04d

0008d624 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
   8d624:	b580      	push	{r7, lr}
   8d626:	b088      	sub	sp, #32
   8d628:	af00      	add	r7, sp, #0
   8d62a:	60f8      	str	r0, [r7, #12]
   8d62c:	60b9      	str	r1, [r7, #8]
   8d62e:	607a      	str	r2, [r7, #4]
   8d630:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   8d632:	68fb      	ldr	r3, [r7, #12]
   8d634:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
   8d636:	69bb      	ldr	r3, [r7, #24]
   8d638:	2b00      	cmp	r3, #0
   8d63a:	d101      	bne.n	8d640 <xQueueGenericSendFromISR+0x1c>
   8d63c:	4b36      	ldr	r3, [pc, #216]	; (8d718 <xQueueGenericSendFromISR+0xf4>)
   8d63e:	4798      	blx	r3
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   8d640:	68bb      	ldr	r3, [r7, #8]
   8d642:	2b00      	cmp	r3, #0
   8d644:	d103      	bne.n	8d64e <xQueueGenericSendFromISR+0x2a>
   8d646:	69bb      	ldr	r3, [r7, #24]
   8d648:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8d64a:	2b00      	cmp	r3, #0
   8d64c:	d101      	bne.n	8d652 <xQueueGenericSendFromISR+0x2e>
   8d64e:	2301      	movs	r3, #1
   8d650:	e000      	b.n	8d654 <xQueueGenericSendFromISR+0x30>
   8d652:	2300      	movs	r3, #0
   8d654:	2b00      	cmp	r3, #0
   8d656:	d101      	bne.n	8d65c <xQueueGenericSendFromISR+0x38>
   8d658:	4b2f      	ldr	r3, [pc, #188]	; (8d718 <xQueueGenericSendFromISR+0xf4>)
   8d65a:	4798      	blx	r3
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   8d65c:	683b      	ldr	r3, [r7, #0]
   8d65e:	2b02      	cmp	r3, #2
   8d660:	d103      	bne.n	8d66a <xQueueGenericSendFromISR+0x46>
   8d662:	69bb      	ldr	r3, [r7, #24]
   8d664:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   8d666:	2b01      	cmp	r3, #1
   8d668:	d101      	bne.n	8d66e <xQueueGenericSendFromISR+0x4a>
   8d66a:	2301      	movs	r3, #1
   8d66c:	e000      	b.n	8d670 <xQueueGenericSendFromISR+0x4c>
   8d66e:	2300      	movs	r3, #0
   8d670:	2b00      	cmp	r3, #0
   8d672:	d101      	bne.n	8d678 <xQueueGenericSendFromISR+0x54>
   8d674:	4b28      	ldr	r3, [pc, #160]	; (8d718 <xQueueGenericSendFromISR+0xf4>)
   8d676:	4798      	blx	r3
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   8d678:	4b28      	ldr	r3, [pc, #160]	; (8d71c <xQueueGenericSendFromISR+0xf8>)
   8d67a:	4798      	blx	r3
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   8d67c:	4b28      	ldr	r3, [pc, #160]	; (8d720 <xQueueGenericSendFromISR+0xfc>)
   8d67e:	4798      	blx	r3
   8d680:	6178      	str	r0, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   8d682:	69bb      	ldr	r3, [r7, #24]
   8d684:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   8d686:	69bb      	ldr	r3, [r7, #24]
   8d688:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   8d68a:	429a      	cmp	r2, r3
   8d68c:	d302      	bcc.n	8d694 <xQueueGenericSendFromISR+0x70>
   8d68e:	683b      	ldr	r3, [r7, #0]
   8d690:	2b02      	cmp	r3, #2
   8d692:	d136      	bne.n	8d702 <xQueueGenericSendFromISR+0xde>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   8d694:	683a      	ldr	r2, [r7, #0]
   8d696:	68b9      	ldr	r1, [r7, #8]
   8d698:	69b8      	ldr	r0, [r7, #24]
   8d69a:	4b22      	ldr	r3, [pc, #136]	; (8d724 <xQueueGenericSendFromISR+0x100>)
   8d69c:	4798      	blx	r3

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
   8d69e:	69bb      	ldr	r3, [r7, #24]
   8d6a0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   8d6a2:	f1b3 3fff 	cmp.w	r3, #4294967295
   8d6a6:	d124      	bne.n	8d6f2 <xQueueGenericSendFromISR+0xce>
			{
				#if ( configUSE_QUEUE_SETS == 1 )
				{
					if( pxQueue->pxQueueSetContainer != NULL )
   8d6a8:	69bb      	ldr	r3, [r7, #24]
   8d6aa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   8d6ac:	2b00      	cmp	r3, #0
   8d6ae:	d00d      	beq.n	8d6cc <xQueueGenericSendFromISR+0xa8>
					{
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
   8d6b0:	6839      	ldr	r1, [r7, #0]
   8d6b2:	69b8      	ldr	r0, [r7, #24]
   8d6b4:	4b1c      	ldr	r3, [pc, #112]	; (8d728 <xQueueGenericSendFromISR+0x104>)
   8d6b6:	4798      	blx	r3
   8d6b8:	4603      	mov	r3, r0
   8d6ba:	2b01      	cmp	r3, #1
   8d6bc:	d11e      	bne.n	8d6fc <xQueueGenericSendFromISR+0xd8>
						{
							/* The queue is a member of a queue set, and posting
							to the queue set caused a higher priority task to
							unblock.  A context switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   8d6be:	687b      	ldr	r3, [r7, #4]
   8d6c0:	2b00      	cmp	r3, #0
   8d6c2:	d01b      	beq.n	8d6fc <xQueueGenericSendFromISR+0xd8>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   8d6c4:	687b      	ldr	r3, [r7, #4]
   8d6c6:	2201      	movs	r2, #1
   8d6c8:	601a      	str	r2, [r3, #0]
   8d6ca:	e017      	b.n	8d6fc <xQueueGenericSendFromISR+0xd8>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   8d6cc:	69bb      	ldr	r3, [r7, #24]
   8d6ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8d6d0:	2b00      	cmp	r3, #0
   8d6d2:	d013      	beq.n	8d6fc <xQueueGenericSendFromISR+0xd8>
						{
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   8d6d4:	69bb      	ldr	r3, [r7, #24]
   8d6d6:	3324      	adds	r3, #36	; 0x24
   8d6d8:	4618      	mov	r0, r3
   8d6da:	4b14      	ldr	r3, [pc, #80]	; (8d72c <xQueueGenericSendFromISR+0x108>)
   8d6dc:	4798      	blx	r3
   8d6de:	4603      	mov	r3, r0
   8d6e0:	2b00      	cmp	r3, #0
   8d6e2:	d00b      	beq.n	8d6fc <xQueueGenericSendFromISR+0xd8>
							{
								/* The task waiting has a higher priority so
								record that a context switch is required. */
								if( pxHigherPriorityTaskWoken != NULL )
   8d6e4:	687b      	ldr	r3, [r7, #4]
   8d6e6:	2b00      	cmp	r3, #0
   8d6e8:	d008      	beq.n	8d6fc <xQueueGenericSendFromISR+0xd8>
								{
									*pxHigherPriorityTaskWoken = pdTRUE;
   8d6ea:	687b      	ldr	r3, [r7, #4]
   8d6ec:	2201      	movs	r2, #1
   8d6ee:	601a      	str	r2, [r3, #0]
   8d6f0:	e004      	b.n	8d6fc <xQueueGenericSendFromISR+0xd8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
   8d6f2:	69bb      	ldr	r3, [r7, #24]
   8d6f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   8d6f6:	1c5a      	adds	r2, r3, #1
   8d6f8:	69bb      	ldr	r3, [r7, #24]
   8d6fa:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
   8d6fc:	2301      	movs	r3, #1
   8d6fe:	61fb      	str	r3, [r7, #28]
   8d700:	e001      	b.n	8d706 <xQueueGenericSendFromISR+0xe2>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   8d702:	2300      	movs	r3, #0
   8d704:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   8d706:	6978      	ldr	r0, [r7, #20]
   8d708:	4b09      	ldr	r3, [pc, #36]	; (8d730 <xQueueGenericSendFromISR+0x10c>)
   8d70a:	4798      	blx	r3

	return xReturn;
   8d70c:	69fb      	ldr	r3, [r7, #28]
}
   8d70e:	4618      	mov	r0, r3
   8d710:	3720      	adds	r7, #32
   8d712:	46bd      	mov	sp, r7
   8d714:	bd80      	pop	{r7, pc}
   8d716:	bf00      	nop
   8d718:	00082eed 	.word	0x00082eed
   8d71c:	000909c1 	.word	0x000909c1
   8d720:	00090909 	.word	0x00090909
   8d724:	0008d925 	.word	0x0008d925
   8d728:	0008dbf5 	.word	0x0008dbf5
   8d72c:	0008e6a9 	.word	0x0008e6a9
   8d730:	0009091d 	.word	0x0009091d

0008d734 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
   8d734:	b580      	push	{r7, lr}
   8d736:	b08a      	sub	sp, #40	; 0x28
   8d738:	af00      	add	r7, sp, #0
   8d73a:	60f8      	str	r0, [r7, #12]
   8d73c:	60b9      	str	r1, [r7, #8]
   8d73e:	607a      	str	r2, [r7, #4]
   8d740:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
   8d742:	2300      	movs	r3, #0
   8d744:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   8d746:	68fb      	ldr	r3, [r7, #12]
   8d748:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
   8d74a:	6a3b      	ldr	r3, [r7, #32]
   8d74c:	2b00      	cmp	r3, #0
   8d74e:	d101      	bne.n	8d754 <xQueueGenericReceive+0x20>
   8d750:	4b64      	ldr	r3, [pc, #400]	; (8d8e4 <xQueueGenericReceive+0x1b0>)
   8d752:	4798      	blx	r3
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   8d754:	68bb      	ldr	r3, [r7, #8]
   8d756:	2b00      	cmp	r3, #0
   8d758:	d103      	bne.n	8d762 <xQueueGenericReceive+0x2e>
   8d75a:	6a3b      	ldr	r3, [r7, #32]
   8d75c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8d75e:	2b00      	cmp	r3, #0
   8d760:	d101      	bne.n	8d766 <xQueueGenericReceive+0x32>
   8d762:	2301      	movs	r3, #1
   8d764:	e000      	b.n	8d768 <xQueueGenericReceive+0x34>
   8d766:	2300      	movs	r3, #0
   8d768:	2b00      	cmp	r3, #0
   8d76a:	d101      	bne.n	8d770 <xQueueGenericReceive+0x3c>
   8d76c:	4b5d      	ldr	r3, [pc, #372]	; (8d8e4 <xQueueGenericReceive+0x1b0>)
   8d76e:	4798      	blx	r3
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   8d770:	4b5d      	ldr	r3, [pc, #372]	; (8d8e8 <xQueueGenericReceive+0x1b4>)
   8d772:	4798      	blx	r3
   8d774:	4603      	mov	r3, r0
   8d776:	2b00      	cmp	r3, #0
   8d778:	d102      	bne.n	8d780 <xQueueGenericReceive+0x4c>
   8d77a:	687b      	ldr	r3, [r7, #4]
   8d77c:	2b00      	cmp	r3, #0
   8d77e:	d101      	bne.n	8d784 <xQueueGenericReceive+0x50>
   8d780:	2301      	movs	r3, #1
   8d782:	e000      	b.n	8d786 <xQueueGenericReceive+0x52>
   8d784:	2300      	movs	r3, #0
   8d786:	2b00      	cmp	r3, #0
   8d788:	d101      	bne.n	8d78e <xQueueGenericReceive+0x5a>
   8d78a:	4b56      	ldr	r3, [pc, #344]	; (8d8e4 <xQueueGenericReceive+0x1b0>)
   8d78c:	4798      	blx	r3
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   8d78e:	4b57      	ldr	r3, [pc, #348]	; (8d8ec <xQueueGenericReceive+0x1b8>)
   8d790:	4798      	blx	r3
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   8d792:	6a3b      	ldr	r3, [r7, #32]
   8d794:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   8d796:	2b00      	cmp	r3, #0
   8d798:	d03b      	beq.n	8d812 <xQueueGenericReceive+0xde>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
   8d79a:	6a3b      	ldr	r3, [r7, #32]
   8d79c:	68db      	ldr	r3, [r3, #12]
   8d79e:	61fb      	str	r3, [r7, #28]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
   8d7a0:	68b9      	ldr	r1, [r7, #8]
   8d7a2:	6a38      	ldr	r0, [r7, #32]
   8d7a4:	4b52      	ldr	r3, [pc, #328]	; (8d8f0 <xQueueGenericReceive+0x1bc>)
   8d7a6:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
   8d7a8:	683b      	ldr	r3, [r7, #0]
   8d7aa:	2b00      	cmp	r3, #0
   8d7ac:	d11c      	bne.n	8d7e8 <xQueueGenericReceive+0xb4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
   8d7ae:	6a3b      	ldr	r3, [r7, #32]
   8d7b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   8d7b2:	1e5a      	subs	r2, r3, #1
   8d7b4:	6a3b      	ldr	r3, [r7, #32]
   8d7b6:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   8d7b8:	6a3b      	ldr	r3, [r7, #32]
   8d7ba:	681b      	ldr	r3, [r3, #0]
   8d7bc:	2b00      	cmp	r3, #0
   8d7be:	d104      	bne.n	8d7ca <xQueueGenericReceive+0x96>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
   8d7c0:	4b4c      	ldr	r3, [pc, #304]	; (8d8f4 <xQueueGenericReceive+0x1c0>)
   8d7c2:	4798      	blx	r3
   8d7c4:	4602      	mov	r2, r0
   8d7c6:	6a3b      	ldr	r3, [r7, #32]
   8d7c8:	605a      	str	r2, [r3, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   8d7ca:	6a3b      	ldr	r3, [r7, #32]
   8d7cc:	691b      	ldr	r3, [r3, #16]
   8d7ce:	2b00      	cmp	r3, #0
   8d7d0:	d01b      	beq.n	8d80a <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   8d7d2:	6a3b      	ldr	r3, [r7, #32]
   8d7d4:	3310      	adds	r3, #16
   8d7d6:	4618      	mov	r0, r3
   8d7d8:	4b47      	ldr	r3, [pc, #284]	; (8d8f8 <xQueueGenericReceive+0x1c4>)
   8d7da:	4798      	blx	r3
   8d7dc:	4603      	mov	r3, r0
   8d7de:	2b01      	cmp	r3, #1
   8d7e0:	d113      	bne.n	8d80a <xQueueGenericReceive+0xd6>
						{
							queueYIELD_IF_USING_PREEMPTION();
   8d7e2:	4b46      	ldr	r3, [pc, #280]	; (8d8fc <xQueueGenericReceive+0x1c8>)
   8d7e4:	4798      	blx	r3
   8d7e6:	e010      	b.n	8d80a <xQueueGenericReceive+0xd6>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
   8d7e8:	6a3b      	ldr	r3, [r7, #32]
   8d7ea:	69fa      	ldr	r2, [r7, #28]
   8d7ec:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   8d7ee:	6a3b      	ldr	r3, [r7, #32]
   8d7f0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8d7f2:	2b00      	cmp	r3, #0
   8d7f4:	d009      	beq.n	8d80a <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   8d7f6:	6a3b      	ldr	r3, [r7, #32]
   8d7f8:	3324      	adds	r3, #36	; 0x24
   8d7fa:	4618      	mov	r0, r3
   8d7fc:	4b3e      	ldr	r3, [pc, #248]	; (8d8f8 <xQueueGenericReceive+0x1c4>)
   8d7fe:	4798      	blx	r3
   8d800:	4603      	mov	r3, r0
   8d802:	2b00      	cmp	r3, #0
   8d804:	d001      	beq.n	8d80a <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
   8d806:	4b3d      	ldr	r3, [pc, #244]	; (8d8fc <xQueueGenericReceive+0x1c8>)
   8d808:	4798      	blx	r3
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
   8d80a:	4b3d      	ldr	r3, [pc, #244]	; (8d900 <xQueueGenericReceive+0x1cc>)
   8d80c:	4798      	blx	r3
				return pdPASS;
   8d80e:	2301      	movs	r3, #1
   8d810:	e064      	b.n	8d8dc <xQueueGenericReceive+0x1a8>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   8d812:	687b      	ldr	r3, [r7, #4]
   8d814:	2b00      	cmp	r3, #0
   8d816:	d103      	bne.n	8d820 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   8d818:	4b39      	ldr	r3, [pc, #228]	; (8d900 <xQueueGenericReceive+0x1cc>)
   8d81a:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   8d81c:	2300      	movs	r3, #0
   8d81e:	e05d      	b.n	8d8dc <xQueueGenericReceive+0x1a8>
				}
				else if( xEntryTimeSet == pdFALSE )
   8d820:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8d822:	2b00      	cmp	r3, #0
   8d824:	d106      	bne.n	8d834 <xQueueGenericReceive+0x100>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   8d826:	f107 0314 	add.w	r3, r7, #20
   8d82a:	4618      	mov	r0, r3
   8d82c:	4b35      	ldr	r3, [pc, #212]	; (8d904 <xQueueGenericReceive+0x1d0>)
   8d82e:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
   8d830:	2301      	movs	r3, #1
   8d832:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   8d834:	4b32      	ldr	r3, [pc, #200]	; (8d900 <xQueueGenericReceive+0x1cc>)
   8d836:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   8d838:	4b33      	ldr	r3, [pc, #204]	; (8d908 <xQueueGenericReceive+0x1d4>)
   8d83a:	4798      	blx	r3
		prvLockQueue( pxQueue );
   8d83c:	4b2b      	ldr	r3, [pc, #172]	; (8d8ec <xQueueGenericReceive+0x1b8>)
   8d83e:	4798      	blx	r3
   8d840:	6a3b      	ldr	r3, [r7, #32]
   8d842:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   8d844:	f1b3 3fff 	cmp.w	r3, #4294967295
   8d848:	d102      	bne.n	8d850 <xQueueGenericReceive+0x11c>
   8d84a:	6a3b      	ldr	r3, [r7, #32]
   8d84c:	2200      	movs	r2, #0
   8d84e:	645a      	str	r2, [r3, #68]	; 0x44
   8d850:	6a3b      	ldr	r3, [r7, #32]
   8d852:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   8d854:	f1b3 3fff 	cmp.w	r3, #4294967295
   8d858:	d102      	bne.n	8d860 <xQueueGenericReceive+0x12c>
   8d85a:	6a3b      	ldr	r3, [r7, #32]
   8d85c:	2200      	movs	r2, #0
   8d85e:	649a      	str	r2, [r3, #72]	; 0x48
   8d860:	4b27      	ldr	r3, [pc, #156]	; (8d900 <xQueueGenericReceive+0x1cc>)
   8d862:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   8d864:	1d3a      	adds	r2, r7, #4
   8d866:	f107 0314 	add.w	r3, r7, #20
   8d86a:	4611      	mov	r1, r2
   8d86c:	4618      	mov	r0, r3
   8d86e:	4b27      	ldr	r3, [pc, #156]	; (8d90c <xQueueGenericReceive+0x1d8>)
   8d870:	4798      	blx	r3
   8d872:	4603      	mov	r3, r0
   8d874:	2b00      	cmp	r3, #0
   8d876:	d12b      	bne.n	8d8d0 <xQueueGenericReceive+0x19c>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   8d878:	6a38      	ldr	r0, [r7, #32]
   8d87a:	4b25      	ldr	r3, [pc, #148]	; (8d910 <xQueueGenericReceive+0x1dc>)
   8d87c:	4798      	blx	r3
   8d87e:	4603      	mov	r3, r0
   8d880:	2b00      	cmp	r3, #0
   8d882:	d01f      	beq.n	8d8c4 <xQueueGenericReceive+0x190>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   8d884:	6a3b      	ldr	r3, [r7, #32]
   8d886:	681b      	ldr	r3, [r3, #0]
   8d888:	2b00      	cmp	r3, #0
   8d88a:	d108      	bne.n	8d89e <xQueueGenericReceive+0x16a>
					{
						taskENTER_CRITICAL();
   8d88c:	4b17      	ldr	r3, [pc, #92]	; (8d8ec <xQueueGenericReceive+0x1b8>)
   8d88e:	4798      	blx	r3
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   8d890:	6a3b      	ldr	r3, [r7, #32]
   8d892:	685b      	ldr	r3, [r3, #4]
   8d894:	4618      	mov	r0, r3
   8d896:	4b1f      	ldr	r3, [pc, #124]	; (8d914 <xQueueGenericReceive+0x1e0>)
   8d898:	4798      	blx	r3
						}
						taskEXIT_CRITICAL();
   8d89a:	4b19      	ldr	r3, [pc, #100]	; (8d900 <xQueueGenericReceive+0x1cc>)
   8d89c:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   8d89e:	6a3b      	ldr	r3, [r7, #32]
   8d8a0:	3324      	adds	r3, #36	; 0x24
   8d8a2:	687a      	ldr	r2, [r7, #4]
   8d8a4:	4611      	mov	r1, r2
   8d8a6:	4618      	mov	r0, r3
   8d8a8:	4b1b      	ldr	r3, [pc, #108]	; (8d918 <xQueueGenericReceive+0x1e4>)
   8d8aa:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   8d8ac:	6a38      	ldr	r0, [r7, #32]
   8d8ae:	4b1b      	ldr	r3, [pc, #108]	; (8d91c <xQueueGenericReceive+0x1e8>)
   8d8b0:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   8d8b2:	4b1b      	ldr	r3, [pc, #108]	; (8d920 <xQueueGenericReceive+0x1ec>)
   8d8b4:	4798      	blx	r3
   8d8b6:	4603      	mov	r3, r0
   8d8b8:	2b00      	cmp	r3, #0
   8d8ba:	f47f af68 	bne.w	8d78e <xQueueGenericReceive+0x5a>
				{
					portYIELD_WITHIN_API();
   8d8be:	4b0f      	ldr	r3, [pc, #60]	; (8d8fc <xQueueGenericReceive+0x1c8>)
   8d8c0:	4798      	blx	r3
   8d8c2:	e764      	b.n	8d78e <xQueueGenericReceive+0x5a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   8d8c4:	6a38      	ldr	r0, [r7, #32]
   8d8c6:	4b15      	ldr	r3, [pc, #84]	; (8d91c <xQueueGenericReceive+0x1e8>)
   8d8c8:	4798      	blx	r3
				( void ) xTaskResumeAll();
   8d8ca:	4b15      	ldr	r3, [pc, #84]	; (8d920 <xQueueGenericReceive+0x1ec>)
   8d8cc:	4798      	blx	r3
   8d8ce:	e75e      	b.n	8d78e <xQueueGenericReceive+0x5a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
   8d8d0:	6a38      	ldr	r0, [r7, #32]
   8d8d2:	4b12      	ldr	r3, [pc, #72]	; (8d91c <xQueueGenericReceive+0x1e8>)
   8d8d4:	4798      	blx	r3
			( void ) xTaskResumeAll();
   8d8d6:	4b12      	ldr	r3, [pc, #72]	; (8d920 <xQueueGenericReceive+0x1ec>)
   8d8d8:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
   8d8da:	2300      	movs	r3, #0
		}
	}
}
   8d8dc:	4618      	mov	r0, r3
   8d8de:	3728      	adds	r7, #40	; 0x28
   8d8e0:	46bd      	mov	sp, r7
   8d8e2:	bd80      	pop	{r7, pc}
   8d8e4:	00082eed 	.word	0x00082eed
   8d8e8:	0008ed19 	.word	0x0008ed19
   8d8ec:	0009088d 	.word	0x0009088d
   8d8f0:	0008da05 	.word	0x0008da05
   8d8f4:	0008f0a5 	.word	0x0008f0a5
   8d8f8:	0008e6a9 	.word	0x0008e6a9
   8d8fc:	0009086d 	.word	0x0009086d
   8d900:	000908d1 	.word	0x000908d1
   8d904:	0008e769 	.word	0x0008e769
   8d908:	0008e031 	.word	0x0008e031
   8d90c:	0008e7a1 	.word	0x0008e7a1
   8d910:	0008db1d 	.word	0x0008db1d
   8d914:	0008ed55 	.word	0x0008ed55
   8d918:	0008e56d 	.word	0x0008e56d
   8d91c:	0008da55 	.word	0x0008da55
   8d920:	0008e04d 	.word	0x0008e04d

0008d924 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   8d924:	b580      	push	{r7, lr}
   8d926:	b086      	sub	sp, #24
   8d928:	af00      	add	r7, sp, #0
   8d92a:	60f8      	str	r0, [r7, #12]
   8d92c:	60b9      	str	r1, [r7, #8]
   8d92e:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
   8d930:	2300      	movs	r3, #0
   8d932:	617b      	str	r3, [r7, #20]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   8d934:	68fb      	ldr	r3, [r7, #12]
   8d936:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8d938:	2b00      	cmp	r3, #0
   8d93a:	d10d      	bne.n	8d958 <prvCopyDataToQueue+0x34>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   8d93c:	68fb      	ldr	r3, [r7, #12]
   8d93e:	681b      	ldr	r3, [r3, #0]
   8d940:	2b00      	cmp	r3, #0
   8d942:	d150      	bne.n	8d9e6 <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   8d944:	68fb      	ldr	r3, [r7, #12]
   8d946:	685b      	ldr	r3, [r3, #4]
   8d948:	4618      	mov	r0, r3
   8d94a:	4b2c      	ldr	r3, [pc, #176]	; (8d9fc <prvCopyDataToQueue+0xd8>)
   8d94c:	4798      	blx	r3
   8d94e:	6178      	str	r0, [r7, #20]
				pxQueue->pxMutexHolder = NULL;
   8d950:	68fb      	ldr	r3, [r7, #12]
   8d952:	2200      	movs	r2, #0
   8d954:	605a      	str	r2, [r3, #4]
   8d956:	e046      	b.n	8d9e6 <prvCopyDataToQueue+0xc2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   8d958:	687b      	ldr	r3, [r7, #4]
   8d95a:	2b00      	cmp	r3, #0
   8d95c:	d119      	bne.n	8d992 <prvCopyDataToQueue+0x6e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   8d95e:	68fb      	ldr	r3, [r7, #12]
   8d960:	6898      	ldr	r0, [r3, #8]
   8d962:	68fb      	ldr	r3, [r7, #12]
   8d964:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8d966:	461a      	mov	r2, r3
   8d968:	68b9      	ldr	r1, [r7, #8]
   8d96a:	4b25      	ldr	r3, [pc, #148]	; (8da00 <prvCopyDataToQueue+0xdc>)
   8d96c:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   8d96e:	68fb      	ldr	r3, [r7, #12]
   8d970:	689a      	ldr	r2, [r3, #8]
   8d972:	68fb      	ldr	r3, [r7, #12]
   8d974:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8d976:	441a      	add	r2, r3
   8d978:	68fb      	ldr	r3, [r7, #12]
   8d97a:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   8d97c:	68fb      	ldr	r3, [r7, #12]
   8d97e:	689a      	ldr	r2, [r3, #8]
   8d980:	68fb      	ldr	r3, [r7, #12]
   8d982:	685b      	ldr	r3, [r3, #4]
   8d984:	429a      	cmp	r2, r3
   8d986:	d32e      	bcc.n	8d9e6 <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   8d988:	68fb      	ldr	r3, [r7, #12]
   8d98a:	681a      	ldr	r2, [r3, #0]
   8d98c:	68fb      	ldr	r3, [r7, #12]
   8d98e:	609a      	str	r2, [r3, #8]
   8d990:	e029      	b.n	8d9e6 <prvCopyDataToQueue+0xc2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   8d992:	68fb      	ldr	r3, [r7, #12]
   8d994:	68d8      	ldr	r0, [r3, #12]
   8d996:	68fb      	ldr	r3, [r7, #12]
   8d998:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8d99a:	461a      	mov	r2, r3
   8d99c:	68b9      	ldr	r1, [r7, #8]
   8d99e:	4b18      	ldr	r3, [pc, #96]	; (8da00 <prvCopyDataToQueue+0xdc>)
   8d9a0:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   8d9a2:	68fb      	ldr	r3, [r7, #12]
   8d9a4:	68da      	ldr	r2, [r3, #12]
   8d9a6:	68fb      	ldr	r3, [r7, #12]
   8d9a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8d9aa:	425b      	negs	r3, r3
   8d9ac:	441a      	add	r2, r3
   8d9ae:	68fb      	ldr	r3, [r7, #12]
   8d9b0:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   8d9b2:	68fb      	ldr	r3, [r7, #12]
   8d9b4:	68da      	ldr	r2, [r3, #12]
   8d9b6:	68fb      	ldr	r3, [r7, #12]
   8d9b8:	681b      	ldr	r3, [r3, #0]
   8d9ba:	429a      	cmp	r2, r3
   8d9bc:	d207      	bcs.n	8d9ce <prvCopyDataToQueue+0xaa>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   8d9be:	68fb      	ldr	r3, [r7, #12]
   8d9c0:	685a      	ldr	r2, [r3, #4]
   8d9c2:	68fb      	ldr	r3, [r7, #12]
   8d9c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8d9c6:	425b      	negs	r3, r3
   8d9c8:	441a      	add	r2, r3
   8d9ca:	68fb      	ldr	r3, [r7, #12]
   8d9cc:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   8d9ce:	687b      	ldr	r3, [r7, #4]
   8d9d0:	2b02      	cmp	r3, #2
   8d9d2:	d108      	bne.n	8d9e6 <prvCopyDataToQueue+0xc2>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   8d9d4:	68fb      	ldr	r3, [r7, #12]
   8d9d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   8d9d8:	2b00      	cmp	r3, #0
   8d9da:	d004      	beq.n	8d9e6 <prvCopyDataToQueue+0xc2>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
   8d9dc:	68fb      	ldr	r3, [r7, #12]
   8d9de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   8d9e0:	1e5a      	subs	r2, r3, #1
   8d9e2:	68fb      	ldr	r3, [r7, #12]
   8d9e4:	639a      	str	r2, [r3, #56]	; 0x38
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
   8d9e6:	68fb      	ldr	r3, [r7, #12]
   8d9e8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   8d9ea:	1c5a      	adds	r2, r3, #1
   8d9ec:	68fb      	ldr	r3, [r7, #12]
   8d9ee:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
   8d9f0:	697b      	ldr	r3, [r7, #20]
}
   8d9f2:	4618      	mov	r0, r3
   8d9f4:	3718      	adds	r7, #24
   8d9f6:	46bd      	mov	sp, r7
   8d9f8:	bd80      	pop	{r7, pc}
   8d9fa:	bf00      	nop
   8d9fc:	0008ee49 	.word	0x0008ee49
   8da00:	00093b11 	.word	0x00093b11

0008da04 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
   8da04:	b580      	push	{r7, lr}
   8da06:	b082      	sub	sp, #8
   8da08:	af00      	add	r7, sp, #0
   8da0a:	6078      	str	r0, [r7, #4]
   8da0c:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   8da0e:	687b      	ldr	r3, [r7, #4]
   8da10:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8da12:	2b00      	cmp	r3, #0
   8da14:	d018      	beq.n	8da48 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   8da16:	687b      	ldr	r3, [r7, #4]
   8da18:	68da      	ldr	r2, [r3, #12]
   8da1a:	687b      	ldr	r3, [r7, #4]
   8da1c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8da1e:	441a      	add	r2, r3
   8da20:	687b      	ldr	r3, [r7, #4]
   8da22:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   8da24:	687b      	ldr	r3, [r7, #4]
   8da26:	68da      	ldr	r2, [r3, #12]
   8da28:	687b      	ldr	r3, [r7, #4]
   8da2a:	685b      	ldr	r3, [r3, #4]
   8da2c:	429a      	cmp	r2, r3
   8da2e:	d303      	bcc.n	8da38 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
   8da30:	687b      	ldr	r3, [r7, #4]
   8da32:	681a      	ldr	r2, [r3, #0]
   8da34:	687b      	ldr	r3, [r7, #4]
   8da36:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
   8da38:	687b      	ldr	r3, [r7, #4]
   8da3a:	68d9      	ldr	r1, [r3, #12]
   8da3c:	687b      	ldr	r3, [r7, #4]
   8da3e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8da40:	461a      	mov	r2, r3
   8da42:	6838      	ldr	r0, [r7, #0]
   8da44:	4b02      	ldr	r3, [pc, #8]	; (8da50 <prvCopyDataFromQueue+0x4c>)
   8da46:	4798      	blx	r3
	}
}
   8da48:	bf00      	nop
   8da4a:	3708      	adds	r7, #8
   8da4c:	46bd      	mov	sp, r7
   8da4e:	bd80      	pop	{r7, pc}
   8da50:	00093b11 	.word	0x00093b11

0008da54 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   8da54:	b580      	push	{r7, lr}
   8da56:	b082      	sub	sp, #8
   8da58:	af00      	add	r7, sp, #0
   8da5a:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   8da5c:	4b2a      	ldr	r3, [pc, #168]	; (8db08 <prvUnlockQueue+0xb4>)
   8da5e:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   8da60:	e020      	b.n	8daa4 <prvUnlockQueue+0x50>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			#if ( configUSE_QUEUE_SETS == 1 )
			{
				if( pxQueue->pxQueueSetContainer != NULL )
   8da62:	687b      	ldr	r3, [r7, #4]
   8da64:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   8da66:	2b00      	cmp	r3, #0
   8da68:	d009      	beq.n	8da7e <prvUnlockQueue+0x2a>
				{
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
   8da6a:	2100      	movs	r1, #0
   8da6c:	6878      	ldr	r0, [r7, #4]
   8da6e:	4b27      	ldr	r3, [pc, #156]	; (8db0c <prvUnlockQueue+0xb8>)
   8da70:	4798      	blx	r3
   8da72:	4603      	mov	r3, r0
   8da74:	2b01      	cmp	r3, #1
   8da76:	d110      	bne.n	8da9a <prvUnlockQueue+0x46>
					{
						/* The queue is a member of a queue set, and posting to
						the queue set caused a higher priority task to unblock.
						A context switch is required. */
						vTaskMissedYield();
   8da78:	4b25      	ldr	r3, [pc, #148]	; (8db10 <prvUnlockQueue+0xbc>)
   8da7a:	4798      	blx	r3
   8da7c:	e00d      	b.n	8da9a <prvUnlockQueue+0x46>
				}
				else
				{
					/* Tasks that are removed from the event list will get added to
					the pending ready list as the scheduler is still suspended. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   8da7e:	687b      	ldr	r3, [r7, #4]
   8da80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8da82:	2b00      	cmp	r3, #0
   8da84:	d013      	beq.n	8daae <prvUnlockQueue+0x5a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   8da86:	687b      	ldr	r3, [r7, #4]
   8da88:	3324      	adds	r3, #36	; 0x24
   8da8a:	4618      	mov	r0, r3
   8da8c:	4b21      	ldr	r3, [pc, #132]	; (8db14 <prvUnlockQueue+0xc0>)
   8da8e:	4798      	blx	r3
   8da90:	4603      	mov	r3, r0
   8da92:	2b00      	cmp	r3, #0
   8da94:	d001      	beq.n	8da9a <prvUnlockQueue+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							vTaskMissedYield();
   8da96:	4b1e      	ldr	r3, [pc, #120]	; (8db10 <prvUnlockQueue+0xbc>)
   8da98:	4798      	blx	r3
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
   8da9a:	687b      	ldr	r3, [r7, #4]
   8da9c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   8da9e:	1e5a      	subs	r2, r3, #1
   8daa0:	687b      	ldr	r3, [r7, #4]
   8daa2:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   8daa4:	687b      	ldr	r3, [r7, #4]
   8daa6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   8daa8:	2b00      	cmp	r3, #0
   8daaa:	dcda      	bgt.n	8da62 <prvUnlockQueue+0xe>
   8daac:	e000      	b.n	8dab0 <prvUnlockQueue+0x5c>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else
					{
						break;
   8daae:	bf00      	nop
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
   8dab0:	687b      	ldr	r3, [r7, #4]
   8dab2:	f04f 32ff 	mov.w	r2, #4294967295
   8dab6:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
   8dab8:	4b17      	ldr	r3, [pc, #92]	; (8db18 <prvUnlockQueue+0xc4>)
   8daba:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   8dabc:	4b12      	ldr	r3, [pc, #72]	; (8db08 <prvUnlockQueue+0xb4>)
   8dabe:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   8dac0:	e012      	b.n	8dae8 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   8dac2:	687b      	ldr	r3, [r7, #4]
   8dac4:	691b      	ldr	r3, [r3, #16]
   8dac6:	2b00      	cmp	r3, #0
   8dac8:	d013      	beq.n	8daf2 <prvUnlockQueue+0x9e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   8daca:	687b      	ldr	r3, [r7, #4]
   8dacc:	3310      	adds	r3, #16
   8dace:	4618      	mov	r0, r3
   8dad0:	4b10      	ldr	r3, [pc, #64]	; (8db14 <prvUnlockQueue+0xc0>)
   8dad2:	4798      	blx	r3
   8dad4:	4603      	mov	r3, r0
   8dad6:	2b00      	cmp	r3, #0
   8dad8:	d001      	beq.n	8dade <prvUnlockQueue+0x8a>
				{
					vTaskMissedYield();
   8dada:	4b0d      	ldr	r3, [pc, #52]	; (8db10 <prvUnlockQueue+0xbc>)
   8dadc:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
   8dade:	687b      	ldr	r3, [r7, #4]
   8dae0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   8dae2:	1e5a      	subs	r2, r3, #1
   8dae4:	687b      	ldr	r3, [r7, #4]
   8dae6:	645a      	str	r2, [r3, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   8dae8:	687b      	ldr	r3, [r7, #4]
   8daea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   8daec:	2b00      	cmp	r3, #0
   8daee:	dce8      	bgt.n	8dac2 <prvUnlockQueue+0x6e>
   8daf0:	e000      	b.n	8daf4 <prvUnlockQueue+0xa0>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
   8daf2:	bf00      	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
   8daf4:	687b      	ldr	r3, [r7, #4]
   8daf6:	f04f 32ff 	mov.w	r2, #4294967295
   8dafa:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
   8dafc:	4b06      	ldr	r3, [pc, #24]	; (8db18 <prvUnlockQueue+0xc4>)
   8dafe:	4798      	blx	r3
}
   8db00:	bf00      	nop
   8db02:	3708      	adds	r7, #8
   8db04:	46bd      	mov	sp, r7
   8db06:	bd80      	pop	{r7, pc}
   8db08:	0009088d 	.word	0x0009088d
   8db0c:	0008dbf5 	.word	0x0008dbf5
   8db10:	0008e84d 	.word	0x0008e84d
   8db14:	0008e6a9 	.word	0x0008e6a9
   8db18:	000908d1 	.word	0x000908d1

0008db1c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   8db1c:	b580      	push	{r7, lr}
   8db1e:	b084      	sub	sp, #16
   8db20:	af00      	add	r7, sp, #0
   8db22:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   8db24:	4b08      	ldr	r3, [pc, #32]	; (8db48 <prvIsQueueEmpty+0x2c>)
   8db26:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   8db28:	687b      	ldr	r3, [r7, #4]
   8db2a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   8db2c:	2b00      	cmp	r3, #0
   8db2e:	d102      	bne.n	8db36 <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
   8db30:	2301      	movs	r3, #1
   8db32:	60fb      	str	r3, [r7, #12]
   8db34:	e001      	b.n	8db3a <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
   8db36:	2300      	movs	r3, #0
   8db38:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   8db3a:	4b04      	ldr	r3, [pc, #16]	; (8db4c <prvIsQueueEmpty+0x30>)
   8db3c:	4798      	blx	r3

	return xReturn;
   8db3e:	68fb      	ldr	r3, [r7, #12]
}
   8db40:	4618      	mov	r0, r3
   8db42:	3710      	adds	r7, #16
   8db44:	46bd      	mov	sp, r7
   8db46:	bd80      	pop	{r7, pc}
   8db48:	0009088d 	.word	0x0009088d
   8db4c:	000908d1 	.word	0x000908d1

0008db50 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
   8db50:	b580      	push	{r7, lr}
   8db52:	b084      	sub	sp, #16
   8db54:	af00      	add	r7, sp, #0
   8db56:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   8db58:	4b09      	ldr	r3, [pc, #36]	; (8db80 <prvIsQueueFull+0x30>)
   8db5a:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   8db5c:	687b      	ldr	r3, [r7, #4]
   8db5e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   8db60:	687b      	ldr	r3, [r7, #4]
   8db62:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   8db64:	429a      	cmp	r2, r3
   8db66:	d102      	bne.n	8db6e <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
   8db68:	2301      	movs	r3, #1
   8db6a:	60fb      	str	r3, [r7, #12]
   8db6c:	e001      	b.n	8db72 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
   8db6e:	2300      	movs	r3, #0
   8db70:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   8db72:	4b04      	ldr	r3, [pc, #16]	; (8db84 <prvIsQueueFull+0x34>)
   8db74:	4798      	blx	r3

	return xReturn;
   8db76:	68fb      	ldr	r3, [r7, #12]
}
   8db78:	4618      	mov	r0, r3
   8db7a:	3710      	adds	r7, #16
   8db7c:	46bd      	mov	sp, r7
   8db7e:	bd80      	pop	{r7, pc}
   8db80:	0009088d 	.word	0x0009088d
   8db84:	000908d1 	.word	0x000908d1

0008db88 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
   8db88:	b580      	push	{r7, lr}
   8db8a:	b086      	sub	sp, #24
   8db8c:	af00      	add	r7, sp, #0
   8db8e:	60f8      	str	r0, [r7, #12]
   8db90:	60b9      	str	r1, [r7, #8]
   8db92:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   8db94:	68fb      	ldr	r3, [r7, #12]
   8db96:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
   8db98:	4b12      	ldr	r3, [pc, #72]	; (8dbe4 <vQueueWaitForMessageRestricted+0x5c>)
   8db9a:	4798      	blx	r3
   8db9c:	697b      	ldr	r3, [r7, #20]
   8db9e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   8dba0:	f1b3 3fff 	cmp.w	r3, #4294967295
   8dba4:	d102      	bne.n	8dbac <vQueueWaitForMessageRestricted+0x24>
   8dba6:	697b      	ldr	r3, [r7, #20]
   8dba8:	2200      	movs	r2, #0
   8dbaa:	645a      	str	r2, [r3, #68]	; 0x44
   8dbac:	697b      	ldr	r3, [r7, #20]
   8dbae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   8dbb0:	f1b3 3fff 	cmp.w	r3, #4294967295
   8dbb4:	d102      	bne.n	8dbbc <vQueueWaitForMessageRestricted+0x34>
   8dbb6:	697b      	ldr	r3, [r7, #20]
   8dbb8:	2200      	movs	r2, #0
   8dbba:	649a      	str	r2, [r3, #72]	; 0x48
   8dbbc:	4b0a      	ldr	r3, [pc, #40]	; (8dbe8 <vQueueWaitForMessageRestricted+0x60>)
   8dbbe:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   8dbc0:	697b      	ldr	r3, [r7, #20]
   8dbc2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   8dbc4:	2b00      	cmp	r3, #0
   8dbc6:	d106      	bne.n	8dbd6 <vQueueWaitForMessageRestricted+0x4e>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
   8dbc8:	697b      	ldr	r3, [r7, #20]
   8dbca:	3324      	adds	r3, #36	; 0x24
   8dbcc:	687a      	ldr	r2, [r7, #4]
   8dbce:	68b9      	ldr	r1, [r7, #8]
   8dbd0:	4618      	mov	r0, r3
   8dbd2:	4b06      	ldr	r3, [pc, #24]	; (8dbec <vQueueWaitForMessageRestricted+0x64>)
   8dbd4:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
   8dbd6:	6978      	ldr	r0, [r7, #20]
   8dbd8:	4b05      	ldr	r3, [pc, #20]	; (8dbf0 <vQueueWaitForMessageRestricted+0x68>)
   8dbda:	4798      	blx	r3
	}
   8dbdc:	bf00      	nop
   8dbde:	3718      	adds	r7, #24
   8dbe0:	46bd      	mov	sp, r7
   8dbe2:	bd80      	pop	{r7, pc}
   8dbe4:	0009088d 	.word	0x0009088d
   8dbe8:	000908d1 	.word	0x000908d1
   8dbec:	0008e60d 	.word	0x0008e60d
   8dbf0:	0008da55 	.word	0x0008da55

0008dbf4 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
   8dbf4:	b580      	push	{r7, lr}
   8dbf6:	b084      	sub	sp, #16
   8dbf8:	af00      	add	r7, sp, #0
   8dbfa:	6078      	str	r0, [r7, #4]
   8dbfc:	6039      	str	r1, [r7, #0]
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
   8dbfe:	687b      	ldr	r3, [r7, #4]
   8dc00:	6d5b      	ldr	r3, [r3, #84]	; 0x54
   8dc02:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
   8dc04:	2300      	movs	r3, #0
   8dc06:	60fb      	str	r3, [r7, #12]

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
   8dc08:	68bb      	ldr	r3, [r7, #8]
   8dc0a:	2b00      	cmp	r3, #0
   8dc0c:	d101      	bne.n	8dc12 <prvNotifyQueueSetContainer+0x1e>
   8dc0e:	4b1a      	ldr	r3, [pc, #104]	; (8dc78 <prvNotifyQueueSetContainer+0x84>)
   8dc10:	4798      	blx	r3
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
   8dc12:	68bb      	ldr	r3, [r7, #8]
   8dc14:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   8dc16:	68bb      	ldr	r3, [r7, #8]
   8dc18:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   8dc1a:	429a      	cmp	r2, r3
   8dc1c:	d301      	bcc.n	8dc22 <prvNotifyQueueSetContainer+0x2e>
   8dc1e:	4b16      	ldr	r3, [pc, #88]	; (8dc78 <prvNotifyQueueSetContainer+0x84>)
   8dc20:	4798      	blx	r3

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
   8dc22:	68bb      	ldr	r3, [r7, #8]
   8dc24:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   8dc26:	68bb      	ldr	r3, [r7, #8]
   8dc28:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   8dc2a:	429a      	cmp	r2, r3
   8dc2c:	d21f      	bcs.n	8dc6e <prvNotifyQueueSetContainer+0x7a>
		{
			traceQUEUE_SEND( pxQueueSetContainer );

			/* The data copied is the handle of the queue that contains data. */
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
   8dc2e:	1d3b      	adds	r3, r7, #4
   8dc30:	683a      	ldr	r2, [r7, #0]
   8dc32:	4619      	mov	r1, r3
   8dc34:	68b8      	ldr	r0, [r7, #8]
   8dc36:	4b11      	ldr	r3, [pc, #68]	; (8dc7c <prvNotifyQueueSetContainer+0x88>)
   8dc38:	4798      	blx	r3
   8dc3a:	60f8      	str	r0, [r7, #12]

			if( pxQueueSetContainer->xTxLock == queueUNLOCKED )
   8dc3c:	68bb      	ldr	r3, [r7, #8]
   8dc3e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   8dc40:	f1b3 3fff 	cmp.w	r3, #4294967295
   8dc44:	d10e      	bne.n	8dc64 <prvNotifyQueueSetContainer+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
   8dc46:	68bb      	ldr	r3, [r7, #8]
   8dc48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8dc4a:	2b00      	cmp	r3, #0
   8dc4c:	d00f      	beq.n	8dc6e <prvNotifyQueueSetContainer+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
   8dc4e:	68bb      	ldr	r3, [r7, #8]
   8dc50:	3324      	adds	r3, #36	; 0x24
   8dc52:	4618      	mov	r0, r3
   8dc54:	4b0a      	ldr	r3, [pc, #40]	; (8dc80 <prvNotifyQueueSetContainer+0x8c>)
   8dc56:	4798      	blx	r3
   8dc58:	4603      	mov	r3, r0
   8dc5a:	2b00      	cmp	r3, #0
   8dc5c:	d007      	beq.n	8dc6e <prvNotifyQueueSetContainer+0x7a>
					{
						/* The task waiting has a higher priority. */
						xReturn = pdTRUE;
   8dc5e:	2301      	movs	r3, #1
   8dc60:	60fb      	str	r3, [r7, #12]
   8dc62:	e004      	b.n	8dc6e <prvNotifyQueueSetContainer+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				( pxQueueSetContainer->xTxLock )++;
   8dc64:	68bb      	ldr	r3, [r7, #8]
   8dc66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   8dc68:	1c5a      	adds	r2, r3, #1
   8dc6a:	68bb      	ldr	r3, [r7, #8]
   8dc6c:	649a      	str	r2, [r3, #72]	; 0x48
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   8dc6e:	68fb      	ldr	r3, [r7, #12]
	}
   8dc70:	4618      	mov	r0, r3
   8dc72:	3710      	adds	r7, #16
   8dc74:	46bd      	mov	sp, r7
   8dc76:	bd80      	pop	{r7, pc}
   8dc78:	00082eed 	.word	0x00082eed
   8dc7c:	0008d925 	.word	0x0008d925
   8dc80:	0008e6a9 	.word	0x0008e6a9

0008dc84 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   8dc84:	b590      	push	{r4, r7, lr}
   8dc86:	b08b      	sub	sp, #44	; 0x2c
   8dc88:	af02      	add	r7, sp, #8
   8dc8a:	60f8      	str	r0, [r7, #12]
   8dc8c:	60b9      	str	r1, [r7, #8]
   8dc8e:	603b      	str	r3, [r7, #0]
   8dc90:	4613      	mov	r3, r2
   8dc92:	80fb      	strh	r3, [r7, #6]
BaseType_t xReturn;
TCB_t * pxNewTCB;
StackType_t *pxTopOfStack;

	configASSERT( pxTaskCode );
   8dc94:	68fb      	ldr	r3, [r7, #12]
   8dc96:	2b00      	cmp	r3, #0
   8dc98:	d101      	bne.n	8dc9e <xTaskGenericCreate+0x1a>
   8dc9a:	4b4c      	ldr	r3, [pc, #304]	; (8ddcc <xTaskGenericCreate+0x148>)
   8dc9c:	4798      	blx	r3
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
   8dc9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   8dca0:	2b05      	cmp	r3, #5
   8dca2:	d901      	bls.n	8dca8 <xTaskGenericCreate+0x24>
   8dca4:	4b49      	ldr	r3, [pc, #292]	; (8ddcc <xTaskGenericCreate+0x148>)
   8dca6:	4798      	blx	r3

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
   8dca8:	88fb      	ldrh	r3, [r7, #6]
   8dcaa:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   8dcac:	4618      	mov	r0, r3
   8dcae:	4b48      	ldr	r3, [pc, #288]	; (8ddd0 <xTaskGenericCreate+0x14c>)
   8dcb0:	4798      	blx	r3
   8dcb2:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
   8dcb4:	69bb      	ldr	r3, [r7, #24]
   8dcb6:	2b00      	cmp	r3, #0
   8dcb8:	d070      	beq.n	8dd9c <xTaskGenericCreate+0x118>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
   8dcba:	69bb      	ldr	r3, [r7, #24]
   8dcbc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   8dcbe:	88fb      	ldrh	r3, [r7, #6]
   8dcc0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   8dcc4:	3b01      	subs	r3, #1
   8dcc6:	009b      	lsls	r3, r3, #2
   8dcc8:	4413      	add	r3, r2
   8dcca:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   8dccc:	697b      	ldr	r3, [r7, #20]
   8dcce:	f023 0307 	bic.w	r3, r3, #7
   8dcd2:	617b      	str	r3, [r7, #20]

			/* Check the alignment of the calculated top of stack is correct. */
			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   8dcd4:	697b      	ldr	r3, [r7, #20]
   8dcd6:	f003 0307 	and.w	r3, r3, #7
   8dcda:	2b00      	cmp	r3, #0
   8dcdc:	d001      	beq.n	8dce2 <xTaskGenericCreate+0x5e>
   8dcde:	4b3b      	ldr	r3, [pc, #236]	; (8ddcc <xTaskGenericCreate+0x148>)
   8dce0:	4798      	blx	r3
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
   8dce2:	88fb      	ldrh	r3, [r7, #6]
   8dce4:	9300      	str	r3, [sp, #0]
   8dce6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   8dce8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   8dcea:	68b9      	ldr	r1, [r7, #8]
   8dcec:	69b8      	ldr	r0, [r7, #24]
   8dcee:	4c39      	ldr	r4, [pc, #228]	; (8ddd4 <xTaskGenericCreate+0x150>)
   8dcf0:	47a0      	blx	r4
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   8dcf2:	683a      	ldr	r2, [r7, #0]
   8dcf4:	68f9      	ldr	r1, [r7, #12]
   8dcf6:	6978      	ldr	r0, [r7, #20]
   8dcf8:	4b37      	ldr	r3, [pc, #220]	; (8ddd8 <xTaskGenericCreate+0x154>)
   8dcfa:	4798      	blx	r3
   8dcfc:	4602      	mov	r2, r0
   8dcfe:	69bb      	ldr	r3, [r7, #24]
   8dd00:	601a      	str	r2, [r3, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
   8dd02:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   8dd04:	2b00      	cmp	r3, #0
   8dd06:	d002      	beq.n	8dd0e <xTaskGenericCreate+0x8a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   8dd08:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   8dd0a:	69ba      	ldr	r2, [r7, #24]
   8dd0c:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
   8dd0e:	4b33      	ldr	r3, [pc, #204]	; (8dddc <xTaskGenericCreate+0x158>)
   8dd10:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
   8dd12:	4b33      	ldr	r3, [pc, #204]	; (8dde0 <xTaskGenericCreate+0x15c>)
   8dd14:	681b      	ldr	r3, [r3, #0]
   8dd16:	3301      	adds	r3, #1
   8dd18:	4a31      	ldr	r2, [pc, #196]	; (8dde0 <xTaskGenericCreate+0x15c>)
   8dd1a:	6013      	str	r3, [r2, #0]
			if( pxCurrentTCB == NULL )
   8dd1c:	4b31      	ldr	r3, [pc, #196]	; (8dde4 <xTaskGenericCreate+0x160>)
   8dd1e:	681b      	ldr	r3, [r3, #0]
   8dd20:	2b00      	cmp	r3, #0
   8dd22:	d109      	bne.n	8dd38 <xTaskGenericCreate+0xb4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
   8dd24:	4a2f      	ldr	r2, [pc, #188]	; (8dde4 <xTaskGenericCreate+0x160>)
   8dd26:	69bb      	ldr	r3, [r7, #24]
   8dd28:	6013      	str	r3, [r2, #0]

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   8dd2a:	4b2d      	ldr	r3, [pc, #180]	; (8dde0 <xTaskGenericCreate+0x15c>)
   8dd2c:	681b      	ldr	r3, [r3, #0]
   8dd2e:	2b01      	cmp	r3, #1
   8dd30:	d10f      	bne.n	8dd52 <xTaskGenericCreate+0xce>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
   8dd32:	4b2d      	ldr	r3, [pc, #180]	; (8dde8 <xTaskGenericCreate+0x164>)
   8dd34:	4798      	blx	r3
   8dd36:	e00c      	b.n	8dd52 <xTaskGenericCreate+0xce>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
   8dd38:	4b2c      	ldr	r3, [pc, #176]	; (8ddec <xTaskGenericCreate+0x168>)
   8dd3a:	681b      	ldr	r3, [r3, #0]
   8dd3c:	2b00      	cmp	r3, #0
   8dd3e:	d108      	bne.n	8dd52 <xTaskGenericCreate+0xce>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
   8dd40:	4b28      	ldr	r3, [pc, #160]	; (8dde4 <xTaskGenericCreate+0x160>)
   8dd42:	681b      	ldr	r3, [r3, #0]
   8dd44:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8dd46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   8dd48:	429a      	cmp	r2, r3
   8dd4a:	d802      	bhi.n	8dd52 <xTaskGenericCreate+0xce>
					{
						pxCurrentTCB = pxNewTCB;
   8dd4c:	4a25      	ldr	r2, [pc, #148]	; (8dde4 <xTaskGenericCreate+0x160>)
   8dd4e:	69bb      	ldr	r3, [r7, #24]
   8dd50:	6013      	str	r3, [r2, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
   8dd52:	4b27      	ldr	r3, [pc, #156]	; (8ddf0 <xTaskGenericCreate+0x16c>)
   8dd54:	681b      	ldr	r3, [r3, #0]
   8dd56:	3301      	adds	r3, #1
   8dd58:	4a25      	ldr	r2, [pc, #148]	; (8ddf0 <xTaskGenericCreate+0x16c>)
   8dd5a:	6013      	str	r3, [r2, #0]

			#if ( configUSE_TRACE_FACILITY == 1 )
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
   8dd5c:	4b24      	ldr	r3, [pc, #144]	; (8ddf0 <xTaskGenericCreate+0x16c>)
   8dd5e:	681a      	ldr	r2, [r3, #0]
   8dd60:	69bb      	ldr	r3, [r7, #24]
   8dd62:	641a      	str	r2, [r3, #64]	; 0x40
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
   8dd64:	69bb      	ldr	r3, [r7, #24]
   8dd66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8dd68:	2201      	movs	r2, #1
   8dd6a:	409a      	lsls	r2, r3
   8dd6c:	4b21      	ldr	r3, [pc, #132]	; (8ddf4 <xTaskGenericCreate+0x170>)
   8dd6e:	681b      	ldr	r3, [r3, #0]
   8dd70:	4313      	orrs	r3, r2
   8dd72:	4a20      	ldr	r2, [pc, #128]	; (8ddf4 <xTaskGenericCreate+0x170>)
   8dd74:	6013      	str	r3, [r2, #0]
   8dd76:	69bb      	ldr	r3, [r7, #24]
   8dd78:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8dd7a:	4613      	mov	r3, r2
   8dd7c:	009b      	lsls	r3, r3, #2
   8dd7e:	4413      	add	r3, r2
   8dd80:	009b      	lsls	r3, r3, #2
   8dd82:	4a1d      	ldr	r2, [pc, #116]	; (8ddf8 <xTaskGenericCreate+0x174>)
   8dd84:	441a      	add	r2, r3
   8dd86:	69bb      	ldr	r3, [r7, #24]
   8dd88:	3304      	adds	r3, #4
   8dd8a:	4619      	mov	r1, r3
   8dd8c:	4610      	mov	r0, r2
   8dd8e:	4b1b      	ldr	r3, [pc, #108]	; (8ddfc <xTaskGenericCreate+0x178>)
   8dd90:	4798      	blx	r3

			xReturn = pdPASS;
   8dd92:	2301      	movs	r3, #1
   8dd94:	61fb      	str	r3, [r7, #28]
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
   8dd96:	4b1a      	ldr	r3, [pc, #104]	; (8de00 <xTaskGenericCreate+0x17c>)
   8dd98:	4798      	blx	r3
   8dd9a:	e002      	b.n	8dda2 <xTaskGenericCreate+0x11e>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   8dd9c:	f04f 33ff 	mov.w	r3, #4294967295
   8dda0:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
   8dda2:	69fb      	ldr	r3, [r7, #28]
   8dda4:	2b01      	cmp	r3, #1
   8dda6:	d10b      	bne.n	8ddc0 <xTaskGenericCreate+0x13c>
	{
		if( xSchedulerRunning != pdFALSE )
   8dda8:	4b10      	ldr	r3, [pc, #64]	; (8ddec <xTaskGenericCreate+0x168>)
   8ddaa:	681b      	ldr	r3, [r3, #0]
   8ddac:	2b00      	cmp	r3, #0
   8ddae:	d007      	beq.n	8ddc0 <xTaskGenericCreate+0x13c>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
   8ddb0:	4b0c      	ldr	r3, [pc, #48]	; (8dde4 <xTaskGenericCreate+0x160>)
   8ddb2:	681b      	ldr	r3, [r3, #0]
   8ddb4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8ddb6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   8ddb8:	429a      	cmp	r2, r3
   8ddba:	d201      	bcs.n	8ddc0 <xTaskGenericCreate+0x13c>
			{
				taskYIELD_IF_USING_PREEMPTION();
   8ddbc:	4b11      	ldr	r3, [pc, #68]	; (8de04 <xTaskGenericCreate+0x180>)
   8ddbe:	4798      	blx	r3
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
   8ddc0:	69fb      	ldr	r3, [r7, #28]
}
   8ddc2:	4618      	mov	r0, r3
   8ddc4:	3724      	adds	r7, #36	; 0x24
   8ddc6:	46bd      	mov	sp, r7
   8ddc8:	bd90      	pop	{r4, r7, pc}
   8ddca:	bf00      	nop
   8ddcc:	00082eed 	.word	0x00082eed
   8ddd0:	0008eac5 	.word	0x0008eac5
   8ddd4:	0008e895 	.word	0x0008e895
   8ddd8:	000906dd 	.word	0x000906dd
   8dddc:	0009088d 	.word	0x0009088d
   8dde0:	20071c18 	.word	0x20071c18
   8dde4:	20071b28 	.word	0x20071b28
   8dde8:	0008e941 	.word	0x0008e941
   8ddec:	20071c24 	.word	0x20071c24
   8ddf0:	20071c34 	.word	0x20071c34
   8ddf4:	20071c20 	.word	0x20071c20
   8ddf8:	20071b2c 	.word	0x20071b2c
   8ddfc:	000905b1 	.word	0x000905b1
   8de00:	000908d1 	.word	0x000908d1
   8de04:	0009086d 	.word	0x0009086d

0008de08 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
   8de08:	b580      	push	{r7, lr}
   8de0a:	b086      	sub	sp, #24
   8de0c:	af00      	add	r7, sp, #0
   8de0e:	6078      	str	r0, [r7, #4]
   8de10:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
   8de12:	2300      	movs	r3, #0
   8de14:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
   8de16:	687b      	ldr	r3, [r7, #4]
   8de18:	2b00      	cmp	r3, #0
   8de1a:	d101      	bne.n	8de20 <vTaskDelayUntil+0x18>
   8de1c:	4b2e      	ldr	r3, [pc, #184]	; (8ded8 <vTaskDelayUntil+0xd0>)
   8de1e:	4798      	blx	r3
		configASSERT( ( xTimeIncrement > 0U ) );
   8de20:	683b      	ldr	r3, [r7, #0]
   8de22:	2b00      	cmp	r3, #0
   8de24:	d101      	bne.n	8de2a <vTaskDelayUntil+0x22>
   8de26:	4b2c      	ldr	r3, [pc, #176]	; (8ded8 <vTaskDelayUntil+0xd0>)
   8de28:	4798      	blx	r3
		configASSERT( uxSchedulerSuspended == 0 );
   8de2a:	4b2c      	ldr	r3, [pc, #176]	; (8dedc <vTaskDelayUntil+0xd4>)
   8de2c:	681b      	ldr	r3, [r3, #0]
   8de2e:	2b00      	cmp	r3, #0
   8de30:	d001      	beq.n	8de36 <vTaskDelayUntil+0x2e>
   8de32:	4b29      	ldr	r3, [pc, #164]	; (8ded8 <vTaskDelayUntil+0xd0>)
   8de34:	4798      	blx	r3

		vTaskSuspendAll();
   8de36:	4b2a      	ldr	r3, [pc, #168]	; (8dee0 <vTaskDelayUntil+0xd8>)
   8de38:	4798      	blx	r3
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
   8de3a:	4b2a      	ldr	r3, [pc, #168]	; (8dee4 <vTaskDelayUntil+0xdc>)
   8de3c:	681b      	ldr	r3, [r3, #0]
   8de3e:	613b      	str	r3, [r7, #16]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   8de40:	687b      	ldr	r3, [r7, #4]
   8de42:	681a      	ldr	r2, [r3, #0]
   8de44:	683b      	ldr	r3, [r7, #0]
   8de46:	4413      	add	r3, r2
   8de48:	60fb      	str	r3, [r7, #12]

			if( xConstTickCount < *pxPreviousWakeTime )
   8de4a:	687b      	ldr	r3, [r7, #4]
   8de4c:	681a      	ldr	r2, [r3, #0]
   8de4e:	693b      	ldr	r3, [r7, #16]
   8de50:	429a      	cmp	r2, r3
   8de52:	d90b      	bls.n	8de6c <vTaskDelayUntil+0x64>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   8de54:	687b      	ldr	r3, [r7, #4]
   8de56:	681a      	ldr	r2, [r3, #0]
   8de58:	68fb      	ldr	r3, [r7, #12]
   8de5a:	429a      	cmp	r2, r3
   8de5c:	d911      	bls.n	8de82 <vTaskDelayUntil+0x7a>
   8de5e:	68fa      	ldr	r2, [r7, #12]
   8de60:	693b      	ldr	r3, [r7, #16]
   8de62:	429a      	cmp	r2, r3
   8de64:	d90d      	bls.n	8de82 <vTaskDelayUntil+0x7a>
				{
					xShouldDelay = pdTRUE;
   8de66:	2301      	movs	r3, #1
   8de68:	617b      	str	r3, [r7, #20]
   8de6a:	e00a      	b.n	8de82 <vTaskDelayUntil+0x7a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   8de6c:	687b      	ldr	r3, [r7, #4]
   8de6e:	681a      	ldr	r2, [r3, #0]
   8de70:	68fb      	ldr	r3, [r7, #12]
   8de72:	429a      	cmp	r2, r3
   8de74:	d803      	bhi.n	8de7e <vTaskDelayUntil+0x76>
   8de76:	68fa      	ldr	r2, [r7, #12]
   8de78:	693b      	ldr	r3, [r7, #16]
   8de7a:	429a      	cmp	r2, r3
   8de7c:	d901      	bls.n	8de82 <vTaskDelayUntil+0x7a>
				{
					xShouldDelay = pdTRUE;
   8de7e:	2301      	movs	r3, #1
   8de80:	617b      	str	r3, [r7, #20]
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
   8de82:	687b      	ldr	r3, [r7, #4]
   8de84:	68fa      	ldr	r2, [r7, #12]
   8de86:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
   8de88:	697b      	ldr	r3, [r7, #20]
   8de8a:	2b00      	cmp	r3, #0
   8de8c:	d017      	beq.n	8debe <vTaskDelayUntil+0xb6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   8de8e:	4b16      	ldr	r3, [pc, #88]	; (8dee8 <vTaskDelayUntil+0xe0>)
   8de90:	681b      	ldr	r3, [r3, #0]
   8de92:	3304      	adds	r3, #4
   8de94:	4618      	mov	r0, r3
   8de96:	4b15      	ldr	r3, [pc, #84]	; (8deec <vTaskDelayUntil+0xe4>)
   8de98:	4798      	blx	r3
   8de9a:	4603      	mov	r3, r0
   8de9c:	2b00      	cmp	r3, #0
   8de9e:	d10b      	bne.n	8deb8 <vTaskDelayUntil+0xb0>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   8dea0:	4b11      	ldr	r3, [pc, #68]	; (8dee8 <vTaskDelayUntil+0xe0>)
   8dea2:	681b      	ldr	r3, [r3, #0]
   8dea4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8dea6:	2201      	movs	r2, #1
   8dea8:	fa02 f303 	lsl.w	r3, r2, r3
   8deac:	43da      	mvns	r2, r3
   8deae:	4b10      	ldr	r3, [pc, #64]	; (8def0 <vTaskDelayUntil+0xe8>)
   8deb0:	681b      	ldr	r3, [r3, #0]
   8deb2:	4013      	ands	r3, r2
   8deb4:	4a0e      	ldr	r2, [pc, #56]	; (8def0 <vTaskDelayUntil+0xe8>)
   8deb6:	6013      	str	r3, [r2, #0]
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
   8deb8:	68f8      	ldr	r0, [r7, #12]
   8deba:	4b0e      	ldr	r3, [pc, #56]	; (8def4 <vTaskDelayUntil+0xec>)
   8debc:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
   8debe:	4b0e      	ldr	r3, [pc, #56]	; (8def8 <vTaskDelayUntil+0xf0>)
   8dec0:	4798      	blx	r3
   8dec2:	60b8      	str	r0, [r7, #8]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   8dec4:	68bb      	ldr	r3, [r7, #8]
   8dec6:	2b00      	cmp	r3, #0
   8dec8:	d101      	bne.n	8dece <vTaskDelayUntil+0xc6>
		{
			portYIELD_WITHIN_API();
   8deca:	4b0c      	ldr	r3, [pc, #48]	; (8defc <vTaskDelayUntil+0xf4>)
   8decc:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   8dece:	bf00      	nop
   8ded0:	3718      	adds	r7, #24
   8ded2:	46bd      	mov	sp, r7
   8ded4:	bd80      	pop	{r7, pc}
   8ded6:	bf00      	nop
   8ded8:	00082eed 	.word	0x00082eed
   8dedc:	20071c3c 	.word	0x20071c3c
   8dee0:	0008e031 	.word	0x0008e031
   8dee4:	20071c1c 	.word	0x20071c1c
   8dee8:	20071b28 	.word	0x20071b28
   8deec:	00090669 	.word	0x00090669
   8def0:	20071c20 	.word	0x20071c20
   8def4:	0008ea55 	.word	0x0008ea55
   8def8:	0008e04d 	.word	0x0008e04d
   8defc:	0009086d 	.word	0x0009086d

0008df00 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
   8df00:	b580      	push	{r7, lr}
   8df02:	b084      	sub	sp, #16
   8df04:	af00      	add	r7, sp, #0
   8df06:	6078      	str	r0, [r7, #4]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
   8df08:	2300      	movs	r3, #0
   8df0a:	60fb      	str	r3, [r7, #12]


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
   8df0c:	687b      	ldr	r3, [r7, #4]
   8df0e:	2b00      	cmp	r3, #0
   8df10:	d027      	beq.n	8df62 <vTaskDelay+0x62>
		{
			configASSERT( uxSchedulerSuspended == 0 );
   8df12:	4b18      	ldr	r3, [pc, #96]	; (8df74 <vTaskDelay+0x74>)
   8df14:	681b      	ldr	r3, [r3, #0]
   8df16:	2b00      	cmp	r3, #0
   8df18:	d001      	beq.n	8df1e <vTaskDelay+0x1e>
   8df1a:	4b17      	ldr	r3, [pc, #92]	; (8df78 <vTaskDelay+0x78>)
   8df1c:	4798      	blx	r3
			vTaskSuspendAll();
   8df1e:	4b17      	ldr	r3, [pc, #92]	; (8df7c <vTaskDelay+0x7c>)
   8df20:	4798      	blx	r3
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
   8df22:	4b17      	ldr	r3, [pc, #92]	; (8df80 <vTaskDelay+0x80>)
   8df24:	681a      	ldr	r2, [r3, #0]
   8df26:	687b      	ldr	r3, [r7, #4]
   8df28:	4413      	add	r3, r2
   8df2a:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   8df2c:	4b15      	ldr	r3, [pc, #84]	; (8df84 <vTaskDelay+0x84>)
   8df2e:	681b      	ldr	r3, [r3, #0]
   8df30:	3304      	adds	r3, #4
   8df32:	4618      	mov	r0, r3
   8df34:	4b14      	ldr	r3, [pc, #80]	; (8df88 <vTaskDelay+0x88>)
   8df36:	4798      	blx	r3
   8df38:	4603      	mov	r3, r0
   8df3a:	2b00      	cmp	r3, #0
   8df3c:	d10b      	bne.n	8df56 <vTaskDelay+0x56>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   8df3e:	4b11      	ldr	r3, [pc, #68]	; (8df84 <vTaskDelay+0x84>)
   8df40:	681b      	ldr	r3, [r3, #0]
   8df42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8df44:	2201      	movs	r2, #1
   8df46:	fa02 f303 	lsl.w	r3, r2, r3
   8df4a:	43da      	mvns	r2, r3
   8df4c:	4b0f      	ldr	r3, [pc, #60]	; (8df8c <vTaskDelay+0x8c>)
   8df4e:	681b      	ldr	r3, [r3, #0]
   8df50:	4013      	ands	r3, r2
   8df52:	4a0e      	ldr	r2, [pc, #56]	; (8df8c <vTaskDelay+0x8c>)
   8df54:	6013      	str	r3, [r2, #0]
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
   8df56:	68b8      	ldr	r0, [r7, #8]
   8df58:	4b0d      	ldr	r3, [pc, #52]	; (8df90 <vTaskDelay+0x90>)
   8df5a:	4798      	blx	r3
			}
			xAlreadyYielded = xTaskResumeAll();
   8df5c:	4b0d      	ldr	r3, [pc, #52]	; (8df94 <vTaskDelay+0x94>)
   8df5e:	4798      	blx	r3
   8df60:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   8df62:	68fb      	ldr	r3, [r7, #12]
   8df64:	2b00      	cmp	r3, #0
   8df66:	d101      	bne.n	8df6c <vTaskDelay+0x6c>
		{
			portYIELD_WITHIN_API();
   8df68:	4b0b      	ldr	r3, [pc, #44]	; (8df98 <vTaskDelay+0x98>)
   8df6a:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   8df6c:	bf00      	nop
   8df6e:	3710      	adds	r7, #16
   8df70:	46bd      	mov	sp, r7
   8df72:	bd80      	pop	{r7, pc}
   8df74:	20071c3c 	.word	0x20071c3c
   8df78:	00082eed 	.word	0x00082eed
   8df7c:	0008e031 	.word	0x0008e031
   8df80:	20071c1c 	.word	0x20071c1c
   8df84:	20071b28 	.word	0x20071b28
   8df88:	00090669 	.word	0x00090669
   8df8c:	20071c20 	.word	0x20071c20
   8df90:	0008ea55 	.word	0x0008ea55
   8df94:	0008e04d 	.word	0x0008e04d
   8df98:	0009086d 	.word	0x0009086d

0008df9c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   8df9c:	b590      	push	{r4, r7, lr}
   8df9e:	b087      	sub	sp, #28
   8dfa0:	af04      	add	r7, sp, #16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   8dfa2:	2300      	movs	r3, #0
   8dfa4:	9303      	str	r3, [sp, #12]
   8dfa6:	2300      	movs	r3, #0
   8dfa8:	9302      	str	r3, [sp, #8]
   8dfaa:	4b16      	ldr	r3, [pc, #88]	; (8e004 <vTaskStartScheduler+0x68>)
   8dfac:	9301      	str	r3, [sp, #4]
   8dfae:	2300      	movs	r3, #0
   8dfb0:	9300      	str	r3, [sp, #0]
   8dfb2:	2300      	movs	r3, #0
   8dfb4:	2282      	movs	r2, #130	; 0x82
   8dfb6:	4914      	ldr	r1, [pc, #80]	; (8e008 <vTaskStartScheduler+0x6c>)
   8dfb8:	4814      	ldr	r0, [pc, #80]	; (8e00c <vTaskStartScheduler+0x70>)
   8dfba:	4c15      	ldr	r4, [pc, #84]	; (8e010 <vTaskStartScheduler+0x74>)
   8dfbc:	47a0      	blx	r4
   8dfbe:	6078      	str	r0, [r7, #4]
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
   8dfc0:	687b      	ldr	r3, [r7, #4]
   8dfc2:	2b01      	cmp	r3, #1
   8dfc4:	d102      	bne.n	8dfcc <vTaskStartScheduler+0x30>
		{
			xReturn = xTimerCreateTimerTask();
   8dfc6:	4b13      	ldr	r3, [pc, #76]	; (8e014 <vTaskStartScheduler+0x78>)
   8dfc8:	4798      	blx	r3
   8dfca:	6078      	str	r0, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   8dfcc:	687b      	ldr	r3, [r7, #4]
   8dfce:	2b01      	cmp	r3, #1
   8dfd0:	d10e      	bne.n	8dff0 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
   8dfd2:	4b11      	ldr	r3, [pc, #68]	; (8e018 <vTaskStartScheduler+0x7c>)
   8dfd4:	4798      	blx	r3
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   8dfd6:	4b11      	ldr	r3, [pc, #68]	; (8e01c <vTaskStartScheduler+0x80>)
   8dfd8:	f04f 32ff 	mov.w	r2, #4294967295
   8dfdc:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   8dfde:	4b10      	ldr	r3, [pc, #64]	; (8e020 <vTaskStartScheduler+0x84>)
   8dfe0:	2201      	movs	r2, #1
   8dfe2:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   8dfe4:	4b0f      	ldr	r3, [pc, #60]	; (8e024 <vTaskStartScheduler+0x88>)
   8dfe6:	2200      	movs	r2, #0
   8dfe8:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   8dfea:	4b0f      	ldr	r3, [pc, #60]	; (8e028 <vTaskStartScheduler+0x8c>)
   8dfec:	4798      	blx	r3
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
   8dfee:	e004      	b.n	8dffa <vTaskStartScheduler+0x5e>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
   8dff0:	687b      	ldr	r3, [r7, #4]
   8dff2:	2b00      	cmp	r3, #0
   8dff4:	d101      	bne.n	8dffa <vTaskStartScheduler+0x5e>
   8dff6:	4b0d      	ldr	r3, [pc, #52]	; (8e02c <vTaskStartScheduler+0x90>)
   8dff8:	4798      	blx	r3
	}
}
   8dffa:	bf00      	nop
   8dffc:	370c      	adds	r7, #12
   8dffe:	46bd      	mov	sp, r7
   8e000:	bd90      	pop	{r4, r7, pc}
   8e002:	bf00      	nop
   8e004:	20071c14 	.word	0x20071c14
   8e008:	0009ae7c 	.word	0x0009ae7c
   8e00c:	0008e865 	.word	0x0008e865
   8e010:	0008dc85 	.word	0x0008dc85
   8e014:	0008f0f5 	.word	0x0008f0f5
   8e018:	00090909 	.word	0x00090909
   8e01c:	20071c38 	.word	0x20071c38
   8e020:	20071c24 	.word	0x20071c24
   8e024:	20071c1c 	.word	0x20071c1c
   8e028:	000907a5 	.word	0x000907a5
   8e02c:	00082eed 	.word	0x00082eed

0008e030 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
   8e030:	b480      	push	{r7}
   8e032:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   8e034:	4b04      	ldr	r3, [pc, #16]	; (8e048 <vTaskSuspendAll+0x18>)
   8e036:	681b      	ldr	r3, [r3, #0]
   8e038:	3301      	adds	r3, #1
   8e03a:	4a03      	ldr	r2, [pc, #12]	; (8e048 <vTaskSuspendAll+0x18>)
   8e03c:	6013      	str	r3, [r2, #0]
}
   8e03e:	bf00      	nop
   8e040:	46bd      	mov	sp, r7
   8e042:	bc80      	pop	{r7}
   8e044:	4770      	bx	lr
   8e046:	bf00      	nop
   8e048:	20071c3c 	.word	0x20071c3c

0008e04c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   8e04c:	b580      	push	{r7, lr}
   8e04e:	b082      	sub	sp, #8
   8e050:	af00      	add	r7, sp, #0
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
   8e052:	2300      	movs	r3, #0
   8e054:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
   8e056:	4b37      	ldr	r3, [pc, #220]	; (8e134 <xTaskResumeAll+0xe8>)
   8e058:	681b      	ldr	r3, [r3, #0]
   8e05a:	2b00      	cmp	r3, #0
   8e05c:	d101      	bne.n	8e062 <xTaskResumeAll+0x16>
   8e05e:	4b36      	ldr	r3, [pc, #216]	; (8e138 <xTaskResumeAll+0xec>)
   8e060:	4798      	blx	r3
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   8e062:	4b36      	ldr	r3, [pc, #216]	; (8e13c <xTaskResumeAll+0xf0>)
   8e064:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
   8e066:	4b33      	ldr	r3, [pc, #204]	; (8e134 <xTaskResumeAll+0xe8>)
   8e068:	681b      	ldr	r3, [r3, #0]
   8e06a:	3b01      	subs	r3, #1
   8e06c:	4a31      	ldr	r2, [pc, #196]	; (8e134 <xTaskResumeAll+0xe8>)
   8e06e:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   8e070:	4b30      	ldr	r3, [pc, #192]	; (8e134 <xTaskResumeAll+0xe8>)
   8e072:	681b      	ldr	r3, [r3, #0]
   8e074:	2b00      	cmp	r3, #0
   8e076:	d155      	bne.n	8e124 <xTaskResumeAll+0xd8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   8e078:	4b31      	ldr	r3, [pc, #196]	; (8e140 <xTaskResumeAll+0xf4>)
   8e07a:	681b      	ldr	r3, [r3, #0]
   8e07c:	2b00      	cmp	r3, #0
   8e07e:	d051      	beq.n	8e124 <xTaskResumeAll+0xd8>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   8e080:	e02e      	b.n	8e0e0 <xTaskResumeAll+0x94>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   8e082:	4b30      	ldr	r3, [pc, #192]	; (8e144 <xTaskResumeAll+0xf8>)
   8e084:	68db      	ldr	r3, [r3, #12]
   8e086:	68db      	ldr	r3, [r3, #12]
   8e088:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   8e08a:	683b      	ldr	r3, [r7, #0]
   8e08c:	3318      	adds	r3, #24
   8e08e:	4618      	mov	r0, r3
   8e090:	4b2d      	ldr	r3, [pc, #180]	; (8e148 <xTaskResumeAll+0xfc>)
   8e092:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   8e094:	683b      	ldr	r3, [r7, #0]
   8e096:	3304      	adds	r3, #4
   8e098:	4618      	mov	r0, r3
   8e09a:	4b2b      	ldr	r3, [pc, #172]	; (8e148 <xTaskResumeAll+0xfc>)
   8e09c:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
   8e09e:	683b      	ldr	r3, [r7, #0]
   8e0a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8e0a2:	2201      	movs	r2, #1
   8e0a4:	409a      	lsls	r2, r3
   8e0a6:	4b29      	ldr	r3, [pc, #164]	; (8e14c <xTaskResumeAll+0x100>)
   8e0a8:	681b      	ldr	r3, [r3, #0]
   8e0aa:	4313      	orrs	r3, r2
   8e0ac:	4a27      	ldr	r2, [pc, #156]	; (8e14c <xTaskResumeAll+0x100>)
   8e0ae:	6013      	str	r3, [r2, #0]
   8e0b0:	683b      	ldr	r3, [r7, #0]
   8e0b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8e0b4:	4613      	mov	r3, r2
   8e0b6:	009b      	lsls	r3, r3, #2
   8e0b8:	4413      	add	r3, r2
   8e0ba:	009b      	lsls	r3, r3, #2
   8e0bc:	4a24      	ldr	r2, [pc, #144]	; (8e150 <xTaskResumeAll+0x104>)
   8e0be:	441a      	add	r2, r3
   8e0c0:	683b      	ldr	r3, [r7, #0]
   8e0c2:	3304      	adds	r3, #4
   8e0c4:	4619      	mov	r1, r3
   8e0c6:	4610      	mov	r0, r2
   8e0c8:	4b22      	ldr	r3, [pc, #136]	; (8e154 <xTaskResumeAll+0x108>)
   8e0ca:	4798      	blx	r3

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   8e0cc:	683b      	ldr	r3, [r7, #0]
   8e0ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8e0d0:	4b21      	ldr	r3, [pc, #132]	; (8e158 <xTaskResumeAll+0x10c>)
   8e0d2:	681b      	ldr	r3, [r3, #0]
   8e0d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8e0d6:	429a      	cmp	r2, r3
   8e0d8:	d302      	bcc.n	8e0e0 <xTaskResumeAll+0x94>
					{
						xYieldPending = pdTRUE;
   8e0da:	4b20      	ldr	r3, [pc, #128]	; (8e15c <xTaskResumeAll+0x110>)
   8e0dc:	2201      	movs	r2, #1
   8e0de:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   8e0e0:	4b18      	ldr	r3, [pc, #96]	; (8e144 <xTaskResumeAll+0xf8>)
   8e0e2:	681b      	ldr	r3, [r3, #0]
   8e0e4:	2b00      	cmp	r3, #0
   8e0e6:	d1cc      	bne.n	8e082 <xTaskResumeAll+0x36>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
   8e0e8:	4b1d      	ldr	r3, [pc, #116]	; (8e160 <xTaskResumeAll+0x114>)
   8e0ea:	681b      	ldr	r3, [r3, #0]
   8e0ec:	2b00      	cmp	r3, #0
   8e0ee:	d011      	beq.n	8e114 <xTaskResumeAll+0xc8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
   8e0f0:	e00c      	b.n	8e10c <xTaskResumeAll+0xc0>
					{
						if( xTaskIncrementTick() != pdFALSE )
   8e0f2:	4b1c      	ldr	r3, [pc, #112]	; (8e164 <xTaskResumeAll+0x118>)
   8e0f4:	4798      	blx	r3
   8e0f6:	4603      	mov	r3, r0
   8e0f8:	2b00      	cmp	r3, #0
   8e0fa:	d002      	beq.n	8e102 <xTaskResumeAll+0xb6>
						{
							xYieldPending = pdTRUE;
   8e0fc:	4b17      	ldr	r3, [pc, #92]	; (8e15c <xTaskResumeAll+0x110>)
   8e0fe:	2201      	movs	r2, #1
   8e100:	601a      	str	r2, [r3, #0]
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
   8e102:	4b17      	ldr	r3, [pc, #92]	; (8e160 <xTaskResumeAll+0x114>)
   8e104:	681b      	ldr	r3, [r3, #0]
   8e106:	3b01      	subs	r3, #1
   8e108:	4a15      	ldr	r2, [pc, #84]	; (8e160 <xTaskResumeAll+0x114>)
   8e10a:	6013      	str	r3, [r2, #0]
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
   8e10c:	4b14      	ldr	r3, [pc, #80]	; (8e160 <xTaskResumeAll+0x114>)
   8e10e:	681b      	ldr	r3, [r3, #0]
   8e110:	2b00      	cmp	r3, #0
   8e112:	d1ee      	bne.n	8e0f2 <xTaskResumeAll+0xa6>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
   8e114:	4b11      	ldr	r3, [pc, #68]	; (8e15c <xTaskResumeAll+0x110>)
   8e116:	681b      	ldr	r3, [r3, #0]
   8e118:	2b01      	cmp	r3, #1
   8e11a:	d103      	bne.n	8e124 <xTaskResumeAll+0xd8>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   8e11c:	2301      	movs	r3, #1
   8e11e:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   8e120:	4b11      	ldr	r3, [pc, #68]	; (8e168 <xTaskResumeAll+0x11c>)
   8e122:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   8e124:	4b11      	ldr	r3, [pc, #68]	; (8e16c <xTaskResumeAll+0x120>)
   8e126:	4798      	blx	r3

	return xAlreadyYielded;
   8e128:	687b      	ldr	r3, [r7, #4]
}
   8e12a:	4618      	mov	r0, r3
   8e12c:	3708      	adds	r7, #8
   8e12e:	46bd      	mov	sp, r7
   8e130:	bd80      	pop	{r7, pc}
   8e132:	bf00      	nop
   8e134:	20071c3c 	.word	0x20071c3c
   8e138:	00082eed 	.word	0x00082eed
   8e13c:	0009088d 	.word	0x0009088d
   8e140:	20071c18 	.word	0x20071c18
   8e144:	20071bd4 	.word	0x20071bd4
   8e148:	00090669 	.word	0x00090669
   8e14c:	20071c20 	.word	0x20071c20
   8e150:	20071b2c 	.word	0x20071b2c
   8e154:	000905b1 	.word	0x000905b1
   8e158:	20071b28 	.word	0x20071b28
   8e15c:	20071c2c 	.word	0x20071c2c
   8e160:	20071c28 	.word	0x20071c28
   8e164:	0008e2ad 	.word	0x0008e2ad
   8e168:	0009086d 	.word	0x0009086d
   8e16c:	000908d1 	.word	0x000908d1

0008e170 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
   8e170:	b480      	push	{r7}
   8e172:	b083      	sub	sp, #12
   8e174:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
   8e176:	4b04      	ldr	r3, [pc, #16]	; (8e188 <xTaskGetTickCount+0x18>)
   8e178:	681b      	ldr	r3, [r3, #0]
   8e17a:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
   8e17c:	687b      	ldr	r3, [r7, #4]
}
   8e17e:	4618      	mov	r0, r3
   8e180:	370c      	adds	r7, #12
   8e182:	46bd      	mov	sp, r7
   8e184:	bc80      	pop	{r7}
   8e186:	4770      	bx	lr
   8e188:	20071c1c 	.word	0x20071c1c

0008e18c <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
   8e18c:	b580      	push	{r7, lr}
   8e18e:	b086      	sub	sp, #24
   8e190:	af00      	add	r7, sp, #0
   8e192:	60f8      	str	r0, [r7, #12]
   8e194:	60b9      	str	r1, [r7, #8]
   8e196:	607a      	str	r2, [r7, #4]
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   8e198:	2300      	movs	r3, #0
   8e19a:	617b      	str	r3, [r7, #20]
   8e19c:	2306      	movs	r3, #6
   8e19e:	613b      	str	r3, [r7, #16]

		vTaskSuspendAll();
   8e1a0:	4b31      	ldr	r3, [pc, #196]	; (8e268 <uxTaskGetSystemState+0xdc>)
   8e1a2:	4798      	blx	r3
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
   8e1a4:	4b31      	ldr	r3, [pc, #196]	; (8e26c <uxTaskGetSystemState+0xe0>)
   8e1a6:	681b      	ldr	r3, [r3, #0]
   8e1a8:	68ba      	ldr	r2, [r7, #8]
   8e1aa:	429a      	cmp	r2, r3
   8e1ac:	d354      	bcc.n	8e258 <uxTaskGetSystemState+0xcc>
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
   8e1ae:	693b      	ldr	r3, [r7, #16]
   8e1b0:	3b01      	subs	r3, #1
   8e1b2:	613b      	str	r3, [r7, #16]
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   8e1b4:	697b      	ldr	r3, [r7, #20]
   8e1b6:	015b      	lsls	r3, r3, #5
   8e1b8:	68fa      	ldr	r2, [r7, #12]
   8e1ba:	18d0      	adds	r0, r2, r3
   8e1bc:	693a      	ldr	r2, [r7, #16]
   8e1be:	4613      	mov	r3, r2
   8e1c0:	009b      	lsls	r3, r3, #2
   8e1c2:	4413      	add	r3, r2
   8e1c4:	009b      	lsls	r3, r3, #2
   8e1c6:	4a2a      	ldr	r2, [pc, #168]	; (8e270 <uxTaskGetSystemState+0xe4>)
   8e1c8:	4413      	add	r3, r2
   8e1ca:	2201      	movs	r2, #1
   8e1cc:	4619      	mov	r1, r3
   8e1ce:	4b29      	ldr	r3, [pc, #164]	; (8e274 <uxTaskGetSystemState+0xe8>)
   8e1d0:	4798      	blx	r3
   8e1d2:	4602      	mov	r2, r0
   8e1d4:	697b      	ldr	r3, [r7, #20]
   8e1d6:	4413      	add	r3, r2
   8e1d8:	617b      	str	r3, [r7, #20]

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   8e1da:	693b      	ldr	r3, [r7, #16]
   8e1dc:	2b00      	cmp	r3, #0
   8e1de:	d1e6      	bne.n	8e1ae <uxTaskGetSystemState+0x22>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   8e1e0:	697b      	ldr	r3, [r7, #20]
   8e1e2:	015b      	lsls	r3, r3, #5
   8e1e4:	68fa      	ldr	r2, [r7, #12]
   8e1e6:	18d0      	adds	r0, r2, r3
   8e1e8:	4b23      	ldr	r3, [pc, #140]	; (8e278 <uxTaskGetSystemState+0xec>)
   8e1ea:	681b      	ldr	r3, [r3, #0]
   8e1ec:	2202      	movs	r2, #2
   8e1ee:	4619      	mov	r1, r3
   8e1f0:	4b20      	ldr	r3, [pc, #128]	; (8e274 <uxTaskGetSystemState+0xe8>)
   8e1f2:	4798      	blx	r3
   8e1f4:	4602      	mov	r2, r0
   8e1f6:	697b      	ldr	r3, [r7, #20]
   8e1f8:	4413      	add	r3, r2
   8e1fa:	617b      	str	r3, [r7, #20]
				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   8e1fc:	697b      	ldr	r3, [r7, #20]
   8e1fe:	015b      	lsls	r3, r3, #5
   8e200:	68fa      	ldr	r2, [r7, #12]
   8e202:	18d0      	adds	r0, r2, r3
   8e204:	4b1d      	ldr	r3, [pc, #116]	; (8e27c <uxTaskGetSystemState+0xf0>)
   8e206:	681b      	ldr	r3, [r3, #0]
   8e208:	2202      	movs	r2, #2
   8e20a:	4619      	mov	r1, r3
   8e20c:	4b19      	ldr	r3, [pc, #100]	; (8e274 <uxTaskGetSystemState+0xe8>)
   8e20e:	4798      	blx	r3
   8e210:	4602      	mov	r2, r0
   8e212:	697b      	ldr	r3, [r7, #20]
   8e214:	4413      	add	r3, r2
   8e216:	617b      	str	r3, [r7, #20]

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   8e218:	697b      	ldr	r3, [r7, #20]
   8e21a:	015b      	lsls	r3, r3, #5
   8e21c:	68fa      	ldr	r2, [r7, #12]
   8e21e:	4413      	add	r3, r2
   8e220:	2204      	movs	r2, #4
   8e222:	4917      	ldr	r1, [pc, #92]	; (8e280 <uxTaskGetSystemState+0xf4>)
   8e224:	4618      	mov	r0, r3
   8e226:	4b13      	ldr	r3, [pc, #76]	; (8e274 <uxTaskGetSystemState+0xe8>)
   8e228:	4798      	blx	r3
   8e22a:	4602      	mov	r2, r0
   8e22c:	697b      	ldr	r3, [r7, #20]
   8e22e:	4413      	add	r3, r2
   8e230:	617b      	str	r3, [r7, #20]

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   8e232:	697b      	ldr	r3, [r7, #20]
   8e234:	015b      	lsls	r3, r3, #5
   8e236:	68fa      	ldr	r2, [r7, #12]
   8e238:	4413      	add	r3, r2
   8e23a:	2203      	movs	r2, #3
   8e23c:	4911      	ldr	r1, [pc, #68]	; (8e284 <uxTaskGetSystemState+0xf8>)
   8e23e:	4618      	mov	r0, r3
   8e240:	4b0c      	ldr	r3, [pc, #48]	; (8e274 <uxTaskGetSystemState+0xe8>)
   8e242:	4798      	blx	r3
   8e244:	4602      	mov	r2, r0
   8e246:	697b      	ldr	r3, [r7, #20]
   8e248:	4413      	add	r3, r2
   8e24a:	617b      	str	r3, [r7, #20]
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
   8e24c:	687b      	ldr	r3, [r7, #4]
   8e24e:	2b00      	cmp	r3, #0
   8e250:	d002      	beq.n	8e258 <uxTaskGetSystemState+0xcc>
					{
						*pulTotalRunTime = 0;
   8e252:	687b      	ldr	r3, [r7, #4]
   8e254:	2200      	movs	r2, #0
   8e256:	601a      	str	r2, [r3, #0]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
   8e258:	4b0b      	ldr	r3, [pc, #44]	; (8e288 <uxTaskGetSystemState+0xfc>)
   8e25a:	4798      	blx	r3

		return uxTask;
   8e25c:	697b      	ldr	r3, [r7, #20]
	}
   8e25e:	4618      	mov	r0, r3
   8e260:	3718      	adds	r7, #24
   8e262:	46bd      	mov	sp, r7
   8e264:	bd80      	pop	{r7, pc}
   8e266:	bf00      	nop
   8e268:	0008e031 	.word	0x0008e031
   8e26c:	20071c18 	.word	0x20071c18
   8e270:	20071b2c 	.word	0x20071b2c
   8e274:	0008eb3d 	.word	0x0008eb3d
   8e278:	20071bcc 	.word	0x20071bcc
   8e27c:	20071bd0 	.word	0x20071bd0
   8e280:	20071be8 	.word	0x20071be8
   8e284:	20071c00 	.word	0x20071c00
   8e288:	0008e04d 	.word	0x0008e04d

0008e28c <xTaskGetIdleTaskHandle>:
/*----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )

	TaskHandle_t xTaskGetIdleTaskHandle( void )
	{
   8e28c:	b580      	push	{r7, lr}
   8e28e:	af00      	add	r7, sp, #0
		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
		started, then xIdleTaskHandle will be NULL. */
		configASSERT( ( xIdleTaskHandle != NULL ) );
   8e290:	4b04      	ldr	r3, [pc, #16]	; (8e2a4 <xTaskGetIdleTaskHandle+0x18>)
   8e292:	681b      	ldr	r3, [r3, #0]
   8e294:	2b00      	cmp	r3, #0
   8e296:	d101      	bne.n	8e29c <xTaskGetIdleTaskHandle+0x10>
   8e298:	4b03      	ldr	r3, [pc, #12]	; (8e2a8 <xTaskGetIdleTaskHandle+0x1c>)
   8e29a:	4798      	blx	r3
		return xIdleTaskHandle;
   8e29c:	4b01      	ldr	r3, [pc, #4]	; (8e2a4 <xTaskGetIdleTaskHandle+0x18>)
   8e29e:	681b      	ldr	r3, [r3, #0]
	}
   8e2a0:	4618      	mov	r0, r3
   8e2a2:	bd80      	pop	{r7, pc}
   8e2a4:	20071c14 	.word	0x20071c14
   8e2a8:	00082eed 	.word	0x00082eed

0008e2ac <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   8e2ac:	b580      	push	{r7, lr}
   8e2ae:	b086      	sub	sp, #24
   8e2b0:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   8e2b2:	2300      	movs	r3, #0
   8e2b4:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   8e2b6:	4b51      	ldr	r3, [pc, #324]	; (8e3fc <xTaskIncrementTick+0x150>)
   8e2b8:	681b      	ldr	r3, [r3, #0]
   8e2ba:	2b00      	cmp	r3, #0
   8e2bc:	f040 808b 	bne.w	8e3d6 <xTaskIncrementTick+0x12a>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
   8e2c0:	4b4f      	ldr	r3, [pc, #316]	; (8e400 <xTaskIncrementTick+0x154>)
   8e2c2:	681b      	ldr	r3, [r3, #0]
   8e2c4:	3301      	adds	r3, #1
   8e2c6:	4a4e      	ldr	r2, [pc, #312]	; (8e400 <xTaskIncrementTick+0x154>)
   8e2c8:	6013      	str	r3, [r2, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
   8e2ca:	4b4d      	ldr	r3, [pc, #308]	; (8e400 <xTaskIncrementTick+0x154>)
   8e2cc:	681b      	ldr	r3, [r3, #0]
   8e2ce:	613b      	str	r3, [r7, #16]

			if( xConstTickCount == ( TickType_t ) 0U )
   8e2d0:	693b      	ldr	r3, [r7, #16]
   8e2d2:	2b00      	cmp	r3, #0
   8e2d4:	d117      	bne.n	8e306 <xTaskIncrementTick+0x5a>
			{
				taskSWITCH_DELAYED_LISTS();
   8e2d6:	4b4b      	ldr	r3, [pc, #300]	; (8e404 <xTaskIncrementTick+0x158>)
   8e2d8:	681b      	ldr	r3, [r3, #0]
   8e2da:	681b      	ldr	r3, [r3, #0]
   8e2dc:	2b00      	cmp	r3, #0
   8e2de:	d001      	beq.n	8e2e4 <xTaskIncrementTick+0x38>
   8e2e0:	4b49      	ldr	r3, [pc, #292]	; (8e408 <xTaskIncrementTick+0x15c>)
   8e2e2:	4798      	blx	r3
   8e2e4:	4b47      	ldr	r3, [pc, #284]	; (8e404 <xTaskIncrementTick+0x158>)
   8e2e6:	681b      	ldr	r3, [r3, #0]
   8e2e8:	60fb      	str	r3, [r7, #12]
   8e2ea:	4b48      	ldr	r3, [pc, #288]	; (8e40c <xTaskIncrementTick+0x160>)
   8e2ec:	681b      	ldr	r3, [r3, #0]
   8e2ee:	4a45      	ldr	r2, [pc, #276]	; (8e404 <xTaskIncrementTick+0x158>)
   8e2f0:	6013      	str	r3, [r2, #0]
   8e2f2:	4a46      	ldr	r2, [pc, #280]	; (8e40c <xTaskIncrementTick+0x160>)
   8e2f4:	68fb      	ldr	r3, [r7, #12]
   8e2f6:	6013      	str	r3, [r2, #0]
   8e2f8:	4b45      	ldr	r3, [pc, #276]	; (8e410 <xTaskIncrementTick+0x164>)
   8e2fa:	681b      	ldr	r3, [r3, #0]
   8e2fc:	3301      	adds	r3, #1
   8e2fe:	4a44      	ldr	r2, [pc, #272]	; (8e410 <xTaskIncrementTick+0x164>)
   8e300:	6013      	str	r3, [r2, #0]
   8e302:	4b44      	ldr	r3, [pc, #272]	; (8e414 <xTaskIncrementTick+0x168>)
   8e304:	4798      	blx	r3

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
   8e306:	4b44      	ldr	r3, [pc, #272]	; (8e418 <xTaskIncrementTick+0x16c>)
   8e308:	681b      	ldr	r3, [r3, #0]
   8e30a:	693a      	ldr	r2, [r7, #16]
   8e30c:	429a      	cmp	r2, r3
   8e30e:	d34d      	bcc.n	8e3ac <xTaskIncrementTick+0x100>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   8e310:	4b3c      	ldr	r3, [pc, #240]	; (8e404 <xTaskIncrementTick+0x158>)
   8e312:	681b      	ldr	r3, [r3, #0]
   8e314:	681b      	ldr	r3, [r3, #0]
   8e316:	2b00      	cmp	r3, #0
   8e318:	d101      	bne.n	8e31e <xTaskIncrementTick+0x72>
   8e31a:	2301      	movs	r3, #1
   8e31c:	e000      	b.n	8e320 <xTaskIncrementTick+0x74>
   8e31e:	2300      	movs	r3, #0
   8e320:	2b00      	cmp	r3, #0
   8e322:	d004      	beq.n	8e32e <xTaskIncrementTick+0x82>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
   8e324:	4b3c      	ldr	r3, [pc, #240]	; (8e418 <xTaskIncrementTick+0x16c>)
   8e326:	f04f 32ff 	mov.w	r2, #4294967295
   8e32a:	601a      	str	r2, [r3, #0]
						break;
   8e32c:	e03e      	b.n	8e3ac <xTaskIncrementTick+0x100>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   8e32e:	4b35      	ldr	r3, [pc, #212]	; (8e404 <xTaskIncrementTick+0x158>)
   8e330:	681b      	ldr	r3, [r3, #0]
   8e332:	68db      	ldr	r3, [r3, #12]
   8e334:	68db      	ldr	r3, [r3, #12]
   8e336:	60bb      	str	r3, [r7, #8]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   8e338:	68bb      	ldr	r3, [r7, #8]
   8e33a:	685b      	ldr	r3, [r3, #4]
   8e33c:	607b      	str	r3, [r7, #4]

						if( xConstTickCount < xItemValue )
   8e33e:	693a      	ldr	r2, [r7, #16]
   8e340:	687b      	ldr	r3, [r7, #4]
   8e342:	429a      	cmp	r2, r3
   8e344:	d203      	bcs.n	8e34e <xTaskIncrementTick+0xa2>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
   8e346:	4a34      	ldr	r2, [pc, #208]	; (8e418 <xTaskIncrementTick+0x16c>)
   8e348:	687b      	ldr	r3, [r7, #4]
   8e34a:	6013      	str	r3, [r2, #0]
							break;
   8e34c:	e02e      	b.n	8e3ac <xTaskIncrementTick+0x100>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   8e34e:	68bb      	ldr	r3, [r7, #8]
   8e350:	3304      	adds	r3, #4
   8e352:	4618      	mov	r0, r3
   8e354:	4b31      	ldr	r3, [pc, #196]	; (8e41c <xTaskIncrementTick+0x170>)
   8e356:	4798      	blx	r3

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   8e358:	68bb      	ldr	r3, [r7, #8]
   8e35a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   8e35c:	2b00      	cmp	r3, #0
   8e35e:	d004      	beq.n	8e36a <xTaskIncrementTick+0xbe>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   8e360:	68bb      	ldr	r3, [r7, #8]
   8e362:	3318      	adds	r3, #24
   8e364:	4618      	mov	r0, r3
   8e366:	4b2d      	ldr	r3, [pc, #180]	; (8e41c <xTaskIncrementTick+0x170>)
   8e368:	4798      	blx	r3
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
   8e36a:	68bb      	ldr	r3, [r7, #8]
   8e36c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8e36e:	2201      	movs	r2, #1
   8e370:	409a      	lsls	r2, r3
   8e372:	4b2b      	ldr	r3, [pc, #172]	; (8e420 <xTaskIncrementTick+0x174>)
   8e374:	681b      	ldr	r3, [r3, #0]
   8e376:	4313      	orrs	r3, r2
   8e378:	4a29      	ldr	r2, [pc, #164]	; (8e420 <xTaskIncrementTick+0x174>)
   8e37a:	6013      	str	r3, [r2, #0]
   8e37c:	68bb      	ldr	r3, [r7, #8]
   8e37e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8e380:	4613      	mov	r3, r2
   8e382:	009b      	lsls	r3, r3, #2
   8e384:	4413      	add	r3, r2
   8e386:	009b      	lsls	r3, r3, #2
   8e388:	4a26      	ldr	r2, [pc, #152]	; (8e424 <xTaskIncrementTick+0x178>)
   8e38a:	441a      	add	r2, r3
   8e38c:	68bb      	ldr	r3, [r7, #8]
   8e38e:	3304      	adds	r3, #4
   8e390:	4619      	mov	r1, r3
   8e392:	4610      	mov	r0, r2
   8e394:	4b24      	ldr	r3, [pc, #144]	; (8e428 <xTaskIncrementTick+0x17c>)
   8e396:	4798      	blx	r3
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   8e398:	68bb      	ldr	r3, [r7, #8]
   8e39a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8e39c:	4b23      	ldr	r3, [pc, #140]	; (8e42c <xTaskIncrementTick+0x180>)
   8e39e:	681b      	ldr	r3, [r3, #0]
   8e3a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8e3a2:	429a      	cmp	r2, r3
   8e3a4:	d3b4      	bcc.n	8e310 <xTaskIncrementTick+0x64>
							{
								xSwitchRequired = pdTRUE;
   8e3a6:	2301      	movs	r3, #1
   8e3a8:	617b      	str	r3, [r7, #20]
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
   8e3aa:	e7b1      	b.n	8e310 <xTaskIncrementTick+0x64>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   8e3ac:	4b1f      	ldr	r3, [pc, #124]	; (8e42c <xTaskIncrementTick+0x180>)
   8e3ae:	681b      	ldr	r3, [r3, #0]
   8e3b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8e3b2:	491c      	ldr	r1, [pc, #112]	; (8e424 <xTaskIncrementTick+0x178>)
   8e3b4:	4613      	mov	r3, r2
   8e3b6:	009b      	lsls	r3, r3, #2
   8e3b8:	4413      	add	r3, r2
   8e3ba:	009b      	lsls	r3, r3, #2
   8e3bc:	440b      	add	r3, r1
   8e3be:	681b      	ldr	r3, [r3, #0]
   8e3c0:	2b01      	cmp	r3, #1
   8e3c2:	d901      	bls.n	8e3c8 <xTaskIncrementTick+0x11c>
			{
				xSwitchRequired = pdTRUE;
   8e3c4:	2301      	movs	r3, #1
   8e3c6:	617b      	str	r3, [r7, #20]

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
   8e3c8:	4b19      	ldr	r3, [pc, #100]	; (8e430 <xTaskIncrementTick+0x184>)
   8e3ca:	681b      	ldr	r3, [r3, #0]
   8e3cc:	2b00      	cmp	r3, #0
   8e3ce:	d109      	bne.n	8e3e4 <xTaskIncrementTick+0x138>
			{
				vApplicationTickHook();
   8e3d0:	4b18      	ldr	r3, [pc, #96]	; (8e434 <xTaskIncrementTick+0x188>)
   8e3d2:	4798      	blx	r3
   8e3d4:	e006      	b.n	8e3e4 <xTaskIncrementTick+0x138>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   8e3d6:	4b16      	ldr	r3, [pc, #88]	; (8e430 <xTaskIncrementTick+0x184>)
   8e3d8:	681b      	ldr	r3, [r3, #0]
   8e3da:	3301      	adds	r3, #1
   8e3dc:	4a14      	ldr	r2, [pc, #80]	; (8e430 <xTaskIncrementTick+0x184>)
   8e3de:	6013      	str	r3, [r2, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
   8e3e0:	4b14      	ldr	r3, [pc, #80]	; (8e434 <xTaskIncrementTick+0x188>)
   8e3e2:	4798      	blx	r3
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   8e3e4:	4b14      	ldr	r3, [pc, #80]	; (8e438 <xTaskIncrementTick+0x18c>)
   8e3e6:	681b      	ldr	r3, [r3, #0]
   8e3e8:	2b00      	cmp	r3, #0
   8e3ea:	d001      	beq.n	8e3f0 <xTaskIncrementTick+0x144>
		{
			xSwitchRequired = pdTRUE;
   8e3ec:	2301      	movs	r3, #1
   8e3ee:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   8e3f0:	697b      	ldr	r3, [r7, #20]
}
   8e3f2:	4618      	mov	r0, r3
   8e3f4:	3718      	adds	r7, #24
   8e3f6:	46bd      	mov	sp, r7
   8e3f8:	bd80      	pop	{r7, pc}
   8e3fa:	bf00      	nop
   8e3fc:	20071c3c 	.word	0x20071c3c
   8e400:	20071c1c 	.word	0x20071c1c
   8e404:	20071bcc 	.word	0x20071bcc
   8e408:	00082eed 	.word	0x00082eed
   8e40c:	20071bd0 	.word	0x20071bd0
   8e410:	20071c30 	.word	0x20071c30
   8e414:	0008ecb5 	.word	0x0008ecb5
   8e418:	20071c38 	.word	0x20071c38
   8e41c:	00090669 	.word	0x00090669
   8e420:	20071c20 	.word	0x20071c20
   8e424:	20071b2c 	.word	0x20071b2c
   8e428:	000905b1 	.word	0x000905b1
   8e42c:	20071b28 	.word	0x20071b28
   8e430:	20071c28 	.word	0x20071c28
   8e434:	00082f7d 	.word	0x00082f7d
   8e438:	20071c2c 	.word	0x20071c2c

0008e43c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   8e43c:	b590      	push	{r4, r7, lr}
   8e43e:	b087      	sub	sp, #28
   8e440:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   8e442:	4b3f      	ldr	r3, [pc, #252]	; (8e540 <vTaskSwitchContext+0x104>)
   8e444:	681b      	ldr	r3, [r3, #0]
   8e446:	2b00      	cmp	r3, #0
   8e448:	d003      	beq.n	8e452 <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   8e44a:	4b3e      	ldr	r3, [pc, #248]	; (8e544 <vTaskSwitchContext+0x108>)
   8e44c:	2201      	movs	r2, #1
   8e44e:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   8e450:	e071      	b.n	8e536 <vTaskSwitchContext+0xfa>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
   8e452:	4b3c      	ldr	r3, [pc, #240]	; (8e544 <vTaskSwitchContext+0x108>)
   8e454:	2200      	movs	r2, #0
   8e456:	601a      	str	r2, [r3, #0]
		traceTASK_SWITCHED_OUT();
   8e458:	4b3b      	ldr	r3, [pc, #236]	; (8e548 <vTaskSwitchContext+0x10c>)
   8e45a:	4798      	blx	r3
   8e45c:	4604      	mov	r4, r0
   8e45e:	4b3b      	ldr	r3, [pc, #236]	; (8e54c <vTaskSwitchContext+0x110>)
   8e460:	4798      	blx	r3
   8e462:	4603      	mov	r3, r0
   8e464:	429c      	cmp	r4, r3
   8e466:	d101      	bne.n	8e46c <vTaskSwitchContext+0x30>
   8e468:	4b39      	ldr	r3, [pc, #228]	; (8e550 <vTaskSwitchContext+0x114>)
   8e46a:	4798      	blx	r3
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
   8e46c:	4b39      	ldr	r3, [pc, #228]	; (8e554 <vTaskSwitchContext+0x118>)
   8e46e:	681b      	ldr	r3, [r3, #0]
   8e470:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   8e472:	617b      	str	r3, [r7, #20]
   8e474:	f04f 33a5 	mov.w	r3, #2779096485	; 0xa5a5a5a5
   8e478:	613b      	str	r3, [r7, #16]
   8e47a:	697b      	ldr	r3, [r7, #20]
   8e47c:	681a      	ldr	r2, [r3, #0]
   8e47e:	693b      	ldr	r3, [r7, #16]
   8e480:	429a      	cmp	r2, r3
   8e482:	d111      	bne.n	8e4a8 <vTaskSwitchContext+0x6c>
   8e484:	697b      	ldr	r3, [r7, #20]
   8e486:	3304      	adds	r3, #4
   8e488:	681a      	ldr	r2, [r3, #0]
   8e48a:	693b      	ldr	r3, [r7, #16]
   8e48c:	429a      	cmp	r2, r3
   8e48e:	d10b      	bne.n	8e4a8 <vTaskSwitchContext+0x6c>
   8e490:	697b      	ldr	r3, [r7, #20]
   8e492:	3308      	adds	r3, #8
   8e494:	681a      	ldr	r2, [r3, #0]
   8e496:	693b      	ldr	r3, [r7, #16]
   8e498:	429a      	cmp	r2, r3
   8e49a:	d105      	bne.n	8e4a8 <vTaskSwitchContext+0x6c>
   8e49c:	697b      	ldr	r3, [r7, #20]
   8e49e:	330c      	adds	r3, #12
   8e4a0:	681a      	ldr	r2, [r3, #0]
   8e4a2:	693b      	ldr	r3, [r7, #16]
   8e4a4:	429a      	cmp	r2, r3
   8e4a6:	d008      	beq.n	8e4ba <vTaskSwitchContext+0x7e>
   8e4a8:	4b2a      	ldr	r3, [pc, #168]	; (8e554 <vTaskSwitchContext+0x118>)
   8e4aa:	681a      	ldr	r2, [r3, #0]
   8e4ac:	4b29      	ldr	r3, [pc, #164]	; (8e554 <vTaskSwitchContext+0x118>)
   8e4ae:	681b      	ldr	r3, [r3, #0]
   8e4b0:	3334      	adds	r3, #52	; 0x34
   8e4b2:	4619      	mov	r1, r3
   8e4b4:	4610      	mov	r0, r2
   8e4b6:	4b28      	ldr	r3, [pc, #160]	; (8e558 <vTaskSwitchContext+0x11c>)
   8e4b8:	4798      	blx	r3

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
   8e4ba:	4b28      	ldr	r3, [pc, #160]	; (8e55c <vTaskSwitchContext+0x120>)
   8e4bc:	681b      	ldr	r3, [r3, #0]
   8e4be:	607b      	str	r3, [r7, #4]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
   8e4c0:	687b      	ldr	r3, [r7, #4]
   8e4c2:	fab3 f383 	clz	r3, r3
   8e4c6:	70fb      	strb	r3, [r7, #3]
		return ucReturn;
   8e4c8:	78fb      	ldrb	r3, [r7, #3]
   8e4ca:	f1c3 031f 	rsb	r3, r3, #31
   8e4ce:	60fb      	str	r3, [r7, #12]
   8e4d0:	4923      	ldr	r1, [pc, #140]	; (8e560 <vTaskSwitchContext+0x124>)
   8e4d2:	68fa      	ldr	r2, [r7, #12]
   8e4d4:	4613      	mov	r3, r2
   8e4d6:	009b      	lsls	r3, r3, #2
   8e4d8:	4413      	add	r3, r2
   8e4da:	009b      	lsls	r3, r3, #2
   8e4dc:	440b      	add	r3, r1
   8e4de:	681b      	ldr	r3, [r3, #0]
   8e4e0:	2b00      	cmp	r3, #0
   8e4e2:	d101      	bne.n	8e4e8 <vTaskSwitchContext+0xac>
   8e4e4:	4b1f      	ldr	r3, [pc, #124]	; (8e564 <vTaskSwitchContext+0x128>)
   8e4e6:	4798      	blx	r3
   8e4e8:	68fa      	ldr	r2, [r7, #12]
   8e4ea:	4613      	mov	r3, r2
   8e4ec:	009b      	lsls	r3, r3, #2
   8e4ee:	4413      	add	r3, r2
   8e4f0:	009b      	lsls	r3, r3, #2
   8e4f2:	4a1b      	ldr	r2, [pc, #108]	; (8e560 <vTaskSwitchContext+0x124>)
   8e4f4:	4413      	add	r3, r2
   8e4f6:	60bb      	str	r3, [r7, #8]
   8e4f8:	68bb      	ldr	r3, [r7, #8]
   8e4fa:	685b      	ldr	r3, [r3, #4]
   8e4fc:	685a      	ldr	r2, [r3, #4]
   8e4fe:	68bb      	ldr	r3, [r7, #8]
   8e500:	605a      	str	r2, [r3, #4]
   8e502:	68bb      	ldr	r3, [r7, #8]
   8e504:	685a      	ldr	r2, [r3, #4]
   8e506:	68bb      	ldr	r3, [r7, #8]
   8e508:	3308      	adds	r3, #8
   8e50a:	429a      	cmp	r2, r3
   8e50c:	d104      	bne.n	8e518 <vTaskSwitchContext+0xdc>
   8e50e:	68bb      	ldr	r3, [r7, #8]
   8e510:	685b      	ldr	r3, [r3, #4]
   8e512:	685a      	ldr	r2, [r3, #4]
   8e514:	68bb      	ldr	r3, [r7, #8]
   8e516:	605a      	str	r2, [r3, #4]
   8e518:	68bb      	ldr	r3, [r7, #8]
   8e51a:	685b      	ldr	r3, [r3, #4]
   8e51c:	68db      	ldr	r3, [r3, #12]
   8e51e:	4a0d      	ldr	r2, [pc, #52]	; (8e554 <vTaskSwitchContext+0x118>)
   8e520:	6013      	str	r3, [r2, #0]
		traceTASK_SWITCHED_IN();
   8e522:	4b09      	ldr	r3, [pc, #36]	; (8e548 <vTaskSwitchContext+0x10c>)
   8e524:	4798      	blx	r3
   8e526:	4604      	mov	r4, r0
   8e528:	4b08      	ldr	r3, [pc, #32]	; (8e54c <vTaskSwitchContext+0x110>)
   8e52a:	4798      	blx	r3
   8e52c:	4603      	mov	r3, r0
   8e52e:	429c      	cmp	r4, r3
   8e530:	d101      	bne.n	8e536 <vTaskSwitchContext+0xfa>
   8e532:	4b0d      	ldr	r3, [pc, #52]	; (8e568 <vTaskSwitchContext+0x12c>)
   8e534:	4798      	blx	r3
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   8e536:	bf00      	nop
   8e538:	371c      	adds	r7, #28
   8e53a:	46bd      	mov	sp, r7
   8e53c:	bd90      	pop	{r4, r7, pc}
   8e53e:	bf00      	nop
   8e540:	20071c3c 	.word	0x20071c3c
   8e544:	20071c2c 	.word	0x20071c2c
   8e548:	0008ecfd 	.word	0x0008ecfd
   8e54c:	0008e28d 	.word	0x0008e28d
   8e550:	00082fd5 	.word	0x00082fd5
   8e554:	20071b28 	.word	0x20071b28
   8e558:	00082f25 	.word	0x00082f25
   8e55c:	20071c20 	.word	0x20071c20
   8e560:	20071b2c 	.word	0x20071b2c
   8e564:	00082eed 	.word	0x00082eed
   8e568:	00082fc1 	.word	0x00082fc1

0008e56c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   8e56c:	b580      	push	{r7, lr}
   8e56e:	b084      	sub	sp, #16
   8e570:	af00      	add	r7, sp, #0
   8e572:	6078      	str	r0, [r7, #4]
   8e574:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;

	configASSERT( pxEventList );
   8e576:	687b      	ldr	r3, [r7, #4]
   8e578:	2b00      	cmp	r3, #0
   8e57a:	d101      	bne.n	8e580 <vTaskPlaceOnEventList+0x14>
   8e57c:	4b1a      	ldr	r3, [pc, #104]	; (8e5e8 <vTaskPlaceOnEventList+0x7c>)
   8e57e:	4798      	blx	r3

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   8e580:	4b1a      	ldr	r3, [pc, #104]	; (8e5ec <vTaskPlaceOnEventList+0x80>)
   8e582:	681b      	ldr	r3, [r3, #0]
   8e584:	3318      	adds	r3, #24
   8e586:	4619      	mov	r1, r3
   8e588:	6878      	ldr	r0, [r7, #4]
   8e58a:	4b19      	ldr	r3, [pc, #100]	; (8e5f0 <vTaskPlaceOnEventList+0x84>)
   8e58c:	4798      	blx	r3

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   8e58e:	4b17      	ldr	r3, [pc, #92]	; (8e5ec <vTaskPlaceOnEventList+0x80>)
   8e590:	681b      	ldr	r3, [r3, #0]
   8e592:	3304      	adds	r3, #4
   8e594:	4618      	mov	r0, r3
   8e596:	4b17      	ldr	r3, [pc, #92]	; (8e5f4 <vTaskPlaceOnEventList+0x88>)
   8e598:	4798      	blx	r3
   8e59a:	4603      	mov	r3, r0
   8e59c:	2b00      	cmp	r3, #0
   8e59e:	d10b      	bne.n	8e5b8 <vTaskPlaceOnEventList+0x4c>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   8e5a0:	4b12      	ldr	r3, [pc, #72]	; (8e5ec <vTaskPlaceOnEventList+0x80>)
   8e5a2:	681b      	ldr	r3, [r3, #0]
   8e5a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8e5a6:	2201      	movs	r2, #1
   8e5a8:	fa02 f303 	lsl.w	r3, r2, r3
   8e5ac:	43da      	mvns	r2, r3
   8e5ae:	4b12      	ldr	r3, [pc, #72]	; (8e5f8 <vTaskPlaceOnEventList+0x8c>)
   8e5b0:	681b      	ldr	r3, [r3, #0]
   8e5b2:	4013      	ands	r3, r2
   8e5b4:	4a10      	ldr	r2, [pc, #64]	; (8e5f8 <vTaskPlaceOnEventList+0x8c>)
   8e5b6:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
   8e5b8:	683b      	ldr	r3, [r7, #0]
   8e5ba:	f1b3 3fff 	cmp.w	r3, #4294967295
   8e5be:	d107      	bne.n	8e5d0 <vTaskPlaceOnEventList+0x64>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   8e5c0:	4b0a      	ldr	r3, [pc, #40]	; (8e5ec <vTaskPlaceOnEventList+0x80>)
   8e5c2:	681b      	ldr	r3, [r3, #0]
   8e5c4:	3304      	adds	r3, #4
   8e5c6:	4619      	mov	r1, r3
   8e5c8:	480c      	ldr	r0, [pc, #48]	; (8e5fc <vTaskPlaceOnEventList+0x90>)
   8e5ca:	4b0d      	ldr	r3, [pc, #52]	; (8e600 <vTaskPlaceOnEventList+0x94>)
   8e5cc:	4798      	blx	r3
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   8e5ce:	e007      	b.n	8e5e0 <vTaskPlaceOnEventList+0x74>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
   8e5d0:	4b0c      	ldr	r3, [pc, #48]	; (8e604 <vTaskPlaceOnEventList+0x98>)
   8e5d2:	681a      	ldr	r2, [r3, #0]
   8e5d4:	683b      	ldr	r3, [r7, #0]
   8e5d6:	4413      	add	r3, r2
   8e5d8:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
   8e5da:	68f8      	ldr	r0, [r7, #12]
   8e5dc:	4b0a      	ldr	r3, [pc, #40]	; (8e608 <vTaskPlaceOnEventList+0x9c>)
   8e5de:	4798      	blx	r3
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   8e5e0:	bf00      	nop
   8e5e2:	3710      	adds	r7, #16
   8e5e4:	46bd      	mov	sp, r7
   8e5e6:	bd80      	pop	{r7, pc}
   8e5e8:	00082eed 	.word	0x00082eed
   8e5ec:	20071b28 	.word	0x20071b28
   8e5f0:	000905f9 	.word	0x000905f9
   8e5f4:	00090669 	.word	0x00090669
   8e5f8:	20071c20 	.word	0x20071c20
   8e5fc:	20071c00 	.word	0x20071c00
   8e600:	000905b1 	.word	0x000905b1
   8e604:	20071c1c 	.word	0x20071c1c
   8e608:	0008ea55 	.word	0x0008ea55

0008e60c <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
   8e60c:	b580      	push	{r7, lr}
   8e60e:	b086      	sub	sp, #24
   8e610:	af00      	add	r7, sp, #0
   8e612:	60f8      	str	r0, [r7, #12]
   8e614:	60b9      	str	r1, [r7, #8]
   8e616:	607a      	str	r2, [r7, #4]
	TickType_t xTimeToWake;

		configASSERT( pxEventList );
   8e618:	68fb      	ldr	r3, [r7, #12]
   8e61a:	2b00      	cmp	r3, #0
   8e61c:	d101      	bne.n	8e622 <vTaskPlaceOnEventListRestricted+0x16>
   8e61e:	4b1a      	ldr	r3, [pc, #104]	; (8e688 <vTaskPlaceOnEventListRestricted+0x7c>)
   8e620:	4798      	blx	r3

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   8e622:	4b1a      	ldr	r3, [pc, #104]	; (8e68c <vTaskPlaceOnEventListRestricted+0x80>)
   8e624:	681b      	ldr	r3, [r3, #0]
   8e626:	3318      	adds	r3, #24
   8e628:	4619      	mov	r1, r3
   8e62a:	68f8      	ldr	r0, [r7, #12]
   8e62c:	4b18      	ldr	r3, [pc, #96]	; (8e690 <vTaskPlaceOnEventListRestricted+0x84>)
   8e62e:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called with the scheduler locked so interrupts will not
		access the lists at the same time. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   8e630:	4b16      	ldr	r3, [pc, #88]	; (8e68c <vTaskPlaceOnEventListRestricted+0x80>)
   8e632:	681b      	ldr	r3, [r3, #0]
   8e634:	3304      	adds	r3, #4
   8e636:	4618      	mov	r0, r3
   8e638:	4b16      	ldr	r3, [pc, #88]	; (8e694 <vTaskPlaceOnEventListRestricted+0x88>)
   8e63a:	4798      	blx	r3
   8e63c:	4603      	mov	r3, r0
   8e63e:	2b00      	cmp	r3, #0
   8e640:	d10b      	bne.n	8e65a <vTaskPlaceOnEventListRestricted+0x4e>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   8e642:	4b12      	ldr	r3, [pc, #72]	; (8e68c <vTaskPlaceOnEventListRestricted+0x80>)
   8e644:	681b      	ldr	r3, [r3, #0]
   8e646:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8e648:	2201      	movs	r2, #1
   8e64a:	fa02 f303 	lsl.w	r3, r2, r3
   8e64e:	43da      	mvns	r2, r3
   8e650:	4b11      	ldr	r3, [pc, #68]	; (8e698 <vTaskPlaceOnEventListRestricted+0x8c>)
   8e652:	681b      	ldr	r3, [r3, #0]
   8e654:	4013      	ands	r3, r2
   8e656:	4a10      	ldr	r2, [pc, #64]	; (8e698 <vTaskPlaceOnEventListRestricted+0x8c>)
   8e658:	6013      	str	r3, [r2, #0]
		Ready state when the event it is waiting indefinitely for occurs).
		Blocking indefinitely is useful when using tickless idle mode as when
		all tasks are blocked indefinitely all timers can be turned off. */
		#if( INCLUDE_vTaskSuspend == 1 )
		{
			if( xWaitIndefinitely == pdTRUE )
   8e65a:	687b      	ldr	r3, [r7, #4]
   8e65c:	2b01      	cmp	r3, #1
   8e65e:	d107      	bne.n	8e670 <vTaskPlaceOnEventListRestricted+0x64>
			{
				/* Add the task to the suspended task list instead of a delayed
				task list to ensure the task is not woken by a timing event.  It
				will block indefinitely. */
				vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   8e660:	4b0a      	ldr	r3, [pc, #40]	; (8e68c <vTaskPlaceOnEventListRestricted+0x80>)
   8e662:	681b      	ldr	r3, [r3, #0]
   8e664:	3304      	adds	r3, #4
   8e666:	4619      	mov	r1, r3
   8e668:	480c      	ldr	r0, [pc, #48]	; (8e69c <vTaskPlaceOnEventListRestricted+0x90>)
   8e66a:	4b09      	ldr	r3, [pc, #36]	; (8e690 <vTaskPlaceOnEventListRestricted+0x84>)
   8e66c:	4798      	blx	r3
			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
			defined. */
			( void ) xWaitIndefinitely;
		}
		#endif
	}
   8e66e:	e007      	b.n	8e680 <vTaskPlaceOnEventListRestricted+0x74>
			else
			{
				/* Calculate the time at which the task should be woken if the
				event does not occur.  This may overflow but this doesn't
				matter. */
				xTimeToWake = xTickCount + xTicksToWait;
   8e670:	4b0b      	ldr	r3, [pc, #44]	; (8e6a0 <vTaskPlaceOnEventListRestricted+0x94>)
   8e672:	681a      	ldr	r2, [r3, #0]
   8e674:	68bb      	ldr	r3, [r7, #8]
   8e676:	4413      	add	r3, r2
   8e678:	617b      	str	r3, [r7, #20]
				traceTASK_DELAY_UNTIL();
				prvAddCurrentTaskToDelayedList( xTimeToWake );
   8e67a:	6978      	ldr	r0, [r7, #20]
   8e67c:	4b09      	ldr	r3, [pc, #36]	; (8e6a4 <vTaskPlaceOnEventListRestricted+0x98>)
   8e67e:	4798      	blx	r3
			/* Remove compiler warnings when INCLUDE_vTaskSuspend() is not
			defined. */
			( void ) xWaitIndefinitely;
		}
		#endif
	}
   8e680:	bf00      	nop
   8e682:	3718      	adds	r7, #24
   8e684:	46bd      	mov	sp, r7
   8e686:	bd80      	pop	{r7, pc}
   8e688:	00082eed 	.word	0x00082eed
   8e68c:	20071b28 	.word	0x20071b28
   8e690:	000905b1 	.word	0x000905b1
   8e694:	00090669 	.word	0x00090669
   8e698:	20071c20 	.word	0x20071c20
   8e69c:	20071c00 	.word	0x20071c00
   8e6a0:	20071c1c 	.word	0x20071c1c
   8e6a4:	0008ea55 	.word	0x0008ea55

0008e6a8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   8e6a8:	b580      	push	{r7, lr}
   8e6aa:	b084      	sub	sp, #16
   8e6ac:	af00      	add	r7, sp, #0
   8e6ae:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   8e6b0:	687b      	ldr	r3, [r7, #4]
   8e6b2:	68db      	ldr	r3, [r3, #12]
   8e6b4:	68db      	ldr	r3, [r3, #12]
   8e6b6:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
   8e6b8:	68bb      	ldr	r3, [r7, #8]
   8e6ba:	2b00      	cmp	r3, #0
   8e6bc:	d101      	bne.n	8e6c2 <xTaskRemoveFromEventList+0x1a>
   8e6be:	4b21      	ldr	r3, [pc, #132]	; (8e744 <xTaskRemoveFromEventList+0x9c>)
   8e6c0:	4798      	blx	r3
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   8e6c2:	68bb      	ldr	r3, [r7, #8]
   8e6c4:	3318      	adds	r3, #24
   8e6c6:	4618      	mov	r0, r3
   8e6c8:	4b1f      	ldr	r3, [pc, #124]	; (8e748 <xTaskRemoveFromEventList+0xa0>)
   8e6ca:	4798      	blx	r3

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   8e6cc:	4b1f      	ldr	r3, [pc, #124]	; (8e74c <xTaskRemoveFromEventList+0xa4>)
   8e6ce:	681b      	ldr	r3, [r3, #0]
   8e6d0:	2b00      	cmp	r3, #0
   8e6d2:	d11c      	bne.n	8e70e <xTaskRemoveFromEventList+0x66>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   8e6d4:	68bb      	ldr	r3, [r7, #8]
   8e6d6:	3304      	adds	r3, #4
   8e6d8:	4618      	mov	r0, r3
   8e6da:	4b1b      	ldr	r3, [pc, #108]	; (8e748 <xTaskRemoveFromEventList+0xa0>)
   8e6dc:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
   8e6de:	68bb      	ldr	r3, [r7, #8]
   8e6e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8e6e2:	2201      	movs	r2, #1
   8e6e4:	409a      	lsls	r2, r3
   8e6e6:	4b1a      	ldr	r3, [pc, #104]	; (8e750 <xTaskRemoveFromEventList+0xa8>)
   8e6e8:	681b      	ldr	r3, [r3, #0]
   8e6ea:	4313      	orrs	r3, r2
   8e6ec:	4a18      	ldr	r2, [pc, #96]	; (8e750 <xTaskRemoveFromEventList+0xa8>)
   8e6ee:	6013      	str	r3, [r2, #0]
   8e6f0:	68bb      	ldr	r3, [r7, #8]
   8e6f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8e6f4:	4613      	mov	r3, r2
   8e6f6:	009b      	lsls	r3, r3, #2
   8e6f8:	4413      	add	r3, r2
   8e6fa:	009b      	lsls	r3, r3, #2
   8e6fc:	4a15      	ldr	r2, [pc, #84]	; (8e754 <xTaskRemoveFromEventList+0xac>)
   8e6fe:	441a      	add	r2, r3
   8e700:	68bb      	ldr	r3, [r7, #8]
   8e702:	3304      	adds	r3, #4
   8e704:	4619      	mov	r1, r3
   8e706:	4610      	mov	r0, r2
   8e708:	4b13      	ldr	r3, [pc, #76]	; (8e758 <xTaskRemoveFromEventList+0xb0>)
   8e70a:	4798      	blx	r3
   8e70c:	e005      	b.n	8e71a <xTaskRemoveFromEventList+0x72>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   8e70e:	68bb      	ldr	r3, [r7, #8]
   8e710:	3318      	adds	r3, #24
   8e712:	4619      	mov	r1, r3
   8e714:	4811      	ldr	r0, [pc, #68]	; (8e75c <xTaskRemoveFromEventList+0xb4>)
   8e716:	4b10      	ldr	r3, [pc, #64]	; (8e758 <xTaskRemoveFromEventList+0xb0>)
   8e718:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   8e71a:	68bb      	ldr	r3, [r7, #8]
   8e71c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8e71e:	4b10      	ldr	r3, [pc, #64]	; (8e760 <xTaskRemoveFromEventList+0xb8>)
   8e720:	681b      	ldr	r3, [r3, #0]
   8e722:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8e724:	429a      	cmp	r2, r3
   8e726:	d905      	bls.n	8e734 <xTaskRemoveFromEventList+0x8c>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   8e728:	2301      	movs	r3, #1
   8e72a:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   8e72c:	4b0d      	ldr	r3, [pc, #52]	; (8e764 <xTaskRemoveFromEventList+0xbc>)
   8e72e:	2201      	movs	r2, #1
   8e730:	601a      	str	r2, [r3, #0]
   8e732:	e001      	b.n	8e738 <xTaskRemoveFromEventList+0x90>
	}
	else
	{
		xReturn = pdFALSE;
   8e734:	2300      	movs	r3, #0
   8e736:	60fb      	str	r3, [r7, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
   8e738:	68fb      	ldr	r3, [r7, #12]
}
   8e73a:	4618      	mov	r0, r3
   8e73c:	3710      	adds	r7, #16
   8e73e:	46bd      	mov	sp, r7
   8e740:	bd80      	pop	{r7, pc}
   8e742:	bf00      	nop
   8e744:	00082eed 	.word	0x00082eed
   8e748:	00090669 	.word	0x00090669
   8e74c:	20071c3c 	.word	0x20071c3c
   8e750:	20071c20 	.word	0x20071c20
   8e754:	20071b2c 	.word	0x20071b2c
   8e758:	000905b1 	.word	0x000905b1
   8e75c:	20071bd4 	.word	0x20071bd4
   8e760:	20071b28 	.word	0x20071b28
   8e764:	20071c2c 	.word	0x20071c2c

0008e768 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   8e768:	b580      	push	{r7, lr}
   8e76a:	b082      	sub	sp, #8
   8e76c:	af00      	add	r7, sp, #0
   8e76e:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
   8e770:	687b      	ldr	r3, [r7, #4]
   8e772:	2b00      	cmp	r3, #0
   8e774:	d101      	bne.n	8e77a <vTaskSetTimeOutState+0x12>
   8e776:	4b07      	ldr	r3, [pc, #28]	; (8e794 <vTaskSetTimeOutState+0x2c>)
   8e778:	4798      	blx	r3
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   8e77a:	4b07      	ldr	r3, [pc, #28]	; (8e798 <vTaskSetTimeOutState+0x30>)
   8e77c:	681a      	ldr	r2, [r3, #0]
   8e77e:	687b      	ldr	r3, [r7, #4]
   8e780:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   8e782:	4b06      	ldr	r3, [pc, #24]	; (8e79c <vTaskSetTimeOutState+0x34>)
   8e784:	681a      	ldr	r2, [r3, #0]
   8e786:	687b      	ldr	r3, [r7, #4]
   8e788:	605a      	str	r2, [r3, #4]
}
   8e78a:	bf00      	nop
   8e78c:	3708      	adds	r7, #8
   8e78e:	46bd      	mov	sp, r7
   8e790:	bd80      	pop	{r7, pc}
   8e792:	bf00      	nop
   8e794:	00082eed 	.word	0x00082eed
   8e798:	20071c30 	.word	0x20071c30
   8e79c:	20071c1c 	.word	0x20071c1c

0008e7a0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   8e7a0:	b580      	push	{r7, lr}
   8e7a2:	b084      	sub	sp, #16
   8e7a4:	af00      	add	r7, sp, #0
   8e7a6:	6078      	str	r0, [r7, #4]
   8e7a8:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
   8e7aa:	687b      	ldr	r3, [r7, #4]
   8e7ac:	2b00      	cmp	r3, #0
   8e7ae:	d101      	bne.n	8e7b4 <xTaskCheckForTimeOut+0x14>
   8e7b0:	4b20      	ldr	r3, [pc, #128]	; (8e834 <xTaskCheckForTimeOut+0x94>)
   8e7b2:	4798      	blx	r3
	configASSERT( pxTicksToWait );
   8e7b4:	683b      	ldr	r3, [r7, #0]
   8e7b6:	2b00      	cmp	r3, #0
   8e7b8:	d101      	bne.n	8e7be <xTaskCheckForTimeOut+0x1e>
   8e7ba:	4b1e      	ldr	r3, [pc, #120]	; (8e834 <xTaskCheckForTimeOut+0x94>)
   8e7bc:	4798      	blx	r3

	taskENTER_CRITICAL();
   8e7be:	4b1e      	ldr	r3, [pc, #120]	; (8e838 <xTaskCheckForTimeOut+0x98>)
   8e7c0:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   8e7c2:	4b1e      	ldr	r3, [pc, #120]	; (8e83c <xTaskCheckForTimeOut+0x9c>)
   8e7c4:	681b      	ldr	r3, [r3, #0]
   8e7c6:	60bb      	str	r3, [r7, #8]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
   8e7c8:	683b      	ldr	r3, [r7, #0]
   8e7ca:	681b      	ldr	r3, [r3, #0]
   8e7cc:	f1b3 3fff 	cmp.w	r3, #4294967295
   8e7d0:	d102      	bne.n	8e7d8 <xTaskCheckForTimeOut+0x38>
			{
				xReturn = pdFALSE;
   8e7d2:	2300      	movs	r3, #0
   8e7d4:	60fb      	str	r3, [r7, #12]
   8e7d6:	e026      	b.n	8e826 <xTaskCheckForTimeOut+0x86>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   8e7d8:	687b      	ldr	r3, [r7, #4]
   8e7da:	681a      	ldr	r2, [r3, #0]
   8e7dc:	4b18      	ldr	r3, [pc, #96]	; (8e840 <xTaskCheckForTimeOut+0xa0>)
   8e7de:	681b      	ldr	r3, [r3, #0]
   8e7e0:	429a      	cmp	r2, r3
   8e7e2:	d007      	beq.n	8e7f4 <xTaskCheckForTimeOut+0x54>
   8e7e4:	687b      	ldr	r3, [r7, #4]
   8e7e6:	685a      	ldr	r2, [r3, #4]
   8e7e8:	68bb      	ldr	r3, [r7, #8]
   8e7ea:	429a      	cmp	r2, r3
   8e7ec:	d802      	bhi.n	8e7f4 <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
   8e7ee:	2301      	movs	r3, #1
   8e7f0:	60fb      	str	r3, [r7, #12]
   8e7f2:	e018      	b.n	8e826 <xTaskCheckForTimeOut+0x86>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
   8e7f4:	687b      	ldr	r3, [r7, #4]
   8e7f6:	685b      	ldr	r3, [r3, #4]
   8e7f8:	68ba      	ldr	r2, [r7, #8]
   8e7fa:	1ad2      	subs	r2, r2, r3
   8e7fc:	683b      	ldr	r3, [r7, #0]
   8e7fe:	681b      	ldr	r3, [r3, #0]
   8e800:	429a      	cmp	r2, r3
   8e802:	d20e      	bcs.n	8e822 <xTaskCheckForTimeOut+0x82>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
   8e804:	683b      	ldr	r3, [r7, #0]
   8e806:	681a      	ldr	r2, [r3, #0]
   8e808:	687b      	ldr	r3, [r7, #4]
   8e80a:	6859      	ldr	r1, [r3, #4]
   8e80c:	68bb      	ldr	r3, [r7, #8]
   8e80e:	1acb      	subs	r3, r1, r3
   8e810:	441a      	add	r2, r3
   8e812:	683b      	ldr	r3, [r7, #0]
   8e814:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
   8e816:	6878      	ldr	r0, [r7, #4]
   8e818:	4b0a      	ldr	r3, [pc, #40]	; (8e844 <xTaskCheckForTimeOut+0xa4>)
   8e81a:	4798      	blx	r3
			xReturn = pdFALSE;
   8e81c:	2300      	movs	r3, #0
   8e81e:	60fb      	str	r3, [r7, #12]
   8e820:	e001      	b.n	8e826 <xTaskCheckForTimeOut+0x86>
		}
		else
		{
			xReturn = pdTRUE;
   8e822:	2301      	movs	r3, #1
   8e824:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   8e826:	4b08      	ldr	r3, [pc, #32]	; (8e848 <xTaskCheckForTimeOut+0xa8>)
   8e828:	4798      	blx	r3

	return xReturn;
   8e82a:	68fb      	ldr	r3, [r7, #12]
}
   8e82c:	4618      	mov	r0, r3
   8e82e:	3710      	adds	r7, #16
   8e830:	46bd      	mov	sp, r7
   8e832:	bd80      	pop	{r7, pc}
   8e834:	00082eed 	.word	0x00082eed
   8e838:	0009088d 	.word	0x0009088d
   8e83c:	20071c1c 	.word	0x20071c1c
   8e840:	20071c30 	.word	0x20071c30
   8e844:	0008e769 	.word	0x0008e769
   8e848:	000908d1 	.word	0x000908d1

0008e84c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
   8e84c:	b480      	push	{r7}
   8e84e:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
   8e850:	4b03      	ldr	r3, [pc, #12]	; (8e860 <vTaskMissedYield+0x14>)
   8e852:	2201      	movs	r2, #1
   8e854:	601a      	str	r2, [r3, #0]
}
   8e856:	bf00      	nop
   8e858:	46bd      	mov	sp, r7
   8e85a:	bc80      	pop	{r7}
   8e85c:	4770      	bx	lr
   8e85e:	bf00      	nop
   8e860:	20071c2c 	.word	0x20071c2c

0008e864 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   8e864:	b580      	push	{r7, lr}
   8e866:	b082      	sub	sp, #8
   8e868:	af00      	add	r7, sp, #0
   8e86a:	6078      	str	r0, [r7, #4]
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
   8e86c:	4b05      	ldr	r3, [pc, #20]	; (8e884 <prvIdleTask+0x20>)
   8e86e:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   8e870:	4b05      	ldr	r3, [pc, #20]	; (8e888 <prvIdleTask+0x24>)
   8e872:	681b      	ldr	r3, [r3, #0]
   8e874:	2b01      	cmp	r3, #1
   8e876:	d901      	bls.n	8e87c <prvIdleTask+0x18>
			{
				taskYIELD();
   8e878:	4b04      	ldr	r3, [pc, #16]	; (8e88c <prvIdleTask+0x28>)
   8e87a:	4798      	blx	r3
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
   8e87c:	4b04      	ldr	r3, [pc, #16]	; (8e890 <prvIdleTask+0x2c>)
   8e87e:	4798      	blx	r3
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
   8e880:	e7f4      	b.n	8e86c <prvIdleTask+0x8>
   8e882:	bf00      	nop
   8e884:	0008e9c5 	.word	0x0008e9c5
   8e888:	20071b2c 	.word	0x20071b2c
   8e88c:	0009086d 	.word	0x0009086d
   8e890:	00082f15 	.word	0x00082f15

0008e894 <prvInitialiseTCBVariables>:

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   8e894:	b580      	push	{r7, lr}
   8e896:	b086      	sub	sp, #24
   8e898:	af00      	add	r7, sp, #0
   8e89a:	60f8      	str	r0, [r7, #12]
   8e89c:	60b9      	str	r1, [r7, #8]
   8e89e:	607a      	str	r2, [r7, #4]
   8e8a0:	603b      	str	r3, [r7, #0]
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   8e8a2:	2300      	movs	r3, #0
   8e8a4:	617b      	str	r3, [r7, #20]
   8e8a6:	e012      	b.n	8e8ce <prvInitialiseTCBVariables+0x3a>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
   8e8a8:	68ba      	ldr	r2, [r7, #8]
   8e8aa:	697b      	ldr	r3, [r7, #20]
   8e8ac:	4413      	add	r3, r2
   8e8ae:	7819      	ldrb	r1, [r3, #0]
   8e8b0:	68fa      	ldr	r2, [r7, #12]
   8e8b2:	697b      	ldr	r3, [r7, #20]
   8e8b4:	4413      	add	r3, r2
   8e8b6:	3334      	adds	r3, #52	; 0x34
   8e8b8:	460a      	mov	r2, r1
   8e8ba:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
   8e8bc:	68ba      	ldr	r2, [r7, #8]
   8e8be:	697b      	ldr	r3, [r7, #20]
   8e8c0:	4413      	add	r3, r2
   8e8c2:	781b      	ldrb	r3, [r3, #0]
   8e8c4:	2b00      	cmp	r3, #0
   8e8c6:	d006      	beq.n	8e8d6 <prvInitialiseTCBVariables+0x42>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   8e8c8:	697b      	ldr	r3, [r7, #20]
   8e8ca:	3301      	adds	r3, #1
   8e8cc:	617b      	str	r3, [r7, #20]
   8e8ce:	697b      	ldr	r3, [r7, #20]
   8e8d0:	2b09      	cmp	r3, #9
   8e8d2:	d9e9      	bls.n	8e8a8 <prvInitialiseTCBVariables+0x14>
   8e8d4:	e000      	b.n	8e8d8 <prvInitialiseTCBVariables+0x44>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
   8e8d6:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   8e8d8:	68fb      	ldr	r3, [r7, #12]
   8e8da:	2200      	movs	r2, #0
   8e8dc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   8e8e0:	687b      	ldr	r3, [r7, #4]
   8e8e2:	2b05      	cmp	r3, #5
   8e8e4:	d901      	bls.n	8e8ea <prvInitialiseTCBVariables+0x56>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   8e8e6:	2305      	movs	r3, #5
   8e8e8:	607b      	str	r3, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
   8e8ea:	68fb      	ldr	r3, [r7, #12]
   8e8ec:	687a      	ldr	r2, [r7, #4]
   8e8ee:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
   8e8f0:	68fb      	ldr	r3, [r7, #12]
   8e8f2:	687a      	ldr	r2, [r7, #4]
   8e8f4:	649a      	str	r2, [r3, #72]	; 0x48
		pxTCB->uxMutexesHeld = 0;
   8e8f6:	68fb      	ldr	r3, [r7, #12]
   8e8f8:	2200      	movs	r2, #0
   8e8fa:	64da      	str	r2, [r3, #76]	; 0x4c
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   8e8fc:	68fb      	ldr	r3, [r7, #12]
   8e8fe:	3304      	adds	r3, #4
   8e900:	4618      	mov	r0, r3
   8e902:	4b0e      	ldr	r3, [pc, #56]	; (8e93c <prvInitialiseTCBVariables+0xa8>)
   8e904:	4798      	blx	r3
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   8e906:	68fb      	ldr	r3, [r7, #12]
   8e908:	3318      	adds	r3, #24
   8e90a:	4618      	mov	r0, r3
   8e90c:	4b0b      	ldr	r3, [pc, #44]	; (8e93c <prvInitialiseTCBVariables+0xa8>)
   8e90e:	4798      	blx	r3

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   8e910:	68fb      	ldr	r3, [r7, #12]
   8e912:	68fa      	ldr	r2, [r7, #12]
   8e914:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   8e916:	687b      	ldr	r3, [r7, #4]
   8e918:	f1c3 0206 	rsb	r2, r3, #6
   8e91c:	68fb      	ldr	r3, [r7, #12]
   8e91e:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   8e920:	68fb      	ldr	r3, [r7, #12]
   8e922:	68fa      	ldr	r2, [r7, #12]
   8e924:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
   8e926:	68fb      	ldr	r3, [r7, #12]
   8e928:	2200      	movs	r2, #0
   8e92a:	651a      	str	r2, [r3, #80]	; 0x50
		pxTCB->eNotifyState = eNotWaitingNotification;
   8e92c:	68fb      	ldr	r3, [r7, #12]
   8e92e:	2200      	movs	r2, #0
   8e930:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
   8e934:	bf00      	nop
   8e936:	3718      	adds	r7, #24
   8e938:	46bd      	mov	sp, r7
   8e93a:	bd80      	pop	{r7, pc}
   8e93c:	00090599 	.word	0x00090599

0008e940 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   8e940:	b580      	push	{r7, lr}
   8e942:	b082      	sub	sp, #8
   8e944:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   8e946:	2300      	movs	r3, #0
   8e948:	607b      	str	r3, [r7, #4]
   8e94a:	e00c      	b.n	8e966 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   8e94c:	687a      	ldr	r2, [r7, #4]
   8e94e:	4613      	mov	r3, r2
   8e950:	009b      	lsls	r3, r3, #2
   8e952:	4413      	add	r3, r2
   8e954:	009b      	lsls	r3, r3, #2
   8e956:	4a12      	ldr	r2, [pc, #72]	; (8e9a0 <prvInitialiseTaskLists+0x60>)
   8e958:	4413      	add	r3, r2
   8e95a:	4618      	mov	r0, r3
   8e95c:	4b11      	ldr	r3, [pc, #68]	; (8e9a4 <prvInitialiseTaskLists+0x64>)
   8e95e:	4798      	blx	r3

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   8e960:	687b      	ldr	r3, [r7, #4]
   8e962:	3301      	adds	r3, #1
   8e964:	607b      	str	r3, [r7, #4]
   8e966:	687b      	ldr	r3, [r7, #4]
   8e968:	2b05      	cmp	r3, #5
   8e96a:	d9ef      	bls.n	8e94c <prvInitialiseTaskLists+0xc>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
   8e96c:	480e      	ldr	r0, [pc, #56]	; (8e9a8 <prvInitialiseTaskLists+0x68>)
   8e96e:	4b0d      	ldr	r3, [pc, #52]	; (8e9a4 <prvInitialiseTaskLists+0x64>)
   8e970:	4798      	blx	r3
	vListInitialise( &xDelayedTaskList2 );
   8e972:	480e      	ldr	r0, [pc, #56]	; (8e9ac <prvInitialiseTaskLists+0x6c>)
   8e974:	4b0b      	ldr	r3, [pc, #44]	; (8e9a4 <prvInitialiseTaskLists+0x64>)
   8e976:	4798      	blx	r3
	vListInitialise( &xPendingReadyList );
   8e978:	480d      	ldr	r0, [pc, #52]	; (8e9b0 <prvInitialiseTaskLists+0x70>)
   8e97a:	4b0a      	ldr	r3, [pc, #40]	; (8e9a4 <prvInitialiseTaskLists+0x64>)
   8e97c:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   8e97e:	480d      	ldr	r0, [pc, #52]	; (8e9b4 <prvInitialiseTaskLists+0x74>)
   8e980:	4b08      	ldr	r3, [pc, #32]	; (8e9a4 <prvInitialiseTaskLists+0x64>)
   8e982:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   8e984:	480c      	ldr	r0, [pc, #48]	; (8e9b8 <prvInitialiseTaskLists+0x78>)
   8e986:	4b07      	ldr	r3, [pc, #28]	; (8e9a4 <prvInitialiseTaskLists+0x64>)
   8e988:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   8e98a:	4b0c      	ldr	r3, [pc, #48]	; (8e9bc <prvInitialiseTaskLists+0x7c>)
   8e98c:	4a06      	ldr	r2, [pc, #24]	; (8e9a8 <prvInitialiseTaskLists+0x68>)
   8e98e:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   8e990:	4b0b      	ldr	r3, [pc, #44]	; (8e9c0 <prvInitialiseTaskLists+0x80>)
   8e992:	4a06      	ldr	r2, [pc, #24]	; (8e9ac <prvInitialiseTaskLists+0x6c>)
   8e994:	601a      	str	r2, [r3, #0]
}
   8e996:	bf00      	nop
   8e998:	3708      	adds	r7, #8
   8e99a:	46bd      	mov	sp, r7
   8e99c:	bd80      	pop	{r7, pc}
   8e99e:	bf00      	nop
   8e9a0:	20071b2c 	.word	0x20071b2c
   8e9a4:	00090559 	.word	0x00090559
   8e9a8:	20071ba4 	.word	0x20071ba4
   8e9ac:	20071bb8 	.word	0x20071bb8
   8e9b0:	20071bd4 	.word	0x20071bd4
   8e9b4:	20071be8 	.word	0x20071be8
   8e9b8:	20071c00 	.word	0x20071c00
   8e9bc:	20071bcc 	.word	0x20071bcc
   8e9c0:	20071bd0 	.word	0x20071bd0

0008e9c4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   8e9c4:	b580      	push	{r7, lr}
   8e9c6:	b082      	sub	sp, #8
   8e9c8:	af00      	add	r7, sp, #0
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
   8e9ca:	e028      	b.n	8ea1e <prvCheckTasksWaitingTermination+0x5a>
		{
			vTaskSuspendAll();
   8e9cc:	4b18      	ldr	r3, [pc, #96]	; (8ea30 <prvCheckTasksWaitingTermination+0x6c>)
   8e9ce:	4798      	blx	r3
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   8e9d0:	4b18      	ldr	r3, [pc, #96]	; (8ea34 <prvCheckTasksWaitingTermination+0x70>)
   8e9d2:	681b      	ldr	r3, [r3, #0]
   8e9d4:	2b00      	cmp	r3, #0
   8e9d6:	bf0c      	ite	eq
   8e9d8:	2301      	moveq	r3, #1
   8e9da:	2300      	movne	r3, #0
   8e9dc:	b2db      	uxtb	r3, r3
   8e9de:	607b      	str	r3, [r7, #4]
			}
			( void ) xTaskResumeAll();
   8e9e0:	4b15      	ldr	r3, [pc, #84]	; (8ea38 <prvCheckTasksWaitingTermination+0x74>)
   8e9e2:	4798      	blx	r3

			if( xListIsEmpty == pdFALSE )
   8e9e4:	687b      	ldr	r3, [r7, #4]
   8e9e6:	2b00      	cmp	r3, #0
   8e9e8:	d119      	bne.n	8ea1e <prvCheckTasksWaitingTermination+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
   8e9ea:	4b14      	ldr	r3, [pc, #80]	; (8ea3c <prvCheckTasksWaitingTermination+0x78>)
   8e9ec:	4798      	blx	r3
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   8e9ee:	4b11      	ldr	r3, [pc, #68]	; (8ea34 <prvCheckTasksWaitingTermination+0x70>)
   8e9f0:	68db      	ldr	r3, [r3, #12]
   8e9f2:	68db      	ldr	r3, [r3, #12]
   8e9f4:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   8e9f6:	683b      	ldr	r3, [r7, #0]
   8e9f8:	3304      	adds	r3, #4
   8e9fa:	4618      	mov	r0, r3
   8e9fc:	4b10      	ldr	r3, [pc, #64]	; (8ea40 <prvCheckTasksWaitingTermination+0x7c>)
   8e9fe:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
   8ea00:	4b10      	ldr	r3, [pc, #64]	; (8ea44 <prvCheckTasksWaitingTermination+0x80>)
   8ea02:	681b      	ldr	r3, [r3, #0]
   8ea04:	3b01      	subs	r3, #1
   8ea06:	4a0f      	ldr	r2, [pc, #60]	; (8ea44 <prvCheckTasksWaitingTermination+0x80>)
   8ea08:	6013      	str	r3, [r2, #0]
					--uxTasksDeleted;
   8ea0a:	4b0f      	ldr	r3, [pc, #60]	; (8ea48 <prvCheckTasksWaitingTermination+0x84>)
   8ea0c:	681b      	ldr	r3, [r3, #0]
   8ea0e:	3b01      	subs	r3, #1
   8ea10:	4a0d      	ldr	r2, [pc, #52]	; (8ea48 <prvCheckTasksWaitingTermination+0x84>)
   8ea12:	6013      	str	r3, [r2, #0]
				}
				taskEXIT_CRITICAL();
   8ea14:	4b0d      	ldr	r3, [pc, #52]	; (8ea4c <prvCheckTasksWaitingTermination+0x88>)
   8ea16:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
   8ea18:	6838      	ldr	r0, [r7, #0]
   8ea1a:	4b0d      	ldr	r3, [pc, #52]	; (8ea50 <prvCheckTasksWaitingTermination+0x8c>)
   8ea1c:	4798      	blx	r3
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
   8ea1e:	4b0a      	ldr	r3, [pc, #40]	; (8ea48 <prvCheckTasksWaitingTermination+0x84>)
   8ea20:	681b      	ldr	r3, [r3, #0]
   8ea22:	2b00      	cmp	r3, #0
   8ea24:	d1d2      	bne.n	8e9cc <prvCheckTasksWaitingTermination+0x8>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
   8ea26:	bf00      	nop
   8ea28:	3708      	adds	r7, #8
   8ea2a:	46bd      	mov	sp, r7
   8ea2c:	bd80      	pop	{r7, pc}
   8ea2e:	bf00      	nop
   8ea30:	0008e031 	.word	0x0008e031
   8ea34:	20071be8 	.word	0x20071be8
   8ea38:	0008e04d 	.word	0x0008e04d
   8ea3c:	0009088d 	.word	0x0009088d
   8ea40:	00090669 	.word	0x00090669
   8ea44:	20071c18 	.word	0x20071c18
   8ea48:	20071bfc 	.word	0x20071bfc
   8ea4c:	000908d1 	.word	0x000908d1
   8ea50:	0008ec91 	.word	0x0008ec91

0008ea54 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
   8ea54:	b580      	push	{r7, lr}
   8ea56:	b082      	sub	sp, #8
   8ea58:	af00      	add	r7, sp, #0
   8ea5a:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   8ea5c:	4b13      	ldr	r3, [pc, #76]	; (8eaac <prvAddCurrentTaskToDelayedList+0x58>)
   8ea5e:	681b      	ldr	r3, [r3, #0]
   8ea60:	687a      	ldr	r2, [r7, #4]
   8ea62:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
   8ea64:	4b12      	ldr	r3, [pc, #72]	; (8eab0 <prvAddCurrentTaskToDelayedList+0x5c>)
   8ea66:	681b      	ldr	r3, [r3, #0]
   8ea68:	687a      	ldr	r2, [r7, #4]
   8ea6a:	429a      	cmp	r2, r3
   8ea6c:	d209      	bcs.n	8ea82 <prvAddCurrentTaskToDelayedList+0x2e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   8ea6e:	4b11      	ldr	r3, [pc, #68]	; (8eab4 <prvAddCurrentTaskToDelayedList+0x60>)
   8ea70:	681a      	ldr	r2, [r3, #0]
   8ea72:	4b0e      	ldr	r3, [pc, #56]	; (8eaac <prvAddCurrentTaskToDelayedList+0x58>)
   8ea74:	681b      	ldr	r3, [r3, #0]
   8ea76:	3304      	adds	r3, #4
   8ea78:	4619      	mov	r1, r3
   8ea7a:	4610      	mov	r0, r2
   8ea7c:	4b0e      	ldr	r3, [pc, #56]	; (8eab8 <prvAddCurrentTaskToDelayedList+0x64>)
   8ea7e:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
   8ea80:	e010      	b.n	8eaa4 <prvAddCurrentTaskToDelayedList+0x50>
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   8ea82:	4b0e      	ldr	r3, [pc, #56]	; (8eabc <prvAddCurrentTaskToDelayedList+0x68>)
   8ea84:	681a      	ldr	r2, [r3, #0]
   8ea86:	4b09      	ldr	r3, [pc, #36]	; (8eaac <prvAddCurrentTaskToDelayedList+0x58>)
   8ea88:	681b      	ldr	r3, [r3, #0]
   8ea8a:	3304      	adds	r3, #4
   8ea8c:	4619      	mov	r1, r3
   8ea8e:	4610      	mov	r0, r2
   8ea90:	4b09      	ldr	r3, [pc, #36]	; (8eab8 <prvAddCurrentTaskToDelayedList+0x64>)
   8ea92:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
   8ea94:	4b0a      	ldr	r3, [pc, #40]	; (8eac0 <prvAddCurrentTaskToDelayedList+0x6c>)
   8ea96:	681b      	ldr	r3, [r3, #0]
   8ea98:	687a      	ldr	r2, [r7, #4]
   8ea9a:	429a      	cmp	r2, r3
   8ea9c:	d202      	bcs.n	8eaa4 <prvAddCurrentTaskToDelayedList+0x50>
		{
			xNextTaskUnblockTime = xTimeToWake;
   8ea9e:	4a08      	ldr	r2, [pc, #32]	; (8eac0 <prvAddCurrentTaskToDelayedList+0x6c>)
   8eaa0:	687b      	ldr	r3, [r7, #4]
   8eaa2:	6013      	str	r3, [r2, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
   8eaa4:	bf00      	nop
   8eaa6:	3708      	adds	r7, #8
   8eaa8:	46bd      	mov	sp, r7
   8eaaa:	bd80      	pop	{r7, pc}
   8eaac:	20071b28 	.word	0x20071b28
   8eab0:	20071c1c 	.word	0x20071c1c
   8eab4:	20071bd0 	.word	0x20071bd0
   8eab8:	000905f9 	.word	0x000905f9
   8eabc:	20071bcc 	.word	0x20071bcc
   8eac0:	20071c38 	.word	0x20071c38

0008eac4 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
   8eac4:	b580      	push	{r7, lr}
   8eac6:	b084      	sub	sp, #16
   8eac8:	af00      	add	r7, sp, #0
   8eaca:	4603      	mov	r3, r0
   8eacc:	6039      	str	r1, [r7, #0]
   8eace:	80fb      	strh	r3, [r7, #6]
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   8ead0:	683b      	ldr	r3, [r7, #0]
   8ead2:	2b00      	cmp	r3, #0
   8ead4:	d106      	bne.n	8eae4 <prvAllocateTCBAndStack+0x20>
   8ead6:	88fb      	ldrh	r3, [r7, #6]
   8ead8:	009b      	lsls	r3, r3, #2
   8eada:	4618      	mov	r0, r3
   8eadc:	4b14      	ldr	r3, [pc, #80]	; (8eb30 <prvAllocateTCBAndStack+0x6c>)
   8eade:	4798      	blx	r3
   8eae0:	4603      	mov	r3, r0
   8eae2:	e000      	b.n	8eae6 <prvAllocateTCBAndStack+0x22>
   8eae4:	683b      	ldr	r3, [r7, #0]
   8eae6:	60bb      	str	r3, [r7, #8]

		if( pxStack != NULL )
   8eae8:	68bb      	ldr	r3, [r7, #8]
   8eaea:	2b00      	cmp	r3, #0
   8eaec:	d00e      	beq.n	8eb0c <prvAllocateTCBAndStack+0x48>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
   8eaee:	2058      	movs	r0, #88	; 0x58
   8eaf0:	4b0f      	ldr	r3, [pc, #60]	; (8eb30 <prvAllocateTCBAndStack+0x6c>)
   8eaf2:	4798      	blx	r3
   8eaf4:	60f8      	str	r0, [r7, #12]

			if( pxNewTCB != NULL )
   8eaf6:	68fb      	ldr	r3, [r7, #12]
   8eaf8:	2b00      	cmp	r3, #0
   8eafa:	d003      	beq.n	8eb04 <prvAllocateTCBAndStack+0x40>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
   8eafc:	68fb      	ldr	r3, [r7, #12]
   8eafe:	68ba      	ldr	r2, [r7, #8]
   8eb00:	631a      	str	r2, [r3, #48]	; 0x30
   8eb02:	e005      	b.n	8eb10 <prvAllocateTCBAndStack+0x4c>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
   8eb04:	68b8      	ldr	r0, [r7, #8]
   8eb06:	4b0b      	ldr	r3, [pc, #44]	; (8eb34 <prvAllocateTCBAndStack+0x70>)
   8eb08:	4798      	blx	r3
   8eb0a:	e001      	b.n	8eb10 <prvAllocateTCBAndStack+0x4c>
			}
		}
		else
		{
			pxNewTCB = NULL;
   8eb0c:	2300      	movs	r3, #0
   8eb0e:	60fb      	str	r3, [r7, #12]
		}
	}
	#endif /* portSTACK_GROWTH */

	if( pxNewTCB != NULL )
   8eb10:	68fb      	ldr	r3, [r7, #12]
   8eb12:	2b00      	cmp	r3, #0
   8eb14:	d007      	beq.n	8eb26 <prvAllocateTCBAndStack+0x62>
	{
		/* Avoid dependency on memset() if it is not required. */
		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
   8eb16:	68fb      	ldr	r3, [r7, #12]
   8eb18:	6b18      	ldr	r0, [r3, #48]	; 0x30
   8eb1a:	88fb      	ldrh	r3, [r7, #6]
   8eb1c:	009b      	lsls	r3, r3, #2
   8eb1e:	461a      	mov	r2, r3
   8eb20:	21a5      	movs	r1, #165	; 0xa5
   8eb22:	4b05      	ldr	r3, [pc, #20]	; (8eb38 <prvAllocateTCBAndStack+0x74>)
   8eb24:	4798      	blx	r3
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
   8eb26:	68fb      	ldr	r3, [r7, #12]
}
   8eb28:	4618      	mov	r0, r3
   8eb2a:	3710      	adds	r7, #16
   8eb2c:	46bd      	mov	sp, r7
   8eb2e:	bd80      	pop	{r7, pc}
   8eb30:	000904e9 	.word	0x000904e9
   8eb34:	00090529 	.word	0x00090529
   8eb38:	00093cc5 	.word	0x00093cc5

0008eb3c <prvListTaskWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
   8eb3c:	b590      	push	{r4, r7, lr}
   8eb3e:	b08b      	sub	sp, #44	; 0x2c
   8eb40:	af00      	add	r7, sp, #0
   8eb42:	60f8      	str	r0, [r7, #12]
   8eb44:	60b9      	str	r1, [r7, #8]
   8eb46:	4613      	mov	r3, r2
   8eb48:	71fb      	strb	r3, [r7, #7]
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
   8eb4a:	2300      	movs	r3, #0
   8eb4c:	627b      	str	r3, [r7, #36]	; 0x24

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   8eb4e:	68bb      	ldr	r3, [r7, #8]
   8eb50:	681b      	ldr	r3, [r3, #0]
   8eb52:	2b00      	cmp	r3, #0
   8eb54:	d078      	beq.n	8ec48 <prvListTaskWithinSingleList+0x10c>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   8eb56:	68bb      	ldr	r3, [r7, #8]
   8eb58:	623b      	str	r3, [r7, #32]
   8eb5a:	6a3b      	ldr	r3, [r7, #32]
   8eb5c:	685b      	ldr	r3, [r3, #4]
   8eb5e:	685a      	ldr	r2, [r3, #4]
   8eb60:	6a3b      	ldr	r3, [r7, #32]
   8eb62:	605a      	str	r2, [r3, #4]
   8eb64:	6a3b      	ldr	r3, [r7, #32]
   8eb66:	685a      	ldr	r2, [r3, #4]
   8eb68:	6a3b      	ldr	r3, [r7, #32]
   8eb6a:	3308      	adds	r3, #8
   8eb6c:	429a      	cmp	r2, r3
   8eb6e:	d104      	bne.n	8eb7a <prvListTaskWithinSingleList+0x3e>
   8eb70:	6a3b      	ldr	r3, [r7, #32]
   8eb72:	685b      	ldr	r3, [r3, #4]
   8eb74:	685a      	ldr	r2, [r3, #4]
   8eb76:	6a3b      	ldr	r3, [r7, #32]
   8eb78:	605a      	str	r2, [r3, #4]
   8eb7a:	6a3b      	ldr	r3, [r7, #32]
   8eb7c:	685b      	ldr	r3, [r3, #4]
   8eb7e:	68db      	ldr	r3, [r3, #12]
   8eb80:	61fb      	str	r3, [r7, #28]
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   8eb82:	68bb      	ldr	r3, [r7, #8]
   8eb84:	61bb      	str	r3, [r7, #24]
   8eb86:	69bb      	ldr	r3, [r7, #24]
   8eb88:	685b      	ldr	r3, [r3, #4]
   8eb8a:	685a      	ldr	r2, [r3, #4]
   8eb8c:	69bb      	ldr	r3, [r7, #24]
   8eb8e:	605a      	str	r2, [r3, #4]
   8eb90:	69bb      	ldr	r3, [r7, #24]
   8eb92:	685a      	ldr	r2, [r3, #4]
   8eb94:	69bb      	ldr	r3, [r7, #24]
   8eb96:	3308      	adds	r3, #8
   8eb98:	429a      	cmp	r2, r3
   8eb9a:	d104      	bne.n	8eba6 <prvListTaskWithinSingleList+0x6a>
   8eb9c:	69bb      	ldr	r3, [r7, #24]
   8eb9e:	685b      	ldr	r3, [r3, #4]
   8eba0:	685a      	ldr	r2, [r3, #4]
   8eba2:	69bb      	ldr	r3, [r7, #24]
   8eba4:	605a      	str	r2, [r3, #4]
   8eba6:	69bb      	ldr	r3, [r7, #24]
   8eba8:	685b      	ldr	r3, [r3, #4]
   8ebaa:	68db      	ldr	r3, [r3, #12]
   8ebac:	617b      	str	r3, [r7, #20]

				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
   8ebae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8ebb0:	015b      	lsls	r3, r3, #5
   8ebb2:	68fa      	ldr	r2, [r7, #12]
   8ebb4:	4413      	add	r3, r2
   8ebb6:	697a      	ldr	r2, [r7, #20]
   8ebb8:	601a      	str	r2, [r3, #0]
				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
   8ebba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8ebbc:	015b      	lsls	r3, r3, #5
   8ebbe:	68fa      	ldr	r2, [r7, #12]
   8ebc0:	4413      	add	r3, r2
   8ebc2:	697a      	ldr	r2, [r7, #20]
   8ebc4:	3234      	adds	r2, #52	; 0x34
   8ebc6:	605a      	str	r2, [r3, #4]
				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
   8ebc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8ebca:	015b      	lsls	r3, r3, #5
   8ebcc:	68fa      	ldr	r2, [r7, #12]
   8ebce:	4413      	add	r3, r2
   8ebd0:	697a      	ldr	r2, [r7, #20]
   8ebd2:	6c12      	ldr	r2, [r2, #64]	; 0x40
   8ebd4:	609a      	str	r2, [r3, #8]
				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
   8ebd6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8ebd8:	015b      	lsls	r3, r3, #5
   8ebda:	68fa      	ldr	r2, [r7, #12]
   8ebdc:	4413      	add	r3, r2
   8ebde:	79fa      	ldrb	r2, [r7, #7]
   8ebe0:	731a      	strb	r2, [r3, #12]
				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
   8ebe2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8ebe4:	015b      	lsls	r3, r3, #5
   8ebe6:	68fa      	ldr	r2, [r7, #12]
   8ebe8:	4413      	add	r3, r2
   8ebea:	697a      	ldr	r2, [r7, #20]
   8ebec:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   8ebee:	611a      	str	r2, [r3, #16]
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a chance
					it is actually just blocked indefinitely - so really it should
					be reported as being in the Blocked state. */
					if( eState == eSuspended )
   8ebf0:	79fb      	ldrb	r3, [r7, #7]
   8ebf2:	2b03      	cmp	r3, #3
   8ebf4:	d109      	bne.n	8ec0a <prvListTaskWithinSingleList+0xce>
					{
						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
   8ebf6:	697b      	ldr	r3, [r7, #20]
   8ebf8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   8ebfa:	2b00      	cmp	r3, #0
   8ebfc:	d005      	beq.n	8ec0a <prvListTaskWithinSingleList+0xce>
						{
							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
   8ebfe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8ec00:	015b      	lsls	r3, r3, #5
   8ec02:	68fa      	ldr	r2, [r7, #12]
   8ec04:	4413      	add	r3, r2
   8ec06:	2202      	movs	r2, #2
   8ec08:	731a      	strb	r2, [r3, #12]
				}
				#endif /* INCLUDE_vTaskSuspend */

				#if ( configUSE_MUTEXES == 1 )
				{
					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
   8ec0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8ec0c:	015b      	lsls	r3, r3, #5
   8ec0e:	68fa      	ldr	r2, [r7, #12]
   8ec10:	4413      	add	r3, r2
   8ec12:	697a      	ldr	r2, [r7, #20]
   8ec14:	6c92      	ldr	r2, [r2, #72]	; 0x48
   8ec16:	615a      	str	r2, [r3, #20]
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
   8ec18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8ec1a:	015b      	lsls	r3, r3, #5
   8ec1c:	68fa      	ldr	r2, [r7, #12]
   8ec1e:	4413      	add	r3, r2
   8ec20:	2200      	movs	r2, #0
   8ec22:	619a      	str	r2, [r3, #24]
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
				}
				#else
				{
					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
   8ec24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8ec26:	015b      	lsls	r3, r3, #5
   8ec28:	68fa      	ldr	r2, [r7, #12]
   8ec2a:	18d4      	adds	r4, r2, r3
   8ec2c:	697b      	ldr	r3, [r7, #20]
   8ec2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   8ec30:	4618      	mov	r0, r3
   8ec32:	4b08      	ldr	r3, [pc, #32]	; (8ec54 <prvListTaskWithinSingleList+0x118>)
   8ec34:	4798      	blx	r3
   8ec36:	4603      	mov	r3, r0
   8ec38:	83a3      	strh	r3, [r4, #28]
				}
				#endif

				uxTask++;
   8ec3a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8ec3c:	3301      	adds	r3, #1
   8ec3e:	627b      	str	r3, [r7, #36]	; 0x24

			} while( pxNextTCB != pxFirstTCB );
   8ec40:	697a      	ldr	r2, [r7, #20]
   8ec42:	69fb      	ldr	r3, [r7, #28]
   8ec44:	429a      	cmp	r2, r3
   8ec46:	d19c      	bne.n	8eb82 <prvListTaskWithinSingleList+0x46>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
   8ec48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	}
   8ec4a:	4618      	mov	r0, r3
   8ec4c:	372c      	adds	r7, #44	; 0x2c
   8ec4e:	46bd      	mov	sp, r7
   8ec50:	bd90      	pop	{r4, r7, pc}
   8ec52:	bf00      	nop
   8ec54:	0008ec59 	.word	0x0008ec59

0008ec58 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
   8ec58:	b480      	push	{r7}
   8ec5a:	b085      	sub	sp, #20
   8ec5c:	af00      	add	r7, sp, #0
   8ec5e:	6078      	str	r0, [r7, #4]
	uint32_t ulCount = 0U;
   8ec60:	2300      	movs	r3, #0
   8ec62:	60fb      	str	r3, [r7, #12]

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   8ec64:	e005      	b.n	8ec72 <prvTaskCheckFreeStackSpace+0x1a>
		{
			pucStackByte -= portSTACK_GROWTH;
   8ec66:	687b      	ldr	r3, [r7, #4]
   8ec68:	3301      	adds	r3, #1
   8ec6a:	607b      	str	r3, [r7, #4]
			ulCount++;
   8ec6c:	68fb      	ldr	r3, [r7, #12]
   8ec6e:	3301      	adds	r3, #1
   8ec70:	60fb      	str	r3, [r7, #12]

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   8ec72:	687b      	ldr	r3, [r7, #4]
   8ec74:	781b      	ldrb	r3, [r3, #0]
   8ec76:	2ba5      	cmp	r3, #165	; 0xa5
   8ec78:	d0f5      	beq.n	8ec66 <prvTaskCheckFreeStackSpace+0xe>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   8ec7a:	68fb      	ldr	r3, [r7, #12]
   8ec7c:	089b      	lsrs	r3, r3, #2
   8ec7e:	60fb      	str	r3, [r7, #12]

		return ( uint16_t ) ulCount;
   8ec80:	68fb      	ldr	r3, [r7, #12]
   8ec82:	b29b      	uxth	r3, r3
	}
   8ec84:	4618      	mov	r0, r3
   8ec86:	3714      	adds	r7, #20
   8ec88:	46bd      	mov	sp, r7
   8ec8a:	bc80      	pop	{r7}
   8ec8c:	4770      	bx	lr
   8ec8e:	bf00      	nop

0008ec90 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   8ec90:	b580      	push	{r7, lr}
   8ec92:	b082      	sub	sp, #8
   8ec94:	af00      	add	r7, sp, #0
   8ec96:	6078      	str	r0, [r7, #4]
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
   8ec98:	687b      	ldr	r3, [r7, #4]
   8ec9a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   8ec9c:	4618      	mov	r0, r3
   8ec9e:	4b04      	ldr	r3, [pc, #16]	; (8ecb0 <prvDeleteTCB+0x20>)
   8eca0:	4798      	blx	r3
		}
		#endif

		vPortFree( pxTCB );
   8eca2:	6878      	ldr	r0, [r7, #4]
   8eca4:	4b02      	ldr	r3, [pc, #8]	; (8ecb0 <prvDeleteTCB+0x20>)
   8eca6:	4798      	blx	r3
	}
   8eca8:	bf00      	nop
   8ecaa:	3708      	adds	r7, #8
   8ecac:	46bd      	mov	sp, r7
   8ecae:	bd80      	pop	{r7, pc}
   8ecb0:	00090529 	.word	0x00090529

0008ecb4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   8ecb4:	b480      	push	{r7}
   8ecb6:	b083      	sub	sp, #12
   8ecb8:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   8ecba:	4b0e      	ldr	r3, [pc, #56]	; (8ecf4 <prvResetNextTaskUnblockTime+0x40>)
   8ecbc:	681b      	ldr	r3, [r3, #0]
   8ecbe:	681b      	ldr	r3, [r3, #0]
   8ecc0:	2b00      	cmp	r3, #0
   8ecc2:	d101      	bne.n	8ecc8 <prvResetNextTaskUnblockTime+0x14>
   8ecc4:	2301      	movs	r3, #1
   8ecc6:	e000      	b.n	8ecca <prvResetNextTaskUnblockTime+0x16>
   8ecc8:	2300      	movs	r3, #0
   8ecca:	2b00      	cmp	r3, #0
   8eccc:	d004      	beq.n	8ecd8 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   8ecce:	4b0a      	ldr	r3, [pc, #40]	; (8ecf8 <prvResetNextTaskUnblockTime+0x44>)
   8ecd0:	f04f 32ff 	mov.w	r2, #4294967295
   8ecd4:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
	}
}
   8ecd6:	e008      	b.n	8ecea <prvResetNextTaskUnblockTime+0x36>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   8ecd8:	4b06      	ldr	r3, [pc, #24]	; (8ecf4 <prvResetNextTaskUnblockTime+0x40>)
   8ecda:	681b      	ldr	r3, [r3, #0]
   8ecdc:	68db      	ldr	r3, [r3, #12]
   8ecde:	68db      	ldr	r3, [r3, #12]
   8ece0:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
   8ece2:	687b      	ldr	r3, [r7, #4]
   8ece4:	685b      	ldr	r3, [r3, #4]
   8ece6:	4a04      	ldr	r2, [pc, #16]	; (8ecf8 <prvResetNextTaskUnblockTime+0x44>)
   8ece8:	6013      	str	r3, [r2, #0]
	}
}
   8ecea:	bf00      	nop
   8ecec:	370c      	adds	r7, #12
   8ecee:	46bd      	mov	sp, r7
   8ecf0:	bc80      	pop	{r7}
   8ecf2:	4770      	bx	lr
   8ecf4:	20071bcc 	.word	0x20071bcc
   8ecf8:	20071c38 	.word	0x20071c38

0008ecfc <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
   8ecfc:	b480      	push	{r7}
   8ecfe:	b083      	sub	sp, #12
   8ed00:	af00      	add	r7, sp, #0
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
   8ed02:	4b04      	ldr	r3, [pc, #16]	; (8ed14 <xTaskGetCurrentTaskHandle+0x18>)
   8ed04:	681b      	ldr	r3, [r3, #0]
   8ed06:	607b      	str	r3, [r7, #4]

		return xReturn;
   8ed08:	687b      	ldr	r3, [r7, #4]
	}
   8ed0a:	4618      	mov	r0, r3
   8ed0c:	370c      	adds	r7, #12
   8ed0e:	46bd      	mov	sp, r7
   8ed10:	bc80      	pop	{r7}
   8ed12:	4770      	bx	lr
   8ed14:	20071b28 	.word	0x20071b28

0008ed18 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
   8ed18:	b480      	push	{r7}
   8ed1a:	b083      	sub	sp, #12
   8ed1c:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
   8ed1e:	4b0b      	ldr	r3, [pc, #44]	; (8ed4c <xTaskGetSchedulerState+0x34>)
   8ed20:	681b      	ldr	r3, [r3, #0]
   8ed22:	2b00      	cmp	r3, #0
   8ed24:	d102      	bne.n	8ed2c <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
   8ed26:	2301      	movs	r3, #1
   8ed28:	607b      	str	r3, [r7, #4]
   8ed2a:	e008      	b.n	8ed3e <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   8ed2c:	4b08      	ldr	r3, [pc, #32]	; (8ed50 <xTaskGetSchedulerState+0x38>)
   8ed2e:	681b      	ldr	r3, [r3, #0]
   8ed30:	2b00      	cmp	r3, #0
   8ed32:	d102      	bne.n	8ed3a <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
   8ed34:	2302      	movs	r3, #2
   8ed36:	607b      	str	r3, [r7, #4]
   8ed38:	e001      	b.n	8ed3e <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
   8ed3a:	2300      	movs	r3, #0
   8ed3c:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
   8ed3e:	687b      	ldr	r3, [r7, #4]
	}
   8ed40:	4618      	mov	r0, r3
   8ed42:	370c      	adds	r7, #12
   8ed44:	46bd      	mov	sp, r7
   8ed46:	bc80      	pop	{r7}
   8ed48:	4770      	bx	lr
   8ed4a:	bf00      	nop
   8ed4c:	20071c24 	.word	0x20071c24
   8ed50:	20071c3c 	.word	0x20071c3c

0008ed54 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
   8ed54:	b580      	push	{r7, lr}
   8ed56:	b084      	sub	sp, #16
   8ed58:	af00      	add	r7, sp, #0
   8ed5a:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   8ed5c:	687b      	ldr	r3, [r7, #4]
   8ed5e:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
   8ed60:	687b      	ldr	r3, [r7, #4]
   8ed62:	2b00      	cmp	r3, #0
   8ed64:	d062      	beq.n	8ee2c <vTaskPriorityInherit+0xd8>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   8ed66:	68fb      	ldr	r3, [r7, #12]
   8ed68:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8ed6a:	4b32      	ldr	r3, [pc, #200]	; (8ee34 <vTaskPriorityInherit+0xe0>)
   8ed6c:	681b      	ldr	r3, [r3, #0]
   8ed6e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8ed70:	429a      	cmp	r2, r3
   8ed72:	d25b      	bcs.n	8ee2c <vTaskPriorityInherit+0xd8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   8ed74:	68fb      	ldr	r3, [r7, #12]
   8ed76:	699b      	ldr	r3, [r3, #24]
   8ed78:	2b00      	cmp	r3, #0
   8ed7a:	db06      	blt.n	8ed8a <vTaskPriorityInherit+0x36>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   8ed7c:	4b2d      	ldr	r3, [pc, #180]	; (8ee34 <vTaskPriorityInherit+0xe0>)
   8ed7e:	681b      	ldr	r3, [r3, #0]
   8ed80:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8ed82:	f1c3 0206 	rsb	r2, r3, #6
   8ed86:	68fb      	ldr	r3, [r7, #12]
   8ed88:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   8ed8a:	68fb      	ldr	r3, [r7, #12]
   8ed8c:	6959      	ldr	r1, [r3, #20]
   8ed8e:	68fb      	ldr	r3, [r7, #12]
   8ed90:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8ed92:	4613      	mov	r3, r2
   8ed94:	009b      	lsls	r3, r3, #2
   8ed96:	4413      	add	r3, r2
   8ed98:	009b      	lsls	r3, r3, #2
   8ed9a:	4a27      	ldr	r2, [pc, #156]	; (8ee38 <vTaskPriorityInherit+0xe4>)
   8ed9c:	4413      	add	r3, r2
   8ed9e:	4299      	cmp	r1, r3
   8eda0:	d101      	bne.n	8eda6 <vTaskPriorityInherit+0x52>
   8eda2:	2301      	movs	r3, #1
   8eda4:	e000      	b.n	8eda8 <vTaskPriorityInherit+0x54>
   8eda6:	2300      	movs	r3, #0
   8eda8:	2b00      	cmp	r3, #0
   8edaa:	d03a      	beq.n	8ee22 <vTaskPriorityInherit+0xce>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   8edac:	68fb      	ldr	r3, [r7, #12]
   8edae:	3304      	adds	r3, #4
   8edb0:	4618      	mov	r0, r3
   8edb2:	4b22      	ldr	r3, [pc, #136]	; (8ee3c <vTaskPriorityInherit+0xe8>)
   8edb4:	4798      	blx	r3
   8edb6:	4603      	mov	r3, r0
   8edb8:	2b00      	cmp	r3, #0
   8edba:	d115      	bne.n	8ede8 <vTaskPriorityInherit+0x94>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   8edbc:	68fb      	ldr	r3, [r7, #12]
   8edbe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8edc0:	491d      	ldr	r1, [pc, #116]	; (8ee38 <vTaskPriorityInherit+0xe4>)
   8edc2:	4613      	mov	r3, r2
   8edc4:	009b      	lsls	r3, r3, #2
   8edc6:	4413      	add	r3, r2
   8edc8:	009b      	lsls	r3, r3, #2
   8edca:	440b      	add	r3, r1
   8edcc:	681b      	ldr	r3, [r3, #0]
   8edce:	2b00      	cmp	r3, #0
   8edd0:	d10a      	bne.n	8ede8 <vTaskPriorityInherit+0x94>
   8edd2:	68fb      	ldr	r3, [r7, #12]
   8edd4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8edd6:	2201      	movs	r2, #1
   8edd8:	fa02 f303 	lsl.w	r3, r2, r3
   8eddc:	43da      	mvns	r2, r3
   8edde:	4b18      	ldr	r3, [pc, #96]	; (8ee40 <vTaskPriorityInherit+0xec>)
   8ede0:	681b      	ldr	r3, [r3, #0]
   8ede2:	4013      	ands	r3, r2
   8ede4:	4a16      	ldr	r2, [pc, #88]	; (8ee40 <vTaskPriorityInherit+0xec>)
   8ede6:	6013      	str	r3, [r2, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   8ede8:	4b12      	ldr	r3, [pc, #72]	; (8ee34 <vTaskPriorityInherit+0xe0>)
   8edea:	681b      	ldr	r3, [r3, #0]
   8edec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8edee:	68fb      	ldr	r3, [r7, #12]
   8edf0:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
   8edf2:	68fb      	ldr	r3, [r7, #12]
   8edf4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8edf6:	2201      	movs	r2, #1
   8edf8:	409a      	lsls	r2, r3
   8edfa:	4b11      	ldr	r3, [pc, #68]	; (8ee40 <vTaskPriorityInherit+0xec>)
   8edfc:	681b      	ldr	r3, [r3, #0]
   8edfe:	4313      	orrs	r3, r2
   8ee00:	4a0f      	ldr	r2, [pc, #60]	; (8ee40 <vTaskPriorityInherit+0xec>)
   8ee02:	6013      	str	r3, [r2, #0]
   8ee04:	68fb      	ldr	r3, [r7, #12]
   8ee06:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8ee08:	4613      	mov	r3, r2
   8ee0a:	009b      	lsls	r3, r3, #2
   8ee0c:	4413      	add	r3, r2
   8ee0e:	009b      	lsls	r3, r3, #2
   8ee10:	4a09      	ldr	r2, [pc, #36]	; (8ee38 <vTaskPriorityInherit+0xe4>)
   8ee12:	441a      	add	r2, r3
   8ee14:	68fb      	ldr	r3, [r7, #12]
   8ee16:	3304      	adds	r3, #4
   8ee18:	4619      	mov	r1, r3
   8ee1a:	4610      	mov	r0, r2
   8ee1c:	4b09      	ldr	r3, [pc, #36]	; (8ee44 <vTaskPriorityInherit+0xf0>)
   8ee1e:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   8ee20:	e004      	b.n	8ee2c <vTaskPriorityInherit+0xd8>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   8ee22:	4b04      	ldr	r3, [pc, #16]	; (8ee34 <vTaskPriorityInherit+0xe0>)
   8ee24:	681b      	ldr	r3, [r3, #0]
   8ee26:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8ee28:	68fb      	ldr	r3, [r7, #12]
   8ee2a:	62da      	str	r2, [r3, #44]	; 0x2c
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   8ee2c:	bf00      	nop
   8ee2e:	3710      	adds	r7, #16
   8ee30:	46bd      	mov	sp, r7
   8ee32:	bd80      	pop	{r7, pc}
   8ee34:	20071b28 	.word	0x20071b28
   8ee38:	20071b2c 	.word	0x20071b2c
   8ee3c:	00090669 	.word	0x00090669
   8ee40:	20071c20 	.word	0x20071c20
   8ee44:	000905b1 	.word	0x000905b1

0008ee48 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
   8ee48:	b580      	push	{r7, lr}
   8ee4a:	b084      	sub	sp, #16
   8ee4c:	af00      	add	r7, sp, #0
   8ee4e:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   8ee50:	687b      	ldr	r3, [r7, #4]
   8ee52:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
   8ee54:	2300      	movs	r3, #0
   8ee56:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
   8ee58:	687b      	ldr	r3, [r7, #4]
   8ee5a:	2b00      	cmp	r3, #0
   8ee5c:	d05c      	beq.n	8ef18 <xTaskPriorityDisinherit+0xd0>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
   8ee5e:	4b31      	ldr	r3, [pc, #196]	; (8ef24 <xTaskPriorityDisinherit+0xdc>)
   8ee60:	681b      	ldr	r3, [r3, #0]
   8ee62:	68ba      	ldr	r2, [r7, #8]
   8ee64:	429a      	cmp	r2, r3
   8ee66:	d001      	beq.n	8ee6c <xTaskPriorityDisinherit+0x24>
   8ee68:	4b2f      	ldr	r3, [pc, #188]	; (8ef28 <xTaskPriorityDisinherit+0xe0>)
   8ee6a:	4798      	blx	r3

			configASSERT( pxTCB->uxMutexesHeld );
   8ee6c:	68bb      	ldr	r3, [r7, #8]
   8ee6e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   8ee70:	2b00      	cmp	r3, #0
   8ee72:	d101      	bne.n	8ee78 <xTaskPriorityDisinherit+0x30>
   8ee74:	4b2c      	ldr	r3, [pc, #176]	; (8ef28 <xTaskPriorityDisinherit+0xe0>)
   8ee76:	4798      	blx	r3
			( pxTCB->uxMutexesHeld )--;
   8ee78:	68bb      	ldr	r3, [r7, #8]
   8ee7a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   8ee7c:	1e5a      	subs	r2, r3, #1
   8ee7e:	68bb      	ldr	r3, [r7, #8]
   8ee80:	64da      	str	r2, [r3, #76]	; 0x4c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   8ee82:	68bb      	ldr	r3, [r7, #8]
   8ee84:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8ee86:	68bb      	ldr	r3, [r7, #8]
   8ee88:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   8ee8a:	429a      	cmp	r2, r3
   8ee8c:	d044      	beq.n	8ef18 <xTaskPriorityDisinherit+0xd0>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   8ee8e:	68bb      	ldr	r3, [r7, #8]
   8ee90:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
   8ee92:	2b00      	cmp	r3, #0
   8ee94:	d140      	bne.n	8ef18 <xTaskPriorityDisinherit+0xd0>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   8ee96:	68bb      	ldr	r3, [r7, #8]
   8ee98:	3304      	adds	r3, #4
   8ee9a:	4618      	mov	r0, r3
   8ee9c:	4b23      	ldr	r3, [pc, #140]	; (8ef2c <xTaskPriorityDisinherit+0xe4>)
   8ee9e:	4798      	blx	r3
   8eea0:	4603      	mov	r3, r0
   8eea2:	2b00      	cmp	r3, #0
   8eea4:	d115      	bne.n	8eed2 <xTaskPriorityDisinherit+0x8a>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   8eea6:	68bb      	ldr	r3, [r7, #8]
   8eea8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8eeaa:	4921      	ldr	r1, [pc, #132]	; (8ef30 <xTaskPriorityDisinherit+0xe8>)
   8eeac:	4613      	mov	r3, r2
   8eeae:	009b      	lsls	r3, r3, #2
   8eeb0:	4413      	add	r3, r2
   8eeb2:	009b      	lsls	r3, r3, #2
   8eeb4:	440b      	add	r3, r1
   8eeb6:	681b      	ldr	r3, [r3, #0]
   8eeb8:	2b00      	cmp	r3, #0
   8eeba:	d10a      	bne.n	8eed2 <xTaskPriorityDisinherit+0x8a>
   8eebc:	68bb      	ldr	r3, [r7, #8]
   8eebe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8eec0:	2201      	movs	r2, #1
   8eec2:	fa02 f303 	lsl.w	r3, r2, r3
   8eec6:	43da      	mvns	r2, r3
   8eec8:	4b1a      	ldr	r3, [pc, #104]	; (8ef34 <xTaskPriorityDisinherit+0xec>)
   8eeca:	681b      	ldr	r3, [r3, #0]
   8eecc:	4013      	ands	r3, r2
   8eece:	4a19      	ldr	r2, [pc, #100]	; (8ef34 <xTaskPriorityDisinherit+0xec>)
   8eed0:	6013      	str	r3, [r2, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   8eed2:	68bb      	ldr	r3, [r7, #8]
   8eed4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
   8eed6:	68bb      	ldr	r3, [r7, #8]
   8eed8:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   8eeda:	68bb      	ldr	r3, [r7, #8]
   8eedc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8eede:	f1c3 0206 	rsb	r2, r3, #6
   8eee2:	68bb      	ldr	r3, [r7, #8]
   8eee4:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
   8eee6:	68bb      	ldr	r3, [r7, #8]
   8eee8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8eeea:	2201      	movs	r2, #1
   8eeec:	409a      	lsls	r2, r3
   8eeee:	4b11      	ldr	r3, [pc, #68]	; (8ef34 <xTaskPriorityDisinherit+0xec>)
   8eef0:	681b      	ldr	r3, [r3, #0]
   8eef2:	4313      	orrs	r3, r2
   8eef4:	4a0f      	ldr	r2, [pc, #60]	; (8ef34 <xTaskPriorityDisinherit+0xec>)
   8eef6:	6013      	str	r3, [r2, #0]
   8eef8:	68bb      	ldr	r3, [r7, #8]
   8eefa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8eefc:	4613      	mov	r3, r2
   8eefe:	009b      	lsls	r3, r3, #2
   8ef00:	4413      	add	r3, r2
   8ef02:	009b      	lsls	r3, r3, #2
   8ef04:	4a0a      	ldr	r2, [pc, #40]	; (8ef30 <xTaskPriorityDisinherit+0xe8>)
   8ef06:	441a      	add	r2, r3
   8ef08:	68bb      	ldr	r3, [r7, #8]
   8ef0a:	3304      	adds	r3, #4
   8ef0c:	4619      	mov	r1, r3
   8ef0e:	4610      	mov	r0, r2
   8ef10:	4b09      	ldr	r3, [pc, #36]	; (8ef38 <xTaskPriorityDisinherit+0xf0>)
   8ef12:	4798      	blx	r3
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
   8ef14:	2301      	movs	r3, #1
   8ef16:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   8ef18:	68fb      	ldr	r3, [r7, #12]
	}
   8ef1a:	4618      	mov	r0, r3
   8ef1c:	3710      	adds	r7, #16
   8ef1e:	46bd      	mov	sp, r7
   8ef20:	bd80      	pop	{r7, pc}
   8ef22:	bf00      	nop
   8ef24:	20071b28 	.word	0x20071b28
   8ef28:	00082eed 	.word	0x00082eed
   8ef2c:	00090669 	.word	0x00090669
   8ef30:	20071b2c 	.word	0x20071b2c
   8ef34:	20071c20 	.word	0x20071c20
   8ef38:	000905b1 	.word	0x000905b1

0008ef3c <prvWriteNameToBuffer>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
	{
   8ef3c:	b580      	push	{r7, lr}
   8ef3e:	b084      	sub	sp, #16
   8ef40:	af00      	add	r7, sp, #0
   8ef42:	6078      	str	r0, [r7, #4]
   8ef44:	6039      	str	r1, [r7, #0]
	size_t x;

		/* Start by copying the entire string. */
		strcpy( pcBuffer, pcTaskName );
   8ef46:	6839      	ldr	r1, [r7, #0]
   8ef48:	6878      	ldr	r0, [r7, #4]
   8ef4a:	4b0f      	ldr	r3, [pc, #60]	; (8ef88 <prvWriteNameToBuffer+0x4c>)
   8ef4c:	4798      	blx	r3

		/* Pad the end of the string with spaces to ensure columns line up when
		printed out. */
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   8ef4e:	6878      	ldr	r0, [r7, #4]
   8ef50:	4b0e      	ldr	r3, [pc, #56]	; (8ef8c <prvWriteNameToBuffer+0x50>)
   8ef52:	4798      	blx	r3
   8ef54:	60f8      	str	r0, [r7, #12]
   8ef56:	e007      	b.n	8ef68 <prvWriteNameToBuffer+0x2c>
		{
			pcBuffer[ x ] = ' ';
   8ef58:	687a      	ldr	r2, [r7, #4]
   8ef5a:	68fb      	ldr	r3, [r7, #12]
   8ef5c:	4413      	add	r3, r2
   8ef5e:	2220      	movs	r2, #32
   8ef60:	701a      	strb	r2, [r3, #0]
		/* Start by copying the entire string. */
		strcpy( pcBuffer, pcTaskName );

		/* Pad the end of the string with spaces to ensure columns line up when
		printed out. */
		for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   8ef62:	68fb      	ldr	r3, [r7, #12]
   8ef64:	3301      	adds	r3, #1
   8ef66:	60fb      	str	r3, [r7, #12]
   8ef68:	68fb      	ldr	r3, [r7, #12]
   8ef6a:	2b08      	cmp	r3, #8
   8ef6c:	d9f4      	bls.n	8ef58 <prvWriteNameToBuffer+0x1c>
		{
			pcBuffer[ x ] = ' ';
		}

		/* Terminate. */
		pcBuffer[ x ] = 0x00;
   8ef6e:	687a      	ldr	r2, [r7, #4]
   8ef70:	68fb      	ldr	r3, [r7, #12]
   8ef72:	4413      	add	r3, r2
   8ef74:	2200      	movs	r2, #0
   8ef76:	701a      	strb	r2, [r3, #0]

		/* Return the new end of string. */
		return &( pcBuffer[ x ] );
   8ef78:	687a      	ldr	r2, [r7, #4]
   8ef7a:	68fb      	ldr	r3, [r7, #12]
   8ef7c:	4413      	add	r3, r2
	}
   8ef7e:	4618      	mov	r0, r3
   8ef80:	3710      	adds	r7, #16
   8ef82:	46bd      	mov	sp, r7
   8ef84:	bd80      	pop	{r7, pc}
   8ef86:	bf00      	nop
   8ef88:	0009428d 	.word	0x0009428d
   8ef8c:	00094349 	.word	0x00094349

0008ef90 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

	void vTaskList( char * pcWriteBuffer )
	{
   8ef90:	b590      	push	{r4, r7, lr}
   8ef92:	b089      	sub	sp, #36	; 0x24
   8ef94:	af02      	add	r7, sp, #8
   8ef96:	6078      	str	r0, [r7, #4]
		 * through a call to vTaskList().
		 */


		/* Make sure the write buffer does not contain a string. */
		*pcWriteBuffer = 0x00;
   8ef98:	687b      	ldr	r3, [r7, #4]
   8ef9a:	2200      	movs	r2, #0
   8ef9c:	701a      	strb	r2, [r3, #0]

		/* Take a snapshot of the number of tasks in case it changes while this
		function is executing. */
		uxArraySize = uxCurrentNumberOfTasks;
   8ef9e:	4b39      	ldr	r3, [pc, #228]	; (8f084 <vTaskList+0xf4>)
   8efa0:	681b      	ldr	r3, [r3, #0]
   8efa2:	60fb      	str	r3, [r7, #12]

		/* Allocate an array index for each task. */
		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   8efa4:	4b37      	ldr	r3, [pc, #220]	; (8f084 <vTaskList+0xf4>)
   8efa6:	681b      	ldr	r3, [r3, #0]
   8efa8:	015b      	lsls	r3, r3, #5
   8efaa:	4618      	mov	r0, r3
   8efac:	4b36      	ldr	r3, [pc, #216]	; (8f088 <vTaskList+0xf8>)
   8efae:	4798      	blx	r3
   8efb0:	6138      	str	r0, [r7, #16]

		if( pxTaskStatusArray != NULL )
   8efb2:	693b      	ldr	r3, [r7, #16]
   8efb4:	2b00      	cmp	r3, #0
   8efb6:	d060      	beq.n	8f07a <vTaskList+0xea>
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   8efb8:	68fb      	ldr	r3, [r7, #12]
   8efba:	2200      	movs	r2, #0
   8efbc:	4619      	mov	r1, r3
   8efbe:	6938      	ldr	r0, [r7, #16]
   8efc0:	4b32      	ldr	r3, [pc, #200]	; (8f08c <vTaskList+0xfc>)
   8efc2:	4798      	blx	r3
   8efc4:	4603      	mov	r3, r0
   8efc6:	60fb      	str	r3, [r7, #12]

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
   8efc8:	2300      	movs	r3, #0
   8efca:	60bb      	str	r3, [r7, #8]
   8efcc:	e04e      	b.n	8f06c <vTaskList+0xdc>
			{
				switch( pxTaskStatusArray[ x ].eCurrentState )
   8efce:	68bb      	ldr	r3, [r7, #8]
   8efd0:	015b      	lsls	r3, r3, #5
   8efd2:	693a      	ldr	r2, [r7, #16]
   8efd4:	4413      	add	r3, r2
   8efd6:	7b1b      	ldrb	r3, [r3, #12]
   8efd8:	3b01      	subs	r3, #1
   8efda:	2b03      	cmp	r3, #3
   8efdc:	d816      	bhi.n	8f00c <vTaskList+0x7c>
   8efde:	a201      	add	r2, pc, #4	; (adr r2, 8efe4 <vTaskList+0x54>)
   8efe0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   8efe4:	0008eff5 	.word	0x0008eff5
   8efe8:	0008effb 	.word	0x0008effb
   8efec:	0008f001 	.word	0x0008f001
   8eff0:	0008f007 	.word	0x0008f007
				{
					case eReady:		cStatus = tskREADY_CHAR;
   8eff4:	2352      	movs	r3, #82	; 0x52
   8eff6:	75fb      	strb	r3, [r7, #23]
										break;
   8eff8:	e00b      	b.n	8f012 <vTaskList+0x82>

					case eBlocked:		cStatus = tskBLOCKED_CHAR;
   8effa:	2342      	movs	r3, #66	; 0x42
   8effc:	75fb      	strb	r3, [r7, #23]
										break;
   8effe:	e008      	b.n	8f012 <vTaskList+0x82>

					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   8f000:	2353      	movs	r3, #83	; 0x53
   8f002:	75fb      	strb	r3, [r7, #23]
										break;
   8f004:	e005      	b.n	8f012 <vTaskList+0x82>

					case eDeleted:		cStatus = tskDELETED_CHAR;
   8f006:	2344      	movs	r3, #68	; 0x44
   8f008:	75fb      	strb	r3, [r7, #23]
										break;
   8f00a:	e002      	b.n	8f012 <vTaskList+0x82>

					default:			/* Should not get here, but it is included
										to prevent static checking errors. */
										cStatus = 0x00;
   8f00c:	2300      	movs	r3, #0
   8f00e:	75fb      	strb	r3, [r7, #23]
										break;
   8f010:	bf00      	nop
				}

				/* Write the task name to the string, padding with spaces so it
				can be printed in tabular form more easily. */
				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   8f012:	68bb      	ldr	r3, [r7, #8]
   8f014:	015b      	lsls	r3, r3, #5
   8f016:	693a      	ldr	r2, [r7, #16]
   8f018:	4413      	add	r3, r2
   8f01a:	685b      	ldr	r3, [r3, #4]
   8f01c:	4619      	mov	r1, r3
   8f01e:	6878      	ldr	r0, [r7, #4]
   8f020:	4b1b      	ldr	r3, [pc, #108]	; (8f090 <vTaskList+0x100>)
   8f022:	4798      	blx	r3
   8f024:	6078      	str	r0, [r7, #4]

				/* Write the rest of the string. */
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
   8f026:	7df9      	ldrb	r1, [r7, #23]
   8f028:	68bb      	ldr	r3, [r7, #8]
   8f02a:	015b      	lsls	r3, r3, #5
   8f02c:	693a      	ldr	r2, [r7, #16]
   8f02e:	4413      	add	r3, r2
   8f030:	6918      	ldr	r0, [r3, #16]
   8f032:	68bb      	ldr	r3, [r7, #8]
   8f034:	015b      	lsls	r3, r3, #5
   8f036:	693a      	ldr	r2, [r7, #16]
   8f038:	4413      	add	r3, r2
   8f03a:	8b9b      	ldrh	r3, [r3, #28]
   8f03c:	461c      	mov	r4, r3
   8f03e:	68bb      	ldr	r3, [r7, #8]
   8f040:	015b      	lsls	r3, r3, #5
   8f042:	693a      	ldr	r2, [r7, #16]
   8f044:	4413      	add	r3, r2
   8f046:	689b      	ldr	r3, [r3, #8]
   8f048:	9301      	str	r3, [sp, #4]
   8f04a:	9400      	str	r4, [sp, #0]
   8f04c:	4603      	mov	r3, r0
   8f04e:	460a      	mov	r2, r1
   8f050:	4910      	ldr	r1, [pc, #64]	; (8f094 <vTaskList+0x104>)
   8f052:	6878      	ldr	r0, [r7, #4]
   8f054:	4c10      	ldr	r4, [pc, #64]	; (8f098 <vTaskList+0x108>)
   8f056:	47a0      	blx	r4
				pcWriteBuffer += strlen( pcWriteBuffer );
   8f058:	6878      	ldr	r0, [r7, #4]
   8f05a:	4b10      	ldr	r3, [pc, #64]	; (8f09c <vTaskList+0x10c>)
   8f05c:	4798      	blx	r3
   8f05e:	4602      	mov	r2, r0
   8f060:	687b      	ldr	r3, [r7, #4]
   8f062:	4413      	add	r3, r2
   8f064:	607b      	str	r3, [r7, #4]
		{
			/* Generate the (binary) data. */
			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );

			/* Create a human readable table from the binary data. */
			for( x = 0; x < uxArraySize; x++ )
   8f066:	68bb      	ldr	r3, [r7, #8]
   8f068:	3301      	adds	r3, #1
   8f06a:	60bb      	str	r3, [r7, #8]
   8f06c:	68ba      	ldr	r2, [r7, #8]
   8f06e:	68fb      	ldr	r3, [r7, #12]
   8f070:	429a      	cmp	r2, r3
   8f072:	d3ac      	bcc.n	8efce <vTaskList+0x3e>
				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
				pcWriteBuffer += strlen( pcWriteBuffer );
			}

			/* Free the array again. */
			vPortFree( pxTaskStatusArray );
   8f074:	6938      	ldr	r0, [r7, #16]
   8f076:	4b0a      	ldr	r3, [pc, #40]	; (8f0a0 <vTaskList+0x110>)
   8f078:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   8f07a:	bf00      	nop
   8f07c:	371c      	adds	r7, #28
   8f07e:	46bd      	mov	sp, r7
   8f080:	bd90      	pop	{r4, r7, pc}
   8f082:	bf00      	nop
   8f084:	20071c18 	.word	0x20071c18
   8f088:	000904e9 	.word	0x000904e9
   8f08c:	0008e18d 	.word	0x0008e18d
   8f090:	0008ef3d 	.word	0x0008ef3d
   8f094:	0009ae84 	.word	0x0009ae84
   8f098:	00094171 	.word	0x00094171
   8f09c:	00094349 	.word	0x00094349
   8f0a0:	00090529 	.word	0x00090529

0008f0a4 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
   8f0a4:	b480      	push	{r7}
   8f0a6:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
   8f0a8:	4b07      	ldr	r3, [pc, #28]	; (8f0c8 <pvTaskIncrementMutexHeldCount+0x24>)
   8f0aa:	681b      	ldr	r3, [r3, #0]
   8f0ac:	2b00      	cmp	r3, #0
   8f0ae:	d004      	beq.n	8f0ba <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
   8f0b0:	4b05      	ldr	r3, [pc, #20]	; (8f0c8 <pvTaskIncrementMutexHeldCount+0x24>)
   8f0b2:	681b      	ldr	r3, [r3, #0]
   8f0b4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
   8f0b6:	3201      	adds	r2, #1
   8f0b8:	64da      	str	r2, [r3, #76]	; 0x4c
		}

		return pxCurrentTCB;
   8f0ba:	4b03      	ldr	r3, [pc, #12]	; (8f0c8 <pvTaskIncrementMutexHeldCount+0x24>)
   8f0bc:	681b      	ldr	r3, [r3, #0]
	}
   8f0be:	4618      	mov	r0, r3
   8f0c0:	46bd      	mov	sp, r7
   8f0c2:	bc80      	pop	{r7}
   8f0c4:	4770      	bx	lr
   8f0c6:	bf00      	nop
   8f0c8:	20071b28 	.word	0x20071b28

0008f0cc <ard_getTaskName>:
	#include "tasks_test_access_functions.h"
#endif

//ARD specific
void ard_getTaskName(char* name)
{
   8f0cc:	b580      	push	{r7, lr}
   8f0ce:	b082      	sub	sp, #8
   8f0d0:	af00      	add	r7, sp, #0
   8f0d2:	6078      	str	r0, [r7, #4]
	strcpy(name, pxCurrentTCB->pcTaskName);
   8f0d4:	4b05      	ldr	r3, [pc, #20]	; (8f0ec <ard_getTaskName+0x20>)
   8f0d6:	681b      	ldr	r3, [r3, #0]
   8f0d8:	3334      	adds	r3, #52	; 0x34
   8f0da:	4619      	mov	r1, r3
   8f0dc:	6878      	ldr	r0, [r7, #4]
   8f0de:	4b04      	ldr	r3, [pc, #16]	; (8f0f0 <ard_getTaskName+0x24>)
   8f0e0:	4798      	blx	r3
}
   8f0e2:	bf00      	nop
   8f0e4:	3708      	adds	r7, #8
   8f0e6:	46bd      	mov	sp, r7
   8f0e8:	bd80      	pop	{r7, pc}
   8f0ea:	bf00      	nop
   8f0ec:	20071b28 	.word	0x20071b28
   8f0f0:	0009428d 	.word	0x0009428d

0008f0f4 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
   8f0f4:	b590      	push	{r4, r7, lr}
   8f0f6:	b087      	sub	sp, #28
   8f0f8:	af04      	add	r7, sp, #16
BaseType_t xReturn = pdFAIL;
   8f0fa:	2300      	movs	r3, #0
   8f0fc:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
   8f0fe:	4b10      	ldr	r3, [pc, #64]	; (8f140 <xTimerCreateTimerTask+0x4c>)
   8f100:	4798      	blx	r3

	if( xTimerQueue != NULL )
   8f102:	4b10      	ldr	r3, [pc, #64]	; (8f144 <xTimerCreateTimerTask+0x50>)
   8f104:	681b      	ldr	r3, [r3, #0]
   8f106:	2b00      	cmp	r3, #0
   8f108:	d00f      	beq.n	8f12a <xTimerCreateTimerTask+0x36>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
   8f10a:	2300      	movs	r3, #0
   8f10c:	9303      	str	r3, [sp, #12]
   8f10e:	2300      	movs	r3, #0
   8f110:	9302      	str	r3, [sp, #8]
   8f112:	2300      	movs	r3, #0
   8f114:	9301      	str	r3, [sp, #4]
   8f116:	2302      	movs	r3, #2
   8f118:	9300      	str	r3, [sp, #0]
   8f11a:	2300      	movs	r3, #0
   8f11c:	f44f 7282 	mov.w	r2, #260	; 0x104
   8f120:	4909      	ldr	r1, [pc, #36]	; (8f148 <xTimerCreateTimerTask+0x54>)
   8f122:	480a      	ldr	r0, [pc, #40]	; (8f14c <xTimerCreateTimerTask+0x58>)
   8f124:	4c0a      	ldr	r4, [pc, #40]	; (8f150 <xTimerCreateTimerTask+0x5c>)
   8f126:	47a0      	blx	r4
   8f128:	6078      	str	r0, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
   8f12a:	687b      	ldr	r3, [r7, #4]
   8f12c:	2b00      	cmp	r3, #0
   8f12e:	d101      	bne.n	8f134 <xTimerCreateTimerTask+0x40>
   8f130:	4b08      	ldr	r3, [pc, #32]	; (8f154 <xTimerCreateTimerTask+0x60>)
   8f132:	4798      	blx	r3
	return xReturn;
   8f134:	687b      	ldr	r3, [r7, #4]
}
   8f136:	4618      	mov	r0, r3
   8f138:	370c      	adds	r7, #12
   8f13a:	46bd      	mov	sp, r7
   8f13c:	bd90      	pop	{r4, r7, pc}
   8f13e:	bf00      	nop
   8f140:	0008f665 	.word	0x0008f665
   8f144:	20071c70 	.word	0x20071c70
   8f148:	0009ae94 	.word	0x0009ae94
   8f14c:	0008f271 	.word	0x0008f271
   8f150:	0008dc85 	.word	0x0008dc85
   8f154:	00082eed 	.word	0x00082eed

0008f158 <xTimerGenericCommand>:
	return ( TimerHandle_t ) pxNewTimer;
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
   8f158:	b590      	push	{r4, r7, lr}
   8f15a:	b08b      	sub	sp, #44	; 0x2c
   8f15c:	af00      	add	r7, sp, #0
   8f15e:	60f8      	str	r0, [r7, #12]
   8f160:	60b9      	str	r1, [r7, #8]
   8f162:	607a      	str	r2, [r7, #4]
   8f164:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
   8f166:	2300      	movs	r3, #0
   8f168:	627b      	str	r3, [r7, #36]	; 0x24
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
   8f16a:	68fb      	ldr	r3, [r7, #12]
   8f16c:	2b00      	cmp	r3, #0
   8f16e:	d101      	bne.n	8f174 <xTimerGenericCommand+0x1c>
   8f170:	4b1a      	ldr	r3, [pc, #104]	; (8f1dc <xTimerGenericCommand+0x84>)
   8f172:	4798      	blx	r3

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
   8f174:	4b1a      	ldr	r3, [pc, #104]	; (8f1e0 <xTimerGenericCommand+0x88>)
   8f176:	681b      	ldr	r3, [r3, #0]
   8f178:	2b00      	cmp	r3, #0
   8f17a:	d02a      	beq.n	8f1d2 <xTimerGenericCommand+0x7a>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
   8f17c:	68bb      	ldr	r3, [r7, #8]
   8f17e:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
   8f180:	687b      	ldr	r3, [r7, #4]
   8f182:	61bb      	str	r3, [r7, #24]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
   8f184:	68fb      	ldr	r3, [r7, #12]
   8f186:	61fb      	str	r3, [r7, #28]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   8f188:	68bb      	ldr	r3, [r7, #8]
   8f18a:	2b05      	cmp	r3, #5
   8f18c:	dc18      	bgt.n	8f1c0 <xTimerGenericCommand+0x68>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   8f18e:	4b15      	ldr	r3, [pc, #84]	; (8f1e4 <xTimerGenericCommand+0x8c>)
   8f190:	4798      	blx	r3
   8f192:	4603      	mov	r3, r0
   8f194:	2b02      	cmp	r3, #2
   8f196:	d109      	bne.n	8f1ac <xTimerGenericCommand+0x54>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   8f198:	4b11      	ldr	r3, [pc, #68]	; (8f1e0 <xTimerGenericCommand+0x88>)
   8f19a:	6818      	ldr	r0, [r3, #0]
   8f19c:	f107 0114 	add.w	r1, r7, #20
   8f1a0:	2300      	movs	r3, #0
   8f1a2:	6bba      	ldr	r2, [r7, #56]	; 0x38
   8f1a4:	4c10      	ldr	r4, [pc, #64]	; (8f1e8 <xTimerGenericCommand+0x90>)
   8f1a6:	47a0      	blx	r4
   8f1a8:	6278      	str	r0, [r7, #36]	; 0x24
   8f1aa:	e012      	b.n	8f1d2 <xTimerGenericCommand+0x7a>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   8f1ac:	4b0c      	ldr	r3, [pc, #48]	; (8f1e0 <xTimerGenericCommand+0x88>)
   8f1ae:	6818      	ldr	r0, [r3, #0]
   8f1b0:	f107 0114 	add.w	r1, r7, #20
   8f1b4:	2300      	movs	r3, #0
   8f1b6:	2200      	movs	r2, #0
   8f1b8:	4c0b      	ldr	r4, [pc, #44]	; (8f1e8 <xTimerGenericCommand+0x90>)
   8f1ba:	47a0      	blx	r4
   8f1bc:	6278      	str	r0, [r7, #36]	; 0x24
   8f1be:	e008      	b.n	8f1d2 <xTimerGenericCommand+0x7a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   8f1c0:	4b07      	ldr	r3, [pc, #28]	; (8f1e0 <xTimerGenericCommand+0x88>)
   8f1c2:	6818      	ldr	r0, [r3, #0]
   8f1c4:	f107 0114 	add.w	r1, r7, #20
   8f1c8:	2300      	movs	r3, #0
   8f1ca:	683a      	ldr	r2, [r7, #0]
   8f1cc:	4c07      	ldr	r4, [pc, #28]	; (8f1ec <xTimerGenericCommand+0x94>)
   8f1ce:	47a0      	blx	r4
   8f1d0:	6278      	str	r0, [r7, #36]	; 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
   8f1d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
   8f1d4:	4618      	mov	r0, r3
   8f1d6:	372c      	adds	r7, #44	; 0x2c
   8f1d8:	46bd      	mov	sp, r7
   8f1da:	bd90      	pop	{r4, r7, pc}
   8f1dc:	00082eed 	.word	0x00082eed
   8f1e0:	20071c70 	.word	0x20071c70
   8f1e4:	0008ed19 	.word	0x0008ed19
   8f1e8:	0008d44d 	.word	0x0008d44d
   8f1ec:	0008d625 	.word	0x0008d625

0008f1f0 <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
   8f1f0:	b590      	push	{r4, r7, lr}
   8f1f2:	b087      	sub	sp, #28
   8f1f4:	af02      	add	r7, sp, #8
   8f1f6:	6078      	str	r0, [r7, #4]
   8f1f8:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   8f1fa:	4b18      	ldr	r3, [pc, #96]	; (8f25c <prvProcessExpiredTimer+0x6c>)
   8f1fc:	681b      	ldr	r3, [r3, #0]
   8f1fe:	68db      	ldr	r3, [r3, #12]
   8f200:	68db      	ldr	r3, [r3, #12]
   8f202:	60fb      	str	r3, [r7, #12]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   8f204:	68fb      	ldr	r3, [r7, #12]
   8f206:	3304      	adds	r3, #4
   8f208:	4618      	mov	r0, r3
   8f20a:	4b15      	ldr	r3, [pc, #84]	; (8f260 <prvProcessExpiredTimer+0x70>)
   8f20c:	4798      	blx	r3
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   8f20e:	68fb      	ldr	r3, [r7, #12]
   8f210:	69db      	ldr	r3, [r3, #28]
   8f212:	2b01      	cmp	r3, #1
   8f214:	d119      	bne.n	8f24a <prvProcessExpiredTimer+0x5a>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
   8f216:	68fb      	ldr	r3, [r7, #12]
   8f218:	699a      	ldr	r2, [r3, #24]
   8f21a:	687b      	ldr	r3, [r7, #4]
   8f21c:	18d1      	adds	r1, r2, r3
   8f21e:	687b      	ldr	r3, [r7, #4]
   8f220:	683a      	ldr	r2, [r7, #0]
   8f222:	68f8      	ldr	r0, [r7, #12]
   8f224:	4c0f      	ldr	r4, [pc, #60]	; (8f264 <prvProcessExpiredTimer+0x74>)
   8f226:	47a0      	blx	r4
   8f228:	4603      	mov	r3, r0
   8f22a:	2b01      	cmp	r3, #1
   8f22c:	d10d      	bne.n	8f24a <prvProcessExpiredTimer+0x5a>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   8f22e:	2300      	movs	r3, #0
   8f230:	9300      	str	r3, [sp, #0]
   8f232:	2300      	movs	r3, #0
   8f234:	687a      	ldr	r2, [r7, #4]
   8f236:	2100      	movs	r1, #0
   8f238:	68f8      	ldr	r0, [r7, #12]
   8f23a:	4c0b      	ldr	r4, [pc, #44]	; (8f268 <prvProcessExpiredTimer+0x78>)
   8f23c:	47a0      	blx	r4
   8f23e:	60b8      	str	r0, [r7, #8]
			configASSERT( xResult );
   8f240:	68bb      	ldr	r3, [r7, #8]
   8f242:	2b00      	cmp	r3, #0
   8f244:	d101      	bne.n	8f24a <prvProcessExpiredTimer+0x5a>
   8f246:	4b09      	ldr	r3, [pc, #36]	; (8f26c <prvProcessExpiredTimer+0x7c>)
   8f248:	4798      	blx	r3
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   8f24a:	68fb      	ldr	r3, [r7, #12]
   8f24c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8f24e:	68f8      	ldr	r0, [r7, #12]
   8f250:	4798      	blx	r3
}
   8f252:	bf00      	nop
   8f254:	3714      	adds	r7, #20
   8f256:	46bd      	mov	sp, r7
   8f258:	bd90      	pop	{r4, r7, pc}
   8f25a:	bf00      	nop
   8f25c:	20071c68 	.word	0x20071c68
   8f260:	00090669 	.word	0x00090669
   8f264:	0008f3d5 	.word	0x0008f3d5
   8f268:	0008f159 	.word	0x0008f159
   8f26c:	00082eed 	.word	0x00082eed

0008f270 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
   8f270:	b580      	push	{r7, lr}
   8f272:	b084      	sub	sp, #16
   8f274:	af00      	add	r7, sp, #0
   8f276:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   8f278:	f107 0308 	add.w	r3, r7, #8
   8f27c:	4618      	mov	r0, r3
   8f27e:	4b05      	ldr	r3, [pc, #20]	; (8f294 <prvTimerTask+0x24>)
   8f280:	4798      	blx	r3
   8f282:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   8f284:	68bb      	ldr	r3, [r7, #8]
   8f286:	4619      	mov	r1, r3
   8f288:	68f8      	ldr	r0, [r7, #12]
   8f28a:	4b03      	ldr	r3, [pc, #12]	; (8f298 <prvTimerTask+0x28>)
   8f28c:	4798      	blx	r3

		/* Empty the command queue. */
		prvProcessReceivedCommands();
   8f28e:	4b03      	ldr	r3, [pc, #12]	; (8f29c <prvTimerTask+0x2c>)
   8f290:	4798      	blx	r3
	}
   8f292:	e7f1      	b.n	8f278 <prvTimerTask+0x8>
   8f294:	0008f345 	.word	0x0008f345
   8f298:	0008f2a1 	.word	0x0008f2a1
   8f29c:	0008f45d 	.word	0x0008f45d

0008f2a0 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
   8f2a0:	b580      	push	{r7, lr}
   8f2a2:	b084      	sub	sp, #16
   8f2a4:	af00      	add	r7, sp, #0
   8f2a6:	6078      	str	r0, [r7, #4]
   8f2a8:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
   8f2aa:	4b1e      	ldr	r3, [pc, #120]	; (8f324 <prvProcessTimerOrBlockTask+0x84>)
   8f2ac:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   8f2ae:	f107 0308 	add.w	r3, r7, #8
   8f2b2:	4618      	mov	r0, r3
   8f2b4:	4b1c      	ldr	r3, [pc, #112]	; (8f328 <prvProcessTimerOrBlockTask+0x88>)
   8f2b6:	4798      	blx	r3
   8f2b8:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
   8f2ba:	68bb      	ldr	r3, [r7, #8]
   8f2bc:	2b00      	cmp	r3, #0
   8f2be:	d12a      	bne.n	8f316 <prvProcessTimerOrBlockTask+0x76>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   8f2c0:	683b      	ldr	r3, [r7, #0]
   8f2c2:	2b00      	cmp	r3, #0
   8f2c4:	d10a      	bne.n	8f2dc <prvProcessTimerOrBlockTask+0x3c>
   8f2c6:	687a      	ldr	r2, [r7, #4]
   8f2c8:	68fb      	ldr	r3, [r7, #12]
   8f2ca:	429a      	cmp	r2, r3
   8f2cc:	d806      	bhi.n	8f2dc <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
   8f2ce:	4b17      	ldr	r3, [pc, #92]	; (8f32c <prvProcessTimerOrBlockTask+0x8c>)
   8f2d0:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   8f2d2:	68f9      	ldr	r1, [r7, #12]
   8f2d4:	6878      	ldr	r0, [r7, #4]
   8f2d6:	4b16      	ldr	r3, [pc, #88]	; (8f330 <prvProcessTimerOrBlockTask+0x90>)
   8f2d8:	4798      	blx	r3
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
   8f2da:	e01e      	b.n	8f31a <prvProcessTimerOrBlockTask+0x7a>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
   8f2dc:	683b      	ldr	r3, [r7, #0]
   8f2de:	2b00      	cmp	r3, #0
   8f2e0:	d008      	beq.n	8f2f4 <prvProcessTimerOrBlockTask+0x54>
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
   8f2e2:	4b14      	ldr	r3, [pc, #80]	; (8f334 <prvProcessTimerOrBlockTask+0x94>)
   8f2e4:	681b      	ldr	r3, [r3, #0]
   8f2e6:	681b      	ldr	r3, [r3, #0]
   8f2e8:	2b00      	cmp	r3, #0
   8f2ea:	bf0c      	ite	eq
   8f2ec:	2301      	moveq	r3, #1
   8f2ee:	2300      	movne	r3, #0
   8f2f0:	b2db      	uxtb	r3, r3
   8f2f2:	603b      	str	r3, [r7, #0]
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
   8f2f4:	4b10      	ldr	r3, [pc, #64]	; (8f338 <prvProcessTimerOrBlockTask+0x98>)
   8f2f6:	6818      	ldr	r0, [r3, #0]
   8f2f8:	687a      	ldr	r2, [r7, #4]
   8f2fa:	68fb      	ldr	r3, [r7, #12]
   8f2fc:	1ad3      	subs	r3, r2, r3
   8f2fe:	683a      	ldr	r2, [r7, #0]
   8f300:	4619      	mov	r1, r3
   8f302:	4b0e      	ldr	r3, [pc, #56]	; (8f33c <prvProcessTimerOrBlockTask+0x9c>)
   8f304:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
   8f306:	4b09      	ldr	r3, [pc, #36]	; (8f32c <prvProcessTimerOrBlockTask+0x8c>)
   8f308:	4798      	blx	r3
   8f30a:	4603      	mov	r3, r0
   8f30c:	2b00      	cmp	r3, #0
   8f30e:	d104      	bne.n	8f31a <prvProcessTimerOrBlockTask+0x7a>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
   8f310:	4b0b      	ldr	r3, [pc, #44]	; (8f340 <prvProcessTimerOrBlockTask+0xa0>)
   8f312:	4798      	blx	r3
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
   8f314:	e001      	b.n	8f31a <prvProcessTimerOrBlockTask+0x7a>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
   8f316:	4b05      	ldr	r3, [pc, #20]	; (8f32c <prvProcessTimerOrBlockTask+0x8c>)
   8f318:	4798      	blx	r3
		}
	}
}
   8f31a:	bf00      	nop
   8f31c:	3710      	adds	r7, #16
   8f31e:	46bd      	mov	sp, r7
   8f320:	bd80      	pop	{r7, pc}
   8f322:	bf00      	nop
   8f324:	0008e031 	.word	0x0008e031
   8f328:	0008f38d 	.word	0x0008f38d
   8f32c:	0008e04d 	.word	0x0008e04d
   8f330:	0008f1f1 	.word	0x0008f1f1
   8f334:	20071c6c 	.word	0x20071c6c
   8f338:	20071c70 	.word	0x20071c70
   8f33c:	0008db89 	.word	0x0008db89
   8f340:	0009086d 	.word	0x0009086d

0008f344 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
   8f344:	b480      	push	{r7}
   8f346:	b085      	sub	sp, #20
   8f348:	af00      	add	r7, sp, #0
   8f34a:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   8f34c:	4b0e      	ldr	r3, [pc, #56]	; (8f388 <prvGetNextExpireTime+0x44>)
   8f34e:	681b      	ldr	r3, [r3, #0]
   8f350:	681b      	ldr	r3, [r3, #0]
   8f352:	2b00      	cmp	r3, #0
   8f354:	bf0c      	ite	eq
   8f356:	2301      	moveq	r3, #1
   8f358:	2300      	movne	r3, #0
   8f35a:	b2db      	uxtb	r3, r3
   8f35c:	461a      	mov	r2, r3
   8f35e:	687b      	ldr	r3, [r7, #4]
   8f360:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
   8f362:	687b      	ldr	r3, [r7, #4]
   8f364:	681b      	ldr	r3, [r3, #0]
   8f366:	2b00      	cmp	r3, #0
   8f368:	d105      	bne.n	8f376 <prvGetNextExpireTime+0x32>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   8f36a:	4b07      	ldr	r3, [pc, #28]	; (8f388 <prvGetNextExpireTime+0x44>)
   8f36c:	681b      	ldr	r3, [r3, #0]
   8f36e:	68db      	ldr	r3, [r3, #12]
   8f370:	681b      	ldr	r3, [r3, #0]
   8f372:	60fb      	str	r3, [r7, #12]
   8f374:	e001      	b.n	8f37a <prvGetNextExpireTime+0x36>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
   8f376:	2300      	movs	r3, #0
   8f378:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
   8f37a:	68fb      	ldr	r3, [r7, #12]
}
   8f37c:	4618      	mov	r0, r3
   8f37e:	3714      	adds	r7, #20
   8f380:	46bd      	mov	sp, r7
   8f382:	bc80      	pop	{r7}
   8f384:	4770      	bx	lr
   8f386:	bf00      	nop
   8f388:	20071c68 	.word	0x20071c68

0008f38c <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
   8f38c:	b580      	push	{r7, lr}
   8f38e:	b084      	sub	sp, #16
   8f390:	af00      	add	r7, sp, #0
   8f392:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
   8f394:	4b0c      	ldr	r3, [pc, #48]	; (8f3c8 <prvSampleTimeNow+0x3c>)
   8f396:	4798      	blx	r3
   8f398:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
   8f39a:	4b0c      	ldr	r3, [pc, #48]	; (8f3cc <prvSampleTimeNow+0x40>)
   8f39c:	681b      	ldr	r3, [r3, #0]
   8f39e:	68fa      	ldr	r2, [r7, #12]
   8f3a0:	429a      	cmp	r2, r3
   8f3a2:	d205      	bcs.n	8f3b0 <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
   8f3a4:	4b0a      	ldr	r3, [pc, #40]	; (8f3d0 <prvSampleTimeNow+0x44>)
   8f3a6:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
   8f3a8:	687b      	ldr	r3, [r7, #4]
   8f3aa:	2201      	movs	r2, #1
   8f3ac:	601a      	str	r2, [r3, #0]
   8f3ae:	e002      	b.n	8f3b6 <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
   8f3b0:	687b      	ldr	r3, [r7, #4]
   8f3b2:	2200      	movs	r2, #0
   8f3b4:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
   8f3b6:	4a05      	ldr	r2, [pc, #20]	; (8f3cc <prvSampleTimeNow+0x40>)
   8f3b8:	68fb      	ldr	r3, [r7, #12]
   8f3ba:	6013      	str	r3, [r2, #0]

	return xTimeNow;
   8f3bc:	68fb      	ldr	r3, [r7, #12]
}
   8f3be:	4618      	mov	r0, r3
   8f3c0:	3710      	adds	r7, #16
   8f3c2:	46bd      	mov	sp, r7
   8f3c4:	bd80      	pop	{r7, pc}
   8f3c6:	bf00      	nop
   8f3c8:	0008e171 	.word	0x0008e171
   8f3cc:	20071c74 	.word	0x20071c74
   8f3d0:	0008f5a5 	.word	0x0008f5a5

0008f3d4 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
   8f3d4:	b580      	push	{r7, lr}
   8f3d6:	b086      	sub	sp, #24
   8f3d8:	af00      	add	r7, sp, #0
   8f3da:	60f8      	str	r0, [r7, #12]
   8f3dc:	60b9      	str	r1, [r7, #8]
   8f3de:	607a      	str	r2, [r7, #4]
   8f3e0:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
   8f3e2:	2300      	movs	r3, #0
   8f3e4:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   8f3e6:	68fb      	ldr	r3, [r7, #12]
   8f3e8:	68ba      	ldr	r2, [r7, #8]
   8f3ea:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   8f3ec:	68fb      	ldr	r3, [r7, #12]
   8f3ee:	68fa      	ldr	r2, [r7, #12]
   8f3f0:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
   8f3f2:	68ba      	ldr	r2, [r7, #8]
   8f3f4:	687b      	ldr	r3, [r7, #4]
   8f3f6:	429a      	cmp	r2, r3
   8f3f8:	d812      	bhi.n	8f420 <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
   8f3fa:	687a      	ldr	r2, [r7, #4]
   8f3fc:	683b      	ldr	r3, [r7, #0]
   8f3fe:	1ad2      	subs	r2, r2, r3
   8f400:	68fb      	ldr	r3, [r7, #12]
   8f402:	699b      	ldr	r3, [r3, #24]
   8f404:	429a      	cmp	r2, r3
   8f406:	d302      	bcc.n	8f40e <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
   8f408:	2301      	movs	r3, #1
   8f40a:	617b      	str	r3, [r7, #20]
   8f40c:	e01b      	b.n	8f446 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   8f40e:	4b10      	ldr	r3, [pc, #64]	; (8f450 <prvInsertTimerInActiveList+0x7c>)
   8f410:	681a      	ldr	r2, [r3, #0]
   8f412:	68fb      	ldr	r3, [r7, #12]
   8f414:	3304      	adds	r3, #4
   8f416:	4619      	mov	r1, r3
   8f418:	4610      	mov	r0, r2
   8f41a:	4b0e      	ldr	r3, [pc, #56]	; (8f454 <prvInsertTimerInActiveList+0x80>)
   8f41c:	4798      	blx	r3
   8f41e:	e012      	b.n	8f446 <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   8f420:	687a      	ldr	r2, [r7, #4]
   8f422:	683b      	ldr	r3, [r7, #0]
   8f424:	429a      	cmp	r2, r3
   8f426:	d206      	bcs.n	8f436 <prvInsertTimerInActiveList+0x62>
   8f428:	68ba      	ldr	r2, [r7, #8]
   8f42a:	683b      	ldr	r3, [r7, #0]
   8f42c:	429a      	cmp	r2, r3
   8f42e:	d302      	bcc.n	8f436 <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
   8f430:	2301      	movs	r3, #1
   8f432:	617b      	str	r3, [r7, #20]
   8f434:	e007      	b.n	8f446 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   8f436:	4b08      	ldr	r3, [pc, #32]	; (8f458 <prvInsertTimerInActiveList+0x84>)
   8f438:	681a      	ldr	r2, [r3, #0]
   8f43a:	68fb      	ldr	r3, [r7, #12]
   8f43c:	3304      	adds	r3, #4
   8f43e:	4619      	mov	r1, r3
   8f440:	4610      	mov	r0, r2
   8f442:	4b04      	ldr	r3, [pc, #16]	; (8f454 <prvInsertTimerInActiveList+0x80>)
   8f444:	4798      	blx	r3
		}
	}

	return xProcessTimerNow;
   8f446:	697b      	ldr	r3, [r7, #20]
}
   8f448:	4618      	mov	r0, r3
   8f44a:	3718      	adds	r7, #24
   8f44c:	46bd      	mov	sp, r7
   8f44e:	bd80      	pop	{r7, pc}
   8f450:	20071c6c 	.word	0x20071c6c
   8f454:	000905f9 	.word	0x000905f9
   8f458:	20071c68 	.word	0x20071c68

0008f45c <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
   8f45c:	b590      	push	{r4, r7, lr}
   8f45e:	b08d      	sub	sp, #52	; 0x34
   8f460:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   8f462:	e07f      	b.n	8f564 <prvProcessReceivedCommands+0x108>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
   8f464:	68bb      	ldr	r3, [r7, #8]
   8f466:	2b00      	cmp	r3, #0
   8f468:	da10      	bge.n	8f48c <prvProcessReceivedCommands+0x30>
			{
				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
   8f46a:	f107 0308 	add.w	r3, r7, #8
   8f46e:	3304      	adds	r3, #4
   8f470:	627b      	str	r3, [r7, #36]	; 0x24

				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );
   8f472:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8f474:	2b00      	cmp	r3, #0
   8f476:	d101      	bne.n	8f47c <prvProcessReceivedCommands+0x20>
   8f478:	4b42      	ldr	r3, [pc, #264]	; (8f584 <prvProcessReceivedCommands+0x128>)
   8f47a:	4798      	blx	r3

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
   8f47c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   8f47e:	681b      	ldr	r3, [r3, #0]
   8f480:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   8f482:	6850      	ldr	r0, [r2, #4]
   8f484:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   8f486:	6892      	ldr	r2, [r2, #8]
   8f488:	4611      	mov	r1, r2
   8f48a:	4798      	blx	r3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
   8f48c:	68bb      	ldr	r3, [r7, #8]
   8f48e:	2b00      	cmp	r3, #0
   8f490:	db68      	blt.n	8f564 <prvProcessReceivedCommands+0x108>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
   8f492:	693b      	ldr	r3, [r7, #16]
   8f494:	623b      	str	r3, [r7, #32]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
   8f496:	6a3b      	ldr	r3, [r7, #32]
   8f498:	695b      	ldr	r3, [r3, #20]
   8f49a:	2b00      	cmp	r3, #0
   8f49c:	d004      	beq.n	8f4a8 <prvProcessReceivedCommands+0x4c>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   8f49e:	6a3b      	ldr	r3, [r7, #32]
   8f4a0:	3304      	adds	r3, #4
   8f4a2:	4618      	mov	r0, r3
   8f4a4:	4b38      	ldr	r3, [pc, #224]	; (8f588 <prvProcessReceivedCommands+0x12c>)
   8f4a6:	4798      	blx	r3
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   8f4a8:	1d3b      	adds	r3, r7, #4
   8f4aa:	4618      	mov	r0, r3
   8f4ac:	4b37      	ldr	r3, [pc, #220]	; (8f58c <prvProcessReceivedCommands+0x130>)
   8f4ae:	4798      	blx	r3
   8f4b0:	61f8      	str	r0, [r7, #28]

			switch( xMessage.xMessageID )
   8f4b2:	68bb      	ldr	r3, [r7, #8]
   8f4b4:	2b09      	cmp	r3, #9
   8f4b6:	d854      	bhi.n	8f562 <prvProcessReceivedCommands+0x106>
   8f4b8:	a201      	add	r2, pc, #4	; (adr r2, 8f4c0 <prvProcessReceivedCommands+0x64>)
   8f4ba:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   8f4be:	bf00      	nop
   8f4c0:	0008f4e9 	.word	0x0008f4e9
   8f4c4:	0008f4e9 	.word	0x0008f4e9
   8f4c8:	0008f4e9 	.word	0x0008f4e9
   8f4cc:	0008f565 	.word	0x0008f565
   8f4d0:	0008f535 	.word	0x0008f535
   8f4d4:	0008f55b 	.word	0x0008f55b
   8f4d8:	0008f4e9 	.word	0x0008f4e9
   8f4dc:	0008f4e9 	.word	0x0008f4e9
   8f4e0:	0008f565 	.word	0x0008f565
   8f4e4:	0008f535 	.word	0x0008f535
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
   8f4e8:	68fa      	ldr	r2, [r7, #12]
   8f4ea:	6a3b      	ldr	r3, [r7, #32]
   8f4ec:	699b      	ldr	r3, [r3, #24]
   8f4ee:	18d1      	adds	r1, r2, r3
   8f4f0:	68fb      	ldr	r3, [r7, #12]
   8f4f2:	69fa      	ldr	r2, [r7, #28]
   8f4f4:	6a38      	ldr	r0, [r7, #32]
   8f4f6:	4c26      	ldr	r4, [pc, #152]	; (8f590 <prvProcessReceivedCommands+0x134>)
   8f4f8:	47a0      	blx	r4
   8f4fa:	4603      	mov	r3, r0
   8f4fc:	2b01      	cmp	r3, #1
   8f4fe:	d131      	bne.n	8f564 <prvProcessReceivedCommands+0x108>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   8f500:	6a3b      	ldr	r3, [r7, #32]
   8f502:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8f504:	6a38      	ldr	r0, [r7, #32]
   8f506:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   8f508:	6a3b      	ldr	r3, [r7, #32]
   8f50a:	69db      	ldr	r3, [r3, #28]
   8f50c:	2b01      	cmp	r3, #1
   8f50e:	d129      	bne.n	8f564 <prvProcessReceivedCommands+0x108>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   8f510:	68fa      	ldr	r2, [r7, #12]
   8f512:	6a3b      	ldr	r3, [r7, #32]
   8f514:	699b      	ldr	r3, [r3, #24]
   8f516:	441a      	add	r2, r3
   8f518:	2300      	movs	r3, #0
   8f51a:	9300      	str	r3, [sp, #0]
   8f51c:	2300      	movs	r3, #0
   8f51e:	2100      	movs	r1, #0
   8f520:	6a38      	ldr	r0, [r7, #32]
   8f522:	4c1c      	ldr	r4, [pc, #112]	; (8f594 <prvProcessReceivedCommands+0x138>)
   8f524:	47a0      	blx	r4
   8f526:	61b8      	str	r0, [r7, #24]
							configASSERT( xResult );
   8f528:	69bb      	ldr	r3, [r7, #24]
   8f52a:	2b00      	cmp	r3, #0
   8f52c:	d11a      	bne.n	8f564 <prvProcessReceivedCommands+0x108>
   8f52e:	4b15      	ldr	r3, [pc, #84]	; (8f584 <prvProcessReceivedCommands+0x128>)
   8f530:	4798      	blx	r3
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
   8f532:	e017      	b.n	8f564 <prvProcessReceivedCommands+0x108>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
   8f534:	68fa      	ldr	r2, [r7, #12]
   8f536:	6a3b      	ldr	r3, [r7, #32]
   8f538:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   8f53a:	6a3b      	ldr	r3, [r7, #32]
   8f53c:	699b      	ldr	r3, [r3, #24]
   8f53e:	2b00      	cmp	r3, #0
   8f540:	d101      	bne.n	8f546 <prvProcessReceivedCommands+0xea>
   8f542:	4b10      	ldr	r3, [pc, #64]	; (8f584 <prvProcessReceivedCommands+0x128>)
   8f544:	4798      	blx	r3
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   8f546:	6a3b      	ldr	r3, [r7, #32]
   8f548:	699a      	ldr	r2, [r3, #24]
   8f54a:	69fb      	ldr	r3, [r7, #28]
   8f54c:	18d1      	adds	r1, r2, r3
   8f54e:	69fb      	ldr	r3, [r7, #28]
   8f550:	69fa      	ldr	r2, [r7, #28]
   8f552:	6a38      	ldr	r0, [r7, #32]
   8f554:	4c0e      	ldr	r4, [pc, #56]	; (8f590 <prvProcessReceivedCommands+0x134>)
   8f556:	47a0      	blx	r4
					break;
   8f558:	e004      	b.n	8f564 <prvProcessReceivedCommands+0x108>

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
   8f55a:	6a38      	ldr	r0, [r7, #32]
   8f55c:	4b0e      	ldr	r3, [pc, #56]	; (8f598 <prvProcessReceivedCommands+0x13c>)
   8f55e:	4798      	blx	r3
					break;
   8f560:	e000      	b.n	8f564 <prvProcessReceivedCommands+0x108>

				default	:
					/* Don't expect to get here. */
					break;
   8f562:	bf00      	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   8f564:	4b0d      	ldr	r3, [pc, #52]	; (8f59c <prvProcessReceivedCommands+0x140>)
   8f566:	6818      	ldr	r0, [r3, #0]
   8f568:	f107 0108 	add.w	r1, r7, #8
   8f56c:	2300      	movs	r3, #0
   8f56e:	2200      	movs	r2, #0
   8f570:	4c0b      	ldr	r4, [pc, #44]	; (8f5a0 <prvProcessReceivedCommands+0x144>)
   8f572:	47a0      	blx	r4
   8f574:	4603      	mov	r3, r0
   8f576:	2b00      	cmp	r3, #0
   8f578:	f47f af74 	bne.w	8f464 <prvProcessReceivedCommands+0x8>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
   8f57c:	bf00      	nop
   8f57e:	372c      	adds	r7, #44	; 0x2c
   8f580:	46bd      	mov	sp, r7
   8f582:	bd90      	pop	{r4, r7, pc}
   8f584:	00082eed 	.word	0x00082eed
   8f588:	00090669 	.word	0x00090669
   8f58c:	0008f38d 	.word	0x0008f38d
   8f590:	0008f3d5 	.word	0x0008f3d5
   8f594:	0008f159 	.word	0x0008f159
   8f598:	00090529 	.word	0x00090529
   8f59c:	20071c70 	.word	0x20071c70
   8f5a0:	0008d735 	.word	0x0008d735

0008f5a4 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
   8f5a4:	b590      	push	{r4, r7, lr}
   8f5a6:	b089      	sub	sp, #36	; 0x24
   8f5a8:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   8f5aa:	e03c      	b.n	8f626 <prvSwitchTimerLists+0x82>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   8f5ac:	4b27      	ldr	r3, [pc, #156]	; (8f64c <prvSwitchTimerLists+0xa8>)
   8f5ae:	681b      	ldr	r3, [r3, #0]
   8f5b0:	68db      	ldr	r3, [r3, #12]
   8f5b2:	681b      	ldr	r3, [r3, #0]
   8f5b4:	617b      	str	r3, [r7, #20]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   8f5b6:	4b25      	ldr	r3, [pc, #148]	; (8f64c <prvSwitchTimerLists+0xa8>)
   8f5b8:	681b      	ldr	r3, [r3, #0]
   8f5ba:	68db      	ldr	r3, [r3, #12]
   8f5bc:	68db      	ldr	r3, [r3, #12]
   8f5be:	613b      	str	r3, [r7, #16]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   8f5c0:	693b      	ldr	r3, [r7, #16]
   8f5c2:	3304      	adds	r3, #4
   8f5c4:	4618      	mov	r0, r3
   8f5c6:	4b22      	ldr	r3, [pc, #136]	; (8f650 <prvSwitchTimerLists+0xac>)
   8f5c8:	4798      	blx	r3
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   8f5ca:	693b      	ldr	r3, [r7, #16]
   8f5cc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   8f5ce:	6938      	ldr	r0, [r7, #16]
   8f5d0:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   8f5d2:	693b      	ldr	r3, [r7, #16]
   8f5d4:	69db      	ldr	r3, [r3, #28]
   8f5d6:	2b01      	cmp	r3, #1
   8f5d8:	d125      	bne.n	8f626 <prvSwitchTimerLists+0x82>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   8f5da:	693b      	ldr	r3, [r7, #16]
   8f5dc:	699a      	ldr	r2, [r3, #24]
   8f5de:	697b      	ldr	r3, [r7, #20]
   8f5e0:	4413      	add	r3, r2
   8f5e2:	60fb      	str	r3, [r7, #12]
			if( xReloadTime > xNextExpireTime )
   8f5e4:	68fa      	ldr	r2, [r7, #12]
   8f5e6:	697b      	ldr	r3, [r7, #20]
   8f5e8:	429a      	cmp	r2, r3
   8f5ea:	d90e      	bls.n	8f60a <prvSwitchTimerLists+0x66>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   8f5ec:	693b      	ldr	r3, [r7, #16]
   8f5ee:	68fa      	ldr	r2, [r7, #12]
   8f5f0:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   8f5f2:	693b      	ldr	r3, [r7, #16]
   8f5f4:	693a      	ldr	r2, [r7, #16]
   8f5f6:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   8f5f8:	4b14      	ldr	r3, [pc, #80]	; (8f64c <prvSwitchTimerLists+0xa8>)
   8f5fa:	681a      	ldr	r2, [r3, #0]
   8f5fc:	693b      	ldr	r3, [r7, #16]
   8f5fe:	3304      	adds	r3, #4
   8f600:	4619      	mov	r1, r3
   8f602:	4610      	mov	r0, r2
   8f604:	4b13      	ldr	r3, [pc, #76]	; (8f654 <prvSwitchTimerLists+0xb0>)
   8f606:	4798      	blx	r3
   8f608:	e00d      	b.n	8f626 <prvSwitchTimerLists+0x82>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   8f60a:	2300      	movs	r3, #0
   8f60c:	9300      	str	r3, [sp, #0]
   8f60e:	2300      	movs	r3, #0
   8f610:	697a      	ldr	r2, [r7, #20]
   8f612:	2100      	movs	r1, #0
   8f614:	6938      	ldr	r0, [r7, #16]
   8f616:	4c10      	ldr	r4, [pc, #64]	; (8f658 <prvSwitchTimerLists+0xb4>)
   8f618:	47a0      	blx	r4
   8f61a:	60b8      	str	r0, [r7, #8]
				configASSERT( xResult );
   8f61c:	68bb      	ldr	r3, [r7, #8]
   8f61e:	2b00      	cmp	r3, #0
   8f620:	d101      	bne.n	8f626 <prvSwitchTimerLists+0x82>
   8f622:	4b0e      	ldr	r3, [pc, #56]	; (8f65c <prvSwitchTimerLists+0xb8>)
   8f624:	4798      	blx	r3

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   8f626:	4b09      	ldr	r3, [pc, #36]	; (8f64c <prvSwitchTimerLists+0xa8>)
   8f628:	681b      	ldr	r3, [r3, #0]
   8f62a:	681b      	ldr	r3, [r3, #0]
   8f62c:	2b00      	cmp	r3, #0
   8f62e:	d1bd      	bne.n	8f5ac <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
   8f630:	4b06      	ldr	r3, [pc, #24]	; (8f64c <prvSwitchTimerLists+0xa8>)
   8f632:	681b      	ldr	r3, [r3, #0]
   8f634:	607b      	str	r3, [r7, #4]
	pxCurrentTimerList = pxOverflowTimerList;
   8f636:	4b0a      	ldr	r3, [pc, #40]	; (8f660 <prvSwitchTimerLists+0xbc>)
   8f638:	681b      	ldr	r3, [r3, #0]
   8f63a:	4a04      	ldr	r2, [pc, #16]	; (8f64c <prvSwitchTimerLists+0xa8>)
   8f63c:	6013      	str	r3, [r2, #0]
	pxOverflowTimerList = pxTemp;
   8f63e:	4a08      	ldr	r2, [pc, #32]	; (8f660 <prvSwitchTimerLists+0xbc>)
   8f640:	687b      	ldr	r3, [r7, #4]
   8f642:	6013      	str	r3, [r2, #0]
}
   8f644:	bf00      	nop
   8f646:	371c      	adds	r7, #28
   8f648:	46bd      	mov	sp, r7
   8f64a:	bd90      	pop	{r4, r7, pc}
   8f64c:	20071c68 	.word	0x20071c68
   8f650:	00090669 	.word	0x00090669
   8f654:	000905f9 	.word	0x000905f9
   8f658:	0008f159 	.word	0x0008f159
   8f65c:	00082eed 	.word	0x00082eed
   8f660:	20071c6c 	.word	0x20071c6c

0008f664 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   8f664:	b580      	push	{r7, lr}
   8f666:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   8f668:	4b11      	ldr	r3, [pc, #68]	; (8f6b0 <prvCheckForValidListAndQueue+0x4c>)
   8f66a:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
   8f66c:	4b11      	ldr	r3, [pc, #68]	; (8f6b4 <prvCheckForValidListAndQueue+0x50>)
   8f66e:	681b      	ldr	r3, [r3, #0]
   8f670:	2b00      	cmp	r3, #0
   8f672:	d119      	bne.n	8f6a8 <prvCheckForValidListAndQueue+0x44>
		{
			vListInitialise( &xActiveTimerList1 );
   8f674:	4810      	ldr	r0, [pc, #64]	; (8f6b8 <prvCheckForValidListAndQueue+0x54>)
   8f676:	4b11      	ldr	r3, [pc, #68]	; (8f6bc <prvCheckForValidListAndQueue+0x58>)
   8f678:	4798      	blx	r3
			vListInitialise( &xActiveTimerList2 );
   8f67a:	4811      	ldr	r0, [pc, #68]	; (8f6c0 <prvCheckForValidListAndQueue+0x5c>)
   8f67c:	4b0f      	ldr	r3, [pc, #60]	; (8f6bc <prvCheckForValidListAndQueue+0x58>)
   8f67e:	4798      	blx	r3
			pxCurrentTimerList = &xActiveTimerList1;
   8f680:	4b10      	ldr	r3, [pc, #64]	; (8f6c4 <prvCheckForValidListAndQueue+0x60>)
   8f682:	4a0d      	ldr	r2, [pc, #52]	; (8f6b8 <prvCheckForValidListAndQueue+0x54>)
   8f684:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
   8f686:	4b10      	ldr	r3, [pc, #64]	; (8f6c8 <prvCheckForValidListAndQueue+0x64>)
   8f688:	4a0d      	ldr	r2, [pc, #52]	; (8f6c0 <prvCheckForValidListAndQueue+0x5c>)
   8f68a:	601a      	str	r2, [r3, #0]
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   8f68c:	2200      	movs	r2, #0
   8f68e:	2110      	movs	r1, #16
   8f690:	2005      	movs	r0, #5
   8f692:	4b0e      	ldr	r3, [pc, #56]	; (8f6cc <prvCheckForValidListAndQueue+0x68>)
   8f694:	4798      	blx	r3
   8f696:	4602      	mov	r2, r0
   8f698:	4b06      	ldr	r3, [pc, #24]	; (8f6b4 <prvCheckForValidListAndQueue+0x50>)
   8f69a:	601a      	str	r2, [r3, #0]
			configASSERT( xTimerQueue );
   8f69c:	4b05      	ldr	r3, [pc, #20]	; (8f6b4 <prvCheckForValidListAndQueue+0x50>)
   8f69e:	681b      	ldr	r3, [r3, #0]
   8f6a0:	2b00      	cmp	r3, #0
   8f6a2:	d101      	bne.n	8f6a8 <prvCheckForValidListAndQueue+0x44>
   8f6a4:	4b0a      	ldr	r3, [pc, #40]	; (8f6d0 <prvCheckForValidListAndQueue+0x6c>)
   8f6a6:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   8f6a8:	4b0a      	ldr	r3, [pc, #40]	; (8f6d4 <prvCheckForValidListAndQueue+0x70>)
   8f6aa:	4798      	blx	r3
}
   8f6ac:	bf00      	nop
   8f6ae:	bd80      	pop	{r7, pc}
   8f6b0:	0009088d 	.word	0x0009088d
   8f6b4:	20071c70 	.word	0x20071c70
   8f6b8:	20071c40 	.word	0x20071c40
   8f6bc:	00090559 	.word	0x00090559
   8f6c0:	20071c54 	.word	0x20071c54
   8f6c4:	20071c68 	.word	0x20071c68
   8f6c8:	20071c6c 	.word	0x20071c6c
   8f6cc:	0008d2bd 	.word	0x0008d2bd
   8f6d0:	00082eed 	.word	0x00082eed
   8f6d4:	000908d1 	.word	0x000908d1

0008f6d8 <_ZN3ard10moduloPiPiEf>:

using namespace ard;

float
ard::moduloPiPi (float a)
{
   8f6d8:	b590      	push	{r4, r7, lr}
   8f6da:	b083      	sub	sp, #12
   8f6dc:	af00      	add	r7, sp, #0
   8f6de:	6078      	str	r0, [r7, #4]
  if (a <= -M_PI)
   8f6e0:	4b25      	ldr	r3, [pc, #148]	; (8f778 <_ZN3ard10moduloPiPiEf+0xa0>)
   8f6e2:	6878      	ldr	r0, [r7, #4]
   8f6e4:	4798      	blx	r3
   8f6e6:	4c25      	ldr	r4, [pc, #148]	; (8f77c <_ZN3ard10moduloPiPiEf+0xa4>)
   8f6e8:	a31d      	add	r3, pc, #116	; (adr r3, 8f760 <_ZN3ard10moduloPiPiEf+0x88>)
   8f6ea:	e9d3 2300 	ldrd	r2, r3, [r3]
   8f6ee:	47a0      	blx	r4
   8f6f0:	4603      	mov	r3, r0
   8f6f2:	2b00      	cmp	r3, #0
   8f6f4:	d011      	beq.n	8f71a <_ZN3ard10moduloPiPiEf+0x42>
    return a + 2 * M_PI;
   8f6f6:	4b20      	ldr	r3, [pc, #128]	; (8f778 <_ZN3ard10moduloPiPiEf+0xa0>)
   8f6f8:	6878      	ldr	r0, [r7, #4]
   8f6fa:	4798      	blx	r3
   8f6fc:	4c20      	ldr	r4, [pc, #128]	; (8f780 <_ZN3ard10moduloPiPiEf+0xa8>)
   8f6fe:	a31a      	add	r3, pc, #104	; (adr r3, 8f768 <_ZN3ard10moduloPiPiEf+0x90>)
   8f700:	e9d3 2300 	ldrd	r2, r3, [r3]
   8f704:	47a0      	blx	r4
   8f706:	4603      	mov	r3, r0
   8f708:	460c      	mov	r4, r1
   8f70a:	4619      	mov	r1, r3
   8f70c:	4622      	mov	r2, r4
   8f70e:	4b1d      	ldr	r3, [pc, #116]	; (8f784 <_ZN3ard10moduloPiPiEf+0xac>)
   8f710:	4608      	mov	r0, r1
   8f712:	4611      	mov	r1, r2
   8f714:	4798      	blx	r3
   8f716:	4603      	mov	r3, r0
   8f718:	e01d      	b.n	8f756 <_ZN3ard10moduloPiPiEf+0x7e>
  else if (a > M_PI)
   8f71a:	4b17      	ldr	r3, [pc, #92]	; (8f778 <_ZN3ard10moduloPiPiEf+0xa0>)
   8f71c:	6878      	ldr	r0, [r7, #4]
   8f71e:	4798      	blx	r3
   8f720:	4c19      	ldr	r4, [pc, #100]	; (8f788 <_ZN3ard10moduloPiPiEf+0xb0>)
   8f722:	a313      	add	r3, pc, #76	; (adr r3, 8f770 <_ZN3ard10moduloPiPiEf+0x98>)
   8f724:	e9d3 2300 	ldrd	r2, r3, [r3]
   8f728:	47a0      	blx	r4
   8f72a:	4603      	mov	r3, r0
   8f72c:	2b00      	cmp	r3, #0
   8f72e:	d011      	beq.n	8f754 <_ZN3ard10moduloPiPiEf+0x7c>
    return a - 2 * M_PI;
   8f730:	4b11      	ldr	r3, [pc, #68]	; (8f778 <_ZN3ard10moduloPiPiEf+0xa0>)
   8f732:	6878      	ldr	r0, [r7, #4]
   8f734:	4798      	blx	r3
   8f736:	4c15      	ldr	r4, [pc, #84]	; (8f78c <_ZN3ard10moduloPiPiEf+0xb4>)
   8f738:	a30b      	add	r3, pc, #44	; (adr r3, 8f768 <_ZN3ard10moduloPiPiEf+0x90>)
   8f73a:	e9d3 2300 	ldrd	r2, r3, [r3]
   8f73e:	47a0      	blx	r4
   8f740:	4603      	mov	r3, r0
   8f742:	460c      	mov	r4, r1
   8f744:	4619      	mov	r1, r3
   8f746:	4622      	mov	r2, r4
   8f748:	4b0e      	ldr	r3, [pc, #56]	; (8f784 <_ZN3ard10moduloPiPiEf+0xac>)
   8f74a:	4608      	mov	r0, r1
   8f74c:	4611      	mov	r1, r2
   8f74e:	4798      	blx	r3
   8f750:	4603      	mov	r3, r0
   8f752:	e000      	b.n	8f756 <_ZN3ard10moduloPiPiEf+0x7e>
  else
    return a;
   8f754:	687b      	ldr	r3, [r7, #4]
}
   8f756:	4618      	mov	r0, r3
   8f758:	370c      	adds	r7, #12
   8f75a:	46bd      	mov	sp, r7
   8f75c:	bd90      	pop	{r4, r7, pc}
   8f75e:	bf00      	nop
   8f760:	54442d18 	.word	0x54442d18
   8f764:	c00921fb 	.word	0xc00921fb
   8f768:	54442d18 	.word	0x54442d18
   8f76c:	401921fb 	.word	0x401921fb
   8f770:	54442d18 	.word	0x54442d18
   8f774:	400921fb 	.word	0x400921fb
   8f778:	000926d5 	.word	0x000926d5
   8f77c:	00092c75 	.word	0x00092c75
   8f780:	00092419 	.word	0x00092419
   8f784:	00092d6d 	.word	0x00092d6d
   8f788:	00092c9d 	.word	0x00092c9d
   8f78c:	00092415 	.word	0x00092415

0008f790 <_ZN3ard5PointC1Ev>:

Point::Point () :
   8f790:	b480      	push	{r7}
   8f792:	b083      	sub	sp, #12
   8f794:	af00      	add	r7, sp, #0
   8f796:	6078      	str	r0, [r7, #4]
    x (0), y (0)
   8f798:	4a08      	ldr	r2, [pc, #32]	; (8f7bc <_ZN3ard5PointC1Ev+0x2c>)
   8f79a:	687b      	ldr	r3, [r7, #4]
   8f79c:	601a      	str	r2, [r3, #0]
   8f79e:	687b      	ldr	r3, [r7, #4]
   8f7a0:	f04f 0200 	mov.w	r2, #0
   8f7a4:	605a      	str	r2, [r3, #4]
   8f7a6:	687b      	ldr	r3, [r7, #4]
   8f7a8:	f04f 0200 	mov.w	r2, #0
   8f7ac:	609a      	str	r2, [r3, #8]
{
}
   8f7ae:	687b      	ldr	r3, [r7, #4]
   8f7b0:	4618      	mov	r0, r3
   8f7b2:	370c      	adds	r7, #12
   8f7b4:	46bd      	mov	sp, r7
   8f7b6:	bc80      	pop	{r7}
   8f7b8:	4770      	bx	lr
   8f7ba:	bf00      	nop
   8f7bc:	0009aef4 	.word	0x0009aef4

0008f7c0 <_ZN3ard5PointC1Eff>:
;

Point::Point (float _x, float _y):
   8f7c0:	b480      	push	{r7}
   8f7c2:	b085      	sub	sp, #20
   8f7c4:	af00      	add	r7, sp, #0
   8f7c6:	60f8      	str	r0, [r7, #12]
   8f7c8:	60b9      	str	r1, [r7, #8]
   8f7ca:	607a      	str	r2, [r7, #4]
  x (_x), y (_y)
   8f7cc:	4a07      	ldr	r2, [pc, #28]	; (8f7ec <_ZN3ard5PointC1Eff+0x2c>)
   8f7ce:	68fb      	ldr	r3, [r7, #12]
   8f7d0:	601a      	str	r2, [r3, #0]
   8f7d2:	68fb      	ldr	r3, [r7, #12]
   8f7d4:	68ba      	ldr	r2, [r7, #8]
   8f7d6:	605a      	str	r2, [r3, #4]
   8f7d8:	68fb      	ldr	r3, [r7, #12]
   8f7da:	687a      	ldr	r2, [r7, #4]
   8f7dc:	609a      	str	r2, [r3, #8]
{
}
   8f7de:	68fb      	ldr	r3, [r7, #12]
   8f7e0:	4618      	mov	r0, r3
   8f7e2:	3714      	adds	r7, #20
   8f7e4:	46bd      	mov	sp, r7
   8f7e6:	bc80      	pop	{r7}
   8f7e8:	4770      	bx	lr
   8f7ea:	bf00      	nop
   8f7ec:	0009aef4 	.word	0x0009aef4

0008f7f0 <_ZN3ard5Point10toAmbiPoseE6eColor>:
;

Point
Point::toAmbiPose (eColor c)
{
   8f7f0:	b590      	push	{r4, r7, lr}
   8f7f2:	b08f      	sub	sp, #60	; 0x3c
   8f7f4:	af00      	add	r7, sp, #0
   8f7f6:	60f8      	str	r0, [r7, #12]
   8f7f8:	60b9      	str	r1, [r7, #8]
   8f7fa:	607a      	str	r2, [r7, #4]
  Point res;
   8f7fc:	68f8      	ldr	r0, [r7, #12]
   8f7fe:	4b2c      	ldr	r3, [pc, #176]	; (8f8b0 <_ZN3ard5Point10toAmbiPoseE6eColor+0xc0>)
   8f800:	4798      	blx	r3
  ardAssert (c != eColor::UNDEF, "Color should not be undefined");
   8f802:	687b      	ldr	r3, [r7, #4]
   8f804:	2b00      	cmp	r3, #0
   8f806:	d137      	bne.n	8f878 <_ZN3ard5Point10toAmbiPoseE6eColor+0x88>
   8f808:	4b2a      	ldr	r3, [pc, #168]	; (8f8b4 <_ZN3ard5Point10toAmbiPoseE6eColor+0xc4>)
   8f80a:	4798      	blx	r3
   8f80c:	4604      	mov	r4, r0
   8f80e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   8f812:	4929      	ldr	r1, [pc, #164]	; (8f8b8 <_ZN3ard5Point10toAmbiPoseE6eColor+0xc8>)
   8f814:	4618      	mov	r0, r3
   8f816:	4b29      	ldr	r3, [pc, #164]	; (8f8bc <_ZN3ard5Point10toAmbiPoseE6eColor+0xcc>)
   8f818:	4798      	blx	r3
   8f81a:	f107 022c 	add.w	r2, r7, #44	; 0x2c
   8f81e:	f107 0320 	add.w	r3, r7, #32
   8f822:	4611      	mov	r1, r2
   8f824:	4618      	mov	r0, r3
   8f826:	4b26      	ldr	r3, [pc, #152]	; (8f8c0 <_ZN3ard5Point10toAmbiPoseE6eColor+0xd0>)
   8f828:	4798      	blx	r3
   8f82a:	f107 0320 	add.w	r3, r7, #32
   8f82e:	4925      	ldr	r1, [pc, #148]	; (8f8c4 <_ZN3ard5Point10toAmbiPoseE6eColor+0xd4>)
   8f830:	4618      	mov	r0, r3
   8f832:	4b25      	ldr	r3, [pc, #148]	; (8f8c8 <_ZN3ard5Point10toAmbiPoseE6eColor+0xd8>)
   8f834:	4798      	blx	r3
   8f836:	4603      	mov	r3, r0
   8f838:	461a      	mov	r2, r3
   8f83a:	f107 0314 	add.w	r3, r7, #20
   8f83e:	4611      	mov	r1, r2
   8f840:	4618      	mov	r0, r3
   8f842:	4b22      	ldr	r3, [pc, #136]	; (8f8cc <_ZN3ard5Point10toAmbiPoseE6eColor+0xdc>)
   8f844:	4798      	blx	r3
   8f846:	f107 0314 	add.w	r3, r7, #20
   8f84a:	4619      	mov	r1, r3
   8f84c:	4620      	mov	r0, r4
   8f84e:	4b20      	ldr	r3, [pc, #128]	; (8f8d0 <_ZN3ard5Point10toAmbiPoseE6eColor+0xe0>)
   8f850:	4798      	blx	r3
   8f852:	f107 0314 	add.w	r3, r7, #20
   8f856:	4618      	mov	r0, r3
   8f858:	4b1e      	ldr	r3, [pc, #120]	; (8f8d4 <_ZN3ard5Point10toAmbiPoseE6eColor+0xe4>)
   8f85a:	4798      	blx	r3
   8f85c:	f107 0320 	add.w	r3, r7, #32
   8f860:	4618      	mov	r0, r3
   8f862:	4b1d      	ldr	r3, [pc, #116]	; (8f8d8 <_ZN3ard5Point10toAmbiPoseE6eColor+0xe8>)
   8f864:	4798      	blx	r3
   8f866:	f107 032c 	add.w	r3, r7, #44	; 0x2c
   8f86a:	4618      	mov	r0, r3
   8f86c:	4b19      	ldr	r3, [pc, #100]	; (8f8d4 <_ZN3ard5Point10toAmbiPoseE6eColor+0xe4>)
   8f86e:	4798      	blx	r3
   8f870:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   8f874:	4b19      	ldr	r3, [pc, #100]	; (8f8dc <_ZN3ard5Point10toAmbiPoseE6eColor+0xec>)
   8f876:	4798      	blx	r3
  if (c == eColor::SYM)
   8f878:	687b      	ldr	r3, [r7, #4]
   8f87a:	2b02      	cmp	r3, #2
   8f87c:	d10a      	bne.n	8f894 <_ZN3ard5Point10toAmbiPoseE6eColor+0xa4>
    {
      res.x = -x;
   8f87e:	68bb      	ldr	r3, [r7, #8]
   8f880:	685b      	ldr	r3, [r3, #4]
   8f882:	f083 4200 	eor.w	r2, r3, #2147483648	; 0x80000000
   8f886:	68fb      	ldr	r3, [r7, #12]
   8f888:	605a      	str	r2, [r3, #4]
      res.y = y;
   8f88a:	68bb      	ldr	r3, [r7, #8]
   8f88c:	689a      	ldr	r2, [r3, #8]
   8f88e:	68fb      	ldr	r3, [r7, #12]
   8f890:	609a      	str	r2, [r3, #8]
  else
    {
      res.x = x;
      res.y = y;
    }
  return res;
   8f892:	e007      	b.n	8f8a4 <_ZN3ard5Point10toAmbiPoseE6eColor+0xb4>
      res.x = -x;
      res.y = y;
    }
  else
    {
      res.x = x;
   8f894:	68bb      	ldr	r3, [r7, #8]
   8f896:	685a      	ldr	r2, [r3, #4]
   8f898:	68fb      	ldr	r3, [r7, #12]
   8f89a:	605a      	str	r2, [r3, #4]
      res.y = y;
   8f89c:	68bb      	ldr	r3, [r7, #8]
   8f89e:	689a      	ldr	r2, [r3, #8]
   8f8a0:	68fb      	ldr	r3, [r7, #12]
   8f8a2:	609a      	str	r2, [r3, #8]
    }
  return res;
   8f8a4:	bf00      	nop
}
   8f8a6:	68f8      	ldr	r0, [r7, #12]
   8f8a8:	373c      	adds	r7, #60	; 0x3c
   8f8aa:	46bd      	mov	sp, r7
   8f8ac:	bd90      	pop	{r4, r7, pc}
   8f8ae:	bf00      	nop
   8f8b0:	0008f791 	.word	0x0008f791
   8f8b4:	00082fad 	.word	0x00082fad
   8f8b8:	0009ae9c 	.word	0x0009ae9c
   8f8bc:	00089009 	.word	0x00089009
   8f8c0:	00082f89 	.word	0x00082f89
   8f8c4:	0009aeac 	.word	0x0009aeac
   8f8c8:	0008951d 	.word	0x0008951d
   8f8cc:	00089049 	.word	0x00089049
   8f8d0:	00083845 	.word	0x00083845
   8f8d4:	00089145 	.word	0x00089145
   8f8d8:	00082fe9 	.word	0x00082fe9
   8f8dc:	00081c7d 	.word	0x00081c7d

0008f8e0 <_ZN3ard5Point7angleToES0_>:

float Point::angleTo(Point p)
{
   8f8e0:	b5b0      	push	{r4, r5, r7, lr}
   8f8e2:	b082      	sub	sp, #8
   8f8e4:	af00      	add	r7, sp, #0
   8f8e6:	6078      	str	r0, [r7, #4]
   8f8e8:	6039      	str	r1, [r7, #0]
  return atan2 (p.y - y, p.x - x);
   8f8ea:	683b      	ldr	r3, [r7, #0]
   8f8ec:	689a      	ldr	r2, [r3, #8]
   8f8ee:	687b      	ldr	r3, [r7, #4]
   8f8f0:	6899      	ldr	r1, [r3, #8]
   8f8f2:	4b13      	ldr	r3, [pc, #76]	; (8f940 <_ZN3ard5Point7angleToES0_+0x60>)
   8f8f4:	4610      	mov	r0, r2
   8f8f6:	4798      	blx	r3
   8f8f8:	4603      	mov	r3, r0
   8f8fa:	461a      	mov	r2, r3
   8f8fc:	4b11      	ldr	r3, [pc, #68]	; (8f944 <_ZN3ard5Point7angleToES0_+0x64>)
   8f8fe:	4610      	mov	r0, r2
   8f900:	4798      	blx	r3
   8f902:	4604      	mov	r4, r0
   8f904:	460d      	mov	r5, r1
   8f906:	683b      	ldr	r3, [r7, #0]
   8f908:	685a      	ldr	r2, [r3, #4]
   8f90a:	687b      	ldr	r3, [r7, #4]
   8f90c:	6859      	ldr	r1, [r3, #4]
   8f90e:	4b0c      	ldr	r3, [pc, #48]	; (8f940 <_ZN3ard5Point7angleToES0_+0x60>)
   8f910:	4610      	mov	r0, r2
   8f912:	4798      	blx	r3
   8f914:	4603      	mov	r3, r0
   8f916:	461a      	mov	r2, r3
   8f918:	4b0a      	ldr	r3, [pc, #40]	; (8f944 <_ZN3ard5Point7angleToES0_+0x64>)
   8f91a:	4610      	mov	r0, r2
   8f91c:	4798      	blx	r3
   8f91e:	4602      	mov	r2, r0
   8f920:	460b      	mov	r3, r1
   8f922:	4620      	mov	r0, r4
   8f924:	4629      	mov	r1, r5
   8f926:	4c08      	ldr	r4, [pc, #32]	; (8f948 <_ZN3ard5Point7angleToES0_+0x68>)
   8f928:	47a0      	blx	r4
   8f92a:	460a      	mov	r2, r1
   8f92c:	4601      	mov	r1, r0
   8f92e:	4b07      	ldr	r3, [pc, #28]	; (8f94c <_ZN3ard5Point7angleToES0_+0x6c>)
   8f930:	4608      	mov	r0, r1
   8f932:	4611      	mov	r1, r2
   8f934:	4798      	blx	r3
   8f936:	4603      	mov	r3, r0
}
   8f938:	4618      	mov	r0, r3
   8f93a:	3708      	adds	r7, #8
   8f93c:	46bd      	mov	sp, r7
   8f93e:	bdb0      	pop	{r4, r5, r7, pc}
   8f940:	00092e15 	.word	0x00092e15
   8f944:	000926d5 	.word	0x000926d5
   8f948:	00090af9 	.word	0x00090af9
   8f94c:	00092d6d 	.word	0x00092d6d

0008f950 <_ZN3ard5Point10distanceToES0_>:

float Point::distanceTo(Point p)
{
   8f950:	b5b0      	push	{r4, r5, r7, lr}
   8f952:	b082      	sub	sp, #8
   8f954:	af00      	add	r7, sp, #0
   8f956:	6078      	str	r0, [r7, #4]
   8f958:	6039      	str	r1, [r7, #0]
  return sqrt( (p.y - y)*(p.y - y) + (p.x - x)*(p.x - x) );
   8f95a:	683b      	ldr	r3, [r7, #0]
   8f95c:	689a      	ldr	r2, [r3, #8]
   8f95e:	687b      	ldr	r3, [r7, #4]
   8f960:	6899      	ldr	r1, [r3, #8]
   8f962:	4b23      	ldr	r3, [pc, #140]	; (8f9f0 <_ZN3ard5Point10distanceToES0_+0xa0>)
   8f964:	4610      	mov	r0, r2
   8f966:	4798      	blx	r3
   8f968:	4603      	mov	r3, r0
   8f96a:	461c      	mov	r4, r3
   8f96c:	683b      	ldr	r3, [r7, #0]
   8f96e:	689a      	ldr	r2, [r3, #8]
   8f970:	687b      	ldr	r3, [r7, #4]
   8f972:	6899      	ldr	r1, [r3, #8]
   8f974:	4b1e      	ldr	r3, [pc, #120]	; (8f9f0 <_ZN3ard5Point10distanceToES0_+0xa0>)
   8f976:	4610      	mov	r0, r2
   8f978:	4798      	blx	r3
   8f97a:	4603      	mov	r3, r0
   8f97c:	461a      	mov	r2, r3
   8f97e:	4b1d      	ldr	r3, [pc, #116]	; (8f9f4 <_ZN3ard5Point10distanceToES0_+0xa4>)
   8f980:	4611      	mov	r1, r2
   8f982:	4620      	mov	r0, r4
   8f984:	4798      	blx	r3
   8f986:	4603      	mov	r3, r0
   8f988:	461c      	mov	r4, r3
   8f98a:	683b      	ldr	r3, [r7, #0]
   8f98c:	685a      	ldr	r2, [r3, #4]
   8f98e:	687b      	ldr	r3, [r7, #4]
   8f990:	6859      	ldr	r1, [r3, #4]
   8f992:	4b17      	ldr	r3, [pc, #92]	; (8f9f0 <_ZN3ard5Point10distanceToES0_+0xa0>)
   8f994:	4610      	mov	r0, r2
   8f996:	4798      	blx	r3
   8f998:	4603      	mov	r3, r0
   8f99a:	461d      	mov	r5, r3
   8f99c:	683b      	ldr	r3, [r7, #0]
   8f99e:	685a      	ldr	r2, [r3, #4]
   8f9a0:	687b      	ldr	r3, [r7, #4]
   8f9a2:	6859      	ldr	r1, [r3, #4]
   8f9a4:	4b12      	ldr	r3, [pc, #72]	; (8f9f0 <_ZN3ard5Point10distanceToES0_+0xa0>)
   8f9a6:	4610      	mov	r0, r2
   8f9a8:	4798      	blx	r3
   8f9aa:	4603      	mov	r3, r0
   8f9ac:	461a      	mov	r2, r3
   8f9ae:	4b11      	ldr	r3, [pc, #68]	; (8f9f4 <_ZN3ard5Point10distanceToES0_+0xa4>)
   8f9b0:	4611      	mov	r1, r2
   8f9b2:	4628      	mov	r0, r5
   8f9b4:	4798      	blx	r3
   8f9b6:	4603      	mov	r3, r0
   8f9b8:	461a      	mov	r2, r3
   8f9ba:	4b0f      	ldr	r3, [pc, #60]	; (8f9f8 <_ZN3ard5Point10distanceToES0_+0xa8>)
   8f9bc:	4611      	mov	r1, r2
   8f9be:	4620      	mov	r0, r4
   8f9c0:	4798      	blx	r3
   8f9c2:	4603      	mov	r3, r0
   8f9c4:	461a      	mov	r2, r3
   8f9c6:	4b0d      	ldr	r3, [pc, #52]	; (8f9fc <_ZN3ard5Point10distanceToES0_+0xac>)
   8f9c8:	4610      	mov	r0, r2
   8f9ca:	4798      	blx	r3
   8f9cc:	4603      	mov	r3, r0
   8f9ce:	460c      	mov	r4, r1
   8f9d0:	4618      	mov	r0, r3
   8f9d2:	4621      	mov	r1, r4
   8f9d4:	4b0a      	ldr	r3, [pc, #40]	; (8fa00 <_ZN3ard5Point10distanceToES0_+0xb0>)
   8f9d6:	4798      	blx	r3
   8f9d8:	460a      	mov	r2, r1
   8f9da:	4601      	mov	r1, r0
   8f9dc:	4b09      	ldr	r3, [pc, #36]	; (8fa04 <_ZN3ard5Point10distanceToES0_+0xb4>)
   8f9de:	4608      	mov	r0, r1
   8f9e0:	4611      	mov	r1, r2
   8f9e2:	4798      	blx	r3
   8f9e4:	4603      	mov	r3, r0
}
   8f9e6:	4618      	mov	r0, r3
   8f9e8:	3708      	adds	r7, #8
   8f9ea:	46bd      	mov	sp, r7
   8f9ec:	bdb0      	pop	{r4, r5, r7, pc}
   8f9ee:	bf00      	nop
   8f9f0:	00092e15 	.word	0x00092e15
   8f9f4:	00093029 	.word	0x00093029
   8f9f8:	00092e19 	.word	0x00092e19
   8f9fc:	000926d5 	.word	0x000926d5
   8fa00:	00090afd 	.word	0x00090afd
   8fa04:	00092d6d 	.word	0x00092d6d

0008fa08 <_ZN3ard5Point8toStringEv>:


String
Point::toString ()
{
   8fa08:	b580      	push	{r7, lr}
   8fa0a:	b088      	sub	sp, #32
   8fa0c:	af00      	add	r7, sp, #0
   8fa0e:	6078      	str	r0, [r7, #4]
   8fa10:	6039      	str	r1, [r7, #0]
  return String("(") + x + ", " + y + ")";
   8fa12:	f107 0314 	add.w	r3, r7, #20
   8fa16:	491c      	ldr	r1, [pc, #112]	; (8fa88 <_ZN3ard5Point8toStringEv+0x80>)
   8fa18:	4618      	mov	r0, r3
   8fa1a:	4b1c      	ldr	r3, [pc, #112]	; (8fa8c <_ZN3ard5Point8toStringEv+0x84>)
   8fa1c:	4798      	blx	r3
   8fa1e:	f107 0214 	add.w	r2, r7, #20
   8fa22:	f107 0308 	add.w	r3, r7, #8
   8fa26:	4611      	mov	r1, r2
   8fa28:	4618      	mov	r0, r3
   8fa2a:	4b19      	ldr	r3, [pc, #100]	; (8fa90 <_ZN3ard5Point8toStringEv+0x88>)
   8fa2c:	4798      	blx	r3
   8fa2e:	683b      	ldr	r3, [r7, #0]
   8fa30:	685a      	ldr	r2, [r3, #4]
   8fa32:	f107 0308 	add.w	r3, r7, #8
   8fa36:	4611      	mov	r1, r2
   8fa38:	4618      	mov	r0, r3
   8fa3a:	4b16      	ldr	r3, [pc, #88]	; (8fa94 <_ZN3ard5Point8toStringEv+0x8c>)
   8fa3c:	4798      	blx	r3
   8fa3e:	4603      	mov	r3, r0
   8fa40:	4915      	ldr	r1, [pc, #84]	; (8fa98 <_ZN3ard5Point8toStringEv+0x90>)
   8fa42:	4618      	mov	r0, r3
   8fa44:	4b15      	ldr	r3, [pc, #84]	; (8fa9c <_ZN3ard5Point8toStringEv+0x94>)
   8fa46:	4798      	blx	r3
   8fa48:	4602      	mov	r2, r0
   8fa4a:	683b      	ldr	r3, [r7, #0]
   8fa4c:	689b      	ldr	r3, [r3, #8]
   8fa4e:	4619      	mov	r1, r3
   8fa50:	4610      	mov	r0, r2
   8fa52:	4b10      	ldr	r3, [pc, #64]	; (8fa94 <_ZN3ard5Point8toStringEv+0x8c>)
   8fa54:	4798      	blx	r3
   8fa56:	4603      	mov	r3, r0
   8fa58:	4911      	ldr	r1, [pc, #68]	; (8faa0 <_ZN3ard5Point8toStringEv+0x98>)
   8fa5a:	4618      	mov	r0, r3
   8fa5c:	4b0f      	ldr	r3, [pc, #60]	; (8fa9c <_ZN3ard5Point8toStringEv+0x94>)
   8fa5e:	4798      	blx	r3
   8fa60:	4603      	mov	r3, r0
   8fa62:	4619      	mov	r1, r3
   8fa64:	6878      	ldr	r0, [r7, #4]
   8fa66:	4b0f      	ldr	r3, [pc, #60]	; (8faa4 <_ZN3ard5Point8toStringEv+0x9c>)
   8fa68:	4798      	blx	r3
   8fa6a:	f107 0308 	add.w	r3, r7, #8
   8fa6e:	4618      	mov	r0, r3
   8fa70:	4b0d      	ldr	r3, [pc, #52]	; (8faa8 <_ZN3ard5Point8toStringEv+0xa0>)
   8fa72:	4798      	blx	r3
   8fa74:	f107 0314 	add.w	r3, r7, #20
   8fa78:	4618      	mov	r0, r3
   8fa7a:	4b0c      	ldr	r3, [pc, #48]	; (8faac <_ZN3ard5Point8toStringEv+0xa4>)
   8fa7c:	4798      	blx	r3
   8fa7e:	bf00      	nop
}
   8fa80:	6878      	ldr	r0, [r7, #4]
   8fa82:	3720      	adds	r7, #32
   8fa84:	46bd      	mov	sp, r7
   8fa86:	bd80      	pop	{r7, pc}
   8fa88:	0009aecc 	.word	0x0009aecc
   8fa8c:	00089009 	.word	0x00089009
   8fa90:	00082f89 	.word	0x00082f89
   8fa94:	00089645 	.word	0x00089645
   8fa98:	0009aed0 	.word	0x0009aed0
   8fa9c:	0008951d 	.word	0x0008951d
   8faa0:	0009aed4 	.word	0x0009aed4
   8faa4:	00089049 	.word	0x00089049
   8faa8:	00082fe9 	.word	0x00082fe9
   8faac:	00089145 	.word	0x00089145

0008fab0 <_ZN3ard8PointCapC1Ev>:




PointCap::PointCap () :
   8fab0:	b580      	push	{r7, lr}
   8fab2:	b082      	sub	sp, #8
   8fab4:	af00      	add	r7, sp, #0
   8fab6:	6078      	str	r0, [r7, #4]
    Point(), h (0)
   8fab8:	687b      	ldr	r3, [r7, #4]
   8faba:	4618      	mov	r0, r3
   8fabc:	4b06      	ldr	r3, [pc, #24]	; (8fad8 <_ZN3ard8PointCapC1Ev+0x28>)
   8fabe:	4798      	blx	r3
   8fac0:	4a06      	ldr	r2, [pc, #24]	; (8fadc <_ZN3ard8PointCapC1Ev+0x2c>)
   8fac2:	687b      	ldr	r3, [r7, #4]
   8fac4:	601a      	str	r2, [r3, #0]
   8fac6:	687b      	ldr	r3, [r7, #4]
   8fac8:	f04f 0200 	mov.w	r2, #0
   8facc:	60da      	str	r2, [r3, #12]
{
}
   8face:	687b      	ldr	r3, [r7, #4]
   8fad0:	4618      	mov	r0, r3
   8fad2:	3708      	adds	r7, #8
   8fad4:	46bd      	mov	sp, r7
   8fad6:	bd80      	pop	{r7, pc}
   8fad8:	0008f791 	.word	0x0008f791
   8fadc:	0009aee0 	.word	0x0009aee0

0008fae0 <_ZN3ard8PointCapC1ENS_5PointE>:
;

PointCap::PointCap (Point p) :
   8fae0:	b580      	push	{r7, lr}
   8fae2:	b082      	sub	sp, #8
   8fae4:	af00      	add	r7, sp, #0
   8fae6:	6078      	str	r0, [r7, #4]
   8fae8:	6039      	str	r1, [r7, #0]
    Point(p.x, p.y), h (0)
   8faea:	6878      	ldr	r0, [r7, #4]
   8faec:	683b      	ldr	r3, [r7, #0]
   8faee:	6859      	ldr	r1, [r3, #4]
   8faf0:	683b      	ldr	r3, [r7, #0]
   8faf2:	689b      	ldr	r3, [r3, #8]
   8faf4:	461a      	mov	r2, r3
   8faf6:	4b07      	ldr	r3, [pc, #28]	; (8fb14 <_ZN3ard8PointCapC1ENS_5PointE+0x34>)
   8faf8:	4798      	blx	r3
   8fafa:	4a07      	ldr	r2, [pc, #28]	; (8fb18 <_ZN3ard8PointCapC1ENS_5PointE+0x38>)
   8fafc:	687b      	ldr	r3, [r7, #4]
   8fafe:	601a      	str	r2, [r3, #0]
   8fb00:	687b      	ldr	r3, [r7, #4]
   8fb02:	f04f 0200 	mov.w	r2, #0
   8fb06:	60da      	str	r2, [r3, #12]
{
}
   8fb08:	687b      	ldr	r3, [r7, #4]
   8fb0a:	4618      	mov	r0, r3
   8fb0c:	3708      	adds	r7, #8
   8fb0e:	46bd      	mov	sp, r7
   8fb10:	bd80      	pop	{r7, pc}
   8fb12:	bf00      	nop
   8fb14:	0008f7c1 	.word	0x0008f7c1
   8fb18:	0009aee0 	.word	0x0009aee0

0008fb1c <_ZN3ard8PointCapC1Efff>:
;

PointCap::PointCap (float x, float y, float h) :
   8fb1c:	b580      	push	{r7, lr}
   8fb1e:	b084      	sub	sp, #16
   8fb20:	af00      	add	r7, sp, #0
   8fb22:	60f8      	str	r0, [r7, #12]
   8fb24:	60b9      	str	r1, [r7, #8]
   8fb26:	607a      	str	r2, [r7, #4]
   8fb28:	603b      	str	r3, [r7, #0]
    Point(x, y), h (h)
   8fb2a:	68fb      	ldr	r3, [r7, #12]
   8fb2c:	687a      	ldr	r2, [r7, #4]
   8fb2e:	68b9      	ldr	r1, [r7, #8]
   8fb30:	4618      	mov	r0, r3
   8fb32:	4b06      	ldr	r3, [pc, #24]	; (8fb4c <_ZN3ard8PointCapC1Efff+0x30>)
   8fb34:	4798      	blx	r3
   8fb36:	4a06      	ldr	r2, [pc, #24]	; (8fb50 <_ZN3ard8PointCapC1Efff+0x34>)
   8fb38:	68fb      	ldr	r3, [r7, #12]
   8fb3a:	601a      	str	r2, [r3, #0]
   8fb3c:	68fb      	ldr	r3, [r7, #12]
   8fb3e:	683a      	ldr	r2, [r7, #0]
   8fb40:	60da      	str	r2, [r3, #12]
{
}
   8fb42:	68fb      	ldr	r3, [r7, #12]
   8fb44:	4618      	mov	r0, r3
   8fb46:	3710      	adds	r7, #16
   8fb48:	46bd      	mov	sp, r7
   8fb4a:	bd80      	pop	{r7, pc}
   8fb4c:	0008f7c1 	.word	0x0008f7c1
   8fb50:	0009aee0 	.word	0x0009aee0
   8fb54:	00000000 	.word	0x00000000

0008fb58 <_ZN3ard8PointCap10toAmbiPoseE6eColor>:
;

PointCap
PointCap::toAmbiPose (eColor c)
{
   8fb58:	b590      	push	{r4, r7, lr}
   8fb5a:	b089      	sub	sp, #36	; 0x24
   8fb5c:	af00      	add	r7, sp, #0
   8fb5e:	60f8      	str	r0, [r7, #12]
   8fb60:	60b9      	str	r1, [r7, #8]
   8fb62:	607a      	str	r2, [r7, #4]
  PointCap res = Point::toAmbiPose(c);
   8fb64:	68b9      	ldr	r1, [r7, #8]
   8fb66:	f107 0314 	add.w	r3, r7, #20
   8fb6a:	687a      	ldr	r2, [r7, #4]
   8fb6c:	4618      	mov	r0, r3
   8fb6e:	4b1a      	ldr	r3, [pc, #104]	; (8fbd8 <_ZN3ard8PointCap10toAmbiPoseE6eColor+0x80>)
   8fb70:	4798      	blx	r3
   8fb72:	f107 0314 	add.w	r3, r7, #20
   8fb76:	4619      	mov	r1, r3
   8fb78:	68f8      	ldr	r0, [r7, #12]
   8fb7a:	4b18      	ldr	r3, [pc, #96]	; (8fbdc <_ZN3ard8PointCap10toAmbiPoseE6eColor+0x84>)
   8fb7c:	4798      	blx	r3
   8fb7e:	f107 0314 	add.w	r3, r7, #20
   8fb82:	4618      	mov	r0, r3
   8fb84:	4b16      	ldr	r3, [pc, #88]	; (8fbe0 <_ZN3ard8PointCap10toAmbiPoseE6eColor+0x88>)
   8fb86:	4798      	blx	r3
  if (c == eColor::SYM)
   8fb88:	687b      	ldr	r3, [r7, #4]
   8fb8a:	2b02      	cmp	r3, #2
   8fb8c:	d117      	bne.n	8fbbe <_ZN3ard8PointCap10toAmbiPoseE6eColor+0x66>
      res.h = M_PI - h;
   8fb8e:	68bb      	ldr	r3, [r7, #8]
   8fb90:	68da      	ldr	r2, [r3, #12]
   8fb92:	4b14      	ldr	r3, [pc, #80]	; (8fbe4 <_ZN3ard8PointCap10toAmbiPoseE6eColor+0x8c>)
   8fb94:	4610      	mov	r0, r2
   8fb96:	4798      	blx	r3
   8fb98:	4602      	mov	r2, r0
   8fb9a:	460b      	mov	r3, r1
   8fb9c:	4c12      	ldr	r4, [pc, #72]	; (8fbe8 <_ZN3ard8PointCap10toAmbiPoseE6eColor+0x90>)
   8fb9e:	a10c      	add	r1, pc, #48	; (adr r1, 8fbd0 <_ZN3ard8PointCap10toAmbiPoseE6eColor+0x78>)
   8fba0:	e9d1 0100 	ldrd	r0, r1, [r1]
   8fba4:	47a0      	blx	r4
   8fba6:	4603      	mov	r3, r0
   8fba8:	460c      	mov	r4, r1
   8fbaa:	4619      	mov	r1, r3
   8fbac:	4622      	mov	r2, r4
   8fbae:	4b0f      	ldr	r3, [pc, #60]	; (8fbec <_ZN3ard8PointCap10toAmbiPoseE6eColor+0x94>)
   8fbb0:	4608      	mov	r0, r1
   8fbb2:	4611      	mov	r1, r2
   8fbb4:	4798      	blx	r3
   8fbb6:	4602      	mov	r2, r0
   8fbb8:	68fb      	ldr	r3, [r7, #12]
   8fbba:	60da      	str	r2, [r3, #12]
  else
      res.h = h;
  return res;
   8fbbc:	e003      	b.n	8fbc6 <_ZN3ard8PointCap10toAmbiPoseE6eColor+0x6e>
{
  PointCap res = Point::toAmbiPose(c);
  if (c == eColor::SYM)
      res.h = M_PI - h;
  else
      res.h = h;
   8fbbe:	68bb      	ldr	r3, [r7, #8]
   8fbc0:	68da      	ldr	r2, [r3, #12]
   8fbc2:	68fb      	ldr	r3, [r7, #12]
   8fbc4:	60da      	str	r2, [r3, #12]
  return res;
   8fbc6:	bf00      	nop
}
   8fbc8:	68f8      	ldr	r0, [r7, #12]
   8fbca:	3724      	adds	r7, #36	; 0x24
   8fbcc:	46bd      	mov	sp, r7
   8fbce:	bd90      	pop	{r4, r7, pc}
   8fbd0:	54442d18 	.word	0x54442d18
   8fbd4:	400921fb 	.word	0x400921fb
   8fbd8:	0008f7f1 	.word	0x0008f7f1
   8fbdc:	0008fae1 	.word	0x0008fae1
   8fbe0:	000859fd 	.word	0x000859fd
   8fbe4:	000926d5 	.word	0x000926d5
   8fbe8:	00092415 	.word	0x00092415
   8fbec:	00092d6d 	.word	0x00092d6d

0008fbf0 <_ZN3ard8PointCap8toStringEv>:

String
PointCap::toString ()
{
   8fbf0:	b580      	push	{r7, lr}
   8fbf2:	b088      	sub	sp, #32
   8fbf4:	af00      	add	r7, sp, #0
   8fbf6:	6078      	str	r0, [r7, #4]
   8fbf8:	6039      	str	r1, [r7, #0]
  return String("(") + x + ", " + y + ", " + h + ")";
   8fbfa:	f107 0314 	add.w	r3, r7, #20
   8fbfe:	4922      	ldr	r1, [pc, #136]	; (8fc88 <_ZN3ard8PointCap8toStringEv+0x98>)
   8fc00:	4618      	mov	r0, r3
   8fc02:	4b22      	ldr	r3, [pc, #136]	; (8fc8c <_ZN3ard8PointCap8toStringEv+0x9c>)
   8fc04:	4798      	blx	r3
   8fc06:	f107 0214 	add.w	r2, r7, #20
   8fc0a:	f107 0308 	add.w	r3, r7, #8
   8fc0e:	4611      	mov	r1, r2
   8fc10:	4618      	mov	r0, r3
   8fc12:	4b1f      	ldr	r3, [pc, #124]	; (8fc90 <_ZN3ard8PointCap8toStringEv+0xa0>)
   8fc14:	4798      	blx	r3
   8fc16:	683b      	ldr	r3, [r7, #0]
   8fc18:	685a      	ldr	r2, [r3, #4]
   8fc1a:	f107 0308 	add.w	r3, r7, #8
   8fc1e:	4611      	mov	r1, r2
   8fc20:	4618      	mov	r0, r3
   8fc22:	4b1c      	ldr	r3, [pc, #112]	; (8fc94 <_ZN3ard8PointCap8toStringEv+0xa4>)
   8fc24:	4798      	blx	r3
   8fc26:	4603      	mov	r3, r0
   8fc28:	491b      	ldr	r1, [pc, #108]	; (8fc98 <_ZN3ard8PointCap8toStringEv+0xa8>)
   8fc2a:	4618      	mov	r0, r3
   8fc2c:	4b1b      	ldr	r3, [pc, #108]	; (8fc9c <_ZN3ard8PointCap8toStringEv+0xac>)
   8fc2e:	4798      	blx	r3
   8fc30:	4602      	mov	r2, r0
   8fc32:	683b      	ldr	r3, [r7, #0]
   8fc34:	689b      	ldr	r3, [r3, #8]
   8fc36:	4619      	mov	r1, r3
   8fc38:	4610      	mov	r0, r2
   8fc3a:	4b16      	ldr	r3, [pc, #88]	; (8fc94 <_ZN3ard8PointCap8toStringEv+0xa4>)
   8fc3c:	4798      	blx	r3
   8fc3e:	4603      	mov	r3, r0
   8fc40:	4915      	ldr	r1, [pc, #84]	; (8fc98 <_ZN3ard8PointCap8toStringEv+0xa8>)
   8fc42:	4618      	mov	r0, r3
   8fc44:	4b15      	ldr	r3, [pc, #84]	; (8fc9c <_ZN3ard8PointCap8toStringEv+0xac>)
   8fc46:	4798      	blx	r3
   8fc48:	4602      	mov	r2, r0
   8fc4a:	683b      	ldr	r3, [r7, #0]
   8fc4c:	68db      	ldr	r3, [r3, #12]
   8fc4e:	4619      	mov	r1, r3
   8fc50:	4610      	mov	r0, r2
   8fc52:	4b10      	ldr	r3, [pc, #64]	; (8fc94 <_ZN3ard8PointCap8toStringEv+0xa4>)
   8fc54:	4798      	blx	r3
   8fc56:	4603      	mov	r3, r0
   8fc58:	4911      	ldr	r1, [pc, #68]	; (8fca0 <_ZN3ard8PointCap8toStringEv+0xb0>)
   8fc5a:	4618      	mov	r0, r3
   8fc5c:	4b0f      	ldr	r3, [pc, #60]	; (8fc9c <_ZN3ard8PointCap8toStringEv+0xac>)
   8fc5e:	4798      	blx	r3
   8fc60:	4603      	mov	r3, r0
   8fc62:	4619      	mov	r1, r3
   8fc64:	6878      	ldr	r0, [r7, #4]
   8fc66:	4b0f      	ldr	r3, [pc, #60]	; (8fca4 <_ZN3ard8PointCap8toStringEv+0xb4>)
   8fc68:	4798      	blx	r3
   8fc6a:	f107 0308 	add.w	r3, r7, #8
   8fc6e:	4618      	mov	r0, r3
   8fc70:	4b0d      	ldr	r3, [pc, #52]	; (8fca8 <_ZN3ard8PointCap8toStringEv+0xb8>)
   8fc72:	4798      	blx	r3
   8fc74:	f107 0314 	add.w	r3, r7, #20
   8fc78:	4618      	mov	r0, r3
   8fc7a:	4b0c      	ldr	r3, [pc, #48]	; (8fcac <_ZN3ard8PointCap8toStringEv+0xbc>)
   8fc7c:	4798      	blx	r3
   8fc7e:	bf00      	nop
}
   8fc80:	6878      	ldr	r0, [r7, #4]
   8fc82:	3720      	adds	r7, #32
   8fc84:	46bd      	mov	sp, r7
   8fc86:	bd80      	pop	{r7, pc}
   8fc88:	0009aecc 	.word	0x0009aecc
   8fc8c:	00089009 	.word	0x00089009
   8fc90:	00082f89 	.word	0x00082f89
   8fc94:	00089645 	.word	0x00089645
   8fc98:	0009aed0 	.word	0x0009aed0
   8fc9c:	0008951d 	.word	0x0008951d
   8fca0:	0009aed4 	.word	0x0009aed4
   8fca4:	00089049 	.word	0x00089049
   8fca8:	00082fe9 	.word	0x00082fe9
   8fcac:	00089145 	.word	0x00089145

0008fcb0 <dtostrf>:
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <stdio.h>

char *dtostrf (double val, signed char width, unsigned char prec, char *sout) {
   8fcb0:	b590      	push	{r4, r7, lr}
   8fcb2:	b08b      	sub	sp, #44	; 0x2c
   8fcb4:	af00      	add	r7, sp, #0
   8fcb6:	e9c7 0102 	strd	r0, r1, [r7, #8]
   8fcba:	4611      	mov	r1, r2
   8fcbc:	461a      	mov	r2, r3
   8fcbe:	460b      	mov	r3, r1
   8fcc0:	71fb      	strb	r3, [r7, #7]
   8fcc2:	4613      	mov	r3, r2
   8fcc4:	71bb      	strb	r3, [r7, #6]
  char fmt[20];
  sprintf(fmt, "%%%d.%df", width, prec);
   8fcc6:	f997 2007 	ldrsb.w	r2, [r7, #7]
   8fcca:	79bb      	ldrb	r3, [r7, #6]
   8fccc:	f107 0014 	add.w	r0, r7, #20
   8fcd0:	4907      	ldr	r1, [pc, #28]	; (8fcf0 <dtostrf+0x40>)
   8fcd2:	4c08      	ldr	r4, [pc, #32]	; (8fcf4 <dtostrf+0x44>)
   8fcd4:	47a0      	blx	r4
  sprintf(sout, fmt, val);
   8fcd6:	f107 0114 	add.w	r1, r7, #20
   8fcda:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
   8fcde:	6bb8      	ldr	r0, [r7, #56]	; 0x38
   8fce0:	4c04      	ldr	r4, [pc, #16]	; (8fcf4 <dtostrf+0x44>)
   8fce2:	47a0      	blx	r4
  return sout;
   8fce4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
   8fce6:	4618      	mov	r0, r3
   8fce8:	372c      	adds	r7, #44	; 0x2c
   8fcea:	46bd      	mov	sp, r7
   8fcec:	bd90      	pop	{r4, r7, pc}
   8fcee:	bf00      	nop
   8fcf0:	0009af00 	.word	0x0009af00
   8fcf4:	00094171 	.word	0x00094171

0008fcf8 <itoa>:
}

#else

extern char* itoa( int value, char *string, int radix )
{
   8fcf8:	b580      	push	{r7, lr}
   8fcfa:	b084      	sub	sp, #16
   8fcfc:	af00      	add	r7, sp, #0
   8fcfe:	60f8      	str	r0, [r7, #12]
   8fd00:	60b9      	str	r1, [r7, #8]
   8fd02:	607a      	str	r2, [r7, #4]
  return ltoa( value, string, radix ) ;
   8fd04:	687a      	ldr	r2, [r7, #4]
   8fd06:	68b9      	ldr	r1, [r7, #8]
   8fd08:	68f8      	ldr	r0, [r7, #12]
   8fd0a:	4b03      	ldr	r3, [pc, #12]	; (8fd18 <itoa+0x20>)
   8fd0c:	4798      	blx	r3
   8fd0e:	4603      	mov	r3, r0
}
   8fd10:	4618      	mov	r0, r3
   8fd12:	3710      	adds	r7, #16
   8fd14:	46bd      	mov	sp, r7
   8fd16:	bd80      	pop	{r7, pc}
   8fd18:	0008fd1d 	.word	0x0008fd1d

0008fd1c <ltoa>:

extern char* ltoa( long value, char *string, int radix )
{
   8fd1c:	b480      	push	{r7}
   8fd1e:	b093      	sub	sp, #76	; 0x4c
   8fd20:	af00      	add	r7, sp, #0
   8fd22:	60f8      	str	r0, [r7, #12]
   8fd24:	60b9      	str	r1, [r7, #8]
   8fd26:	607a      	str	r2, [r7, #4]
  char tmp[33];
  char *tp = tmp;
   8fd28:	f107 0310 	add.w	r3, r7, #16
   8fd2c:	647b      	str	r3, [r7, #68]	; 0x44
  long i;
  unsigned long v;
  int sign;
  char *sp;

  if ( string == NULL )
   8fd2e:	68bb      	ldr	r3, [r7, #8]
   8fd30:	2b00      	cmp	r3, #0
   8fd32:	d101      	bne.n	8fd38 <ltoa+0x1c>
  {
    return 0 ;
   8fd34:	2300      	movs	r3, #0
   8fd36:	e061      	b.n	8fdfc <ltoa+0xe0>
  }

  if (radix > 36 || radix <= 1)
   8fd38:	687b      	ldr	r3, [r7, #4]
   8fd3a:	2b24      	cmp	r3, #36	; 0x24
   8fd3c:	dc02      	bgt.n	8fd44 <ltoa+0x28>
   8fd3e:	687b      	ldr	r3, [r7, #4]
   8fd40:	2b01      	cmp	r3, #1
   8fd42:	dc01      	bgt.n	8fd48 <ltoa+0x2c>
  {
    return 0 ;
   8fd44:	2300      	movs	r3, #0
   8fd46:	e059      	b.n	8fdfc <ltoa+0xe0>
  }

  sign = (radix == 10 && value < 0);
   8fd48:	687b      	ldr	r3, [r7, #4]
   8fd4a:	2b0a      	cmp	r3, #10
   8fd4c:	d104      	bne.n	8fd58 <ltoa+0x3c>
   8fd4e:	68fb      	ldr	r3, [r7, #12]
   8fd50:	2b00      	cmp	r3, #0
   8fd52:	da01      	bge.n	8fd58 <ltoa+0x3c>
   8fd54:	2301      	movs	r3, #1
   8fd56:	e000      	b.n	8fd5a <ltoa+0x3e>
   8fd58:	2300      	movs	r3, #0
   8fd5a:	63bb      	str	r3, [r7, #56]	; 0x38
  if (sign)
   8fd5c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   8fd5e:	2b00      	cmp	r3, #0
   8fd60:	d003      	beq.n	8fd6a <ltoa+0x4e>
  {
    v = -value;
   8fd62:	68fb      	ldr	r3, [r7, #12]
   8fd64:	425b      	negs	r3, r3
   8fd66:	643b      	str	r3, [r7, #64]	; 0x40
   8fd68:	e023      	b.n	8fdb2 <ltoa+0x96>
  }
  else
  {
    v = (unsigned long)value;
   8fd6a:	68fb      	ldr	r3, [r7, #12]
   8fd6c:	643b      	str	r3, [r7, #64]	; 0x40
  }

  while (v || tp == tmp)
   8fd6e:	e020      	b.n	8fdb2 <ltoa+0x96>
  {
    i = v % radix;
   8fd70:	687a      	ldr	r2, [r7, #4]
   8fd72:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   8fd74:	fbb3 f1f2 	udiv	r1, r3, r2
   8fd78:	fb02 f201 	mul.w	r2, r2, r1
   8fd7c:	1a9b      	subs	r3, r3, r2
   8fd7e:	637b      	str	r3, [r7, #52]	; 0x34
    v = v / radix;
   8fd80:	687b      	ldr	r3, [r7, #4]
   8fd82:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   8fd84:	fbb2 f3f3 	udiv	r3, r2, r3
   8fd88:	643b      	str	r3, [r7, #64]	; 0x40
    if (i < 10)
   8fd8a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   8fd8c:	2b09      	cmp	r3, #9
   8fd8e:	dc08      	bgt.n	8fda2 <ltoa+0x86>
      *tp++ = i+'0';
   8fd90:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   8fd92:	1c5a      	adds	r2, r3, #1
   8fd94:	647a      	str	r2, [r7, #68]	; 0x44
   8fd96:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   8fd98:	b2d2      	uxtb	r2, r2
   8fd9a:	3230      	adds	r2, #48	; 0x30
   8fd9c:	b2d2      	uxtb	r2, r2
   8fd9e:	701a      	strb	r2, [r3, #0]
   8fda0:	e007      	b.n	8fdb2 <ltoa+0x96>
    else
      *tp++ = i + 'a' - 10;
   8fda2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   8fda4:	1c5a      	adds	r2, r3, #1
   8fda6:	647a      	str	r2, [r7, #68]	; 0x44
   8fda8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   8fdaa:	b2d2      	uxtb	r2, r2
   8fdac:	3257      	adds	r2, #87	; 0x57
   8fdae:	b2d2      	uxtb	r2, r2
   8fdb0:	701a      	strb	r2, [r3, #0]
  else
  {
    v = (unsigned long)value;
  }

  while (v || tp == tmp)
   8fdb2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   8fdb4:	2b00      	cmp	r3, #0
   8fdb6:	d1db      	bne.n	8fd70 <ltoa+0x54>
   8fdb8:	f107 0310 	add.w	r3, r7, #16
   8fdbc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   8fdbe:	429a      	cmp	r2, r3
   8fdc0:	d0d6      	beq.n	8fd70 <ltoa+0x54>
      *tp++ = i+'0';
    else
      *tp++ = i + 'a' - 10;
  }

  sp = string;
   8fdc2:	68bb      	ldr	r3, [r7, #8]
   8fdc4:	63fb      	str	r3, [r7, #60]	; 0x3c

  if (sign)
   8fdc6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   8fdc8:	2b00      	cmp	r3, #0
   8fdca:	d00e      	beq.n	8fdea <ltoa+0xce>
    *sp++ = '-';
   8fdcc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   8fdce:	1c5a      	adds	r2, r3, #1
   8fdd0:	63fa      	str	r2, [r7, #60]	; 0x3c
   8fdd2:	222d      	movs	r2, #45	; 0x2d
   8fdd4:	701a      	strb	r2, [r3, #0]
  while (tp > tmp)
   8fdd6:	e008      	b.n	8fdea <ltoa+0xce>
    *sp++ = *--tp;
   8fdd8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   8fdda:	1c5a      	adds	r2, r3, #1
   8fddc:	63fa      	str	r2, [r7, #60]	; 0x3c
   8fdde:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   8fde0:	3a01      	subs	r2, #1
   8fde2:	647a      	str	r2, [r7, #68]	; 0x44
   8fde4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   8fde6:	7812      	ldrb	r2, [r2, #0]
   8fde8:	701a      	strb	r2, [r3, #0]

  sp = string;

  if (sign)
    *sp++ = '-';
  while (tp > tmp)
   8fdea:	f107 0310 	add.w	r3, r7, #16
   8fdee:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   8fdf0:	429a      	cmp	r2, r3
   8fdf2:	d8f1      	bhi.n	8fdd8 <ltoa+0xbc>
    *sp++ = *--tp;
  *sp = 0;
   8fdf4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   8fdf6:	2200      	movs	r2, #0
   8fdf8:	701a      	strb	r2, [r3, #0]

  return string;
   8fdfa:	68bb      	ldr	r3, [r7, #8]
}
   8fdfc:	4618      	mov	r0, r3
   8fdfe:	374c      	adds	r7, #76	; 0x4c
   8fe00:	46bd      	mov	sp, r7
   8fe02:	bc80      	pop	{r7}
   8fe04:	4770      	bx	lr
   8fe06:	bf00      	nop

0008fe08 <utoa>:

extern char* utoa( unsigned long value, char *string, int radix )
{
   8fe08:	b580      	push	{r7, lr}
   8fe0a:	b084      	sub	sp, #16
   8fe0c:	af00      	add	r7, sp, #0
   8fe0e:	60f8      	str	r0, [r7, #12]
   8fe10:	60b9      	str	r1, [r7, #8]
   8fe12:	607a      	str	r2, [r7, #4]
  return ultoa( value, string, radix ) ;
   8fe14:	687a      	ldr	r2, [r7, #4]
   8fe16:	68b9      	ldr	r1, [r7, #8]
   8fe18:	68f8      	ldr	r0, [r7, #12]
   8fe1a:	4b03      	ldr	r3, [pc, #12]	; (8fe28 <utoa+0x20>)
   8fe1c:	4798      	blx	r3
   8fe1e:	4603      	mov	r3, r0
}
   8fe20:	4618      	mov	r0, r3
   8fe22:	3710      	adds	r7, #16
   8fe24:	46bd      	mov	sp, r7
   8fe26:	bd80      	pop	{r7, pc}
   8fe28:	0008fe2d 	.word	0x0008fe2d

0008fe2c <ultoa>:

extern char* ultoa( unsigned long value, char *string, int radix )
{
   8fe2c:	b480      	push	{r7}
   8fe2e:	b093      	sub	sp, #76	; 0x4c
   8fe30:	af00      	add	r7, sp, #0
   8fe32:	60f8      	str	r0, [r7, #12]
   8fe34:	60b9      	str	r1, [r7, #8]
   8fe36:	607a      	str	r2, [r7, #4]
  char tmp[33];
  char *tp = tmp;
   8fe38:	f107 0314 	add.w	r3, r7, #20
   8fe3c:	647b      	str	r3, [r7, #68]	; 0x44
  long i;
  unsigned long v = value;
   8fe3e:	68fb      	ldr	r3, [r7, #12]
   8fe40:	643b      	str	r3, [r7, #64]	; 0x40
  char *sp;

  if ( string == NULL )
   8fe42:	68bb      	ldr	r3, [r7, #8]
   8fe44:	2b00      	cmp	r3, #0
   8fe46:	d101      	bne.n	8fe4c <ultoa+0x20>
  {
    return 0;
   8fe48:	2300      	movs	r3, #0
   8fe4a:	e045      	b.n	8fed8 <ultoa+0xac>
  }

  if (radix > 36 || radix <= 1)
   8fe4c:	687b      	ldr	r3, [r7, #4]
   8fe4e:	2b24      	cmp	r3, #36	; 0x24
   8fe50:	dc02      	bgt.n	8fe58 <ultoa+0x2c>
   8fe52:	687b      	ldr	r3, [r7, #4]
   8fe54:	2b01      	cmp	r3, #1
   8fe56:	dc22      	bgt.n	8fe9e <ultoa+0x72>
  {
    return 0;
   8fe58:	2300      	movs	r3, #0
   8fe5a:	e03d      	b.n	8fed8 <ultoa+0xac>
  }
 
  while (v || tp == tmp)
  {
    i = v % radix;
   8fe5c:	687a      	ldr	r2, [r7, #4]
   8fe5e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   8fe60:	fbb3 f1f2 	udiv	r1, r3, r2
   8fe64:	fb02 f201 	mul.w	r2, r2, r1
   8fe68:	1a9b      	subs	r3, r3, r2
   8fe6a:	63bb      	str	r3, [r7, #56]	; 0x38
    v = v / radix;
   8fe6c:	687b      	ldr	r3, [r7, #4]
   8fe6e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   8fe70:	fbb2 f3f3 	udiv	r3, r2, r3
   8fe74:	643b      	str	r3, [r7, #64]	; 0x40
    if (i < 10)
   8fe76:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   8fe78:	2b09      	cmp	r3, #9
   8fe7a:	dc08      	bgt.n	8fe8e <ultoa+0x62>
      *tp++ = i+'0';
   8fe7c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   8fe7e:	1c5a      	adds	r2, r3, #1
   8fe80:	647a      	str	r2, [r7, #68]	; 0x44
   8fe82:	6bba      	ldr	r2, [r7, #56]	; 0x38
   8fe84:	b2d2      	uxtb	r2, r2
   8fe86:	3230      	adds	r2, #48	; 0x30
   8fe88:	b2d2      	uxtb	r2, r2
   8fe8a:	701a      	strb	r2, [r3, #0]
   8fe8c:	e007      	b.n	8fe9e <ultoa+0x72>
    else
      *tp++ = i + 'a' - 10;
   8fe8e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   8fe90:	1c5a      	adds	r2, r3, #1
   8fe92:	647a      	str	r2, [r7, #68]	; 0x44
   8fe94:	6bba      	ldr	r2, [r7, #56]	; 0x38
   8fe96:	b2d2      	uxtb	r2, r2
   8fe98:	3257      	adds	r2, #87	; 0x57
   8fe9a:	b2d2      	uxtb	r2, r2
   8fe9c:	701a      	strb	r2, [r3, #0]
  if (radix > 36 || radix <= 1)
  {
    return 0;
  }
 
  while (v || tp == tmp)
   8fe9e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   8fea0:	2b00      	cmp	r3, #0
   8fea2:	d1db      	bne.n	8fe5c <ultoa+0x30>
   8fea4:	f107 0314 	add.w	r3, r7, #20
   8fea8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   8feaa:	429a      	cmp	r2, r3
   8feac:	d0d6      	beq.n	8fe5c <ultoa+0x30>
      *tp++ = i+'0';
    else
      *tp++ = i + 'a' - 10;
  }

  sp = string;
   8feae:	68bb      	ldr	r3, [r7, #8]
   8feb0:	63fb      	str	r3, [r7, #60]	; 0x3c

 
  while (tp > tmp)
   8feb2:	e008      	b.n	8fec6 <ultoa+0x9a>
    *sp++ = *--tp;
   8feb4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   8feb6:	1c5a      	adds	r2, r3, #1
   8feb8:	63fa      	str	r2, [r7, #60]	; 0x3c
   8feba:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   8febc:	3a01      	subs	r2, #1
   8febe:	647a      	str	r2, [r7, #68]	; 0x44
   8fec0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   8fec2:	7812      	ldrb	r2, [r2, #0]
   8fec4:	701a      	strb	r2, [r3, #0]
  }

  sp = string;

 
  while (tp > tmp)
   8fec6:	f107 0314 	add.w	r3, r7, #20
   8feca:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   8fecc:	429a      	cmp	r2, r3
   8fece:	d8f1      	bhi.n	8feb4 <ultoa+0x88>
    *sp++ = *--tp;
  *sp = 0;
   8fed0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   8fed2:	2200      	movs	r2, #0
   8fed4:	701a      	strb	r2, [r3, #0]

  return string;
   8fed6:	68bb      	ldr	r3, [r7, #8]
}
   8fed8:	4618      	mov	r0, r3
   8feda:	374c      	adds	r7, #76	; 0x4c
   8fedc:	46bd      	mov	sp, r7
   8fede:	bc80      	pop	{r7}
   8fee0:	4770      	bx	lr
   8fee2:	bf00      	nop

0008fee4 <_ZN8SPIClassC1EP3SpimPFvvE>:
 * published by the Free Software Foundation.
 */

#include "SPI.h"

SPIClass::SPIClass(Spi *_spi, uint32_t _id, void(*_initCb)(void)) :
   8fee4:	b480      	push	{r7}
   8fee6:	b085      	sub	sp, #20
   8fee8:	af00      	add	r7, sp, #0
   8feea:	60f8      	str	r0, [r7, #12]
   8feec:	60b9      	str	r1, [r7, #8]
   8feee:	607a      	str	r2, [r7, #4]
   8fef0:	603b      	str	r3, [r7, #0]
	spi(_spi), id(_id), initCb(_initCb), initialized(false)
   8fef2:	68fb      	ldr	r3, [r7, #12]
   8fef4:	68ba      	ldr	r2, [r7, #8]
   8fef6:	601a      	str	r2, [r3, #0]
   8fef8:	68fb      	ldr	r3, [r7, #12]
   8fefa:	687a      	ldr	r2, [r7, #4]
   8fefc:	605a      	str	r2, [r3, #4]
   8fefe:	68fb      	ldr	r3, [r7, #12]
   8ff00:	683a      	ldr	r2, [r7, #0]
   8ff02:	62da      	str	r2, [r3, #44]	; 0x2c
   8ff04:	68fb      	ldr	r3, [r7, #12]
   8ff06:	2200      	movs	r2, #0
   8ff08:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
{
	// Empty
}
   8ff0c:	68fb      	ldr	r3, [r7, #12]
   8ff0e:	4618      	mov	r0, r3
   8ff10:	3714      	adds	r7, #20
   8ff12:	46bd      	mov	sp, r7
   8ff14:	bc80      	pop	{r7}
   8ff16:	4770      	bx	lr

0008ff18 <_ZN8SPIClass5beginEv>:

void SPIClass::begin() {
   8ff18:	b580      	push	{r7, lr}
   8ff1a:	b082      	sub	sp, #8
   8ff1c:	af00      	add	r7, sp, #0
   8ff1e:	6078      	str	r0, [r7, #4]
	init();
   8ff20:	6878      	ldr	r0, [r7, #4]
   8ff22:	4b0a      	ldr	r3, [pc, #40]	; (8ff4c <_ZN8SPIClass5beginEv+0x34>)
   8ff24:	4798      	blx	r3
	// NPCS control is left to the user

	// Default speed set to 4Mhz
	setClockDivider(BOARD_SPI_DEFAULT_SS, 21);
   8ff26:	2215      	movs	r2, #21
   8ff28:	214e      	movs	r1, #78	; 0x4e
   8ff2a:	6878      	ldr	r0, [r7, #4]
   8ff2c:	4b08      	ldr	r3, [pc, #32]	; (8ff50 <_ZN8SPIClass5beginEv+0x38>)
   8ff2e:	4798      	blx	r3
	setDataMode(BOARD_SPI_DEFAULT_SS, SPI_MODE0);
   8ff30:	2202      	movs	r2, #2
   8ff32:	214e      	movs	r1, #78	; 0x4e
   8ff34:	6878      	ldr	r0, [r7, #4]
   8ff36:	4b07      	ldr	r3, [pc, #28]	; (8ff54 <_ZN8SPIClass5beginEv+0x3c>)
   8ff38:	4798      	blx	r3
	setBitOrder(BOARD_SPI_DEFAULT_SS, MSBFIRST);
   8ff3a:	2201      	movs	r2, #1
   8ff3c:	214e      	movs	r1, #78	; 0x4e
   8ff3e:	6878      	ldr	r0, [r7, #4]
   8ff40:	4b05      	ldr	r3, [pc, #20]	; (8ff58 <_ZN8SPIClass5beginEv+0x40>)
   8ff42:	4798      	blx	r3
}
   8ff44:	bf00      	nop
   8ff46:	3708      	adds	r7, #8
   8ff48:	46bd      	mov	sp, r7
   8ff4a:	bd80      	pop	{r7, pc}
   8ff4c:	0008ff5d 	.word	0x0008ff5d
   8ff50:	00090221 	.word	0x00090221
   8ff54:	0009019d 	.word	0x0009019d
   8ff58:	00090155 	.word	0x00090155

0008ff5c <_ZN8SPIClass4initEv>:
	setClockDivider(_pin, 21);
	setDataMode(_pin, SPI_MODE0);
	setBitOrder(_pin, MSBFIRST);
}

void SPIClass::init() {
   8ff5c:	b580      	push	{r7, lr}
   8ff5e:	b082      	sub	sp, #8
   8ff60:	af00      	add	r7, sp, #0
   8ff62:	6078      	str	r0, [r7, #4]
	if (initialized)
   8ff64:	687b      	ldr	r3, [r7, #4]
   8ff66:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   8ff6a:	2b00      	cmp	r3, #0
   8ff6c:	d128      	bne.n	8ffc0 <_ZN8SPIClass4initEv+0x64>
		return;
	interruptMode = 0;
   8ff6e:	687b      	ldr	r3, [r7, #4]
   8ff70:	2200      	movs	r2, #0
   8ff72:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
	interruptSave = 0;
   8ff76:	687b      	ldr	r3, [r7, #4]
   8ff78:	2200      	movs	r2, #0
   8ff7a:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
	interruptMask[0] = 0;
   8ff7e:	687b      	ldr	r3, [r7, #4]
   8ff80:	2200      	movs	r2, #0
   8ff82:	635a      	str	r2, [r3, #52]	; 0x34
	interruptMask[1] = 0;
   8ff84:	687b      	ldr	r3, [r7, #4]
   8ff86:	2200      	movs	r2, #0
   8ff88:	639a      	str	r2, [r3, #56]	; 0x38
	interruptMask[2] = 0;
   8ff8a:	687b      	ldr	r3, [r7, #4]
   8ff8c:	2200      	movs	r2, #0
   8ff8e:	63da      	str	r2, [r3, #60]	; 0x3c
	interruptMask[3] = 0;
   8ff90:	687b      	ldr	r3, [r7, #4]
   8ff92:	2200      	movs	r2, #0
   8ff94:	641a      	str	r2, [r3, #64]	; 0x40
	initCb();
   8ff96:	687b      	ldr	r3, [r7, #4]
   8ff98:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   8ff9a:	4798      	blx	r3
	SPI_Configure(spi, id, SPI_MR_MSTR | SPI_MR_PS | SPI_MR_MODFDIS);
   8ff9c:	687b      	ldr	r3, [r7, #4]
   8ff9e:	6818      	ldr	r0, [r3, #0]
   8ffa0:	687b      	ldr	r3, [r7, #4]
   8ffa2:	685b      	ldr	r3, [r3, #4]
   8ffa4:	2213      	movs	r2, #19
   8ffa6:	4619      	mov	r1, r3
   8ffa8:	4b07      	ldr	r3, [pc, #28]	; (8ffc8 <_ZN8SPIClass4initEv+0x6c>)
   8ffaa:	4798      	blx	r3
	SPI_Enable(spi);
   8ffac:	687b      	ldr	r3, [r7, #4]
   8ffae:	681b      	ldr	r3, [r3, #0]
   8ffb0:	4618      	mov	r0, r3
   8ffb2:	4b06      	ldr	r3, [pc, #24]	; (8ffcc <_ZN8SPIClass4initEv+0x70>)
   8ffb4:	4798      	blx	r3
	initialized = true;
   8ffb6:	687b      	ldr	r3, [r7, #4]
   8ffb8:	2201      	movs	r2, #1
   8ffba:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
   8ffbe:	e000      	b.n	8ffc2 <_ZN8SPIClass4initEv+0x66>
	setBitOrder(_pin, MSBFIRST);
}

void SPIClass::init() {
	if (initialized)
		return;
   8ffc0:	bf00      	nop
	interruptMask[3] = 0;
	initCb();
	SPI_Configure(spi, id, SPI_MR_MSTR | SPI_MR_PS | SPI_MR_MODFDIS);
	SPI_Enable(spi);
	initialized = true;
}
   8ffc2:	3708      	adds	r7, #8
   8ffc4:	46bd      	mov	sp, r7
   8ffc6:	bd80      	pop	{r7, pc}
   8ffc8:	00090471 	.word	0x00090471
   8ffcc:	00090459 	.word	0x00090459

0008ffd0 <_ZN8SPIClass16beginTransactionEh11SPISettings>:
	}
	if (irestore) interrupts();
}

void SPIClass::beginTransaction(uint8_t pin, SPISettings settings)
{
   8ffd0:	b580      	push	{r7, lr}
   8ffd2:	b088      	sub	sp, #32
   8ffd4:	af00      	add	r7, sp, #0
   8ffd6:	60f8      	str	r0, [r7, #12]
   8ffd8:	4608      	mov	r0, r1
   8ffda:	4639      	mov	r1, r7
   8ffdc:	e881 000c 	stmia.w	r1, {r2, r3}
   8ffe0:	4603      	mov	r3, r0
   8ffe2:	72fb      	strb	r3, [r7, #11]
	uint8_t mode = interruptMode;
   8ffe4:	68fb      	ldr	r3, [r7, #12]
   8ffe6:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
   8ffea:	77fb      	strb	r3, [r7, #31]
	if (mode > 0) {
   8ffec:	7ffb      	ldrb	r3, [r7, #31]
   8ffee:	2b00      	cmp	r3, #0
   8fff0:	d03c      	beq.n	9006c <_ZN8SPIClass16beginTransactionEh11SPISettings+0x9c>
		if (mode < 16) {
   8fff2:	7ffb      	ldrb	r3, [r7, #31]
   8fff4:	2b0f      	cmp	r3, #15
   8fff6:	d824      	bhi.n	90042 <_ZN8SPIClass16beginTransactionEh11SPISettings+0x72>
			if (mode & 1) PIOA->PIO_IDR = interruptMask[0];
   8fff8:	7ffb      	ldrb	r3, [r7, #31]
   8fffa:	f003 0301 	and.w	r3, r3, #1
   8fffe:	2b00      	cmp	r3, #0
   90000:	d003      	beq.n	9000a <_ZN8SPIClass16beginTransactionEh11SPISettings+0x3a>
   90002:	4a2c      	ldr	r2, [pc, #176]	; (900b4 <_ZN8SPIClass16beginTransactionEh11SPISettings+0xe4>)
   90004:	68fb      	ldr	r3, [r7, #12]
   90006:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   90008:	6453      	str	r3, [r2, #68]	; 0x44
			if (mode & 2) PIOB->PIO_IDR = interruptMask[1];
   9000a:	7ffb      	ldrb	r3, [r7, #31]
   9000c:	f003 0302 	and.w	r3, r3, #2
   90010:	2b00      	cmp	r3, #0
   90012:	d003      	beq.n	9001c <_ZN8SPIClass16beginTransactionEh11SPISettings+0x4c>
   90014:	4a28      	ldr	r2, [pc, #160]	; (900b8 <_ZN8SPIClass16beginTransactionEh11SPISettings+0xe8>)
   90016:	68fb      	ldr	r3, [r7, #12]
   90018:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   9001a:	6453      	str	r3, [r2, #68]	; 0x44
			if (mode & 4) PIOC->PIO_IDR = interruptMask[2];
   9001c:	7ffb      	ldrb	r3, [r7, #31]
   9001e:	f003 0304 	and.w	r3, r3, #4
   90022:	2b00      	cmp	r3, #0
   90024:	d003      	beq.n	9002e <_ZN8SPIClass16beginTransactionEh11SPISettings+0x5e>
   90026:	4a25      	ldr	r2, [pc, #148]	; (900bc <_ZN8SPIClass16beginTransactionEh11SPISettings+0xec>)
   90028:	68fb      	ldr	r3, [r7, #12]
   9002a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   9002c:	6453      	str	r3, [r2, #68]	; 0x44
			if (mode & 8) PIOD->PIO_IDR = interruptMask[3];
   9002e:	7ffb      	ldrb	r3, [r7, #31]
   90030:	f003 0308 	and.w	r3, r3, #8
   90034:	2b00      	cmp	r3, #0
   90036:	d019      	beq.n	9006c <_ZN8SPIClass16beginTransactionEh11SPISettings+0x9c>
   90038:	4a21      	ldr	r2, [pc, #132]	; (900c0 <_ZN8SPIClass16beginTransactionEh11SPISettings+0xf0>)
   9003a:	68fb      	ldr	r3, [r7, #12]
   9003c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   9003e:	6453      	str	r3, [r2, #68]	; 0x44
   90040:	e014      	b.n	9006c <_ZN8SPIClass16beginTransactionEh11SPISettings+0x9c>
#ifndef interruptsStatus
#define interruptsStatus() __interruptsStatus()
static inline unsigned char __interruptsStatus(void) __attribute__((always_inline, unused));
static inline unsigned char __interruptsStatus(void) {
	unsigned int primask, faultmask;
	asm volatile ("mrs %0, primask" : "=r" (primask));
   90042:	f3ef 8310 	mrs	r3, PRIMASK
   90046:	61bb      	str	r3, [r7, #24]
	if (primask) return 0;
   90048:	69bb      	ldr	r3, [r7, #24]
   9004a:	2b00      	cmp	r3, #0
   9004c:	d001      	beq.n	90052 <_ZN8SPIClass16beginTransactionEh11SPISettings+0x82>
   9004e:	2300      	movs	r3, #0
   90050:	e008      	b.n	90064 <_ZN8SPIClass16beginTransactionEh11SPISettings+0x94>
	asm volatile ("mrs %0, faultmask" : "=r" (faultmask));
   90052:	f3ef 8313 	mrs	r3, FAULTMASK
   90056:	613b      	str	r3, [r7, #16]
	if (faultmask) return 0;
   90058:	693b      	ldr	r3, [r7, #16]
   9005a:	2b00      	cmp	r3, #0
   9005c:	d001      	beq.n	90062 <_ZN8SPIClass16beginTransactionEh11SPISettings+0x92>
   9005e:	2300      	movs	r3, #0
   90060:	e000      	b.n	90064 <_ZN8SPIClass16beginTransactionEh11SPISettings+0x94>
	return 1;
   90062:	2301      	movs	r3, #1
			if (mode & 1) PIOA->PIO_IDR = interruptMask[0];
			if (mode & 2) PIOB->PIO_IDR = interruptMask[1];
			if (mode & 4) PIOC->PIO_IDR = interruptMask[2];
			if (mode & 8) PIOD->PIO_IDR = interruptMask[3];
		} else {
			interruptSave = interruptsStatus();
   90064:	68fa      	ldr	r2, [r7, #12]
   90066:	f882 3032 	strb.w	r3, [r2, #50]	; 0x32
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
   9006a:	b672      	cpsid	i
			noInterrupts();
		}
	}
	uint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(pin);
   9006c:	7afb      	ldrb	r3, [r7, #11]
   9006e:	2b0a      	cmp	r3, #10
   90070:	d00b      	beq.n	9008a <_ZN8SPIClass16beginTransactionEh11SPISettings+0xba>
   90072:	7afb      	ldrb	r3, [r7, #11]
   90074:	2b04      	cmp	r3, #4
   90076:	d006      	beq.n	90086 <_ZN8SPIClass16beginTransactionEh11SPISettings+0xb6>
   90078:	7afb      	ldrb	r3, [r7, #11]
   9007a:	2b34      	cmp	r3, #52	; 0x34
   9007c:	d101      	bne.n	90082 <_ZN8SPIClass16beginTransactionEh11SPISettings+0xb2>
   9007e:	2302      	movs	r3, #2
   90080:	e004      	b.n	9008c <_ZN8SPIClass16beginTransactionEh11SPISettings+0xbc>
   90082:	2303      	movs	r3, #3
   90084:	e002      	b.n	9008c <_ZN8SPIClass16beginTransactionEh11SPISettings+0xbc>
   90086:	2301      	movs	r3, #1
   90088:	e000      	b.n	9008c <_ZN8SPIClass16beginTransactionEh11SPISettings+0xbc>
   9008a:	2300      	movs	r3, #0
   9008c:	617b      	str	r3, [r7, #20]
	bitOrder[ch] = settings.border;
   9008e:	7939      	ldrb	r1, [r7, #4]
   90090:	68fa      	ldr	r2, [r7, #12]
   90092:	697b      	ldr	r3, [r7, #20]
   90094:	4413      	add	r3, r2
   90096:	3308      	adds	r3, #8
   90098:	460a      	mov	r2, r1
   9009a:	701a      	strb	r2, [r3, #0]
	SPI_ConfigureNPCS(spi, ch, settings.config);
   9009c:	68fb      	ldr	r3, [r7, #12]
   9009e:	681b      	ldr	r3, [r3, #0]
   900a0:	683a      	ldr	r2, [r7, #0]
   900a2:	6979      	ldr	r1, [r7, #20]
   900a4:	4618      	mov	r0, r3
   900a6:	4b07      	ldr	r3, [pc, #28]	; (900c4 <_ZN8SPIClass16beginTransactionEh11SPISettings+0xf4>)
   900a8:	4798      	blx	r3
	//setBitOrder(pin, settings.border);
	//setDataMode(pin, settings.datamode);
	//setClockDivider(pin, settings.clockdiv);
}
   900aa:	bf00      	nop
   900ac:	3720      	adds	r7, #32
   900ae:	46bd      	mov	sp, r7
   900b0:	bd80      	pop	{r7, pc}
   900b2:	bf00      	nop
   900b4:	400e0e00 	.word	0x400e0e00
   900b8:	400e1000 	.word	0x400e1000
   900bc:	400e1200 	.word	0x400e1200
   900c0:	400e1400 	.word	0x400e1400
   900c4:	000904a9 	.word	0x000904a9

000900c8 <_ZN8SPIClass14endTransactionEv>:

void SPIClass::endTransaction(void)
{
   900c8:	b480      	push	{r7}
   900ca:	b085      	sub	sp, #20
   900cc:	af00      	add	r7, sp, #0
   900ce:	6078      	str	r0, [r7, #4]
	uint8_t mode = interruptMode;
   900d0:	687b      	ldr	r3, [r7, #4]
   900d2:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
   900d6:	73fb      	strb	r3, [r7, #15]
	if (mode > 0) {
   900d8:	7bfb      	ldrb	r3, [r7, #15]
   900da:	2b00      	cmp	r3, #0
   900dc:	d02d      	beq.n	9013a <_ZN8SPIClass14endTransactionEv+0x72>
		if (mode < 16) {
   900de:	7bfb      	ldrb	r3, [r7, #15]
   900e0:	2b0f      	cmp	r3, #15
   900e2:	d824      	bhi.n	9012e <_ZN8SPIClass14endTransactionEv+0x66>
			if (mode & 1) PIOA->PIO_IER = interruptMask[0];
   900e4:	7bfb      	ldrb	r3, [r7, #15]
   900e6:	f003 0301 	and.w	r3, r3, #1
   900ea:	2b00      	cmp	r3, #0
   900ec:	d003      	beq.n	900f6 <_ZN8SPIClass14endTransactionEv+0x2e>
   900ee:	4a15      	ldr	r2, [pc, #84]	; (90144 <_ZN8SPIClass14endTransactionEv+0x7c>)
   900f0:	687b      	ldr	r3, [r7, #4]
   900f2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   900f4:	6413      	str	r3, [r2, #64]	; 0x40
			if (mode & 2) PIOB->PIO_IER = interruptMask[1];
   900f6:	7bfb      	ldrb	r3, [r7, #15]
   900f8:	f003 0302 	and.w	r3, r3, #2
   900fc:	2b00      	cmp	r3, #0
   900fe:	d003      	beq.n	90108 <_ZN8SPIClass14endTransactionEv+0x40>
   90100:	4a11      	ldr	r2, [pc, #68]	; (90148 <_ZN8SPIClass14endTransactionEv+0x80>)
   90102:	687b      	ldr	r3, [r7, #4]
   90104:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   90106:	6413      	str	r3, [r2, #64]	; 0x40
			if (mode & 4) PIOC->PIO_IER = interruptMask[2];
   90108:	7bfb      	ldrb	r3, [r7, #15]
   9010a:	f003 0304 	and.w	r3, r3, #4
   9010e:	2b00      	cmp	r3, #0
   90110:	d003      	beq.n	9011a <_ZN8SPIClass14endTransactionEv+0x52>
   90112:	4a0e      	ldr	r2, [pc, #56]	; (9014c <_ZN8SPIClass14endTransactionEv+0x84>)
   90114:	687b      	ldr	r3, [r7, #4]
   90116:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   90118:	6413      	str	r3, [r2, #64]	; 0x40
			if (mode & 8) PIOD->PIO_IER = interruptMask[3];
   9011a:	7bfb      	ldrb	r3, [r7, #15]
   9011c:	f003 0308 	and.w	r3, r3, #8
   90120:	2b00      	cmp	r3, #0
   90122:	d00a      	beq.n	9013a <_ZN8SPIClass14endTransactionEv+0x72>
   90124:	4a0a      	ldr	r2, [pc, #40]	; (90150 <_ZN8SPIClass14endTransactionEv+0x88>)
   90126:	687b      	ldr	r3, [r7, #4]
   90128:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   9012a:	6413      	str	r3, [r2, #64]	; 0x40
		} else {
			if (interruptSave) interrupts();
		}
	}
}
   9012c:	e005      	b.n	9013a <_ZN8SPIClass14endTransactionEv+0x72>
			if (mode & 1) PIOA->PIO_IER = interruptMask[0];
			if (mode & 2) PIOB->PIO_IER = interruptMask[1];
			if (mode & 4) PIOC->PIO_IER = interruptMask[2];
			if (mode & 8) PIOD->PIO_IER = interruptMask[3];
		} else {
			if (interruptSave) interrupts();
   9012e:	687b      	ldr	r3, [r7, #4]
   90130:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
   90134:	2b00      	cmp	r3, #0
   90136:	d000      	beq.n	9013a <_ZN8SPIClass14endTransactionEv+0x72>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
   90138:	b662      	cpsie	i
		}
	}
}
   9013a:	bf00      	nop
   9013c:	3714      	adds	r7, #20
   9013e:	46bd      	mov	sp, r7
   90140:	bc80      	pop	{r7}
   90142:	4770      	bx	lr
   90144:	400e0e00 	.word	0x400e0e00
   90148:	400e1000 	.word	0x400e1000
   9014c:	400e1200 	.word	0x400e1200
   90150:	400e1400 	.word	0x400e1400

00090154 <_ZN8SPIClass11setBitOrderEh8BitOrder>:
void SPIClass::end() {
	SPI_Disable(spi);
	initialized = false;
}

void SPIClass::setBitOrder(uint8_t _pin, BitOrder _bitOrder) {
   90154:	b480      	push	{r7}
   90156:	b085      	sub	sp, #20
   90158:	af00      	add	r7, sp, #0
   9015a:	6078      	str	r0, [r7, #4]
   9015c:	460b      	mov	r3, r1
   9015e:	70fb      	strb	r3, [r7, #3]
   90160:	4613      	mov	r3, r2
   90162:	70bb      	strb	r3, [r7, #2]
	uint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(_pin);
   90164:	78fb      	ldrb	r3, [r7, #3]
   90166:	2b0a      	cmp	r3, #10
   90168:	d00b      	beq.n	90182 <_ZN8SPIClass11setBitOrderEh8BitOrder+0x2e>
   9016a:	78fb      	ldrb	r3, [r7, #3]
   9016c:	2b04      	cmp	r3, #4
   9016e:	d006      	beq.n	9017e <_ZN8SPIClass11setBitOrderEh8BitOrder+0x2a>
   90170:	78fb      	ldrb	r3, [r7, #3]
   90172:	2b34      	cmp	r3, #52	; 0x34
   90174:	d101      	bne.n	9017a <_ZN8SPIClass11setBitOrderEh8BitOrder+0x26>
   90176:	2302      	movs	r3, #2
   90178:	e004      	b.n	90184 <_ZN8SPIClass11setBitOrderEh8BitOrder+0x30>
   9017a:	2303      	movs	r3, #3
   9017c:	e002      	b.n	90184 <_ZN8SPIClass11setBitOrderEh8BitOrder+0x30>
   9017e:	2301      	movs	r3, #1
   90180:	e000      	b.n	90184 <_ZN8SPIClass11setBitOrderEh8BitOrder+0x30>
   90182:	2300      	movs	r3, #0
   90184:	60fb      	str	r3, [r7, #12]
	bitOrder[ch] = _bitOrder;
   90186:	687a      	ldr	r2, [r7, #4]
   90188:	68fb      	ldr	r3, [r7, #12]
   9018a:	4413      	add	r3, r2
   9018c:	3308      	adds	r3, #8
   9018e:	78ba      	ldrb	r2, [r7, #2]
   90190:	701a      	strb	r2, [r3, #0]
}
   90192:	bf00      	nop
   90194:	3714      	adds	r7, #20
   90196:	46bd      	mov	sp, r7
   90198:	bc80      	pop	{r7}
   9019a:	4770      	bx	lr

0009019c <_ZN8SPIClass11setDataModeEhh>:

void SPIClass::setDataMode(uint8_t _pin, uint8_t _mode) {
   9019c:	b580      	push	{r7, lr}
   9019e:	b084      	sub	sp, #16
   901a0:	af00      	add	r7, sp, #0
   901a2:	6078      	str	r0, [r7, #4]
   901a4:	460b      	mov	r3, r1
   901a6:	70fb      	strb	r3, [r7, #3]
   901a8:	4613      	mov	r3, r2
   901aa:	70bb      	strb	r3, [r7, #2]
	uint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(_pin);
   901ac:	78fb      	ldrb	r3, [r7, #3]
   901ae:	2b0a      	cmp	r3, #10
   901b0:	d00b      	beq.n	901ca <_ZN8SPIClass11setDataModeEhh+0x2e>
   901b2:	78fb      	ldrb	r3, [r7, #3]
   901b4:	2b04      	cmp	r3, #4
   901b6:	d006      	beq.n	901c6 <_ZN8SPIClass11setDataModeEhh+0x2a>
   901b8:	78fb      	ldrb	r3, [r7, #3]
   901ba:	2b34      	cmp	r3, #52	; 0x34
   901bc:	d101      	bne.n	901c2 <_ZN8SPIClass11setDataModeEhh+0x26>
   901be:	2302      	movs	r3, #2
   901c0:	e004      	b.n	901cc <_ZN8SPIClass11setDataModeEhh+0x30>
   901c2:	2303      	movs	r3, #3
   901c4:	e002      	b.n	901cc <_ZN8SPIClass11setDataModeEhh+0x30>
   901c6:	2301      	movs	r3, #1
   901c8:	e000      	b.n	901cc <_ZN8SPIClass11setDataModeEhh+0x30>
   901ca:	2300      	movs	r3, #0
   901cc:	60fb      	str	r3, [r7, #12]
	mode[ch] = _mode | SPI_CSR_CSAAT;
   901ce:	78bb      	ldrb	r3, [r7, #2]
   901d0:	f043 0308 	orr.w	r3, r3, #8
   901d4:	b2db      	uxtb	r3, r3
   901d6:	4619      	mov	r1, r3
   901d8:	687a      	ldr	r2, [r7, #4]
   901da:	68fb      	ldr	r3, [r7, #12]
   901dc:	3306      	adds	r3, #6
   901de:	009b      	lsls	r3, r3, #2
   901e0:	4413      	add	r3, r2
   901e2:	6059      	str	r1, [r3, #4]
	// SPI_CSR_DLYBCT(1) keeps CS enabled for 32 MCLK after a completed
	// transfer. Some device needs that for working properly.
	SPI_ConfigureNPCS(spi, ch, mode[ch] | SPI_CSR_SCBR(divider[ch]) | SPI_CSR_DLYBCT(1));
   901e4:	687b      	ldr	r3, [r7, #4]
   901e6:	6818      	ldr	r0, [r3, #0]
   901e8:	687a      	ldr	r2, [r7, #4]
   901ea:	68fb      	ldr	r3, [r7, #12]
   901ec:	3306      	adds	r3, #6
   901ee:	009b      	lsls	r3, r3, #2
   901f0:	4413      	add	r3, r2
   901f2:	685a      	ldr	r2, [r3, #4]
   901f4:	6879      	ldr	r1, [r7, #4]
   901f6:	68fb      	ldr	r3, [r7, #12]
   901f8:	3302      	adds	r3, #2
   901fa:	009b      	lsls	r3, r3, #2
   901fc:	440b      	add	r3, r1
   901fe:	685b      	ldr	r3, [r3, #4]
   90200:	021b      	lsls	r3, r3, #8
   90202:	b29b      	uxth	r3, r3
   90204:	4313      	orrs	r3, r2
   90206:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   9020a:	461a      	mov	r2, r3
   9020c:	68f9      	ldr	r1, [r7, #12]
   9020e:	4b03      	ldr	r3, [pc, #12]	; (9021c <_ZN8SPIClass11setDataModeEhh+0x80>)
   90210:	4798      	blx	r3
}
   90212:	bf00      	nop
   90214:	3710      	adds	r7, #16
   90216:	46bd      	mov	sp, r7
   90218:	bd80      	pop	{r7, pc}
   9021a:	bf00      	nop
   9021c:	000904a9 	.word	0x000904a9

00090220 <_ZN8SPIClass15setClockDividerEhh>:

void SPIClass::setClockDivider(uint8_t _pin, uint8_t _divider) {
   90220:	b580      	push	{r7, lr}
   90222:	b084      	sub	sp, #16
   90224:	af00      	add	r7, sp, #0
   90226:	6078      	str	r0, [r7, #4]
   90228:	460b      	mov	r3, r1
   9022a:	70fb      	strb	r3, [r7, #3]
   9022c:	4613      	mov	r3, r2
   9022e:	70bb      	strb	r3, [r7, #2]
	uint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(_pin);
   90230:	78fb      	ldrb	r3, [r7, #3]
   90232:	2b0a      	cmp	r3, #10
   90234:	d00b      	beq.n	9024e <_ZN8SPIClass15setClockDividerEhh+0x2e>
   90236:	78fb      	ldrb	r3, [r7, #3]
   90238:	2b04      	cmp	r3, #4
   9023a:	d006      	beq.n	9024a <_ZN8SPIClass15setClockDividerEhh+0x2a>
   9023c:	78fb      	ldrb	r3, [r7, #3]
   9023e:	2b34      	cmp	r3, #52	; 0x34
   90240:	d101      	bne.n	90246 <_ZN8SPIClass15setClockDividerEhh+0x26>
   90242:	2302      	movs	r3, #2
   90244:	e004      	b.n	90250 <_ZN8SPIClass15setClockDividerEhh+0x30>
   90246:	2303      	movs	r3, #3
   90248:	e002      	b.n	90250 <_ZN8SPIClass15setClockDividerEhh+0x30>
   9024a:	2301      	movs	r3, #1
   9024c:	e000      	b.n	90250 <_ZN8SPIClass15setClockDividerEhh+0x30>
   9024e:	2300      	movs	r3, #0
   90250:	60fb      	str	r3, [r7, #12]
	divider[ch] = _divider;
   90252:	78ba      	ldrb	r2, [r7, #2]
   90254:	6879      	ldr	r1, [r7, #4]
   90256:	68fb      	ldr	r3, [r7, #12]
   90258:	3302      	adds	r3, #2
   9025a:	009b      	lsls	r3, r3, #2
   9025c:	440b      	add	r3, r1
   9025e:	605a      	str	r2, [r3, #4]
	// SPI_CSR_DLYBCT(1) keeps CS enabled for 32 MCLK after a completed
	// transfer. Some device needs that for working properly.
	SPI_ConfigureNPCS(spi, ch, mode[ch] | SPI_CSR_SCBR(divider[ch]) | SPI_CSR_DLYBCT(1));
   90260:	687b      	ldr	r3, [r7, #4]
   90262:	6818      	ldr	r0, [r3, #0]
   90264:	687a      	ldr	r2, [r7, #4]
   90266:	68fb      	ldr	r3, [r7, #12]
   90268:	3306      	adds	r3, #6
   9026a:	009b      	lsls	r3, r3, #2
   9026c:	4413      	add	r3, r2
   9026e:	685a      	ldr	r2, [r3, #4]
   90270:	6879      	ldr	r1, [r7, #4]
   90272:	68fb      	ldr	r3, [r7, #12]
   90274:	3302      	adds	r3, #2
   90276:	009b      	lsls	r3, r3, #2
   90278:	440b      	add	r3, r1
   9027a:	685b      	ldr	r3, [r3, #4]
   9027c:	021b      	lsls	r3, r3, #8
   9027e:	b29b      	uxth	r3, r3
   90280:	4313      	orrs	r3, r2
   90282:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   90286:	461a      	mov	r2, r3
   90288:	68f9      	ldr	r1, [r7, #12]
   9028a:	4b03      	ldr	r3, [pc, #12]	; (90298 <_ZN8SPIClass15setClockDividerEhh+0x78>)
   9028c:	4798      	blx	r3
}
   9028e:	bf00      	nop
   90290:	3710      	adds	r7, #16
   90292:	46bd      	mov	sp, r7
   90294:	bd80      	pop	{r7, pc}
   90296:	bf00      	nop
   90298:	000904a9 	.word	0x000904a9

0009029c <_ZN8SPIClass8transferEhh15SPITransferMode>:

byte SPIClass::transfer(byte _pin, uint8_t _data, SPITransferMode _mode) {
   9029c:	b480      	push	{r7}
   9029e:	b08d      	sub	sp, #52	; 0x34
   902a0:	af00      	add	r7, sp, #0
   902a2:	6078      	str	r0, [r7, #4]
   902a4:	4608      	mov	r0, r1
   902a6:	4611      	mov	r1, r2
   902a8:	461a      	mov	r2, r3
   902aa:	4603      	mov	r3, r0
   902ac:	70fb      	strb	r3, [r7, #3]
   902ae:	460b      	mov	r3, r1
   902b0:	70bb      	strb	r3, [r7, #2]
   902b2:	4613      	mov	r3, r2
   902b4:	707b      	strb	r3, [r7, #1]
	uint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(_pin);
   902b6:	78fb      	ldrb	r3, [r7, #3]
   902b8:	2b0a      	cmp	r3, #10
   902ba:	d00b      	beq.n	902d4 <_ZN8SPIClass8transferEhh15SPITransferMode+0x38>
   902bc:	78fb      	ldrb	r3, [r7, #3]
   902be:	2b04      	cmp	r3, #4
   902c0:	d006      	beq.n	902d0 <_ZN8SPIClass8transferEhh15SPITransferMode+0x34>
   902c2:	78fb      	ldrb	r3, [r7, #3]
   902c4:	2b34      	cmp	r3, #52	; 0x34
   902c6:	d101      	bne.n	902cc <_ZN8SPIClass8transferEhh15SPITransferMode+0x30>
   902c8:	2302      	movs	r3, #2
   902ca:	e004      	b.n	902d6 <_ZN8SPIClass8transferEhh15SPITransferMode+0x3a>
   902cc:	2303      	movs	r3, #3
   902ce:	e002      	b.n	902d6 <_ZN8SPIClass8transferEhh15SPITransferMode+0x3a>
   902d0:	2301      	movs	r3, #1
   902d2:	e000      	b.n	902d6 <_ZN8SPIClass8transferEhh15SPITransferMode+0x3a>
   902d4:	2300      	movs	r3, #0
   902d6:	62bb      	str	r3, [r7, #40]	; 0x28
	// Reverse bit order
	if (bitOrder[ch] == LSBFIRST)
   902d8:	687a      	ldr	r2, [r7, #4]
   902da:	6abb      	ldr	r3, [r7, #40]	; 0x28
   902dc:	4413      	add	r3, r2
   902de:	3308      	adds	r3, #8
   902e0:	781b      	ldrb	r3, [r3, #0]
   902e2:	2b00      	cmp	r3, #0
   902e4:	d10c      	bne.n	90300 <_ZN8SPIClass8transferEhh15SPITransferMode+0x64>
		_data = __REV(__RBIT(_data));
   902e6:	78bb      	ldrb	r3, [r7, #2]
   902e8:	623b      	str	r3, [r7, #32]
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;
  
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
   902ea:	6a3b      	ldr	r3, [r7, #32]
   902ec:	fa93 f3a3 	rbit	r3, r3
   902f0:	613b      	str	r3, [r7, #16]
   return(result);
   902f2:	693b      	ldr	r3, [r7, #16]
   902f4:	61bb      	str	r3, [r7, #24]
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV(uint32_t value)
{
  uint32_t result;
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
   902f6:	69bb      	ldr	r3, [r7, #24]
   902f8:	ba1b      	rev	r3, r3
   902fa:	617b      	str	r3, [r7, #20]
  return(result);
   902fc:	697b      	ldr	r3, [r7, #20]
   902fe:	70bb      	strb	r3, [r7, #2]
	uint32_t d = _data | SPI_PCS(ch);
   90300:	78ba      	ldrb	r2, [r7, #2]
   90302:	2101      	movs	r1, #1
   90304:	6abb      	ldr	r3, [r7, #40]	; 0x28
   90306:	fa01 f303 	lsl.w	r3, r1, r3
   9030a:	43db      	mvns	r3, r3
   9030c:	041b      	lsls	r3, r3, #16
   9030e:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
   90312:	4313      	orrs	r3, r2
   90314:	62fb      	str	r3, [r7, #44]	; 0x2c
	if (_mode == SPI_LAST)
   90316:	787b      	ldrb	r3, [r7, #1]
   90318:	2b01      	cmp	r3, #1
   9031a:	d103      	bne.n	90324 <_ZN8SPIClass8transferEhh15SPITransferMode+0x88>
		d |= SPI_TDR_LASTXFER;
   9031c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   9031e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   90322:	62fb      	str	r3, [r7, #44]	; 0x2c

	// SPI_Write(spi, _channel, _data);
	while ((spi->SPI_SR & SPI_SR_TDRE) == 0)
   90324:	687b      	ldr	r3, [r7, #4]
   90326:	681b      	ldr	r3, [r3, #0]
   90328:	691b      	ldr	r3, [r3, #16]
   9032a:	f003 0302 	and.w	r3, r3, #2
   9032e:	2b00      	cmp	r3, #0
   90330:	bf0c      	ite	eq
   90332:	2301      	moveq	r3, #1
   90334:	2300      	movne	r3, #0
   90336:	b2db      	uxtb	r3, r3
   90338:	2b00      	cmp	r3, #0
   9033a:	d000      	beq.n	9033e <_ZN8SPIClass8transferEhh15SPITransferMode+0xa2>
   9033c:	e7f2      	b.n	90324 <_ZN8SPIClass8transferEhh15SPITransferMode+0x88>
		;
	spi->SPI_TDR = d;
   9033e:	687b      	ldr	r3, [r7, #4]
   90340:	681b      	ldr	r3, [r3, #0]
   90342:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   90344:	60da      	str	r2, [r3, #12]

	// return SPI_Read(spi);
	while ((spi->SPI_SR & SPI_SR_RDRF) == 0)
   90346:	687b      	ldr	r3, [r7, #4]
   90348:	681b      	ldr	r3, [r3, #0]
   9034a:	691b      	ldr	r3, [r3, #16]
   9034c:	f003 0301 	and.w	r3, r3, #1
   90350:	2b00      	cmp	r3, #0
   90352:	bf0c      	ite	eq
   90354:	2301      	moveq	r3, #1
   90356:	2300      	movne	r3, #0
   90358:	b2db      	uxtb	r3, r3
   9035a:	2b00      	cmp	r3, #0
   9035c:	d000      	beq.n	90360 <_ZN8SPIClass8transferEhh15SPITransferMode+0xc4>
   9035e:	e7f2      	b.n	90346 <_ZN8SPIClass8transferEhh15SPITransferMode+0xaa>
		;
	d = spi->SPI_RDR;
   90360:	687b      	ldr	r3, [r7, #4]
   90362:	681b      	ldr	r3, [r3, #0]
   90364:	689b      	ldr	r3, [r3, #8]
   90366:	62fb      	str	r3, [r7, #44]	; 0x2c
	// Reverse bit order
	if (bitOrder[ch] == LSBFIRST)
   90368:	687a      	ldr	r2, [r7, #4]
   9036a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   9036c:	4413      	add	r3, r2
   9036e:	3308      	adds	r3, #8
   90370:	781b      	ldrb	r3, [r3, #0]
   90372:	2b00      	cmp	r3, #0
   90374:	d10c      	bne.n	90390 <_ZN8SPIClass8transferEhh15SPITransferMode+0xf4>
   90376:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   90378:	61fb      	str	r3, [r7, #28]
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;
  
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
   9037a:	69fb      	ldr	r3, [r7, #28]
   9037c:	fa93 f3a3 	rbit	r3, r3
   90380:	60bb      	str	r3, [r7, #8]
   return(result);
   90382:	68bb      	ldr	r3, [r7, #8]
   90384:	627b      	str	r3, [r7, #36]	; 0x24
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __REV(uint32_t value)
{
  uint32_t result;
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
   90386:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   90388:	ba1b      	rev	r3, r3
   9038a:	60fb      	str	r3, [r7, #12]
  return(result);
   9038c:	68fb      	ldr	r3, [r7, #12]
		d = __REV(__RBIT(d));
   9038e:	62fb      	str	r3, [r7, #44]	; 0x2c
	return d & 0xFF;
   90390:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   90392:	b2db      	uxtb	r3, r3
}
   90394:	4618      	mov	r0, r3
   90396:	3734      	adds	r7, #52	; 0x34
   90398:	46bd      	mov	sp, r7
   9039a:	bc80      	pop	{r7}
   9039c:	4770      	bx	lr
   9039e:	bf00      	nop

000903a0 <_ZL10SPI_0_Initv>:
void SPIClass::detachInterrupt(void) {
	// Should be disableInterrupt()
}

#if SPI_INTERFACES_COUNT > 0
static void SPI_0_Init(void) {
   903a0:	b598      	push	{r3, r4, r7, lr}
   903a2:	af00      	add	r7, sp, #0
	PIO_Configure(
			g_APinDescription[PIN_SPI_MOSI].pPort,
   903a4:	4b15      	ldr	r3, [pc, #84]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903a6:	f8d3 0834 	ldr.w	r0, [r3, #2100]	; 0x834
			g_APinDescription[PIN_SPI_MOSI].ulPinType,
   903aa:	4b14      	ldr	r3, [pc, #80]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903ac:	f893 1840 	ldrb.w	r1, [r3, #2112]	; 0x840
			g_APinDescription[PIN_SPI_MOSI].ulPin,
   903b0:	4b12      	ldr	r3, [pc, #72]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903b2:	f8d3 2838 	ldr.w	r2, [r3, #2104]	; 0x838
			g_APinDescription[PIN_SPI_MOSI].ulPinConfiguration);
   903b6:	4b11      	ldr	r3, [pc, #68]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903b8:	f8d3 3844 	ldr.w	r3, [r3, #2116]	; 0x844
   903bc:	4c10      	ldr	r4, [pc, #64]	; (90400 <_ZL10SPI_0_Initv+0x60>)
   903be:	47a0      	blx	r4
	PIO_Configure(
			g_APinDescription[PIN_SPI_MISO].pPort,
   903c0:	4b0e      	ldr	r3, [pc, #56]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903c2:	f8d3 0818 	ldr.w	r0, [r3, #2072]	; 0x818
			g_APinDescription[PIN_SPI_MISO].ulPinType,
   903c6:	4b0d      	ldr	r3, [pc, #52]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903c8:	f893 1824 	ldrb.w	r1, [r3, #2084]	; 0x824
			g_APinDescription[PIN_SPI_MISO].ulPin,
   903cc:	4b0b      	ldr	r3, [pc, #44]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903ce:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
			g_APinDescription[PIN_SPI_MISO].ulPinConfiguration);
   903d2:	4b0a      	ldr	r3, [pc, #40]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903d4:	f8d3 3828 	ldr.w	r3, [r3, #2088]	; 0x828
   903d8:	4c09      	ldr	r4, [pc, #36]	; (90400 <_ZL10SPI_0_Initv+0x60>)
   903da:	47a0      	blx	r4
	PIO_Configure(
			g_APinDescription[PIN_SPI_SCK].pPort,
   903dc:	4b07      	ldr	r3, [pc, #28]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903de:	f8d3 0850 	ldr.w	r0, [r3, #2128]	; 0x850
			g_APinDescription[PIN_SPI_SCK].ulPinType,
   903e2:	4b06      	ldr	r3, [pc, #24]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903e4:	f893 185c 	ldrb.w	r1, [r3, #2140]	; 0x85c
			g_APinDescription[PIN_SPI_SCK].ulPin,
   903e8:	4b04      	ldr	r3, [pc, #16]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903ea:	f8d3 2854 	ldr.w	r2, [r3, #2132]	; 0x854
			g_APinDescription[PIN_SPI_SCK].ulPinConfiguration);
   903ee:	4b03      	ldr	r3, [pc, #12]	; (903fc <_ZL10SPI_0_Initv+0x5c>)
   903f0:	f8d3 3860 	ldr.w	r3, [r3, #2144]	; 0x860
   903f4:	4c02      	ldr	r4, [pc, #8]	; (90400 <_ZL10SPI_0_Initv+0x60>)
   903f6:	47a0      	blx	r4
}
   903f8:	bf00      	nop
   903fa:	bd98      	pop	{r3, r4, r7, pc}
   903fc:	0009958c 	.word	0x0009958c
   90400:	00087efd 	.word	0x00087efd

00090404 <_Z41__static_initialization_and_destruction_0ii>:

SPIClass SPI(SPI_INTERFACE, SPI_INTERFACE_ID, SPI_0_Init);
   90404:	b590      	push	{r4, r7, lr}
   90406:	b083      	sub	sp, #12
   90408:	af00      	add	r7, sp, #0
   9040a:	6078      	str	r0, [r7, #4]
   9040c:	6039      	str	r1, [r7, #0]
   9040e:	687b      	ldr	r3, [r7, #4]
   90410:	2b01      	cmp	r3, #1
   90412:	d10a      	bne.n	9042a <_Z41__static_initialization_and_destruction_0ii+0x26>
   90414:	683b      	ldr	r3, [r7, #0]
   90416:	f64f 72ff 	movw	r2, #65535	; 0xffff
   9041a:	4293      	cmp	r3, r2
   9041c:	d105      	bne.n	9042a <_Z41__static_initialization_and_destruction_0ii+0x26>
   9041e:	4b05      	ldr	r3, [pc, #20]	; (90434 <_Z41__static_initialization_and_destruction_0ii+0x30>)
   90420:	2218      	movs	r2, #24
   90422:	4905      	ldr	r1, [pc, #20]	; (90438 <_Z41__static_initialization_and_destruction_0ii+0x34>)
   90424:	4805      	ldr	r0, [pc, #20]	; (9043c <_Z41__static_initialization_and_destruction_0ii+0x38>)
   90426:	4c06      	ldr	r4, [pc, #24]	; (90440 <_Z41__static_initialization_and_destruction_0ii+0x3c>)
   90428:	47a0      	blx	r4
   9042a:	bf00      	nop
   9042c:	370c      	adds	r7, #12
   9042e:	46bd      	mov	sp, r7
   90430:	bd90      	pop	{r4, r7, pc}
   90432:	bf00      	nop
   90434:	000903a1 	.word	0x000903a1
   90438:	40008000 	.word	0x40008000
   9043c:	20071c78 	.word	0x20071c78
   90440:	0008fee5 	.word	0x0008fee5

00090444 <_GLOBAL__sub_I__ZN8SPIClassC2EP3SpimPFvvE>:
   90444:	b580      	push	{r7, lr}
   90446:	af00      	add	r7, sp, #0
   90448:	f64f 71ff 	movw	r1, #65535	; 0xffff
   9044c:	2001      	movs	r0, #1
   9044e:	4b01      	ldr	r3, [pc, #4]	; (90454 <_GLOBAL__sub_I__ZN8SPIClassC2EP3SpimPFvvE+0x10>)
   90450:	4798      	blx	r3
   90452:	bd80      	pop	{r7, pc}
   90454:	00090405 	.word	0x00090405

00090458 <SPI_Enable>:
 * \brief Enables a SPI peripheral.
 *
 * \param spi  Pointer to an Spi instance.
 */
extern void SPI_Enable( Spi* spi )
{
   90458:	b480      	push	{r7}
   9045a:	b083      	sub	sp, #12
   9045c:	af00      	add	r7, sp, #0
   9045e:	6078      	str	r0, [r7, #4]
    spi->SPI_CR = SPI_CR_SPIEN ;
   90460:	687b      	ldr	r3, [r7, #4]
   90462:	2201      	movs	r2, #1
   90464:	601a      	str	r2, [r3, #0]
}
   90466:	bf00      	nop
   90468:	370c      	adds	r7, #12
   9046a:	46bd      	mov	sp, r7
   9046c:	bc80      	pop	{r7}
   9046e:	4770      	bx	lr

00090470 <SPI_Configure>:
 * \param spi  Pointer to an Spi instance.
 * \param id   Peripheral ID of the SPI.
 * \param configuration  Value of the SPI configuration register.
 */
extern void SPI_Configure( Spi* spi, uint32_t dwId, uint32_t dwConfiguration )
{
   90470:	b580      	push	{r7, lr}
   90472:	b084      	sub	sp, #16
   90474:	af00      	add	r7, sp, #0
   90476:	60f8      	str	r0, [r7, #12]
   90478:	60b9      	str	r1, [r7, #8]
   9047a:	607a      	str	r2, [r7, #4]
    pmc_enable_periph_clk( dwId ) ;
   9047c:	68b8      	ldr	r0, [r7, #8]
   9047e:	4b09      	ldr	r3, [pc, #36]	; (904a4 <SPI_Configure+0x34>)
   90480:	4798      	blx	r3
    spi->SPI_CR = SPI_CR_SPIDIS ;
   90482:	68fb      	ldr	r3, [r7, #12]
   90484:	2202      	movs	r2, #2
   90486:	601a      	str	r2, [r3, #0]

    /* Execute a software reset of the SPI twice */
    spi->SPI_CR = SPI_CR_SWRST ;
   90488:	68fb      	ldr	r3, [r7, #12]
   9048a:	2280      	movs	r2, #128	; 0x80
   9048c:	601a      	str	r2, [r3, #0]
    spi->SPI_CR = SPI_CR_SWRST ;
   9048e:	68fb      	ldr	r3, [r7, #12]
   90490:	2280      	movs	r2, #128	; 0x80
   90492:	601a      	str	r2, [r3, #0]
    spi->SPI_MR = dwConfiguration ;
   90494:	68fb      	ldr	r3, [r7, #12]
   90496:	687a      	ldr	r2, [r7, #4]
   90498:	605a      	str	r2, [r3, #4]
}
   9049a:	bf00      	nop
   9049c:	3710      	adds	r7, #16
   9049e:	46bd      	mov	sp, r7
   904a0:	bd80      	pop	{r7, pc}
   904a2:	bf00      	nop
   904a4:	00088021 	.word	0x00088021

000904a8 <SPI_ConfigureNPCS>:
 * \param spi   Pointer to an Spi instance.
 * \param npcs  Chip select to configure (0, 1, 2 or 3).
 * \param configuration  Desired chip select configuration.
 */
void SPI_ConfigureNPCS( Spi* spi, uint32_t dwNpcs, uint32_t dwConfiguration )
{
   904a8:	b480      	push	{r7}
   904aa:	b085      	sub	sp, #20
   904ac:	af00      	add	r7, sp, #0
   904ae:	60f8      	str	r0, [r7, #12]
   904b0:	60b9      	str	r1, [r7, #8]
   904b2:	607a      	str	r2, [r7, #4]
    spi->SPI_CSR[dwNpcs] = dwConfiguration ;
   904b4:	68fb      	ldr	r3, [r7, #12]
   904b6:	68ba      	ldr	r2, [r7, #8]
   904b8:	320c      	adds	r2, #12
   904ba:	6879      	ldr	r1, [r7, #4]
   904bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   904c0:	bf00      	nop
   904c2:	3714      	adds	r7, #20
   904c4:	46bd      	mov	sp, r7
   904c6:	bc80      	pop	{r7}
   904c8:	4770      	bx	lr
   904ca:	bf00      	nop

000904cc <UOTGHS_Handler>:
#if SAM3XA_SERIES

void (*gpf_isr)(void) = (0UL);

void UOTGHS_Handler( void )
{
   904cc:	b580      	push	{r7, lr}
   904ce:	af00      	add	r7, sp, #0
	if (gpf_isr)
   904d0:	4b04      	ldr	r3, [pc, #16]	; (904e4 <UOTGHS_Handler+0x18>)
   904d2:	681b      	ldr	r3, [r3, #0]
   904d4:	2b00      	cmp	r3, #0
   904d6:	d002      	beq.n	904de <UOTGHS_Handler+0x12>
		gpf_isr();
   904d8:	4b02      	ldr	r3, [pc, #8]	; (904e4 <UOTGHS_Handler+0x18>)
   904da:	681b      	ldr	r3, [r3, #0]
   904dc:	4798      	blx	r3
}
   904de:	bf00      	nop
   904e0:	bd80      	pop	{r7, pc}
   904e2:	bf00      	nop
   904e4:	20071cbc 	.word	0x20071cbc

000904e8 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   904e8:	b580      	push	{r7, lr}
   904ea:	b084      	sub	sp, #16
   904ec:	af00      	add	r7, sp, #0
   904ee:	6078      	str	r0, [r7, #4]
void *pvReturn;

	vTaskSuspendAll();
   904f0:	4b09      	ldr	r3, [pc, #36]	; (90518 <pvPortMalloc+0x30>)
   904f2:	4798      	blx	r3
	{
		pvReturn = malloc( xWantedSize );
   904f4:	6878      	ldr	r0, [r7, #4]
   904f6:	4b09      	ldr	r3, [pc, #36]	; (9051c <pvPortMalloc+0x34>)
   904f8:	4798      	blx	r3
   904fa:	4603      	mov	r3, r0
   904fc:	60fb      	str	r3, [r7, #12]
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   904fe:	4b08      	ldr	r3, [pc, #32]	; (90520 <pvPortMalloc+0x38>)
   90500:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
   90502:	68fb      	ldr	r3, [r7, #12]
   90504:	2b00      	cmp	r3, #0
   90506:	d101      	bne.n	9050c <pvPortMalloc+0x24>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
   90508:	4b06      	ldr	r3, [pc, #24]	; (90524 <pvPortMalloc+0x3c>)
   9050a:	4798      	blx	r3
		}
	}
	#endif

	return pvReturn;
   9050c:	68fb      	ldr	r3, [r7, #12]
}
   9050e:	4618      	mov	r0, r3
   90510:	3710      	adds	r7, #16
   90512:	46bd      	mov	sp, r7
   90514:	bd80      	pop	{r7, pc}
   90516:	bf00      	nop
   90518:	0008e031 	.word	0x0008e031
   9051c:	00093535 	.word	0x00093535
   90520:	0008e04d 	.word	0x0008e04d
   90524:	00082f01 	.word	0x00082f01

00090528 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   90528:	b580      	push	{r7, lr}
   9052a:	b082      	sub	sp, #8
   9052c:	af00      	add	r7, sp, #0
   9052e:	6078      	str	r0, [r7, #4]
	if( pv )
   90530:	687b      	ldr	r3, [r7, #4]
   90532:	2b00      	cmp	r3, #0
   90534:	d006      	beq.n	90544 <vPortFree+0x1c>
	{
		vTaskSuspendAll();
   90536:	4b05      	ldr	r3, [pc, #20]	; (9054c <vPortFree+0x24>)
   90538:	4798      	blx	r3
		{
			free( pv );
   9053a:	6878      	ldr	r0, [r7, #4]
   9053c:	4b04      	ldr	r3, [pc, #16]	; (90550 <vPortFree+0x28>)
   9053e:	4798      	blx	r3
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
   90540:	4b04      	ldr	r3, [pc, #16]	; (90554 <vPortFree+0x2c>)
   90542:	4798      	blx	r3
	}
}
   90544:	bf00      	nop
   90546:	3708      	adds	r7, #8
   90548:	46bd      	mov	sp, r7
   9054a:	bd80      	pop	{r7, pc}
   9054c:	0008e031 	.word	0x0008e031
   90550:	00093545 	.word	0x00093545
   90554:	0008e04d 	.word	0x0008e04d

00090558 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
   90558:	b480      	push	{r7}
   9055a:	b083      	sub	sp, #12
   9055c:	af00      	add	r7, sp, #0
   9055e:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   90560:	687b      	ldr	r3, [r7, #4]
   90562:	f103 0208 	add.w	r2, r3, #8
   90566:	687b      	ldr	r3, [r7, #4]
   90568:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   9056a:	687b      	ldr	r3, [r7, #4]
   9056c:	f04f 32ff 	mov.w	r2, #4294967295
   90570:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   90572:	687b      	ldr	r3, [r7, #4]
   90574:	f103 0208 	add.w	r2, r3, #8
   90578:	687b      	ldr	r3, [r7, #4]
   9057a:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   9057c:	687b      	ldr	r3, [r7, #4]
   9057e:	f103 0208 	add.w	r2, r3, #8
   90582:	687b      	ldr	r3, [r7, #4]
   90584:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   90586:	687b      	ldr	r3, [r7, #4]
   90588:	2200      	movs	r2, #0
   9058a:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
   9058c:	bf00      	nop
   9058e:	370c      	adds	r7, #12
   90590:	46bd      	mov	sp, r7
   90592:	bc80      	pop	{r7}
   90594:	4770      	bx	lr
   90596:	bf00      	nop

00090598 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
   90598:	b480      	push	{r7}
   9059a:	b083      	sub	sp, #12
   9059c:	af00      	add	r7, sp, #0
   9059e:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   905a0:	687b      	ldr	r3, [r7, #4]
   905a2:	2200      	movs	r2, #0
   905a4:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
   905a6:	bf00      	nop
   905a8:	370c      	adds	r7, #12
   905aa:	46bd      	mov	sp, r7
   905ac:	bc80      	pop	{r7}
   905ae:	4770      	bx	lr

000905b0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   905b0:	b480      	push	{r7}
   905b2:	b085      	sub	sp, #20
   905b4:	af00      	add	r7, sp, #0
   905b6:	6078      	str	r0, [r7, #4]
   905b8:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
   905ba:	687b      	ldr	r3, [r7, #4]
   905bc:	685b      	ldr	r3, [r3, #4]
   905be:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   905c0:	683b      	ldr	r3, [r7, #0]
   905c2:	68fa      	ldr	r2, [r7, #12]
   905c4:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   905c6:	68fb      	ldr	r3, [r7, #12]
   905c8:	689a      	ldr	r2, [r3, #8]
   905ca:	683b      	ldr	r3, [r7, #0]
   905cc:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   905ce:	68fb      	ldr	r3, [r7, #12]
   905d0:	689b      	ldr	r3, [r3, #8]
   905d2:	683a      	ldr	r2, [r7, #0]
   905d4:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
   905d6:	68fb      	ldr	r3, [r7, #12]
   905d8:	683a      	ldr	r2, [r7, #0]
   905da:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   905dc:	683b      	ldr	r3, [r7, #0]
   905de:	687a      	ldr	r2, [r7, #4]
   905e0:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   905e2:	687b      	ldr	r3, [r7, #4]
   905e4:	681b      	ldr	r3, [r3, #0]
   905e6:	1c5a      	adds	r2, r3, #1
   905e8:	687b      	ldr	r3, [r7, #4]
   905ea:	601a      	str	r2, [r3, #0]
}
   905ec:	bf00      	nop
   905ee:	3714      	adds	r7, #20
   905f0:	46bd      	mov	sp, r7
   905f2:	bc80      	pop	{r7}
   905f4:	4770      	bx	lr
   905f6:	bf00      	nop

000905f8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   905f8:	b480      	push	{r7}
   905fa:	b085      	sub	sp, #20
   905fc:	af00      	add	r7, sp, #0
   905fe:	6078      	str	r0, [r7, #4]
   90600:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   90602:	683b      	ldr	r3, [r7, #0]
   90604:	681b      	ldr	r3, [r3, #0]
   90606:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   90608:	68bb      	ldr	r3, [r7, #8]
   9060a:	f1b3 3fff 	cmp.w	r3, #4294967295
   9060e:	d103      	bne.n	90618 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   90610:	687b      	ldr	r3, [r7, #4]
   90612:	691b      	ldr	r3, [r3, #16]
   90614:	60fb      	str	r3, [r7, #12]
   90616:	e00c      	b.n	90632 <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   90618:	687b      	ldr	r3, [r7, #4]
   9061a:	3308      	adds	r3, #8
   9061c:	60fb      	str	r3, [r7, #12]
   9061e:	e002      	b.n	90626 <vListInsert+0x2e>
   90620:	68fb      	ldr	r3, [r7, #12]
   90622:	685b      	ldr	r3, [r3, #4]
   90624:	60fb      	str	r3, [r7, #12]
   90626:	68fb      	ldr	r3, [r7, #12]
   90628:	685b      	ldr	r3, [r3, #4]
   9062a:	681a      	ldr	r2, [r3, #0]
   9062c:	68bb      	ldr	r3, [r7, #8]
   9062e:	429a      	cmp	r2, r3
   90630:	d9f6      	bls.n	90620 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   90632:	68fb      	ldr	r3, [r7, #12]
   90634:	685a      	ldr	r2, [r3, #4]
   90636:	683b      	ldr	r3, [r7, #0]
   90638:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   9063a:	683b      	ldr	r3, [r7, #0]
   9063c:	685b      	ldr	r3, [r3, #4]
   9063e:	683a      	ldr	r2, [r7, #0]
   90640:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   90642:	683b      	ldr	r3, [r7, #0]
   90644:	68fa      	ldr	r2, [r7, #12]
   90646:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
   90648:	68fb      	ldr	r3, [r7, #12]
   9064a:	683a      	ldr	r2, [r7, #0]
   9064c:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   9064e:	683b      	ldr	r3, [r7, #0]
   90650:	687a      	ldr	r2, [r7, #4]
   90652:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   90654:	687b      	ldr	r3, [r7, #4]
   90656:	681b      	ldr	r3, [r3, #0]
   90658:	1c5a      	adds	r2, r3, #1
   9065a:	687b      	ldr	r3, [r7, #4]
   9065c:	601a      	str	r2, [r3, #0]
}
   9065e:	bf00      	nop
   90660:	3714      	adds	r7, #20
   90662:	46bd      	mov	sp, r7
   90664:	bc80      	pop	{r7}
   90666:	4770      	bx	lr

00090668 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   90668:	b480      	push	{r7}
   9066a:	b085      	sub	sp, #20
   9066c:	af00      	add	r7, sp, #0
   9066e:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   90670:	687b      	ldr	r3, [r7, #4]
   90672:	691b      	ldr	r3, [r3, #16]
   90674:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   90676:	687b      	ldr	r3, [r7, #4]
   90678:	685b      	ldr	r3, [r3, #4]
   9067a:	687a      	ldr	r2, [r7, #4]
   9067c:	6892      	ldr	r2, [r2, #8]
   9067e:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   90680:	687b      	ldr	r3, [r7, #4]
   90682:	689b      	ldr	r3, [r3, #8]
   90684:	687a      	ldr	r2, [r7, #4]
   90686:	6852      	ldr	r2, [r2, #4]
   90688:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   9068a:	68fb      	ldr	r3, [r7, #12]
   9068c:	685a      	ldr	r2, [r3, #4]
   9068e:	687b      	ldr	r3, [r7, #4]
   90690:	429a      	cmp	r2, r3
   90692:	d103      	bne.n	9069c <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   90694:	687b      	ldr	r3, [r7, #4]
   90696:	689a      	ldr	r2, [r3, #8]
   90698:	68fb      	ldr	r3, [r7, #12]
   9069a:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   9069c:	687b      	ldr	r3, [r7, #4]
   9069e:	2200      	movs	r2, #0
   906a0:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
   906a2:	68fb      	ldr	r3, [r7, #12]
   906a4:	681b      	ldr	r3, [r3, #0]
   906a6:	1e5a      	subs	r2, r3, #1
   906a8:	68fb      	ldr	r3, [r7, #12]
   906aa:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   906ac:	68fb      	ldr	r3, [r7, #12]
   906ae:	681b      	ldr	r3, [r3, #0]
}
   906b0:	4618      	mov	r0, r3
   906b2:	3714      	adds	r7, #20
   906b4:	46bd      	mov	sp, r7
   906b6:	bc80      	pop	{r7}
   906b8:	4770      	bx	lr
   906ba:	bf00      	nop

000906bc <sysTickHook>:
#else  // CORE_TEENSY
// Due
#define vPortSVCHandler svcHook
#define xPortPendSVHandler pendSVHook

int sysTickHook(void) {
   906bc:	b580      	push	{r7, lr}
   906be:	af00      	add	r7, sp, #0
  if (sysTickEnabled) xPortSysTickHandler();
   906c0:	4b04      	ldr	r3, [pc, #16]	; (906d4 <sysTickHook+0x18>)
   906c2:	681b      	ldr	r3, [r3, #0]
   906c4:	2b00      	cmp	r3, #0
   906c6:	d001      	beq.n	906cc <sysTickHook+0x10>
   906c8:	4b03      	ldr	r3, [pc, #12]	; (906d8 <sysTickHook+0x1c>)
   906ca:	4798      	blx	r3
  return 0;
   906cc:	2300      	movs	r3, #0
}
   906ce:	4618      	mov	r0, r3
   906d0:	bd80      	pop	{r7, pc}
   906d2:	bf00      	nop
   906d4:	20071cc8 	.word	0x20071cc8
   906d8:	00090975 	.word	0x00090975

000906dc <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   906dc:	b480      	push	{r7}
   906de:	b085      	sub	sp, #20
   906e0:	af00      	add	r7, sp, #0
   906e2:	60f8      	str	r0, [r7, #12]
   906e4:	60b9      	str	r1, [r7, #8]
   906e6:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
   906e8:	68fb      	ldr	r3, [r7, #12]
   906ea:	3b04      	subs	r3, #4
   906ec:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   906ee:	68fb      	ldr	r3, [r7, #12]
   906f0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   906f4:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   906f6:	68fb      	ldr	r3, [r7, #12]
   906f8:	3b04      	subs	r3, #4
   906fa:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
   906fc:	68ba      	ldr	r2, [r7, #8]
   906fe:	68fb      	ldr	r3, [r7, #12]
   90700:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   90702:	68fb      	ldr	r3, [r7, #12]
   90704:	3b04      	subs	r3, #4
   90706:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   90708:	4a08      	ldr	r2, [pc, #32]	; (9072c <pxPortInitialiseStack+0x50>)
   9070a:	68fb      	ldr	r3, [r7, #12]
   9070c:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   9070e:	68fb      	ldr	r3, [r7, #12]
   90710:	3b14      	subs	r3, #20
   90712:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   90714:	687a      	ldr	r2, [r7, #4]
   90716:	68fb      	ldr	r3, [r7, #12]
   90718:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   9071a:	68fb      	ldr	r3, [r7, #12]
   9071c:	3b20      	subs	r3, #32
   9071e:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
   90720:	68fb      	ldr	r3, [r7, #12]
}
   90722:	4618      	mov	r0, r3
   90724:	3714      	adds	r7, #20
   90726:	46bd      	mov	sp, r7
   90728:	bc80      	pop	{r7}
   9072a:	4770      	bx	lr
   9072c:	00090731 	.word	0x00090731

00090730 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   90730:	b580      	push	{r7, lr}
   90732:	af00      	add	r7, sp, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
   90734:	4b04      	ldr	r3, [pc, #16]	; (90748 <prvTaskExitError+0x18>)
   90736:	681b      	ldr	r3, [r3, #0]
   90738:	f1b3 3fff 	cmp.w	r3, #4294967295
   9073c:	d001      	beq.n	90742 <prvTaskExitError+0x12>
   9073e:	4b03      	ldr	r3, [pc, #12]	; (9074c <prvTaskExitError+0x1c>)
   90740:	4798      	blx	r3
	portDISABLE_INTERRUPTS();
   90742:	4b03      	ldr	r3, [pc, #12]	; (90750 <prvTaskExitError+0x20>)
   90744:	4798      	blx	r3
	for( ;; );
   90746:	e7fe      	b.n	90746 <prvTaskExitError+0x16>
   90748:	20070118 	.word	0x20070118
   9074c:	00082eed 	.word	0x00082eed
   90750:	00090909 	.word	0x00090909

00090754 <svcHook>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
   90754:	b480      	push	{r7}
   90756:	af00      	add	r7, sp, #0
	__asm volatile (
   90758:	4b07      	ldr	r3, [pc, #28]	; (90778 <pxCurrentTCBConst2>)
   9075a:	6819      	ldr	r1, [r3, #0]
   9075c:	6808      	ldr	r0, [r1, #0]
   9075e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   90762:	f380 8809 	msr	PSP, r0
   90766:	f3bf 8f6f 	isb	sy
   9076a:	f04f 0000 	mov.w	r0, #0
   9076e:	f380 8811 	msr	BASEPRI, r0
   90772:	f04e 0e0d 	orr.w	lr, lr, #13
   90776:	4770      	bx	lr

00090778 <pxCurrentTCBConst2>:
   90778:	20071b28 	.word	0x20071b28
					"	bx r14							\n"
					"									\n"
					"	.align 2						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
   9077c:	bf00      	nop
   9077e:	46bd      	mov	sp, r7
   90780:	bc80      	pop	{r7}
   90782:	4770      	bx	lr

00090784 <prvPortStartFirstTask>:
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
   90784:	4806      	ldr	r0, [pc, #24]	; (907a0 <prvPortStartFirstTask+0x1c>)
   90786:	6800      	ldr	r0, [r0, #0]
   90788:	6800      	ldr	r0, [r0, #0]
   9078a:	f380 8808 	msr	MSP, r0
   9078e:	b662      	cpsie	i
   90790:	b661      	cpsie	f
   90792:	f3bf 8f4f 	dsb	sy
   90796:	f3bf 8f6f 	isb	sy
   9079a:	df00      	svc	0
   9079c:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
   9079e:	bf00      	nop
   907a0:	e000ed08 	.word	0xe000ed08

000907a4 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   907a4:	b580      	push	{r7, lr}
   907a6:	b084      	sub	sp, #16
   907a8:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
   907aa:	4b28      	ldr	r3, [pc, #160]	; (9084c <xPortStartScheduler+0xa8>)
   907ac:	60fb      	str	r3, [r7, #12]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
   907ae:	68fb      	ldr	r3, [r7, #12]
   907b0:	781b      	ldrb	r3, [r3, #0]
   907b2:	b2db      	uxtb	r3, r3
   907b4:	60bb      	str	r3, [r7, #8]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
   907b6:	68fb      	ldr	r3, [r7, #12]
   907b8:	22ff      	movs	r2, #255	; 0xff
   907ba:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
   907bc:	68fb      	ldr	r3, [r7, #12]
   907be:	781b      	ldrb	r3, [r3, #0]
   907c0:	b2db      	uxtb	r3, r3
   907c2:	71fb      	strb	r3, [r7, #7]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
   907c4:	79fb      	ldrb	r3, [r7, #7]
   907c6:	b2db      	uxtb	r3, r3
   907c8:	f003 0310 	and.w	r3, r3, #16
   907cc:	b2da      	uxtb	r2, r3
   907ce:	4b20      	ldr	r3, [pc, #128]	; (90850 <xPortStartScheduler+0xac>)
   907d0:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
   907d2:	4b20      	ldr	r3, [pc, #128]	; (90854 <xPortStartScheduler+0xb0>)
   907d4:	2207      	movs	r2, #7
   907d6:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   907d8:	e009      	b.n	907ee <xPortStartScheduler+0x4a>
		{
			ulMaxPRIGROUPValue--;
   907da:	4b1e      	ldr	r3, [pc, #120]	; (90854 <xPortStartScheduler+0xb0>)
   907dc:	681b      	ldr	r3, [r3, #0]
   907de:	3b01      	subs	r3, #1
   907e0:	4a1c      	ldr	r2, [pc, #112]	; (90854 <xPortStartScheduler+0xb0>)
   907e2:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
   907e4:	79fb      	ldrb	r3, [r7, #7]
   907e6:	b2db      	uxtb	r3, r3
   907e8:	005b      	lsls	r3, r3, #1
   907ea:	b2db      	uxtb	r3, r3
   907ec:	71fb      	strb	r3, [r7, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   907ee:	79fb      	ldrb	r3, [r7, #7]
   907f0:	b2db      	uxtb	r3, r3
   907f2:	b25b      	sxtb	r3, r3
   907f4:	2b00      	cmp	r3, #0
   907f6:	dbf0      	blt.n	907da <xPortStartScheduler+0x36>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
   907f8:	4b16      	ldr	r3, [pc, #88]	; (90854 <xPortStartScheduler+0xb0>)
   907fa:	681b      	ldr	r3, [r3, #0]
   907fc:	021b      	lsls	r3, r3, #8
   907fe:	4a15      	ldr	r2, [pc, #84]	; (90854 <xPortStartScheduler+0xb0>)
   90800:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
   90802:	4b14      	ldr	r3, [pc, #80]	; (90854 <xPortStartScheduler+0xb0>)
   90804:	681b      	ldr	r3, [r3, #0]
   90806:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
   9080a:	4a12      	ldr	r2, [pc, #72]	; (90854 <xPortStartScheduler+0xb0>)
   9080c:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
   9080e:	68bb      	ldr	r3, [r7, #8]
   90810:	b2da      	uxtb	r2, r3
   90812:	68fb      	ldr	r3, [r7, #12]
   90814:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   90816:	4a10      	ldr	r2, [pc, #64]	; (90858 <xPortStartScheduler+0xb4>)
   90818:	4b0f      	ldr	r3, [pc, #60]	; (90858 <xPortStartScheduler+0xb4>)
   9081a:	681b      	ldr	r3, [r3, #0]
   9081c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   90820:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   90822:	4a0d      	ldr	r2, [pc, #52]	; (90858 <xPortStartScheduler+0xb4>)
   90824:	4b0c      	ldr	r3, [pc, #48]	; (90858 <xPortStartScheduler+0xb4>)
   90826:	681b      	ldr	r3, [r3, #0]
   90828:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
   9082c:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   9082e:	4b0b      	ldr	r3, [pc, #44]	; (9085c <xPortStartScheduler+0xb8>)
   90830:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   90832:	4b0b      	ldr	r3, [pc, #44]	; (90860 <xPortStartScheduler+0xbc>)
   90834:	2200      	movs	r2, #0
   90836:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   90838:	4b0a      	ldr	r3, [pc, #40]	; (90864 <xPortStartScheduler+0xc0>)
   9083a:	4798      	blx	r3

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
   9083c:	4b0a      	ldr	r3, [pc, #40]	; (90868 <xPortStartScheduler+0xc4>)
   9083e:	4798      	blx	r3

	/* Should not get here! */
	return 0;
   90840:	2300      	movs	r3, #0
}
   90842:	4618      	mov	r0, r3
   90844:	3710      	adds	r7, #16
   90846:	46bd      	mov	sp, r7
   90848:	bd80      	pop	{r7, pc}
   9084a:	bf00      	nop
   9084c:	e000e400 	.word	0xe000e400
   90850:	20071cc0 	.word	0x20071cc0
   90854:	20071cc4 	.word	0x20071cc4
   90858:	e000ed20 	.word	0xe000ed20
   9085c:	000909a9 	.word	0x000909a9
   90860:	20070118 	.word	0x20070118
   90864:	00090785 	.word	0x00090785
   90868:	00090731 	.word	0x00090731

0009086c <vPortYield>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
   9086c:	b480      	push	{r7}
   9086e:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   90870:	4b05      	ldr	r3, [pc, #20]	; (90888 <vPortYield+0x1c>)
   90872:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   90876:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
   90878:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
   9087c:	f3bf 8f6f 	isb	sy
}
   90880:	bf00      	nop
   90882:	46bd      	mov	sp, r7
   90884:	bc80      	pop	{r7}
   90886:	4770      	bx	lr
   90888:	e000ed04 	.word	0xe000ed04

0009088c <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   9088c:	b580      	push	{r7, lr}
   9088e:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
   90890:	4b0b      	ldr	r3, [pc, #44]	; (908c0 <vPortEnterCritical+0x34>)
   90892:	4798      	blx	r3
	uxCriticalNesting++;
   90894:	4b0b      	ldr	r3, [pc, #44]	; (908c4 <vPortEnterCritical+0x38>)
   90896:	681b      	ldr	r3, [r3, #0]
   90898:	3301      	adds	r3, #1
   9089a:	4a0a      	ldr	r2, [pc, #40]	; (908c4 <vPortEnterCritical+0x38>)
   9089c:	6013      	str	r3, [r2, #0]
	__asm volatile( "dsb" );
   9089e:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
   908a2:	f3bf 8f6f 	isb	sy
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API 
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
   908a6:	4b07      	ldr	r3, [pc, #28]	; (908c4 <vPortEnterCritical+0x38>)
   908a8:	681b      	ldr	r3, [r3, #0]
   908aa:	2b01      	cmp	r3, #1
   908ac:	d106      	bne.n	908bc <vPortEnterCritical+0x30>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
   908ae:	4b06      	ldr	r3, [pc, #24]	; (908c8 <vPortEnterCritical+0x3c>)
   908b0:	681b      	ldr	r3, [r3, #0]
   908b2:	b2db      	uxtb	r3, r3
   908b4:	2b00      	cmp	r3, #0
   908b6:	d001      	beq.n	908bc <vPortEnterCritical+0x30>
   908b8:	4b04      	ldr	r3, [pc, #16]	; (908cc <vPortEnterCritical+0x40>)
   908ba:	4798      	blx	r3
	}
}
   908bc:	bf00      	nop
   908be:	bd80      	pop	{r7, pc}
   908c0:	00090909 	.word	0x00090909
   908c4:	20070118 	.word	0x20070118
   908c8:	e000ed04 	.word	0xe000ed04
   908cc:	00082eed 	.word	0x00082eed

000908d0 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   908d0:	b580      	push	{r7, lr}
   908d2:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
   908d4:	4b09      	ldr	r3, [pc, #36]	; (908fc <vPortExitCritical+0x2c>)
   908d6:	681b      	ldr	r3, [r3, #0]
   908d8:	2b00      	cmp	r3, #0
   908da:	d101      	bne.n	908e0 <vPortExitCritical+0x10>
   908dc:	4b08      	ldr	r3, [pc, #32]	; (90900 <vPortExitCritical+0x30>)
   908de:	4798      	blx	r3
	uxCriticalNesting--;
   908e0:	4b06      	ldr	r3, [pc, #24]	; (908fc <vPortExitCritical+0x2c>)
   908e2:	681b      	ldr	r3, [r3, #0]
   908e4:	3b01      	subs	r3, #1
   908e6:	4a05      	ldr	r2, [pc, #20]	; (908fc <vPortExitCritical+0x2c>)
   908e8:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   908ea:	4b04      	ldr	r3, [pc, #16]	; (908fc <vPortExitCritical+0x2c>)
   908ec:	681b      	ldr	r3, [r3, #0]
   908ee:	2b00      	cmp	r3, #0
   908f0:	d102      	bne.n	908f8 <vPortExitCritical+0x28>
	{
		portENABLE_INTERRUPTS();
   908f2:	2000      	movs	r0, #0
   908f4:	4b03      	ldr	r3, [pc, #12]	; (90904 <vPortExitCritical+0x34>)
   908f6:	4798      	blx	r3
	}
}
   908f8:	bf00      	nop
   908fa:	bd80      	pop	{r7, pc}
   908fc:	20070118 	.word	0x20070118
   90900:	00082eed 	.word	0x00082eed
   90904:	0009091d 	.word	0x0009091d

00090908 <ulPortSetInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) uint32_t ulPortSetInterruptMask( void )
{
	__asm volatile														\
   90908:	f3ef 8011 	mrs	r0, BASEPRI
   9090c:	f04f 0110 	mov.w	r1, #16
   90910:	f381 8811 	msr	BASEPRI, r1
   90914:	4770      	bx	lr
		:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "r0", "r1"	\
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
   90916:	2300      	movs	r3, #0
}
   90918:	4618      	mov	r0, r3
   9091a:	bf00      	nop

0009091c <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( uint32_t ulNewMaskValue )
{
	__asm volatile													\
   9091c:	f380 8811 	msr	BASEPRI, r0
   90920:	4770      	bx	lr
		:::"r0"														\
	);

	/* Just to avoid compiler warnings. */
	( void ) ulNewMaskValue;
}
   90922:	bf00      	nop

00090924 <pendSVHook>:
/*-----------------------------------------------------------*/

void xPortPendSVHandler( void )
{
   90924:	b480      	push	{r7}
   90926:	af00      	add	r7, sp, #0
	/* This is a naked function. */

	__asm volatile
   90928:	f3ef 8009 	mrs	r0, PSP
   9092c:	f3bf 8f6f 	isb	sy
   90930:	4b0d      	ldr	r3, [pc, #52]	; (90968 <pxCurrentTCBConst>)
   90932:	681a      	ldr	r2, [r3, #0]
   90934:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   90938:	6010      	str	r0, [r2, #0]
   9093a:	e92d 4008 	stmdb	sp!, {r3, lr}
   9093e:	f04f 0010 	mov.w	r0, #16
   90942:	f380 8811 	msr	BASEPRI, r0
   90946:	f7fd fd79 	bl	8e43c <vTaskSwitchContext>
   9094a:	f04f 0000 	mov.w	r0, #0
   9094e:	f380 8811 	msr	BASEPRI, r0
   90952:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   90956:	6819      	ldr	r1, [r3, #0]
   90958:	6808      	ldr	r0, [r1, #0]
   9095a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   9095e:	f380 8809 	msr	PSP, r0
   90962:	f3bf 8f6f 	isb	sy
   90966:	4770      	bx	lr

00090968 <pxCurrentTCBConst>:
   90968:	20071b28 	.word	0x20071b28
	"										\n"
	"	.align 2							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
   9096c:	bf00      	nop
   9096e:	46bd      	mov	sp, r7
   90970:	bc80      	pop	{r7}
   90972:	4770      	bx	lr

00090974 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   90974:	b580      	push	{r7, lr}
   90976:	af00      	add	r7, sp, #0
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
   90978:	4b07      	ldr	r3, [pc, #28]	; (90998 <xPortSysTickHandler+0x24>)
   9097a:	4798      	blx	r3
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   9097c:	4b07      	ldr	r3, [pc, #28]	; (9099c <xPortSysTickHandler+0x28>)
   9097e:	4798      	blx	r3
   90980:	4603      	mov	r3, r0
   90982:	2b00      	cmp	r3, #0
   90984:	d003      	beq.n	9098e <xPortSysTickHandler+0x1a>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   90986:	4b06      	ldr	r3, [pc, #24]	; (909a0 <xPortSysTickHandler+0x2c>)
   90988:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   9098c:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
   9098e:	2000      	movs	r0, #0
   90990:	4b04      	ldr	r3, [pc, #16]	; (909a4 <xPortSysTickHandler+0x30>)
   90992:	4798      	blx	r3
}
   90994:	bf00      	nop
   90996:	bd80      	pop	{r7, pc}
   90998:	00090909 	.word	0x00090909
   9099c:	0008e2ad 	.word	0x0008e2ad
   909a0:	e000ed04 	.word	0xe000ed04
   909a4:	0009091d 	.word	0x0009091d

000909a8 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
   909a8:	b480      	push	{r7}
   909aa:	af00      	add	r7, sp, #0
  // can't replace weak version in same file
  sysTickEnabled = 1; // WHG for Arduino
   909ac:	4b03      	ldr	r3, [pc, #12]	; (909bc <vPortSetupTimerInterrupt+0x14>)
   909ae:	2201      	movs	r2, #1
   909b0:	601a      	str	r2, [r3, #0]
  return;  // WHG
   909b2:	bf00      	nop
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
}
   909b4:	46bd      	mov	sp, r7
   909b6:	bc80      	pop	{r7}
   909b8:	4770      	bx	lr
   909ba:	bf00      	nop
   909bc:	20071cc8 	.word	0x20071cc8

000909c0 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

void vPortValidateInterruptPriority( void )
{
   909c0:	b480      	push	{r7}
   909c2:	af00      	add	r7, sp, #0
#ifndef CORE_TEENSY
  // Due uses priority zero interrupts do ignore problems.
  return;
   909c4:	bf00      	nop
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
	}
   909c6:	46bd      	mov	sp, r7
   909c8:	bc80      	pop	{r7}
   909ca:	4770      	bx	lr

000909cc <__aeabi_atexit>:
   909cc:	460b      	mov	r3, r1
   909ce:	4601      	mov	r1, r0
   909d0:	4618      	mov	r0, r3
   909d2:	f002 bd53 	b.w	9347c <__cxa_atexit>
   909d6:	bf00      	nop

000909d8 <cos>:
   909d8:	b530      	push	{r4, r5, lr}
   909da:	4a21      	ldr	r2, [pc, #132]	; (90a60 <cos+0x88>)
   909dc:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   909e0:	4293      	cmp	r3, r2
   909e2:	b087      	sub	sp, #28
   909e4:	dd1b      	ble.n	90a1e <cos+0x46>
   909e6:	4a1f      	ldr	r2, [pc, #124]	; (90a64 <cos+0x8c>)
   909e8:	4293      	cmp	r3, r2
   909ea:	dd05      	ble.n	909f8 <cos+0x20>
   909ec:	4602      	mov	r2, r0
   909ee:	460b      	mov	r3, r1
   909f0:	f001 fd10 	bl	92414 <__aeabi_dsub>
   909f4:	b007      	add	sp, #28
   909f6:	bd30      	pop	{r4, r5, pc}
   909f8:	aa02      	add	r2, sp, #8
   909fa:	f000 f9a9 	bl	90d50 <__ieee754_rem_pio2>
   909fe:	f000 0003 	and.w	r0, r0, #3
   90a02:	2801      	cmp	r0, #1
   90a04:	d01a      	beq.n	90a3c <cos+0x64>
   90a06:	2802      	cmp	r0, #2
   90a08:	d00f      	beq.n	90a2a <cos+0x52>
   90a0a:	b308      	cbz	r0, 90a50 <cos+0x78>
   90a0c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   90a10:	2301      	movs	r3, #1
   90a12:	9300      	str	r3, [sp, #0]
   90a14:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   90a18:	f001 f996 	bl	91d48 <__kernel_sin>
   90a1c:	e7ea      	b.n	909f4 <cos+0x1c>
   90a1e:	2200      	movs	r2, #0
   90a20:	2300      	movs	r3, #0
   90a22:	f000 fc71 	bl	91308 <__kernel_cos>
   90a26:	b007      	add	sp, #28
   90a28:	bd30      	pop	{r4, r5, pc}
   90a2a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   90a2e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   90a32:	f000 fc69 	bl	91308 <__kernel_cos>
   90a36:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   90a3a:	e7db      	b.n	909f4 <cos+0x1c>
   90a3c:	9000      	str	r0, [sp, #0]
   90a3e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   90a42:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   90a46:	f001 f97f 	bl	91d48 <__kernel_sin>
   90a4a:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   90a4e:	e7d1      	b.n	909f4 <cos+0x1c>
   90a50:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   90a54:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   90a58:	f000 fc56 	bl	91308 <__kernel_cos>
   90a5c:	e7ca      	b.n	909f4 <cos+0x1c>
   90a5e:	bf00      	nop
   90a60:	3fe921fb 	.word	0x3fe921fb
   90a64:	7fefffff 	.word	0x7fefffff

00090a68 <sin>:
   90a68:	b530      	push	{r4, r5, lr}
   90a6a:	4a21      	ldr	r2, [pc, #132]	; (90af0 <sin+0x88>)
   90a6c:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   90a70:	4293      	cmp	r3, r2
   90a72:	b087      	sub	sp, #28
   90a74:	dd1b      	ble.n	90aae <sin+0x46>
   90a76:	4a1f      	ldr	r2, [pc, #124]	; (90af4 <sin+0x8c>)
   90a78:	4293      	cmp	r3, r2
   90a7a:	dd05      	ble.n	90a88 <sin+0x20>
   90a7c:	4602      	mov	r2, r0
   90a7e:	460b      	mov	r3, r1
   90a80:	f001 fcc8 	bl	92414 <__aeabi_dsub>
   90a84:	b007      	add	sp, #28
   90a86:	bd30      	pop	{r4, r5, pc}
   90a88:	aa02      	add	r2, sp, #8
   90a8a:	f000 f961 	bl	90d50 <__ieee754_rem_pio2>
   90a8e:	f000 0003 	and.w	r0, r0, #3
   90a92:	2801      	cmp	r0, #1
   90a94:	d01e      	beq.n	90ad4 <sin+0x6c>
   90a96:	2802      	cmp	r0, #2
   90a98:	d011      	beq.n	90abe <sin+0x56>
   90a9a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   90a9e:	b300      	cbz	r0, 90ae2 <sin+0x7a>
   90aa0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   90aa4:	f000 fc30 	bl	91308 <__kernel_cos>
   90aa8:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   90aac:	e7ea      	b.n	90a84 <sin+0x1c>
   90aae:	2300      	movs	r3, #0
   90ab0:	9300      	str	r3, [sp, #0]
   90ab2:	2200      	movs	r2, #0
   90ab4:	2300      	movs	r3, #0
   90ab6:	f001 f947 	bl	91d48 <__kernel_sin>
   90aba:	b007      	add	sp, #28
   90abc:	bd30      	pop	{r4, r5, pc}
   90abe:	2301      	movs	r3, #1
   90ac0:	9300      	str	r3, [sp, #0]
   90ac2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   90ac6:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   90aca:	f001 f93d 	bl	91d48 <__kernel_sin>
   90ace:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   90ad2:	e7d7      	b.n	90a84 <sin+0x1c>
   90ad4:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   90ad8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   90adc:	f000 fc14 	bl	91308 <__kernel_cos>
   90ae0:	e7d0      	b.n	90a84 <sin+0x1c>
   90ae2:	2401      	movs	r4, #1
   90ae4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   90ae8:	9400      	str	r4, [sp, #0]
   90aea:	f001 f92d 	bl	91d48 <__kernel_sin>
   90aee:	e7c9      	b.n	90a84 <sin+0x1c>
   90af0:	3fe921fb 	.word	0x3fe921fb
   90af4:	7fefffff 	.word	0x7fefffff

00090af8 <atan2>:
   90af8:	f000 b85e 	b.w	90bb8 <__ieee754_atan2>

00090afc <sqrt>:
   90afc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   90b00:	b08b      	sub	sp, #44	; 0x2c
   90b02:	4604      	mov	r4, r0
   90b04:	460d      	mov	r5, r1
   90b06:	f000 fb39 	bl	9117c <__ieee754_sqrt>
   90b0a:	4b28      	ldr	r3, [pc, #160]	; (90bac <sqrt+0xb0>)
   90b0c:	4606      	mov	r6, r0
   90b0e:	f993 a000 	ldrsb.w	sl, [r3]
   90b12:	460f      	mov	r7, r1
   90b14:	f1ba 3fff 	cmp.w	sl, #4294967295
   90b18:	d012      	beq.n	90b40 <sqrt+0x44>
   90b1a:	4622      	mov	r2, r4
   90b1c:	462b      	mov	r3, r5
   90b1e:	4620      	mov	r0, r4
   90b20:	4629      	mov	r1, r5
   90b22:	f002 f8c5 	bl	92cb0 <__aeabi_dcmpun>
   90b26:	4683      	mov	fp, r0
   90b28:	b950      	cbnz	r0, 90b40 <sqrt+0x44>
   90b2a:	f04f 0800 	mov.w	r8, #0
   90b2e:	f04f 0900 	mov.w	r9, #0
   90b32:	4620      	mov	r0, r4
   90b34:	4629      	mov	r1, r5
   90b36:	4642      	mov	r2, r8
   90b38:	464b      	mov	r3, r9
   90b3a:	f002 f891 	bl	92c60 <__aeabi_dcmplt>
   90b3e:	b920      	cbnz	r0, 90b4a <sqrt+0x4e>
   90b40:	4630      	mov	r0, r6
   90b42:	4639      	mov	r1, r7
   90b44:	b00b      	add	sp, #44	; 0x2c
   90b46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   90b4a:	4a19      	ldr	r2, [pc, #100]	; (90bb0 <sqrt+0xb4>)
   90b4c:	2301      	movs	r3, #1
   90b4e:	f8cd b020 	str.w	fp, [sp, #32]
   90b52:	e9cd 4504 	strd	r4, r5, [sp, #16]
   90b56:	e9cd 4502 	strd	r4, r5, [sp, #8]
   90b5a:	9201      	str	r2, [sp, #4]
   90b5c:	9300      	str	r3, [sp, #0]
   90b5e:	f1ba 0f00 	cmp.w	sl, #0
   90b62:	d015      	beq.n	90b90 <sqrt+0x94>
   90b64:	4642      	mov	r2, r8
   90b66:	464b      	mov	r3, r9
   90b68:	4640      	mov	r0, r8
   90b6a:	4649      	mov	r1, r9
   90b6c:	f001 ff30 	bl	929d0 <__aeabi_ddiv>
   90b70:	f1ba 0f02 	cmp.w	sl, #2
   90b74:	e9cd 0106 	strd	r0, r1, [sp, #24]
   90b78:	d10c      	bne.n	90b94 <sqrt+0x98>
   90b7a:	f002 fc85 	bl	93488 <__errno>
   90b7e:	2321      	movs	r3, #33	; 0x21
   90b80:	6003      	str	r3, [r0, #0]
   90b82:	9b08      	ldr	r3, [sp, #32]
   90b84:	b963      	cbnz	r3, 90ba0 <sqrt+0xa4>
   90b86:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   90b8a:	b00b      	add	sp, #44	; 0x2c
   90b8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   90b90:	e9cd 8906 	strd	r8, r9, [sp, #24]
   90b94:	4668      	mov	r0, sp
   90b96:	f001 fbbb 	bl	92310 <matherr>
   90b9a:	2800      	cmp	r0, #0
   90b9c:	d1f1      	bne.n	90b82 <sqrt+0x86>
   90b9e:	e7ec      	b.n	90b7a <sqrt+0x7e>
   90ba0:	f002 fc72 	bl	93488 <__errno>
   90ba4:	9b08      	ldr	r3, [sp, #32]
   90ba6:	6003      	str	r3, [r0, #0]
   90ba8:	e7ed      	b.n	90b86 <sqrt+0x8a>
   90baa:	bf00      	nop
   90bac:	2007011c 	.word	0x2007011c
   90bb0:	0009af0c 	.word	0x0009af0c
   90bb4:	00000000 	.word	0x00000000

00090bb8 <__ieee754_atan2>:
   90bb8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   90bbc:	4254      	negs	r4, r2
   90bbe:	4314      	orrs	r4, r2
   90bc0:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
   90bc4:	f8df e180 	ldr.w	lr, [pc, #384]	; 90d48 <__ieee754_atan2+0x190>
   90bc8:	ea49 74d4 	orr.w	r4, r9, r4, lsr #31
   90bcc:	4574      	cmp	r4, lr
   90bce:	4606      	mov	r6, r0
   90bd0:	460d      	mov	r5, r1
   90bd2:	d83e      	bhi.n	90c52 <__ieee754_atan2+0x9a>
   90bd4:	4244      	negs	r4, r0
   90bd6:	4304      	orrs	r4, r0
   90bd8:	f021 4b00 	bic.w	fp, r1, #2147483648	; 0x80000000
   90bdc:	ea4b 74d4 	orr.w	r4, fp, r4, lsr #31
   90be0:	4574      	cmp	r4, lr
   90be2:	468a      	mov	sl, r1
   90be4:	d835      	bhi.n	90c52 <__ieee754_atan2+0x9a>
   90be6:	f103 4440 	add.w	r4, r3, #3221225472	; 0xc0000000
   90bea:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
   90bee:	4314      	orrs	r4, r2
   90bf0:	d044      	beq.n	90c7c <__ieee754_atan2+0xc4>
   90bf2:	179c      	asrs	r4, r3, #30
   90bf4:	f004 0402 	and.w	r4, r4, #2
   90bf8:	ea44 74d1 	orr.w	r4, r4, r1, lsr #31
   90bfc:	ea50 010b 	orrs.w	r1, r0, fp
   90c00:	d02f      	beq.n	90c62 <__ieee754_atan2+0xaa>
   90c02:	ea52 0109 	orrs.w	r1, r2, r9
   90c06:	d033      	beq.n	90c70 <__ieee754_atan2+0xb8>
   90c08:	45f1      	cmp	r9, lr
   90c0a:	d046      	beq.n	90c9a <__ieee754_atan2+0xe2>
   90c0c:	45f3      	cmp	fp, lr
   90c0e:	d02f      	beq.n	90c70 <__ieee754_atan2+0xb8>
   90c10:	ebc9 090b 	rsb	r9, r9, fp
   90c14:	ea4f 5929 	mov.w	r9, r9, asr #20
   90c18:	f1b9 0f3c 	cmp.w	r9, #60	; 0x3c
   90c1c:	dc34      	bgt.n	90c88 <__ieee754_atan2+0xd0>
   90c1e:	2b00      	cmp	r3, #0
   90c20:	db57      	blt.n	90cd2 <__ieee754_atan2+0x11a>
   90c22:	4630      	mov	r0, r6
   90c24:	4629      	mov	r1, r5
   90c26:	f001 fed3 	bl	929d0 <__aeabi_ddiv>
   90c2a:	f001 fae3 	bl	921f4 <fabs>
   90c2e:	f001 f943 	bl	91eb8 <atan>
   90c32:	2c01      	cmp	r4, #1
   90c34:	d04a      	beq.n	90ccc <__ieee754_atan2+0x114>
   90c36:	2c02      	cmp	r4, #2
   90c38:	d03b      	beq.n	90cb2 <__ieee754_atan2+0xfa>
   90c3a:	b184      	cbz	r4, 90c5e <__ieee754_atan2+0xa6>
   90c3c:	a332      	add	r3, pc, #200	; (adr r3, 90d08 <__ieee754_atan2+0x150>)
   90c3e:	e9d3 2300 	ldrd	r2, r3, [r3]
   90c42:	f001 fbe7 	bl	92414 <__aeabi_dsub>
   90c46:	a332      	add	r3, pc, #200	; (adr r3, 90d10 <__ieee754_atan2+0x158>)
   90c48:	e9d3 2300 	ldrd	r2, r3, [r3]
   90c4c:	f001 fbe2 	bl	92414 <__aeabi_dsub>
   90c50:	e005      	b.n	90c5e <__ieee754_atan2+0xa6>
   90c52:	4610      	mov	r0, r2
   90c54:	4619      	mov	r1, r3
   90c56:	4632      	mov	r2, r6
   90c58:	462b      	mov	r3, r5
   90c5a:	f001 fbdd 	bl	92418 <__adddf3>
   90c5e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   90c62:	2c02      	cmp	r4, #2
   90c64:	d014      	beq.n	90c90 <__ieee754_atan2+0xd8>
   90c66:	2c03      	cmp	r4, #3
   90c68:	d10c      	bne.n	90c84 <__ieee754_atan2+0xcc>
   90c6a:	482d      	ldr	r0, [pc, #180]	; (90d20 <__ieee754_atan2+0x168>)
   90c6c:	492d      	ldr	r1, [pc, #180]	; (90d24 <__ieee754_atan2+0x16c>)
   90c6e:	e7f6      	b.n	90c5e <__ieee754_atan2+0xa6>
   90c70:	f1ba 0f00 	cmp.w	sl, #0
   90c74:	482a      	ldr	r0, [pc, #168]	; (90d20 <__ieee754_atan2+0x168>)
   90c76:	db0e      	blt.n	90c96 <__ieee754_atan2+0xde>
   90c78:	492b      	ldr	r1, [pc, #172]	; (90d28 <__ieee754_atan2+0x170>)
   90c7a:	e7f0      	b.n	90c5e <__ieee754_atan2+0xa6>
   90c7c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   90c80:	f001 b91a 	b.w	91eb8 <atan>
   90c84:	4629      	mov	r1, r5
   90c86:	e7ea      	b.n	90c5e <__ieee754_atan2+0xa6>
   90c88:	a123      	add	r1, pc, #140	; (adr r1, 90d18 <__ieee754_atan2+0x160>)
   90c8a:	e9d1 0100 	ldrd	r0, r1, [r1]
   90c8e:	e7d0      	b.n	90c32 <__ieee754_atan2+0x7a>
   90c90:	4823      	ldr	r0, [pc, #140]	; (90d20 <__ieee754_atan2+0x168>)
   90c92:	4926      	ldr	r1, [pc, #152]	; (90d2c <__ieee754_atan2+0x174>)
   90c94:	e7e3      	b.n	90c5e <__ieee754_atan2+0xa6>
   90c96:	4926      	ldr	r1, [pc, #152]	; (90d30 <__ieee754_atan2+0x178>)
   90c98:	e7e1      	b.n	90c5e <__ieee754_atan2+0xa6>
   90c9a:	45cb      	cmp	fp, r9
   90c9c:	d01f      	beq.n	90cde <__ieee754_atan2+0x126>
   90c9e:	2c02      	cmp	r4, #2
   90ca0:	d0f6      	beq.n	90c90 <__ieee754_atan2+0xd8>
   90ca2:	2c03      	cmp	r4, #3
   90ca4:	d0e1      	beq.n	90c6a <__ieee754_atan2+0xb2>
   90ca6:	2c01      	cmp	r4, #1
   90ca8:	f04f 0000 	mov.w	r0, #0
   90cac:	d020      	beq.n	90cf0 <__ieee754_atan2+0x138>
   90cae:	4601      	mov	r1, r0
   90cb0:	e7d5      	b.n	90c5e <__ieee754_atan2+0xa6>
   90cb2:	a315      	add	r3, pc, #84	; (adr r3, 90d08 <__ieee754_atan2+0x150>)
   90cb4:	e9d3 2300 	ldrd	r2, r3, [r3]
   90cb8:	f001 fbac 	bl	92414 <__aeabi_dsub>
   90cbc:	4602      	mov	r2, r0
   90cbe:	460b      	mov	r3, r1
   90cc0:	a113      	add	r1, pc, #76	; (adr r1, 90d10 <__ieee754_atan2+0x158>)
   90cc2:	e9d1 0100 	ldrd	r0, r1, [r1]
   90cc6:	f001 fba5 	bl	92414 <__aeabi_dsub>
   90cca:	e7c8      	b.n	90c5e <__ieee754_atan2+0xa6>
   90ccc:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   90cd0:	e7c5      	b.n	90c5e <__ieee754_atan2+0xa6>
   90cd2:	f119 0f3c 	cmn.w	r9, #60	; 0x3c
   90cd6:	daa4      	bge.n	90c22 <__ieee754_atan2+0x6a>
   90cd8:	2000      	movs	r0, #0
   90cda:	2100      	movs	r1, #0
   90cdc:	e7a9      	b.n	90c32 <__ieee754_atan2+0x7a>
   90cde:	2c02      	cmp	r4, #2
   90ce0:	d00e      	beq.n	90d00 <__ieee754_atan2+0x148>
   90ce2:	2c03      	cmp	r4, #3
   90ce4:	d009      	beq.n	90cfa <__ieee754_atan2+0x142>
   90ce6:	2c01      	cmp	r4, #1
   90ce8:	480d      	ldr	r0, [pc, #52]	; (90d20 <__ieee754_atan2+0x168>)
   90cea:	d004      	beq.n	90cf6 <__ieee754_atan2+0x13e>
   90cec:	4911      	ldr	r1, [pc, #68]	; (90d34 <__ieee754_atan2+0x17c>)
   90cee:	e7b6      	b.n	90c5e <__ieee754_atan2+0xa6>
   90cf0:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   90cf4:	e7b3      	b.n	90c5e <__ieee754_atan2+0xa6>
   90cf6:	4910      	ldr	r1, [pc, #64]	; (90d38 <__ieee754_atan2+0x180>)
   90cf8:	e7b1      	b.n	90c5e <__ieee754_atan2+0xa6>
   90cfa:	4810      	ldr	r0, [pc, #64]	; (90d3c <__ieee754_atan2+0x184>)
   90cfc:	4910      	ldr	r1, [pc, #64]	; (90d40 <__ieee754_atan2+0x188>)
   90cfe:	e7ae      	b.n	90c5e <__ieee754_atan2+0xa6>
   90d00:	480e      	ldr	r0, [pc, #56]	; (90d3c <__ieee754_atan2+0x184>)
   90d02:	4910      	ldr	r1, [pc, #64]	; (90d44 <__ieee754_atan2+0x18c>)
   90d04:	e7ab      	b.n	90c5e <__ieee754_atan2+0xa6>
   90d06:	bf00      	nop
   90d08:	33145c07 	.word	0x33145c07
   90d0c:	3ca1a626 	.word	0x3ca1a626
   90d10:	54442d18 	.word	0x54442d18
   90d14:	400921fb 	.word	0x400921fb
   90d18:	54442d18 	.word	0x54442d18
   90d1c:	3ff921fb 	.word	0x3ff921fb
   90d20:	54442d18 	.word	0x54442d18
   90d24:	c00921fb 	.word	0xc00921fb
   90d28:	3ff921fb 	.word	0x3ff921fb
   90d2c:	400921fb 	.word	0x400921fb
   90d30:	bff921fb 	.word	0xbff921fb
   90d34:	3fe921fb 	.word	0x3fe921fb
   90d38:	bfe921fb 	.word	0xbfe921fb
   90d3c:	7f3321d2 	.word	0x7f3321d2
   90d40:	c002d97c 	.word	0xc002d97c
   90d44:	4002d97c 	.word	0x4002d97c
   90d48:	7ff00000 	.word	0x7ff00000
   90d4c:	00000000 	.word	0x00000000

00090d50 <__ieee754_rem_pio2>:
   90d50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   90d54:	4c94      	ldr	r4, [pc, #592]	; (90fa8 <__ieee754_rem_pio2+0x258>)
   90d56:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
   90d5a:	42a7      	cmp	r7, r4
   90d5c:	b08f      	sub	sp, #60	; 0x3c
   90d5e:	f340 8081 	ble.w	90e64 <__ieee754_rem_pio2+0x114>
   90d62:	4614      	mov	r4, r2
   90d64:	4a91      	ldr	r2, [pc, #580]	; (90fac <__ieee754_rem_pio2+0x25c>)
   90d66:	460e      	mov	r6, r1
   90d68:	4297      	cmp	r7, r2
   90d6a:	dc26      	bgt.n	90dba <__ieee754_rem_pio2+0x6a>
   90d6c:	a384      	add	r3, pc, #528	; (adr r3, 90f80 <__ieee754_rem_pio2+0x230>)
   90d6e:	e9d3 2300 	ldrd	r2, r3, [r3]
   90d72:	2900      	cmp	r1, #0
   90d74:	f340 81a0 	ble.w	910b8 <__ieee754_rem_pio2+0x368>
   90d78:	f001 fb4c 	bl	92414 <__aeabi_dsub>
   90d7c:	4b8c      	ldr	r3, [pc, #560]	; (90fb0 <__ieee754_rem_pio2+0x260>)
   90d7e:	4680      	mov	r8, r0
   90d80:	429f      	cmp	r7, r3
   90d82:	4689      	mov	r9, r1
   90d84:	f000 8083 	beq.w	90e8e <__ieee754_rem_pio2+0x13e>
   90d88:	a37f      	add	r3, pc, #508	; (adr r3, 90f88 <__ieee754_rem_pio2+0x238>)
   90d8a:	e9d3 2300 	ldrd	r2, r3, [r3]
   90d8e:	f001 fb41 	bl	92414 <__aeabi_dsub>
   90d92:	4602      	mov	r2, r0
   90d94:	460b      	mov	r3, r1
   90d96:	4640      	mov	r0, r8
   90d98:	e9c4 2300 	strd	r2, r3, [r4]
   90d9c:	4649      	mov	r1, r9
   90d9e:	f001 fb39 	bl	92414 <__aeabi_dsub>
   90da2:	a379      	add	r3, pc, #484	; (adr r3, 90f88 <__ieee754_rem_pio2+0x238>)
   90da4:	e9d3 2300 	ldrd	r2, r3, [r3]
   90da8:	f001 fb34 	bl	92414 <__aeabi_dsub>
   90dac:	2501      	movs	r5, #1
   90dae:	e9c4 0102 	strd	r0, r1, [r4, #8]
   90db2:	4628      	mov	r0, r5
   90db4:	b00f      	add	sp, #60	; 0x3c
   90db6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   90dba:	4a7e      	ldr	r2, [pc, #504]	; (90fb4 <__ieee754_rem_pio2+0x264>)
   90dbc:	4297      	cmp	r7, r2
   90dbe:	f340 8083 	ble.w	90ec8 <__ieee754_rem_pio2+0x178>
   90dc2:	4a7d      	ldr	r2, [pc, #500]	; (90fb8 <__ieee754_rem_pio2+0x268>)
   90dc4:	4297      	cmp	r7, r2
   90dc6:	dc58      	bgt.n	90e7a <__ieee754_rem_pio2+0x12a>
   90dc8:	153d      	asrs	r5, r7, #20
   90dca:	f2a5 4516 	subw	r5, r5, #1046	; 0x416
   90dce:	eba7 5105 	sub.w	r1, r7, r5, lsl #20
   90dd2:	468b      	mov	fp, r1
   90dd4:	4682      	mov	sl, r0
   90dd6:	f001 ff81 	bl	92cdc <__aeabi_d2iz>
   90dda:	f001 fc69 	bl	926b0 <__aeabi_i2d>
   90dde:	4680      	mov	r8, r0
   90de0:	4689      	mov	r9, r1
   90de2:	4642      	mov	r2, r8
   90de4:	464b      	mov	r3, r9
   90de6:	4650      	mov	r0, sl
   90de8:	4659      	mov	r1, fp
   90dea:	e9cd 8908 	strd	r8, r9, [sp, #32]
   90dee:	f001 fb11 	bl	92414 <__aeabi_dsub>
   90df2:	2200      	movs	r2, #0
   90df4:	4b71      	ldr	r3, [pc, #452]	; (90fbc <__ieee754_rem_pio2+0x26c>)
   90df6:	f001 fcc1 	bl	9277c <__aeabi_dmul>
   90dfa:	468b      	mov	fp, r1
   90dfc:	4682      	mov	sl, r0
   90dfe:	f001 ff6d 	bl	92cdc <__aeabi_d2iz>
   90e02:	f001 fc55 	bl	926b0 <__aeabi_i2d>
   90e06:	4680      	mov	r8, r0
   90e08:	4689      	mov	r9, r1
   90e0a:	4642      	mov	r2, r8
   90e0c:	464b      	mov	r3, r9
   90e0e:	4650      	mov	r0, sl
   90e10:	4659      	mov	r1, fp
   90e12:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
   90e16:	f001 fafd 	bl	92414 <__aeabi_dsub>
   90e1a:	2200      	movs	r2, #0
   90e1c:	4b67      	ldr	r3, [pc, #412]	; (90fbc <__ieee754_rem_pio2+0x26c>)
   90e1e:	f001 fcad 	bl	9277c <__aeabi_dmul>
   90e22:	2200      	movs	r2, #0
   90e24:	2300      	movs	r3, #0
   90e26:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   90e2a:	f001 ff0f 	bl	92c4c <__aeabi_dcmpeq>
   90e2e:	2800      	cmp	r0, #0
   90e30:	f000 816a 	beq.w	91108 <__ieee754_rem_pio2+0x3b8>
   90e34:	2300      	movs	r3, #0
   90e36:	4640      	mov	r0, r8
   90e38:	4649      	mov	r1, r9
   90e3a:	2200      	movs	r2, #0
   90e3c:	f001 ff06 	bl	92c4c <__aeabi_dcmpeq>
   90e40:	2800      	cmp	r0, #0
   90e42:	bf14      	ite	ne
   90e44:	2301      	movne	r3, #1
   90e46:	2302      	moveq	r3, #2
   90e48:	485d      	ldr	r0, [pc, #372]	; (90fc0 <__ieee754_rem_pio2+0x270>)
   90e4a:	2102      	movs	r1, #2
   90e4c:	9001      	str	r0, [sp, #4]
   90e4e:	9100      	str	r1, [sp, #0]
   90e50:	462a      	mov	r2, r5
   90e52:	4621      	mov	r1, r4
   90e54:	a808      	add	r0, sp, #32
   90e56:	f000 fb7b 	bl	91550 <__kernel_rem_pio2>
   90e5a:	2e00      	cmp	r6, #0
   90e5c:	f2c0 814a 	blt.w	910f4 <__ieee754_rem_pio2+0x3a4>
   90e60:	4605      	mov	r5, r0
   90e62:	e006      	b.n	90e72 <__ieee754_rem_pio2+0x122>
   90e64:	e9c2 0100 	strd	r0, r1, [r2]
   90e68:	2500      	movs	r5, #0
   90e6a:	2400      	movs	r4, #0
   90e6c:	e9c2 4502 	strd	r4, r5, [r2, #8]
   90e70:	2500      	movs	r5, #0
   90e72:	4628      	mov	r0, r5
   90e74:	b00f      	add	sp, #60	; 0x3c
   90e76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   90e7a:	4602      	mov	r2, r0
   90e7c:	460b      	mov	r3, r1
   90e7e:	f001 fac9 	bl	92414 <__aeabi_dsub>
   90e82:	2500      	movs	r5, #0
   90e84:	e9c4 0102 	strd	r0, r1, [r4, #8]
   90e88:	e9c4 0100 	strd	r0, r1, [r4]
   90e8c:	e7f1      	b.n	90e72 <__ieee754_rem_pio2+0x122>
   90e8e:	a340      	add	r3, pc, #256	; (adr r3, 90f90 <__ieee754_rem_pio2+0x240>)
   90e90:	e9d3 2300 	ldrd	r2, r3, [r3]
   90e94:	f001 fabe 	bl	92414 <__aeabi_dsub>
   90e98:	a33f      	add	r3, pc, #252	; (adr r3, 90f98 <__ieee754_rem_pio2+0x248>)
   90e9a:	e9d3 2300 	ldrd	r2, r3, [r3]
   90e9e:	4606      	mov	r6, r0
   90ea0:	460f      	mov	r7, r1
   90ea2:	f001 fab7 	bl	92414 <__aeabi_dsub>
   90ea6:	4602      	mov	r2, r0
   90ea8:	460b      	mov	r3, r1
   90eaa:	4630      	mov	r0, r6
   90eac:	e9c4 2300 	strd	r2, r3, [r4]
   90eb0:	4639      	mov	r1, r7
   90eb2:	f001 faaf 	bl	92414 <__aeabi_dsub>
   90eb6:	a338      	add	r3, pc, #224	; (adr r3, 90f98 <__ieee754_rem_pio2+0x248>)
   90eb8:	e9d3 2300 	ldrd	r2, r3, [r3]
   90ebc:	f001 faaa 	bl	92414 <__aeabi_dsub>
   90ec0:	2501      	movs	r5, #1
   90ec2:	e9c4 0102 	strd	r0, r1, [r4, #8]
   90ec6:	e7d4      	b.n	90e72 <__ieee754_rem_pio2+0x122>
   90ec8:	f001 f994 	bl	921f4 <fabs>
   90ecc:	a334      	add	r3, pc, #208	; (adr r3, 90fa0 <__ieee754_rem_pio2+0x250>)
   90ece:	e9d3 2300 	ldrd	r2, r3, [r3]
   90ed2:	4680      	mov	r8, r0
   90ed4:	4689      	mov	r9, r1
   90ed6:	f001 fc51 	bl	9277c <__aeabi_dmul>
   90eda:	2200      	movs	r2, #0
   90edc:	4b39      	ldr	r3, [pc, #228]	; (90fc4 <__ieee754_rem_pio2+0x274>)
   90ede:	f001 fa9b 	bl	92418 <__adddf3>
   90ee2:	f001 fefb 	bl	92cdc <__aeabi_d2iz>
   90ee6:	4605      	mov	r5, r0
   90ee8:	f001 fbe2 	bl	926b0 <__aeabi_i2d>
   90eec:	a324      	add	r3, pc, #144	; (adr r3, 90f80 <__ieee754_rem_pio2+0x230>)
   90eee:	e9d3 2300 	ldrd	r2, r3, [r3]
   90ef2:	e9cd 0104 	strd	r0, r1, [sp, #16]
   90ef6:	f001 fc41 	bl	9277c <__aeabi_dmul>
   90efa:	4602      	mov	r2, r0
   90efc:	460b      	mov	r3, r1
   90efe:	4640      	mov	r0, r8
   90f00:	4649      	mov	r1, r9
   90f02:	f001 fa87 	bl	92414 <__aeabi_dsub>
   90f06:	a320      	add	r3, pc, #128	; (adr r3, 90f88 <__ieee754_rem_pio2+0x238>)
   90f08:	e9d3 2300 	ldrd	r2, r3, [r3]
   90f0c:	4682      	mov	sl, r0
   90f0e:	468b      	mov	fp, r1
   90f10:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   90f14:	f001 fc32 	bl	9277c <__aeabi_dmul>
   90f18:	2d1f      	cmp	r5, #31
   90f1a:	e9cd 0102 	strd	r0, r1, [sp, #8]
   90f1e:	dc55      	bgt.n	90fcc <__ieee754_rem_pio2+0x27c>
   90f20:	4b29      	ldr	r3, [pc, #164]	; (90fc8 <__ieee754_rem_pio2+0x278>)
   90f22:	1e6a      	subs	r2, r5, #1
   90f24:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   90f28:	429f      	cmp	r7, r3
   90f2a:	d04f      	beq.n	90fcc <__ieee754_rem_pio2+0x27c>
   90f2c:	4602      	mov	r2, r0
   90f2e:	460b      	mov	r3, r1
   90f30:	4650      	mov	r0, sl
   90f32:	4659      	mov	r1, fp
   90f34:	f001 fa6e 	bl	92414 <__aeabi_dsub>
   90f38:	4602      	mov	r2, r0
   90f3a:	460b      	mov	r3, r1
   90f3c:	4681      	mov	r9, r0
   90f3e:	4688      	mov	r8, r1
   90f40:	e9c4 2300 	strd	r2, r3, [r4]
   90f44:	464a      	mov	r2, r9
   90f46:	4643      	mov	r3, r8
   90f48:	4650      	mov	r0, sl
   90f4a:	4659      	mov	r1, fp
   90f4c:	f001 fa62 	bl	92414 <__aeabi_dsub>
   90f50:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   90f54:	f001 fa5e 	bl	92414 <__aeabi_dsub>
   90f58:	4602      	mov	r2, r0
   90f5a:	460b      	mov	r3, r1
   90f5c:	2e00      	cmp	r6, #0
   90f5e:	e9c4 2302 	strd	r2, r3, [r4, #8]
   90f62:	da86      	bge.n	90e72 <__ieee754_rem_pio2+0x122>
   90f64:	464a      	mov	r2, r9
   90f66:	f108 4300 	add.w	r3, r8, #2147483648	; 0x80000000
   90f6a:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   90f6e:	e884 000c 	stmia.w	r4, {r2, r3}
   90f72:	60e1      	str	r1, [r4, #12]
   90f74:	60a0      	str	r0, [r4, #8]
   90f76:	426d      	negs	r5, r5
   90f78:	e77b      	b.n	90e72 <__ieee754_rem_pio2+0x122>
   90f7a:	bf00      	nop
   90f7c:	f3af 8000 	nop.w
   90f80:	54400000 	.word	0x54400000
   90f84:	3ff921fb 	.word	0x3ff921fb
   90f88:	1a626331 	.word	0x1a626331
   90f8c:	3dd0b461 	.word	0x3dd0b461
   90f90:	1a600000 	.word	0x1a600000
   90f94:	3dd0b461 	.word	0x3dd0b461
   90f98:	2e037073 	.word	0x2e037073
   90f9c:	3ba3198a 	.word	0x3ba3198a
   90fa0:	6dc9c883 	.word	0x6dc9c883
   90fa4:	3fe45f30 	.word	0x3fe45f30
   90fa8:	3fe921fb 	.word	0x3fe921fb
   90fac:	4002d97b 	.word	0x4002d97b
   90fb0:	3ff921fb 	.word	0x3ff921fb
   90fb4:	413921fb 	.word	0x413921fb
   90fb8:	7fefffff 	.word	0x7fefffff
   90fbc:	41700000 	.word	0x41700000
   90fc0:	0009af94 	.word	0x0009af94
   90fc4:	3fe00000 	.word	0x3fe00000
   90fc8:	0009af14 	.word	0x0009af14
   90fcc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   90fd0:	4650      	mov	r0, sl
   90fd2:	4659      	mov	r1, fp
   90fd4:	f001 fa1e 	bl	92414 <__aeabi_dsub>
   90fd8:	153f      	asrs	r7, r7, #20
   90fda:	f3c1 530a 	ubfx	r3, r1, #20, #11
   90fde:	1afb      	subs	r3, r7, r3
   90fe0:	2b10      	cmp	r3, #16
   90fe2:	4681      	mov	r9, r0
   90fe4:	4688      	mov	r8, r1
   90fe6:	e9c4 0100 	strd	r0, r1, [r4]
   90fea:	ddab      	ble.n	90f44 <__ieee754_rem_pio2+0x1f4>
   90fec:	a358      	add	r3, pc, #352	; (adr r3, 91150 <__ieee754_rem_pio2+0x400>)
   90fee:	e9d3 2300 	ldrd	r2, r3, [r3]
   90ff2:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   90ff6:	f001 fbc1 	bl	9277c <__aeabi_dmul>
   90ffa:	4680      	mov	r8, r0
   90ffc:	4689      	mov	r9, r1
   90ffe:	4602      	mov	r2, r0
   91000:	460b      	mov	r3, r1
   91002:	4650      	mov	r0, sl
   91004:	4659      	mov	r1, fp
   91006:	f001 fa05 	bl	92414 <__aeabi_dsub>
   9100a:	e9cd 0106 	strd	r0, r1, [sp, #24]
   9100e:	4602      	mov	r2, r0
   91010:	460b      	mov	r3, r1
   91012:	4650      	mov	r0, sl
   91014:	4659      	mov	r1, fp
   91016:	f001 f9fd 	bl	92414 <__aeabi_dsub>
   9101a:	4642      	mov	r2, r8
   9101c:	464b      	mov	r3, r9
   9101e:	f001 f9f9 	bl	92414 <__aeabi_dsub>
   91022:	a34d      	add	r3, pc, #308	; (adr r3, 91158 <__ieee754_rem_pio2+0x408>)
   91024:	e9d3 2300 	ldrd	r2, r3, [r3]
   91028:	4680      	mov	r8, r0
   9102a:	4689      	mov	r9, r1
   9102c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   91030:	f001 fba4 	bl	9277c <__aeabi_dmul>
   91034:	4642      	mov	r2, r8
   91036:	464b      	mov	r3, r9
   91038:	f001 f9ec 	bl	92414 <__aeabi_dsub>
   9103c:	4602      	mov	r2, r0
   9103e:	460b      	mov	r3, r1
   91040:	e9cd 0102 	strd	r0, r1, [sp, #8]
   91044:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   91048:	f001 f9e4 	bl	92414 <__aeabi_dsub>
   9104c:	460b      	mov	r3, r1
   9104e:	4602      	mov	r2, r0
   91050:	4688      	mov	r8, r1
   91052:	f3c1 510a 	ubfx	r1, r1, #20, #11
   91056:	1a7f      	subs	r7, r7, r1
   91058:	2f31      	cmp	r7, #49	; 0x31
   9105a:	4681      	mov	r9, r0
   9105c:	e9c4 2300 	strd	r2, r3, [r4]
   91060:	dd72      	ble.n	91148 <__ieee754_rem_pio2+0x3f8>
   91062:	a33f      	add	r3, pc, #252	; (adr r3, 91160 <__ieee754_rem_pio2+0x410>)
   91064:	e9d3 2300 	ldrd	r2, r3, [r3]
   91068:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   9106c:	f001 fb86 	bl	9277c <__aeabi_dmul>
   91070:	4680      	mov	r8, r0
   91072:	4689      	mov	r9, r1
   91074:	4602      	mov	r2, r0
   91076:	460b      	mov	r3, r1
   91078:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   9107c:	f001 f9ca 	bl	92414 <__aeabi_dsub>
   91080:	4602      	mov	r2, r0
   91082:	460b      	mov	r3, r1
   91084:	4682      	mov	sl, r0
   91086:	468b      	mov	fp, r1
   91088:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   9108c:	f001 f9c2 	bl	92414 <__aeabi_dsub>
   91090:	4642      	mov	r2, r8
   91092:	464b      	mov	r3, r9
   91094:	f001 f9be 	bl	92414 <__aeabi_dsub>
   91098:	a333      	add	r3, pc, #204	; (adr r3, 91168 <__ieee754_rem_pio2+0x418>)
   9109a:	e9d3 2300 	ldrd	r2, r3, [r3]
   9109e:	4680      	mov	r8, r0
   910a0:	4689      	mov	r9, r1
   910a2:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   910a6:	f001 fb69 	bl	9277c <__aeabi_dmul>
   910aa:	4642      	mov	r2, r8
   910ac:	464b      	mov	r3, r9
   910ae:	f001 f9b1 	bl	92414 <__aeabi_dsub>
   910b2:	e9cd 0102 	strd	r0, r1, [sp, #8]
   910b6:	e739      	b.n	90f2c <__ieee754_rem_pio2+0x1dc>
   910b8:	f001 f9ae 	bl	92418 <__adddf3>
   910bc:	4b2e      	ldr	r3, [pc, #184]	; (91178 <__ieee754_rem_pio2+0x428>)
   910be:	4680      	mov	r8, r0
   910c0:	429f      	cmp	r7, r3
   910c2:	4689      	mov	r9, r1
   910c4:	d022      	beq.n	9110c <__ieee754_rem_pio2+0x3bc>
   910c6:	a32a      	add	r3, pc, #168	; (adr r3, 91170 <__ieee754_rem_pio2+0x420>)
   910c8:	e9d3 2300 	ldrd	r2, r3, [r3]
   910cc:	f001 f9a4 	bl	92418 <__adddf3>
   910d0:	4602      	mov	r2, r0
   910d2:	460b      	mov	r3, r1
   910d4:	4640      	mov	r0, r8
   910d6:	e9c4 2300 	strd	r2, r3, [r4]
   910da:	4649      	mov	r1, r9
   910dc:	f001 f99a 	bl	92414 <__aeabi_dsub>
   910e0:	a323      	add	r3, pc, #140	; (adr r3, 91170 <__ieee754_rem_pio2+0x420>)
   910e2:	e9d3 2300 	ldrd	r2, r3, [r3]
   910e6:	f001 f997 	bl	92418 <__adddf3>
   910ea:	f04f 35ff 	mov.w	r5, #4294967295
   910ee:	e9c4 0102 	strd	r0, r1, [r4, #8]
   910f2:	e6be      	b.n	90e72 <__ieee754_rem_pio2+0x122>
   910f4:	6862      	ldr	r2, [r4, #4]
   910f6:	68e3      	ldr	r3, [r4, #12]
   910f8:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
   910fc:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
   91100:	4245      	negs	r5, r0
   91102:	6062      	str	r2, [r4, #4]
   91104:	60e3      	str	r3, [r4, #12]
   91106:	e6b4      	b.n	90e72 <__ieee754_rem_pio2+0x122>
   91108:	2303      	movs	r3, #3
   9110a:	e69d      	b.n	90e48 <__ieee754_rem_pio2+0xf8>
   9110c:	a310      	add	r3, pc, #64	; (adr r3, 91150 <__ieee754_rem_pio2+0x400>)
   9110e:	e9d3 2300 	ldrd	r2, r3, [r3]
   91112:	f001 f981 	bl	92418 <__adddf3>
   91116:	a310      	add	r3, pc, #64	; (adr r3, 91158 <__ieee754_rem_pio2+0x408>)
   91118:	e9d3 2300 	ldrd	r2, r3, [r3]
   9111c:	4606      	mov	r6, r0
   9111e:	460f      	mov	r7, r1
   91120:	f001 f97a 	bl	92418 <__adddf3>
   91124:	4602      	mov	r2, r0
   91126:	460b      	mov	r3, r1
   91128:	4630      	mov	r0, r6
   9112a:	e9c4 2300 	strd	r2, r3, [r4]
   9112e:	4639      	mov	r1, r7
   91130:	f001 f970 	bl	92414 <__aeabi_dsub>
   91134:	a308      	add	r3, pc, #32	; (adr r3, 91158 <__ieee754_rem_pio2+0x408>)
   91136:	e9d3 2300 	ldrd	r2, r3, [r3]
   9113a:	f001 f96d 	bl	92418 <__adddf3>
   9113e:	f04f 35ff 	mov.w	r5, #4294967295
   91142:	e9c4 0102 	strd	r0, r1, [r4, #8]
   91146:	e694      	b.n	90e72 <__ieee754_rem_pio2+0x122>
   91148:	e9dd ab06 	ldrd	sl, fp, [sp, #24]
   9114c:	e6fa      	b.n	90f44 <__ieee754_rem_pio2+0x1f4>
   9114e:	bf00      	nop
   91150:	1a600000 	.word	0x1a600000
   91154:	3dd0b461 	.word	0x3dd0b461
   91158:	2e037073 	.word	0x2e037073
   9115c:	3ba3198a 	.word	0x3ba3198a
   91160:	2e000000 	.word	0x2e000000
   91164:	3ba3198a 	.word	0x3ba3198a
   91168:	252049c1 	.word	0x252049c1
   9116c:	397b839a 	.word	0x397b839a
   91170:	1a626331 	.word	0x1a626331
   91174:	3dd0b461 	.word	0x3dd0b461
   91178:	3ff921fb 	.word	0x3ff921fb

0009117c <__ieee754_sqrt>:
   9117c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   91180:	4e5f      	ldr	r6, [pc, #380]	; (91300 <__ieee754_sqrt+0x184>)
   91182:	460c      	mov	r4, r1
   91184:	46b6      	mov	lr, r6
   91186:	400e      	ands	r6, r1
   91188:	4576      	cmp	r6, lr
   9118a:	4605      	mov	r5, r0
   9118c:	f000 8098 	beq.w	912c0 <__ieee754_sqrt+0x144>
   91190:	2900      	cmp	r1, #0
   91192:	460b      	mov	r3, r1
   91194:	4602      	mov	r2, r0
   91196:	dd74      	ble.n	91282 <__ieee754_sqrt+0x106>
   91198:	ea5f 5e21 	movs.w	lr, r1, asr #20
   9119c:	d07f      	beq.n	9129e <__ieee754_sqrt+0x122>
   9119e:	f2ae 3eff 	subw	lr, lr, #1023	; 0x3ff
   911a2:	f3c3 0313 	ubfx	r3, r3, #0, #20
   911a6:	f01e 0f01 	tst.w	lr, #1
   911aa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   911ae:	d163      	bne.n	91278 <__ieee754_sqrt+0xfc>
   911b0:	2700      	movs	r7, #0
   911b2:	463e      	mov	r6, r7
   911b4:	eb03 71d2 	add.w	r1, r3, r2, lsr #31
   911b8:	440b      	add	r3, r1
   911ba:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   911be:	0052      	lsls	r2, r2, #1
   911c0:	2016      	movs	r0, #22
   911c2:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
   911c6:	1874      	adds	r4, r6, r1
   911c8:	429c      	cmp	r4, r3
   911ca:	ea4f 75d2 	mov.w	r5, r2, lsr #31
   911ce:	ea4f 0242 	mov.w	r2, r2, lsl #1
   911d2:	dc02      	bgt.n	911da <__ieee754_sqrt+0x5e>
   911d4:	1b1b      	subs	r3, r3, r4
   911d6:	1866      	adds	r6, r4, r1
   911d8:	440f      	add	r7, r1
   911da:	3801      	subs	r0, #1
   911dc:	eb05 0343 	add.w	r3, r5, r3, lsl #1
   911e0:	ea4f 0151 	mov.w	r1, r1, lsr #1
   911e4:	d1ef      	bne.n	911c6 <__ieee754_sqrt+0x4a>
   911e6:	4684      	mov	ip, r0
   911e8:	2420      	movs	r4, #32
   911ea:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   911ee:	e009      	b.n	91204 <__ieee754_sqrt+0x88>
   911f0:	d020      	beq.n	91234 <__ieee754_sqrt+0xb8>
   911f2:	eb03 75d2 	add.w	r5, r3, r2, lsr #31
   911f6:	3c01      	subs	r4, #1
   911f8:	ea4f 0151 	mov.w	r1, r1, lsr #1
   911fc:	442b      	add	r3, r5
   911fe:	ea4f 0242 	mov.w	r2, r2, lsl #1
   91202:	d020      	beq.n	91246 <__ieee754_sqrt+0xca>
   91204:	429e      	cmp	r6, r3
   91206:	eb01 050c 	add.w	r5, r1, ip
   9120a:	daf1      	bge.n	911f0 <__ieee754_sqrt+0x74>
   9120c:	2d00      	cmp	r5, #0
   9120e:	eb05 0c01 	add.w	ip, r5, r1
   91212:	db09      	blt.n	91228 <__ieee754_sqrt+0xac>
   91214:	46b0      	mov	r8, r6
   91216:	4295      	cmp	r5, r2
   91218:	eba3 0306 	sub.w	r3, r3, r6
   9121c:	d900      	bls.n	91220 <__ieee754_sqrt+0xa4>
   9121e:	3b01      	subs	r3, #1
   91220:	4646      	mov	r6, r8
   91222:	1b52      	subs	r2, r2, r5
   91224:	4408      	add	r0, r1
   91226:	e7e4      	b.n	911f2 <__ieee754_sqrt+0x76>
   91228:	f1bc 0f00 	cmp.w	ip, #0
   9122c:	dbf2      	blt.n	91214 <__ieee754_sqrt+0x98>
   9122e:	f106 0801 	add.w	r8, r6, #1
   91232:	e7f0      	b.n	91216 <__ieee754_sqrt+0x9a>
   91234:	4295      	cmp	r5, r2
   91236:	d817      	bhi.n	91268 <__ieee754_sqrt+0xec>
   91238:	2d00      	cmp	r5, #0
   9123a:	eb05 0c01 	add.w	ip, r5, r1
   9123e:	db49      	blt.n	912d4 <__ieee754_sqrt+0x158>
   91240:	4698      	mov	r8, r3
   91242:	2300      	movs	r3, #0
   91244:	e7ec      	b.n	91220 <__ieee754_sqrt+0xa4>
   91246:	4313      	orrs	r3, r2
   91248:	d110      	bne.n	9126c <__ieee754_sqrt+0xf0>
   9124a:	0840      	lsrs	r0, r0, #1
   9124c:	107b      	asrs	r3, r7, #1
   9124e:	f103 537f 	add.w	r3, r3, #1069547520	; 0x3fc00000
   91252:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   91256:	07fa      	lsls	r2, r7, #31
   91258:	eb03 570e 	add.w	r7, r3, lr, lsl #20
   9125c:	4639      	mov	r1, r7
   9125e:	bf48      	it	mi
   91260:	f040 4000 	orrmi.w	r0, r0, #2147483648	; 0x80000000
   91264:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   91268:	4633      	mov	r3, r6
   9126a:	e7c2      	b.n	911f2 <__ieee754_sqrt+0x76>
   9126c:	1c41      	adds	r1, r0, #1
   9126e:	d035      	beq.n	912dc <__ieee754_sqrt+0x160>
   91270:	f000 0301 	and.w	r3, r0, #1
   91274:	4418      	add	r0, r3
   91276:	e7e8      	b.n	9124a <__ieee754_sqrt+0xce>
   91278:	005b      	lsls	r3, r3, #1
   9127a:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
   9127e:	0052      	lsls	r2, r2, #1
   91280:	e796      	b.n	911b0 <__ieee754_sqrt+0x34>
   91282:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
   91286:	4306      	orrs	r6, r0
   91288:	d0ec      	beq.n	91264 <__ieee754_sqrt+0xe8>
   9128a:	bb79      	cbnz	r1, 912ec <__ieee754_sqrt+0x170>
   9128c:	468e      	mov	lr, r1
   9128e:	0ad3      	lsrs	r3, r2, #11
   91290:	f1ae 0e15 	sub.w	lr, lr, #21
   91294:	0552      	lsls	r2, r2, #21
   91296:	2b00      	cmp	r3, #0
   91298:	d0f9      	beq.n	9128e <__ieee754_sqrt+0x112>
   9129a:	02dd      	lsls	r5, r3, #11
   9129c:	d421      	bmi.n	912e2 <__ieee754_sqrt+0x166>
   9129e:	2100      	movs	r1, #0
   912a0:	e000      	b.n	912a4 <__ieee754_sqrt+0x128>
   912a2:	4601      	mov	r1, r0
   912a4:	005b      	lsls	r3, r3, #1
   912a6:	02dc      	lsls	r4, r3, #11
   912a8:	f101 0001 	add.w	r0, r1, #1
   912ac:	d5f9      	bpl.n	912a2 <__ieee754_sqrt+0x126>
   912ae:	f1c0 0420 	rsb	r4, r0, #32
   912b2:	fa22 f404 	lsr.w	r4, r2, r4
   912b6:	4323      	orrs	r3, r4
   912b8:	ebc1 0e0e 	rsb	lr, r1, lr
   912bc:	4082      	lsls	r2, r0
   912be:	e76e      	b.n	9119e <__ieee754_sqrt+0x22>
   912c0:	4602      	mov	r2, r0
   912c2:	460b      	mov	r3, r1
   912c4:	f001 fa5a 	bl	9277c <__aeabi_dmul>
   912c8:	462a      	mov	r2, r5
   912ca:	4623      	mov	r3, r4
   912cc:	f001 f8a4 	bl	92418 <__adddf3>
   912d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   912d4:	f1bc 0f00 	cmp.w	ip, #0
   912d8:	daa9      	bge.n	9122e <__ieee754_sqrt+0xb2>
   912da:	e7b1      	b.n	91240 <__ieee754_sqrt+0xc4>
   912dc:	3701      	adds	r7, #1
   912de:	4620      	mov	r0, r4
   912e0:	e7b4      	b.n	9124c <__ieee754_sqrt+0xd0>
   912e2:	2420      	movs	r4, #32
   912e4:	f04f 31ff 	mov.w	r1, #4294967295
   912e8:	2000      	movs	r0, #0
   912ea:	e7e2      	b.n	912b2 <__ieee754_sqrt+0x136>
   912ec:	4602      	mov	r2, r0
   912ee:	460b      	mov	r3, r1
   912f0:	f001 f890 	bl	92414 <__aeabi_dsub>
   912f4:	4602      	mov	r2, r0
   912f6:	460b      	mov	r3, r1
   912f8:	f001 fb6a 	bl	929d0 <__aeabi_ddiv>
   912fc:	e7b2      	b.n	91264 <__ieee754_sqrt+0xe8>
   912fe:	bf00      	nop
   91300:	7ff00000 	.word	0x7ff00000
   91304:	00000000 	.word	0x00000000

00091308 <__kernel_cos>:
   91308:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   9130c:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
   91310:	f1b6 5f79 	cmp.w	r6, #1044381696	; 0x3e400000
   91314:	b085      	sub	sp, #20
   91316:	460c      	mov	r4, r1
   91318:	4692      	mov	sl, r2
   9131a:	469b      	mov	fp, r3
   9131c:	4605      	mov	r5, r0
   9131e:	da6b      	bge.n	913f8 <__kernel_cos+0xf0>
   91320:	f001 fcdc 	bl	92cdc <__aeabi_d2iz>
   91324:	2800      	cmp	r0, #0
   91326:	f000 80e7 	beq.w	914f8 <__kernel_cos+0x1f0>
   9132a:	462a      	mov	r2, r5
   9132c:	4623      	mov	r3, r4
   9132e:	4628      	mov	r0, r5
   91330:	4621      	mov	r1, r4
   91332:	f001 fa23 	bl	9277c <__aeabi_dmul>
   91336:	a374      	add	r3, pc, #464	; (adr r3, 91508 <__kernel_cos+0x200>)
   91338:	e9d3 2300 	ldrd	r2, r3, [r3]
   9133c:	4680      	mov	r8, r0
   9133e:	4689      	mov	r9, r1
   91340:	f001 fa1c 	bl	9277c <__aeabi_dmul>
   91344:	a372      	add	r3, pc, #456	; (adr r3, 91510 <__kernel_cos+0x208>)
   91346:	e9d3 2300 	ldrd	r2, r3, [r3]
   9134a:	f001 f865 	bl	92418 <__adddf3>
   9134e:	4642      	mov	r2, r8
   91350:	464b      	mov	r3, r9
   91352:	f001 fa13 	bl	9277c <__aeabi_dmul>
   91356:	a370      	add	r3, pc, #448	; (adr r3, 91518 <__kernel_cos+0x210>)
   91358:	e9d3 2300 	ldrd	r2, r3, [r3]
   9135c:	f001 f85a 	bl	92414 <__aeabi_dsub>
   91360:	4642      	mov	r2, r8
   91362:	464b      	mov	r3, r9
   91364:	f001 fa0a 	bl	9277c <__aeabi_dmul>
   91368:	a36d      	add	r3, pc, #436	; (adr r3, 91520 <__kernel_cos+0x218>)
   9136a:	e9d3 2300 	ldrd	r2, r3, [r3]
   9136e:	f001 f853 	bl	92418 <__adddf3>
   91372:	4642      	mov	r2, r8
   91374:	464b      	mov	r3, r9
   91376:	f001 fa01 	bl	9277c <__aeabi_dmul>
   9137a:	a36b      	add	r3, pc, #428	; (adr r3, 91528 <__kernel_cos+0x220>)
   9137c:	e9d3 2300 	ldrd	r2, r3, [r3]
   91380:	f001 f848 	bl	92414 <__aeabi_dsub>
   91384:	4642      	mov	r2, r8
   91386:	464b      	mov	r3, r9
   91388:	f001 f9f8 	bl	9277c <__aeabi_dmul>
   9138c:	a368      	add	r3, pc, #416	; (adr r3, 91530 <__kernel_cos+0x228>)
   9138e:	e9d3 2300 	ldrd	r2, r3, [r3]
   91392:	f001 f841 	bl	92418 <__adddf3>
   91396:	4642      	mov	r2, r8
   91398:	464b      	mov	r3, r9
   9139a:	f001 f9ef 	bl	9277c <__aeabi_dmul>
   9139e:	e9cd 0100 	strd	r0, r1, [sp]
   913a2:	2200      	movs	r2, #0
   913a4:	4b64      	ldr	r3, [pc, #400]	; (91538 <__kernel_cos+0x230>)
   913a6:	4640      	mov	r0, r8
   913a8:	4649      	mov	r1, r9
   913aa:	f001 f9e7 	bl	9277c <__aeabi_dmul>
   913ae:	e9dd 2300 	ldrd	r2, r3, [sp]
   913b2:	4606      	mov	r6, r0
   913b4:	460f      	mov	r7, r1
   913b6:	4640      	mov	r0, r8
   913b8:	4649      	mov	r1, r9
   913ba:	f001 f9df 	bl	9277c <__aeabi_dmul>
   913be:	4652      	mov	r2, sl
   913c0:	4680      	mov	r8, r0
   913c2:	4689      	mov	r9, r1
   913c4:	465b      	mov	r3, fp
   913c6:	4628      	mov	r0, r5
   913c8:	4621      	mov	r1, r4
   913ca:	f001 f9d7 	bl	9277c <__aeabi_dmul>
   913ce:	4602      	mov	r2, r0
   913d0:	460b      	mov	r3, r1
   913d2:	4640      	mov	r0, r8
   913d4:	4649      	mov	r1, r9
   913d6:	f001 f81d 	bl	92414 <__aeabi_dsub>
   913da:	4602      	mov	r2, r0
   913dc:	460b      	mov	r3, r1
   913de:	4630      	mov	r0, r6
   913e0:	4639      	mov	r1, r7
   913e2:	f001 f817 	bl	92414 <__aeabi_dsub>
   913e6:	4602      	mov	r2, r0
   913e8:	460b      	mov	r3, r1
   913ea:	2000      	movs	r0, #0
   913ec:	4953      	ldr	r1, [pc, #332]	; (9153c <__kernel_cos+0x234>)
   913ee:	f001 f811 	bl	92414 <__aeabi_dsub>
   913f2:	b005      	add	sp, #20
   913f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   913f8:	4602      	mov	r2, r0
   913fa:	460b      	mov	r3, r1
   913fc:	f001 f9be 	bl	9277c <__aeabi_dmul>
   91400:	a341      	add	r3, pc, #260	; (adr r3, 91508 <__kernel_cos+0x200>)
   91402:	e9d3 2300 	ldrd	r2, r3, [r3]
   91406:	4680      	mov	r8, r0
   91408:	4689      	mov	r9, r1
   9140a:	f001 f9b7 	bl	9277c <__aeabi_dmul>
   9140e:	a340      	add	r3, pc, #256	; (adr r3, 91510 <__kernel_cos+0x208>)
   91410:	e9d3 2300 	ldrd	r2, r3, [r3]
   91414:	f001 f800 	bl	92418 <__adddf3>
   91418:	4642      	mov	r2, r8
   9141a:	464b      	mov	r3, r9
   9141c:	f001 f9ae 	bl	9277c <__aeabi_dmul>
   91420:	a33d      	add	r3, pc, #244	; (adr r3, 91518 <__kernel_cos+0x210>)
   91422:	e9d3 2300 	ldrd	r2, r3, [r3]
   91426:	f000 fff5 	bl	92414 <__aeabi_dsub>
   9142a:	4642      	mov	r2, r8
   9142c:	464b      	mov	r3, r9
   9142e:	f001 f9a5 	bl	9277c <__aeabi_dmul>
   91432:	a33b      	add	r3, pc, #236	; (adr r3, 91520 <__kernel_cos+0x218>)
   91434:	e9d3 2300 	ldrd	r2, r3, [r3]
   91438:	f000 ffee 	bl	92418 <__adddf3>
   9143c:	4642      	mov	r2, r8
   9143e:	464b      	mov	r3, r9
   91440:	f001 f99c 	bl	9277c <__aeabi_dmul>
   91444:	a338      	add	r3, pc, #224	; (adr r3, 91528 <__kernel_cos+0x220>)
   91446:	e9d3 2300 	ldrd	r2, r3, [r3]
   9144a:	f000 ffe3 	bl	92414 <__aeabi_dsub>
   9144e:	4642      	mov	r2, r8
   91450:	464b      	mov	r3, r9
   91452:	f001 f993 	bl	9277c <__aeabi_dmul>
   91456:	a336      	add	r3, pc, #216	; (adr r3, 91530 <__kernel_cos+0x228>)
   91458:	e9d3 2300 	ldrd	r2, r3, [r3]
   9145c:	f000 ffdc 	bl	92418 <__adddf3>
   91460:	464b      	mov	r3, r9
   91462:	4642      	mov	r2, r8
   91464:	f001 f98a 	bl	9277c <__aeabi_dmul>
   91468:	4b35      	ldr	r3, [pc, #212]	; (91540 <__kernel_cos+0x238>)
   9146a:	e9cd 0100 	strd	r0, r1, [sp]
   9146e:	429e      	cmp	r6, r3
   91470:	dd97      	ble.n	913a2 <__kernel_cos+0x9a>
   91472:	4b34      	ldr	r3, [pc, #208]	; (91544 <__kernel_cos+0x23c>)
   91474:	2200      	movs	r2, #0
   91476:	429e      	cmp	r6, r3
   91478:	dc38      	bgt.n	914ec <__kernel_cos+0x1e4>
   9147a:	f5a6 1300 	sub.w	r3, r6, #2097152	; 0x200000
   9147e:	2000      	movs	r0, #0
   91480:	492e      	ldr	r1, [pc, #184]	; (9153c <__kernel_cos+0x234>)
   91482:	4616      	mov	r6, r2
   91484:	461f      	mov	r7, r3
   91486:	f000 ffc5 	bl	92414 <__aeabi_dsub>
   9148a:	e9cd 0102 	strd	r0, r1, [sp, #8]
   9148e:	2200      	movs	r2, #0
   91490:	4b29      	ldr	r3, [pc, #164]	; (91538 <__kernel_cos+0x230>)
   91492:	4640      	mov	r0, r8
   91494:	4649      	mov	r1, r9
   91496:	f001 f971 	bl	9277c <__aeabi_dmul>
   9149a:	4632      	mov	r2, r6
   9149c:	463b      	mov	r3, r7
   9149e:	f000 ffb9 	bl	92414 <__aeabi_dsub>
   914a2:	e9dd 2300 	ldrd	r2, r3, [sp]
   914a6:	4606      	mov	r6, r0
   914a8:	460f      	mov	r7, r1
   914aa:	4640      	mov	r0, r8
   914ac:	4649      	mov	r1, r9
   914ae:	f001 f965 	bl	9277c <__aeabi_dmul>
   914b2:	4652      	mov	r2, sl
   914b4:	4680      	mov	r8, r0
   914b6:	4689      	mov	r9, r1
   914b8:	465b      	mov	r3, fp
   914ba:	4628      	mov	r0, r5
   914bc:	4621      	mov	r1, r4
   914be:	f001 f95d 	bl	9277c <__aeabi_dmul>
   914c2:	4602      	mov	r2, r0
   914c4:	460b      	mov	r3, r1
   914c6:	4640      	mov	r0, r8
   914c8:	4649      	mov	r1, r9
   914ca:	f000 ffa3 	bl	92414 <__aeabi_dsub>
   914ce:	4602      	mov	r2, r0
   914d0:	460b      	mov	r3, r1
   914d2:	4630      	mov	r0, r6
   914d4:	4639      	mov	r1, r7
   914d6:	f000 ff9d 	bl	92414 <__aeabi_dsub>
   914da:	4602      	mov	r2, r0
   914dc:	460b      	mov	r3, r1
   914de:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   914e2:	f000 ff97 	bl	92414 <__aeabi_dsub>
   914e6:	b005      	add	sp, #20
   914e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   914ec:	4b16      	ldr	r3, [pc, #88]	; (91548 <__kernel_cos+0x240>)
   914ee:	2600      	movs	r6, #0
   914f0:	e9cd 2302 	strd	r2, r3, [sp, #8]
   914f4:	4f15      	ldr	r7, [pc, #84]	; (9154c <__kernel_cos+0x244>)
   914f6:	e7ca      	b.n	9148e <__kernel_cos+0x186>
   914f8:	4910      	ldr	r1, [pc, #64]	; (9153c <__kernel_cos+0x234>)
   914fa:	2000      	movs	r0, #0
   914fc:	b005      	add	sp, #20
   914fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   91502:	bf00      	nop
   91504:	f3af 8000 	nop.w
   91508:	be8838d4 	.word	0xbe8838d4
   9150c:	bda8fae9 	.word	0xbda8fae9
   91510:	bdb4b1c4 	.word	0xbdb4b1c4
   91514:	3e21ee9e 	.word	0x3e21ee9e
   91518:	809c52ad 	.word	0x809c52ad
   9151c:	3e927e4f 	.word	0x3e927e4f
   91520:	19cb1590 	.word	0x19cb1590
   91524:	3efa01a0 	.word	0x3efa01a0
   91528:	16c15177 	.word	0x16c15177
   9152c:	3f56c16c 	.word	0x3f56c16c
   91530:	5555554c 	.word	0x5555554c
   91534:	3fa55555 	.word	0x3fa55555
   91538:	3fe00000 	.word	0x3fe00000
   9153c:	3ff00000 	.word	0x3ff00000
   91540:	3fd33332 	.word	0x3fd33332
   91544:	3fe90000 	.word	0x3fe90000
   91548:	3fe70000 	.word	0x3fe70000
   9154c:	3fd20000 	.word	0x3fd20000

00091550 <__kernel_rem_pio2>:
   91550:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   91554:	4c7a      	ldr	r4, [pc, #488]	; (91740 <__kernel_rem_pio2+0x1f0>)
   91556:	f5ad 7d1d 	sub.w	sp, sp, #628	; 0x274
   9155a:	461f      	mov	r7, r3
   9155c:	930c      	str	r3, [sp, #48]	; 0x30
   9155e:	1ed3      	subs	r3, r2, #3
   91560:	fb84 5403 	smull	r5, r4, r4, r3
   91564:	17db      	asrs	r3, r3, #31
   91566:	ebc3 03a4 	rsb	r3, r3, r4, asr #2
   9156a:	9ea6      	ldr	r6, [sp, #664]	; 0x298
   9156c:	4c75      	ldr	r4, [pc, #468]	; (91744 <__kernel_rem_pio2+0x1f4>)
   9156e:	ea23 75e3 	bic.w	r5, r3, r3, asr #31
   91572:	f854 4026 	ldr.w	r4, [r4, r6, lsl #2]
   91576:	1c6b      	adds	r3, r5, #1
   91578:	4626      	mov	r6, r4
   9157a:	9409      	str	r4, [sp, #36]	; 0x24
   9157c:	eba3 0383 	sub.w	r3, r3, r3, lsl #2
   91580:	1e7c      	subs	r4, r7, #1
   91582:	950d      	str	r5, [sp, #52]	; 0x34
   91584:	9402      	str	r4, [sp, #8]
   91586:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   9158a:	1b2d      	subs	r5, r5, r4
   9158c:	1934      	adds	r4, r6, r4
   9158e:	9004      	str	r0, [sp, #16]
   91590:	910a      	str	r1, [sp, #40]	; 0x28
   91592:	9308      	str	r3, [sp, #32]
   91594:	d416      	bmi.n	915c4 <__kernel_rem_pio2+0x74>
   91596:	442c      	add	r4, r5
   91598:	3401      	adds	r4, #1
   9159a:	ae22      	add	r6, sp, #136	; 0x88
   9159c:	9fa7      	ldr	r7, [sp, #668]	; 0x29c
   9159e:	e008      	b.n	915b2 <__kernel_rem_pio2+0x62>
   915a0:	f857 0025 	ldr.w	r0, [r7, r5, lsl #2]
   915a4:	f001 f884 	bl	926b0 <__aeabi_i2d>
   915a8:	3501      	adds	r5, #1
   915aa:	42a5      	cmp	r5, r4
   915ac:	e9e6 0102 	strd	r0, r1, [r6, #8]!
   915b0:	d008      	beq.n	915c4 <__kernel_rem_pio2+0x74>
   915b2:	2d00      	cmp	r5, #0
   915b4:	daf4      	bge.n	915a0 <__kernel_rem_pio2+0x50>
   915b6:	3501      	adds	r5, #1
   915b8:	2000      	movs	r0, #0
   915ba:	2100      	movs	r1, #0
   915bc:	42a5      	cmp	r5, r4
   915be:	e9e6 0102 	strd	r0, r1, [r6, #8]!
   915c2:	d1f6      	bne.n	915b2 <__kernel_rem_pio2+0x62>
   915c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
   915c6:	2b00      	cmp	r3, #0
   915c8:	db31      	blt.n	9162e <__kernel_rem_pio2+0xde>
   915ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
   915cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   915ce:	a974      	add	r1, sp, #464	; 0x1d0
   915d0:	eb01 0bc2 	add.w	fp, r1, r2, lsl #3
   915d4:	ebc3 7343 	rsb	r3, r3, r3, lsl #29
   915d8:	9a02      	ldr	r2, [sp, #8]
   915da:	a924      	add	r1, sp, #144	; 0x90
   915dc:	00db      	lsls	r3, r3, #3
   915de:	eb01 09c2 	add.w	r9, r1, r2, lsl #3
   915e2:	9301      	str	r3, [sp, #4]
   915e4:	f50d 7ae4 	add.w	sl, sp, #456	; 0x1c8
   915e8:	9b02      	ldr	r3, [sp, #8]
   915ea:	2b00      	cmp	r3, #0
   915ec:	f2c0 8190 	blt.w	91910 <__kernel_rem_pio2+0x3c0>
   915f0:	464c      	mov	r4, r9
   915f2:	9b04      	ldr	r3, [sp, #16]
   915f4:	2600      	movs	r6, #0
   915f6:	f1a3 0508 	sub.w	r5, r3, #8
   915fa:	9b01      	ldr	r3, [sp, #4]
   915fc:	2700      	movs	r7, #0
   915fe:	eb09 0803 	add.w	r8, r9, r3
   91602:	e9f5 2302 	ldrd	r2, r3, [r5, #8]!
   91606:	e874 0102 	ldrd	r0, r1, [r4], #-8
   9160a:	f001 f8b7 	bl	9277c <__aeabi_dmul>
   9160e:	4602      	mov	r2, r0
   91610:	460b      	mov	r3, r1
   91612:	4630      	mov	r0, r6
   91614:	4639      	mov	r1, r7
   91616:	f000 feff 	bl	92418 <__adddf3>
   9161a:	4544      	cmp	r4, r8
   9161c:	4606      	mov	r6, r0
   9161e:	460f      	mov	r7, r1
   91620:	d1ef      	bne.n	91602 <__kernel_rem_pio2+0xb2>
   91622:	e9ea 6702 	strd	r6, r7, [sl, #8]!
   91626:	45da      	cmp	sl, fp
   91628:	f109 0908 	add.w	r9, r9, #8
   9162c:	d1dc      	bne.n	915e8 <__kernel_rem_pio2+0x98>
   9162e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   91630:	a910      	add	r1, sp, #64	; 0x40
   91632:	461d      	mov	r5, r3
   91634:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   91638:	3b02      	subs	r3, #2
   9163a:	009b      	lsls	r3, r3, #2
   9163c:	1d1a      	adds	r2, r3, #4
   9163e:	440a      	add	r2, r1
   91640:	440b      	add	r3, r1
   91642:	920f      	str	r2, [sp, #60]	; 0x3c
   91644:	930e      	str	r3, [sp, #56]	; 0x38
   91646:	ab9c      	add	r3, sp, #624	; 0x270
   91648:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
   9164c:	2d00      	cmp	r5, #0
   9164e:	e953 6728 	ldrd	r6, r7, [r3, #-160]	; 0xa0
   91652:	dd2b      	ble.n	916ac <__kernel_rem_pio2+0x15c>
   91654:	ab9c      	add	r3, sp, #624	; 0x270
   91656:	eb03 04c5 	add.w	r4, r3, r5, lsl #3
   9165a:	3ca8      	subs	r4, #168	; 0xa8
   9165c:	f10d 0a3c 	add.w	sl, sp, #60	; 0x3c
   91660:	f50d 7be4 	add.w	fp, sp, #456	; 0x1c8
   91664:	2200      	movs	r2, #0
   91666:	4b38      	ldr	r3, [pc, #224]	; (91748 <__kernel_rem_pio2+0x1f8>)
   91668:	4630      	mov	r0, r6
   9166a:	4639      	mov	r1, r7
   9166c:	f001 f886 	bl	9277c <__aeabi_dmul>
   91670:	f001 fb34 	bl	92cdc <__aeabi_d2iz>
   91674:	f001 f81c 	bl	926b0 <__aeabi_i2d>
   91678:	2200      	movs	r2, #0
   9167a:	4b34      	ldr	r3, [pc, #208]	; (9174c <__kernel_rem_pio2+0x1fc>)
   9167c:	4680      	mov	r8, r0
   9167e:	4689      	mov	r9, r1
   91680:	f001 f87c 	bl	9277c <__aeabi_dmul>
   91684:	4602      	mov	r2, r0
   91686:	460b      	mov	r3, r1
   91688:	4630      	mov	r0, r6
   9168a:	4639      	mov	r1, r7
   9168c:	f000 fec2 	bl	92414 <__aeabi_dsub>
   91690:	f001 fb24 	bl	92cdc <__aeabi_d2iz>
   91694:	e874 2302 	ldrd	r2, r3, [r4], #-8
   91698:	f84a 0f04 	str.w	r0, [sl, #4]!
   9169c:	4649      	mov	r1, r9
   9169e:	4640      	mov	r0, r8
   916a0:	f000 feba 	bl	92418 <__adddf3>
   916a4:	455c      	cmp	r4, fp
   916a6:	4606      	mov	r6, r0
   916a8:	460f      	mov	r7, r1
   916aa:	d1db      	bne.n	91664 <__kernel_rem_pio2+0x114>
   916ac:	9c08      	ldr	r4, [sp, #32]
   916ae:	4630      	mov	r0, r6
   916b0:	4639      	mov	r1, r7
   916b2:	4622      	mov	r2, r4
   916b4:	f000 fe30 	bl	92318 <scalbn>
   916b8:	2200      	movs	r2, #0
   916ba:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
   916be:	4606      	mov	r6, r0
   916c0:	460f      	mov	r7, r1
   916c2:	f001 f85b 	bl	9277c <__aeabi_dmul>
   916c6:	f000 fd9b 	bl	92200 <floor>
   916ca:	2200      	movs	r2, #0
   916cc:	4b20      	ldr	r3, [pc, #128]	; (91750 <__kernel_rem_pio2+0x200>)
   916ce:	f001 f855 	bl	9277c <__aeabi_dmul>
   916d2:	4602      	mov	r2, r0
   916d4:	460b      	mov	r3, r1
   916d6:	4630      	mov	r0, r6
   916d8:	4639      	mov	r1, r7
   916da:	f000 fe9b 	bl	92414 <__aeabi_dsub>
   916de:	460f      	mov	r7, r1
   916e0:	4606      	mov	r6, r0
   916e2:	f001 fafb 	bl	92cdc <__aeabi_d2iz>
   916e6:	4681      	mov	r9, r0
   916e8:	f000 ffe2 	bl	926b0 <__aeabi_i2d>
   916ec:	4602      	mov	r2, r0
   916ee:	460b      	mov	r3, r1
   916f0:	4630      	mov	r0, r6
   916f2:	4639      	mov	r1, r7
   916f4:	f000 fe8e 	bl	92414 <__aeabi_dsub>
   916f8:	2c00      	cmp	r4, #0
   916fa:	4606      	mov	r6, r0
   916fc:	460f      	mov	r7, r1
   916fe:	f340 80ee 	ble.w	918de <__kernel_rem_pio2+0x38e>
   91702:	1e68      	subs	r0, r5, #1
   91704:	ab10      	add	r3, sp, #64	; 0x40
   91706:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   9170a:	f1c4 0218 	rsb	r2, r4, #24
   9170e:	fa43 f102 	asr.w	r1, r3, r2
   91712:	fa01 f202 	lsl.w	r2, r1, r2
   91716:	1a9b      	subs	r3, r3, r2
   91718:	f1c4 0817 	rsb	r8, r4, #23
   9171c:	aa10      	add	r2, sp, #64	; 0x40
   9171e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
   91722:	4489      	add	r9, r1
   91724:	fa43 f808 	asr.w	r8, r3, r8
   91728:	f1b8 0f00 	cmp.w	r8, #0
   9172c:	dd3d      	ble.n	917aa <__kernel_rem_pio2+0x25a>
   9172e:	2d00      	cmp	r5, #0
   91730:	f109 0901 	add.w	r9, r9, #1
   91734:	f340 82d5 	ble.w	91ce2 <__kernel_rem_pio2+0x792>
   91738:	2200      	movs	r2, #0
   9173a:	4614      	mov	r4, r2
   9173c:	a90f      	add	r1, sp, #60	; 0x3c
   9173e:	e011      	b.n	91764 <__kernel_rem_pio2+0x214>
   91740:	2aaaaaab 	.word	0x2aaaaaab
   91744:	0009b09c 	.word	0x0009b09c
   91748:	3e700000 	.word	0x3e700000
   9174c:	41700000 	.word	0x41700000
   91750:	40200000 	.word	0x40200000
   91754:	f1c3 7080 	rsb	r0, r3, #16777216	; 0x1000000
   91758:	b10b      	cbz	r3, 9175e <__kernel_rem_pio2+0x20e>
   9175a:	6008      	str	r0, [r1, #0]
   9175c:	2401      	movs	r4, #1
   9175e:	3201      	adds	r2, #1
   91760:	4295      	cmp	r5, r2
   91762:	dd0d      	ble.n	91780 <__kernel_rem_pio2+0x230>
   91764:	f851 3f04 	ldr.w	r3, [r1, #4]!
   91768:	2c00      	cmp	r4, #0
   9176a:	d0f3      	beq.n	91754 <__kernel_rem_pio2+0x204>
   9176c:	f1c3 13ff 	rsb	r3, r3, #16711935	; 0xff00ff
   91770:	3201      	adds	r2, #1
   91772:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
   91776:	4295      	cmp	r5, r2
   91778:	600b      	str	r3, [r1, #0]
   9177a:	f04f 0401 	mov.w	r4, #1
   9177e:	dcf1      	bgt.n	91764 <__kernel_rem_pio2+0x214>
   91780:	9b08      	ldr	r3, [sp, #32]
   91782:	2b00      	cmp	r3, #0
   91784:	dd0d      	ble.n	917a2 <__kernel_rem_pio2+0x252>
   91786:	2b01      	cmp	r3, #1
   91788:	f000 80b1 	beq.w	918ee <__kernel_rem_pio2+0x39e>
   9178c:	2b02      	cmp	r3, #2
   9178e:	d108      	bne.n	917a2 <__kernel_rem_pio2+0x252>
   91790:	1e6a      	subs	r2, r5, #1
   91792:	ab10      	add	r3, sp, #64	; 0x40
   91794:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   91798:	a910      	add	r1, sp, #64	; 0x40
   9179a:	f3c3 0315 	ubfx	r3, r3, #0, #22
   9179e:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
   917a2:	f1b8 0f02 	cmp.w	r8, #2
   917a6:	f000 8081 	beq.w	918ac <__kernel_rem_pio2+0x35c>
   917aa:	2200      	movs	r2, #0
   917ac:	2300      	movs	r3, #0
   917ae:	4630      	mov	r0, r6
   917b0:	4639      	mov	r1, r7
   917b2:	f001 fa4b 	bl	92c4c <__aeabi_dcmpeq>
   917b6:	2800      	cmp	r0, #0
   917b8:	f000 825d 	beq.w	91c76 <__kernel_rem_pio2+0x726>
   917bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   917be:	f105 3bff 	add.w	fp, r5, #4294967295
   917c2:	455b      	cmp	r3, fp
   917c4:	dc10      	bgt.n	917e8 <__kernel_rem_pio2+0x298>
   917c6:	f105 4380 	add.w	r3, r5, #1073741824	; 0x40000000
   917ca:	aa10      	add	r2, sp, #64	; 0x40
   917cc:	3b01      	subs	r3, #1
   917ce:	980f      	ldr	r0, [sp, #60]	; 0x3c
   917d0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   917d4:	2200      	movs	r2, #0
   917d6:	f853 1904 	ldr.w	r1, [r3], #-4
   917da:	4283      	cmp	r3, r0
   917dc:	ea42 0201 	orr.w	r2, r2, r1
   917e0:	d1f9      	bne.n	917d6 <__kernel_rem_pio2+0x286>
   917e2:	2a00      	cmp	r2, #0
   917e4:	f040 80b1 	bne.w	9194a <__kernel_rem_pio2+0x3fa>
   917e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   917ea:	aa10      	add	r2, sp, #64	; 0x40
   917ec:	3b01      	subs	r3, #1
   917ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   917f2:	2b00      	cmp	r3, #0
   917f4:	f040 8273 	bne.w	91cde <__kernel_rem_pio2+0x78e>
   917f8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   917fa:	2301      	movs	r3, #1
   917fc:	f852 1904 	ldr.w	r1, [r2], #-4
   91800:	3301      	adds	r3, #1
   91802:	2900      	cmp	r1, #0
   91804:	d0fa      	beq.n	917fc <__kernel_rem_pio2+0x2ac>
   91806:	18e9      	adds	r1, r5, r3
   91808:	1c6a      	adds	r2, r5, #1
   9180a:	428a      	cmp	r2, r1
   9180c:	910b      	str	r1, [sp, #44]	; 0x2c
   9180e:	dc4b      	bgt.n	918a8 <__kernel_rem_pio2+0x358>
   91810:	990d      	ldr	r1, [sp, #52]	; 0x34
   91812:	980c      	ldr	r0, [sp, #48]	; 0x30
   91814:	1851      	adds	r1, r2, r1
   91816:	00db      	lsls	r3, r3, #3
   91818:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   9181c:	9305      	str	r3, [sp, #20]
   9181e:	9ba7      	ldr	r3, [sp, #668]	; 0x29c
   91820:	4405      	add	r5, r0
   91822:	3901      	subs	r1, #1
   91824:	00e8      	lsls	r0, r5, #3
   91826:	eb03 0a81 	add.w	sl, r3, r1, lsl #2
   9182a:	ab24      	add	r3, sp, #144	; 0x90
   9182c:	00d2      	lsls	r2, r2, #3
   9182e:	eb03 0b00 	add.w	fp, r3, r0
   91832:	ab74      	add	r3, sp, #464	; 0x1d0
   91834:	4413      	add	r3, r2
   91836:	9301      	str	r3, [sp, #4]
   91838:	f1a2 0308 	sub.w	r3, r2, #8
   9183c:	9006      	str	r0, [sp, #24]
   9183e:	9307      	str	r3, [sp, #28]
   91840:	f04f 0900 	mov.w	r9, #0
   91844:	f85a 0f04 	ldr.w	r0, [sl, #4]!
   91848:	f000 ff32 	bl	926b0 <__aeabi_i2d>
   9184c:	9b02      	ldr	r3, [sp, #8]
   9184e:	e8eb 0102 	strd	r0, r1, [fp], #8
   91852:	2b00      	cmp	r3, #0
   91854:	f04f 0600 	mov.w	r6, #0
   91858:	f04f 0700 	mov.w	r7, #0
   9185c:	db1b      	blt.n	91896 <__kernel_rem_pio2+0x346>
   9185e:	9b06      	ldr	r3, [sp, #24]
   91860:	eb03 0409 	add.w	r4, r3, r9
   91864:	9b07      	ldr	r3, [sp, #28]
   91866:	eb09 0803 	add.w	r8, r9, r3
   9186a:	ab24      	add	r3, sp, #144	; 0x90
   9186c:	441c      	add	r4, r3
   9186e:	4498      	add	r8, r3
   91870:	9b04      	ldr	r3, [sp, #16]
   91872:	f1a3 0508 	sub.w	r5, r3, #8
   91876:	e9f5 2302 	ldrd	r2, r3, [r5, #8]!
   9187a:	e874 0102 	ldrd	r0, r1, [r4], #-8
   9187e:	f000 ff7d 	bl	9277c <__aeabi_dmul>
   91882:	4602      	mov	r2, r0
   91884:	460b      	mov	r3, r1
   91886:	4630      	mov	r0, r6
   91888:	4639      	mov	r1, r7
   9188a:	f000 fdc5 	bl	92418 <__adddf3>
   9188e:	4544      	cmp	r4, r8
   91890:	4606      	mov	r6, r0
   91892:	460f      	mov	r7, r1
   91894:	d1ef      	bne.n	91876 <__kernel_rem_pio2+0x326>
   91896:	9b01      	ldr	r3, [sp, #4]
   91898:	f109 0908 	add.w	r9, r9, #8
   9189c:	e8e3 6702 	strd	r6, r7, [r3], #8
   918a0:	9301      	str	r3, [sp, #4]
   918a2:	9b05      	ldr	r3, [sp, #20]
   918a4:	4599      	cmp	r9, r3
   918a6:	d1cd      	bne.n	91844 <__kernel_rem_pio2+0x2f4>
   918a8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   918aa:	e6cc      	b.n	91646 <__kernel_rem_pio2+0xf6>
   918ac:	4632      	mov	r2, r6
   918ae:	463b      	mov	r3, r7
   918b0:	2000      	movs	r0, #0
   918b2:	49b1      	ldr	r1, [pc, #708]	; (91b78 <__kernel_rem_pio2+0x628>)
   918b4:	f000 fdae 	bl	92414 <__aeabi_dsub>
   918b8:	4606      	mov	r6, r0
   918ba:	460f      	mov	r7, r1
   918bc:	2c00      	cmp	r4, #0
   918be:	f43f af74 	beq.w	917aa <__kernel_rem_pio2+0x25a>
   918c2:	9a08      	ldr	r2, [sp, #32]
   918c4:	2000      	movs	r0, #0
   918c6:	49ac      	ldr	r1, [pc, #688]	; (91b78 <__kernel_rem_pio2+0x628>)
   918c8:	f000 fd26 	bl	92318 <scalbn>
   918cc:	4602      	mov	r2, r0
   918ce:	460b      	mov	r3, r1
   918d0:	4630      	mov	r0, r6
   918d2:	4639      	mov	r1, r7
   918d4:	f000 fd9e 	bl	92414 <__aeabi_dsub>
   918d8:	4606      	mov	r6, r0
   918da:	460f      	mov	r7, r1
   918dc:	e765      	b.n	917aa <__kernel_rem_pio2+0x25a>
   918de:	d110      	bne.n	91902 <__kernel_rem_pio2+0x3b2>
   918e0:	1e6b      	subs	r3, r5, #1
   918e2:	aa10      	add	r2, sp, #64	; 0x40
   918e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   918e8:	ea4f 58e3 	mov.w	r8, r3, asr #23
   918ec:	e71c      	b.n	91728 <__kernel_rem_pio2+0x1d8>
   918ee:	1e6a      	subs	r2, r5, #1
   918f0:	ab10      	add	r3, sp, #64	; 0x40
   918f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   918f6:	a910      	add	r1, sp, #64	; 0x40
   918f8:	f3c3 0316 	ubfx	r3, r3, #0, #23
   918fc:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
   91900:	e74f      	b.n	917a2 <__kernel_rem_pio2+0x252>
   91902:	2200      	movs	r2, #0
   91904:	4b9d      	ldr	r3, [pc, #628]	; (91b7c <__kernel_rem_pio2+0x62c>)
   91906:	f001 f9bf 	bl	92c88 <__aeabi_dcmpge>
   9190a:	b958      	cbnz	r0, 91924 <__kernel_rem_pio2+0x3d4>
   9190c:	4680      	mov	r8, r0
   9190e:	e74c      	b.n	917aa <__kernel_rem_pio2+0x25a>
   91910:	2600      	movs	r6, #0
   91912:	2700      	movs	r7, #0
   91914:	e9ea 6702 	strd	r6, r7, [sl, #8]!
   91918:	45da      	cmp	sl, fp
   9191a:	f109 0908 	add.w	r9, r9, #8
   9191e:	f47f ae63 	bne.w	915e8 <__kernel_rem_pio2+0x98>
   91922:	e684      	b.n	9162e <__kernel_rem_pio2+0xde>
   91924:	2d00      	cmp	r5, #0
   91926:	f109 0901 	add.w	r9, r9, #1
   9192a:	bfc8      	it	gt
   9192c:	f04f 0802 	movgt.w	r8, #2
   91930:	f73f af02 	bgt.w	91738 <__kernel_rem_pio2+0x1e8>
   91934:	4632      	mov	r2, r6
   91936:	463b      	mov	r3, r7
   91938:	2000      	movs	r0, #0
   9193a:	498f      	ldr	r1, [pc, #572]	; (91b78 <__kernel_rem_pio2+0x628>)
   9193c:	f000 fd6a 	bl	92414 <__aeabi_dsub>
   91940:	f04f 0802 	mov.w	r8, #2
   91944:	4606      	mov	r6, r0
   91946:	460f      	mov	r7, r1
   91948:	e72f      	b.n	917aa <__kernel_rem_pio2+0x25a>
   9194a:	9a08      	ldr	r2, [sp, #32]
   9194c:	ab10      	add	r3, sp, #64	; 0x40
   9194e:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
   91952:	3a18      	subs	r2, #24
   91954:	f8cd 9014 	str.w	r9, [sp, #20]
   91958:	f8cd 8004 	str.w	r8, [sp, #4]
   9195c:	9208      	str	r2, [sp, #32]
   9195e:	b96b      	cbnz	r3, 9197c <__kernel_rem_pio2+0x42c>
   91960:	f10b 4380 	add.w	r3, fp, #1073741824	; 0x40000000
   91964:	3b01      	subs	r3, #1
   91966:	a910      	add	r1, sp, #64	; 0x40
   91968:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   9196c:	f853 1904 	ldr.w	r1, [r3], #-4
   91970:	f10b 3bff 	add.w	fp, fp, #4294967295
   91974:	3a18      	subs	r2, #24
   91976:	2900      	cmp	r1, #0
   91978:	d0f8      	beq.n	9196c <__kernel_rem_pio2+0x41c>
   9197a:	9208      	str	r2, [sp, #32]
   9197c:	9a08      	ldr	r2, [sp, #32]
   9197e:	2000      	movs	r0, #0
   91980:	497d      	ldr	r1, [pc, #500]	; (91b78 <__kernel_rem_pio2+0x628>)
   91982:	f000 fcc9 	bl	92318 <scalbn>
   91986:	f1bb 0f00 	cmp.w	fp, #0
   9198a:	4604      	mov	r4, r0
   9198c:	460d      	mov	r5, r1
   9198e:	f2c0 81b8 	blt.w	91d02 <__kernel_rem_pio2+0x7b2>
   91992:	ea4f 03cb 	mov.w	r3, fp, lsl #3
   91996:	f50d 78e8 	add.w	r8, sp, #464	; 0x1d0
   9199a:	aa10      	add	r2, sp, #64	; 0x40
   9199c:	eb02 068b 	add.w	r6, r2, fp, lsl #2
   919a0:	eb08 0903 	add.w	r9, r8, r3
   919a4:	9304      	str	r3, [sp, #16]
   919a6:	3604      	adds	r6, #4
   919a8:	f109 0708 	add.w	r7, r9, #8
   919ac:	f856 0d04 	ldr.w	r0, [r6, #-4]!
   919b0:	f000 fe7e 	bl	926b0 <__aeabi_i2d>
   919b4:	4622      	mov	r2, r4
   919b6:	462b      	mov	r3, r5
   919b8:	f000 fee0 	bl	9277c <__aeabi_dmul>
   919bc:	2200      	movs	r2, #0
   919be:	e967 0102 	strd	r0, r1, [r7, #-8]!
   919c2:	4b6f      	ldr	r3, [pc, #444]	; (91b80 <__kernel_rem_pio2+0x630>)
   919c4:	4620      	mov	r0, r4
   919c6:	4629      	mov	r1, r5
   919c8:	f000 fed8 	bl	9277c <__aeabi_dmul>
   919cc:	45b8      	cmp	r8, r7
   919ce:	4604      	mov	r4, r0
   919d0:	460d      	mov	r5, r1
   919d2:	d1eb      	bne.n	919ac <__kernel_rem_pio2+0x45c>
   919d4:	464b      	mov	r3, r9
   919d6:	f8cd b018 	str.w	fp, [sp, #24]
   919da:	469b      	mov	fp, r3
   919dc:	f50d 7a98 	add.w	sl, sp, #304	; 0x130
   919e0:	f8cd a008 	str.w	sl, [sp, #8]
   919e4:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
   919e8:	f04f 0900 	mov.w	r9, #0
   919ec:	f1ba 0f00 	cmp.w	sl, #0
   919f0:	f2c0 8128 	blt.w	91c44 <__kernel_rem_pio2+0x6f4>
   919f4:	a35e      	add	r3, pc, #376	; (adr r3, 91b70 <__kernel_rem_pio2+0x620>)
   919f6:	e9d3 2300 	ldrd	r2, r3, [r3]
   919fa:	f8df 8188 	ldr.w	r8, [pc, #392]	; 91b84 <__kernel_rem_pio2+0x634>
   919fe:	465d      	mov	r5, fp
   91a00:	2600      	movs	r6, #0
   91a02:	2700      	movs	r7, #0
   91a04:	2400      	movs	r4, #0
   91a06:	e003      	b.n	91a10 <__kernel_rem_pio2+0x4c0>
   91a08:	45a1      	cmp	r9, r4
   91a0a:	db10      	blt.n	91a2e <__kernel_rem_pio2+0x4de>
   91a0c:	e9f8 2302 	ldrd	r2, r3, [r8, #8]!
   91a10:	e8f5 0102 	ldrd	r0, r1, [r5], #8
   91a14:	f000 feb2 	bl	9277c <__aeabi_dmul>
   91a18:	4602      	mov	r2, r0
   91a1a:	460b      	mov	r3, r1
   91a1c:	4630      	mov	r0, r6
   91a1e:	4639      	mov	r1, r7
   91a20:	f000 fcfa 	bl	92418 <__adddf3>
   91a24:	3401      	adds	r4, #1
   91a26:	45a2      	cmp	sl, r4
   91a28:	4606      	mov	r6, r0
   91a2a:	460f      	mov	r7, r1
   91a2c:	daec      	bge.n	91a08 <__kernel_rem_pio2+0x4b8>
   91a2e:	9b02      	ldr	r3, [sp, #8]
   91a30:	f1ab 0b08 	sub.w	fp, fp, #8
   91a34:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
   91a38:	e9c3 6700 	strd	r6, r7, [r3]
   91a3c:	ab72      	add	r3, sp, #456	; 0x1c8
   91a3e:	455b      	cmp	r3, fp
   91a40:	f109 0901 	add.w	r9, r9, #1
   91a44:	d1d2      	bne.n	919ec <__kernel_rem_pio2+0x49c>
   91a46:	9ba6      	ldr	r3, [sp, #664]	; 0x298
   91a48:	f8dd b018 	ldr.w	fp, [sp, #24]
   91a4c:	f8dd a008 	ldr.w	sl, [sp, #8]
   91a50:	2b03      	cmp	r3, #3
   91a52:	f200 8083 	bhi.w	91b5c <__kernel_rem_pio2+0x60c>
   91a56:	e8df f013 	tbh	[pc, r3, lsl #1]
   91a5a:	00d3      	.short	0x00d3
   91a5c:	00970097 	.word	0x00970097
   91a60:	0004      	.short	0x0004
   91a62:	f1bb 0f00 	cmp.w	fp, #0
   91a66:	f340 8156 	ble.w	91d16 <__kernel_rem_pio2+0x7c6>
   91a6a:	9b04      	ldr	r3, [sp, #16]
   91a6c:	f8cd b008 	str.w	fp, [sp, #8]
   91a70:	4453      	add	r3, sl
   91a72:	4698      	mov	r8, r3
   91a74:	e9d3 6700 	ldrd	r6, r7, [r3]
   91a78:	46d3      	mov	fp, sl
   91a7a:	e958 9a02 	ldrd	r9, sl, [r8, #-8]
   91a7e:	4632      	mov	r2, r6
   91a80:	463b      	mov	r3, r7
   91a82:	4648      	mov	r0, r9
   91a84:	4651      	mov	r1, sl
   91a86:	f000 fcc7 	bl	92418 <__adddf3>
   91a8a:	4604      	mov	r4, r0
   91a8c:	460d      	mov	r5, r1
   91a8e:	4602      	mov	r2, r0
   91a90:	460b      	mov	r3, r1
   91a92:	4648      	mov	r0, r9
   91a94:	4651      	mov	r1, sl
   91a96:	f000 fcbd 	bl	92414 <__aeabi_dsub>
   91a9a:	4632      	mov	r2, r6
   91a9c:	463b      	mov	r3, r7
   91a9e:	f000 fcbb 	bl	92418 <__adddf3>
   91aa2:	e9c8 0100 	strd	r0, r1, [r8]
   91aa6:	e968 4502 	strd	r4, r5, [r8, #-8]!
   91aaa:	45c3      	cmp	fp, r8
   91aac:	4626      	mov	r6, r4
   91aae:	462f      	mov	r7, r5
   91ab0:	d1e3      	bne.n	91a7a <__kernel_rem_pio2+0x52a>
   91ab2:	46da      	mov	sl, fp
   91ab4:	f8dd b008 	ldr.w	fp, [sp, #8]
   91ab8:	f1bb 0f01 	cmp.w	fp, #1
   91abc:	f340 812b 	ble.w	91d16 <__kernel_rem_pio2+0x7c6>
   91ac0:	9b04      	ldr	r3, [sp, #16]
   91ac2:	f50d 7b9c 	add.w	fp, sp, #312	; 0x138
   91ac6:	4453      	add	r3, sl
   91ac8:	4698      	mov	r8, r3
   91aca:	e9d3 6700 	ldrd	r6, r7, [r3]
   91ace:	4699      	mov	r9, r3
   91ad0:	e959 3402 	ldrd	r3, r4, [r9, #-8]
   91ad4:	4630      	mov	r0, r6
   91ad6:	e9cd 3402 	strd	r3, r4, [sp, #8]
   91ada:	461a      	mov	r2, r3
   91adc:	4639      	mov	r1, r7
   91ade:	4623      	mov	r3, r4
   91ae0:	f000 fc9a 	bl	92418 <__adddf3>
   91ae4:	4604      	mov	r4, r0
   91ae6:	460d      	mov	r5, r1
   91ae8:	4602      	mov	r2, r0
   91aea:	460b      	mov	r3, r1
   91aec:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   91af0:	f000 fc90 	bl	92414 <__aeabi_dsub>
   91af4:	4632      	mov	r2, r6
   91af6:	463b      	mov	r3, r7
   91af8:	f000 fc8e 	bl	92418 <__adddf3>
   91afc:	e9c9 0100 	strd	r0, r1, [r9]
   91b00:	e969 4502 	strd	r4, r5, [r9, #-8]!
   91b04:	45cb      	cmp	fp, r9
   91b06:	4626      	mov	r6, r4
   91b08:	462f      	mov	r7, r5
   91b0a:	d1e1      	bne.n	91ad0 <__kernel_rem_pio2+0x580>
   91b0c:	2300      	movs	r3, #0
   91b0e:	461d      	mov	r5, r3
   91b10:	f108 0808 	add.w	r8, r8, #8
   91b14:	ac50      	add	r4, sp, #320	; 0x140
   91b16:	4618      	mov	r0, r3
   91b18:	e978 2302 	ldrd	r2, r3, [r8, #-8]!
   91b1c:	4629      	mov	r1, r5
   91b1e:	f000 fc7b 	bl	92418 <__adddf3>
   91b22:	4544      	cmp	r4, r8
   91b24:	4603      	mov	r3, r0
   91b26:	460d      	mov	r5, r1
   91b28:	d1f5      	bne.n	91b16 <__kernel_rem_pio2+0x5c6>
   91b2a:	9a01      	ldr	r2, [sp, #4]
   91b2c:	2a00      	cmp	r2, #0
   91b2e:	f000 80da 	beq.w	91ce6 <__kernel_rem_pio2+0x796>
   91b32:	f8da 4004 	ldr.w	r4, [sl, #4]
   91b36:	f8da 200c 	ldr.w	r2, [sl, #12]
   91b3a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   91b3c:	f8da 1000 	ldr.w	r1, [sl]
   91b40:	f8da 0008 	ldr.w	r0, [sl, #8]
   91b44:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
   91b48:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
   91b4c:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
   91b50:	617d      	str	r5, [r7, #20]
   91b52:	613b      	str	r3, [r7, #16]
   91b54:	607c      	str	r4, [r7, #4]
   91b56:	60fa      	str	r2, [r7, #12]
   91b58:	6039      	str	r1, [r7, #0]
   91b5a:	60b8      	str	r0, [r7, #8]
   91b5c:	9b05      	ldr	r3, [sp, #20]
   91b5e:	f003 0007 	and.w	r0, r3, #7
   91b62:	f50d 7d1d 	add.w	sp, sp, #628	; 0x274
   91b66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   91b6a:	bf00      	nop
   91b6c:	f3af 8000 	nop.w
   91b70:	40000000 	.word	0x40000000
   91b74:	3ff921fb 	.word	0x3ff921fb
   91b78:	3ff00000 	.word	0x3ff00000
   91b7c:	3fe00000 	.word	0x3fe00000
   91b80:	3e700000 	.word	0x3e700000
   91b84:	0009b0b0 	.word	0x0009b0b0
   91b88:	2400      	movs	r4, #0
   91b8a:	4621      	mov	r1, r4
   91b8c:	9d04      	ldr	r5, [sp, #16]
   91b8e:	3508      	adds	r5, #8
   91b90:	4455      	add	r5, sl
   91b92:	e975 2302 	ldrd	r2, r3, [r5, #-8]!
   91b96:	4620      	mov	r0, r4
   91b98:	f000 fc3e 	bl	92418 <__adddf3>
   91b9c:	4555      	cmp	r5, sl
   91b9e:	4604      	mov	r4, r0
   91ba0:	d1f7      	bne.n	91b92 <__kernel_rem_pio2+0x642>
   91ba2:	9b01      	ldr	r3, [sp, #4]
   91ba4:	2b00      	cmp	r3, #0
   91ba6:	d050      	beq.n	91c4a <__kernel_rem_pio2+0x6fa>
   91ba8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   91baa:	f101 4500 	add.w	r5, r1, #2147483648	; 0x80000000
   91bae:	460b      	mov	r3, r1
   91bb0:	e9da 0100 	ldrd	r0, r1, [sl]
   91bb4:	e887 0030 	stmia.w	r7, {r4, r5}
   91bb8:	4622      	mov	r2, r4
   91bba:	f000 fc2b 	bl	92414 <__aeabi_dsub>
   91bbe:	f1bb 0f00 	cmp.w	fp, #0
   91bc2:	4603      	mov	r3, r0
   91bc4:	460d      	mov	r5, r1
   91bc6:	dd0d      	ble.n	91be4 <__kernel_rem_pio2+0x694>
   91bc8:	2401      	movs	r4, #1
   91bca:	4618      	mov	r0, r3
   91bcc:	e9fa 2302 	ldrd	r2, r3, [sl, #8]!
   91bd0:	4629      	mov	r1, r5
   91bd2:	f000 fc21 	bl	92418 <__adddf3>
   91bd6:	3401      	adds	r4, #1
   91bd8:	45a3      	cmp	fp, r4
   91bda:	4603      	mov	r3, r0
   91bdc:	460d      	mov	r5, r1
   91bde:	daf4      	bge.n	91bca <__kernel_rem_pio2+0x67a>
   91be0:	9a01      	ldr	r2, [sp, #4]
   91be2:	b10a      	cbz	r2, 91be8 <__kernel_rem_pio2+0x698>
   91be4:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
   91be8:	4618      	mov	r0, r3
   91bea:	4629      	mov	r1, r5
   91bec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   91bee:	e9c3 0102 	strd	r0, r1, [r3, #8]
   91bf2:	9b05      	ldr	r3, [sp, #20]
   91bf4:	f003 0007 	and.w	r0, r3, #7
   91bf8:	f50d 7d1d 	add.w	sp, sp, #628	; 0x274
   91bfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   91c00:	2300      	movs	r3, #0
   91c02:	461c      	mov	r4, r3
   91c04:	9a04      	ldr	r2, [sp, #16]
   91c06:	3208      	adds	r2, #8
   91c08:	4492      	add	sl, r2
   91c0a:	4618      	mov	r0, r3
   91c0c:	e97a 2302 	ldrd	r2, r3, [sl, #-8]!
   91c10:	4621      	mov	r1, r4
   91c12:	f000 fc01 	bl	92418 <__adddf3>
   91c16:	f10b 3bff 	add.w	fp, fp, #4294967295
   91c1a:	f1bb 3fff 	cmp.w	fp, #4294967295
   91c1e:	4603      	mov	r3, r0
   91c20:	460c      	mov	r4, r1
   91c22:	d1f2      	bne.n	91c0a <__kernel_rem_pio2+0x6ba>
   91c24:	9a01      	ldr	r2, [sp, #4]
   91c26:	b10a      	cbz	r2, 91c2c <__kernel_rem_pio2+0x6dc>
   91c28:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
   91c2c:	4618      	mov	r0, r3
   91c2e:	4621      	mov	r1, r4
   91c30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   91c32:	e9c3 0100 	strd	r0, r1, [r3]
   91c36:	9b05      	ldr	r3, [sp, #20]
   91c38:	f003 0007 	and.w	r0, r3, #7
   91c3c:	f50d 7d1d 	add.w	sp, sp, #628	; 0x274
   91c40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   91c44:	2600      	movs	r6, #0
   91c46:	2700      	movs	r7, #0
   91c48:	e6f1      	b.n	91a2e <__kernel_rem_pio2+0x4de>
   91c4a:	4626      	mov	r6, r4
   91c4c:	460f      	mov	r7, r1
   91c4e:	4622      	mov	r2, r4
   91c50:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   91c52:	460b      	mov	r3, r1
   91c54:	e9da 0100 	ldrd	r0, r1, [sl]
   91c58:	e9c4 6700 	strd	r6, r7, [r4]
   91c5c:	f000 fbda 	bl	92414 <__aeabi_dsub>
   91c60:	f1bb 0f00 	cmp.w	fp, #0
   91c64:	4603      	mov	r3, r0
   91c66:	460d      	mov	r5, r1
   91c68:	dcae      	bgt.n	91bc8 <__kernel_rem_pio2+0x678>
   91c6a:	4618      	mov	r0, r3
   91c6c:	4629      	mov	r1, r5
   91c6e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   91c70:	e9c3 0102 	strd	r0, r1, [r3, #8]
   91c74:	e7bd      	b.n	91bf2 <__kernel_rem_pio2+0x6a2>
   91c76:	9b08      	ldr	r3, [sp, #32]
   91c78:	4630      	mov	r0, r6
   91c7a:	425a      	negs	r2, r3
   91c7c:	4639      	mov	r1, r7
   91c7e:	f8cd 9014 	str.w	r9, [sp, #20]
   91c82:	f8cd 8004 	str.w	r8, [sp, #4]
   91c86:	f000 fb47 	bl	92318 <scalbn>
   91c8a:	2200      	movs	r2, #0
   91c8c:	4b2c      	ldr	r3, [pc, #176]	; (91d40 <__kernel_rem_pio2+0x7f0>)
   91c8e:	4606      	mov	r6, r0
   91c90:	460f      	mov	r7, r1
   91c92:	f000 fff9 	bl	92c88 <__aeabi_dcmpge>
   91c96:	2800      	cmp	r0, #0
   91c98:	d040      	beq.n	91d1c <__kernel_rem_pio2+0x7cc>
   91c9a:	2200      	movs	r2, #0
   91c9c:	4b29      	ldr	r3, [pc, #164]	; (91d44 <__kernel_rem_pio2+0x7f4>)
   91c9e:	4630      	mov	r0, r6
   91ca0:	4639      	mov	r1, r7
   91ca2:	f000 fd6b 	bl	9277c <__aeabi_dmul>
   91ca6:	f001 f819 	bl	92cdc <__aeabi_d2iz>
   91caa:	4604      	mov	r4, r0
   91cac:	f000 fd00 	bl	926b0 <__aeabi_i2d>
   91cb0:	2200      	movs	r2, #0
   91cb2:	4b23      	ldr	r3, [pc, #140]	; (91d40 <__kernel_rem_pio2+0x7f0>)
   91cb4:	f000 fd62 	bl	9277c <__aeabi_dmul>
   91cb8:	460b      	mov	r3, r1
   91cba:	4602      	mov	r2, r0
   91cbc:	4639      	mov	r1, r7
   91cbe:	4630      	mov	r0, r6
   91cc0:	f000 fba8 	bl	92414 <__aeabi_dsub>
   91cc4:	f001 f80a 	bl	92cdc <__aeabi_d2iz>
   91cc8:	9b08      	ldr	r3, [sp, #32]
   91cca:	f105 0b01 	add.w	fp, r5, #1
   91cce:	3318      	adds	r3, #24
   91cd0:	9308      	str	r3, [sp, #32]
   91cd2:	ab10      	add	r3, sp, #64	; 0x40
   91cd4:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
   91cd8:	f843 402b 	str.w	r4, [r3, fp, lsl #2]
   91cdc:	e64e      	b.n	9197c <__kernel_rem_pio2+0x42c>
   91cde:	2301      	movs	r3, #1
   91ce0:	e591      	b.n	91806 <__kernel_rem_pio2+0x2b6>
   91ce2:	2400      	movs	r4, #0
   91ce4:	e54c      	b.n	91780 <__kernel_rem_pio2+0x230>
   91ce6:	4618      	mov	r0, r3
   91ce8:	e9da 6700 	ldrd	r6, r7, [sl]
   91cec:	e9da 2302 	ldrd	r2, r3, [sl, #8]
   91cf0:	4629      	mov	r1, r5
   91cf2:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   91cf4:	e9c5 6700 	strd	r6, r7, [r5]
   91cf8:	e9c5 0104 	strd	r0, r1, [r5, #16]
   91cfc:	e9c5 2302 	strd	r2, r3, [r5, #8]
   91d00:	e72c      	b.n	91b5c <__kernel_rem_pio2+0x60c>
   91d02:	9ba6      	ldr	r3, [sp, #664]	; 0x298
   91d04:	2b03      	cmp	r3, #3
   91d06:	f63f af29 	bhi.w	91b5c <__kernel_rem_pio2+0x60c>
   91d0a:	e8df f003 	tbb	[pc, r3]
   91d0e:	1015      	.short	0x1015
   91d10:	0210      	.short	0x0210
   91d12:	f50d 7a98 	add.w	sl, sp, #304	; 0x130
   91d16:	2300      	movs	r3, #0
   91d18:	461d      	mov	r5, r3
   91d1a:	e706      	b.n	91b2a <__kernel_rem_pio2+0x5da>
   91d1c:	4630      	mov	r0, r6
   91d1e:	4639      	mov	r1, r7
   91d20:	f000 ffdc 	bl	92cdc <__aeabi_d2iz>
   91d24:	ab10      	add	r3, sp, #64	; 0x40
   91d26:	46ab      	mov	fp, r5
   91d28:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
   91d2c:	e626      	b.n	9197c <__kernel_rem_pio2+0x42c>
   91d2e:	2400      	movs	r4, #0
   91d30:	4621      	mov	r1, r4
   91d32:	f50d 7a98 	add.w	sl, sp, #304	; 0x130
   91d36:	e734      	b.n	91ba2 <__kernel_rem_pio2+0x652>
   91d38:	2300      	movs	r3, #0
   91d3a:	461c      	mov	r4, r3
   91d3c:	e772      	b.n	91c24 <__kernel_rem_pio2+0x6d4>
   91d3e:	bf00      	nop
   91d40:	41700000 	.word	0x41700000
   91d44:	3e700000 	.word	0x3e700000

00091d48 <__kernel_sin>:
   91d48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   91d4c:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
   91d50:	f1b6 5f79 	cmp.w	r6, #1044381696	; 0x3e400000
   91d54:	b085      	sub	sp, #20
   91d56:	460c      	mov	r4, r1
   91d58:	4690      	mov	r8, r2
   91d5a:	4699      	mov	r9, r3
   91d5c:	4605      	mov	r5, r0
   91d5e:	da04      	bge.n	91d6a <__kernel_sin+0x22>
   91d60:	f000 ffbc 	bl	92cdc <__aeabi_d2iz>
   91d64:	2800      	cmp	r0, #0
   91d66:	f000 8085 	beq.w	91e74 <__kernel_sin+0x12c>
   91d6a:	462a      	mov	r2, r5
   91d6c:	4623      	mov	r3, r4
   91d6e:	4628      	mov	r0, r5
   91d70:	4621      	mov	r1, r4
   91d72:	f000 fd03 	bl	9277c <__aeabi_dmul>
   91d76:	4606      	mov	r6, r0
   91d78:	460f      	mov	r7, r1
   91d7a:	4602      	mov	r2, r0
   91d7c:	460b      	mov	r3, r1
   91d7e:	4628      	mov	r0, r5
   91d80:	4621      	mov	r1, r4
   91d82:	f000 fcfb 	bl	9277c <__aeabi_dmul>
   91d86:	a33e      	add	r3, pc, #248	; (adr r3, 91e80 <__kernel_sin+0x138>)
   91d88:	e9d3 2300 	ldrd	r2, r3, [r3]
   91d8c:	4682      	mov	sl, r0
   91d8e:	468b      	mov	fp, r1
   91d90:	4630      	mov	r0, r6
   91d92:	4639      	mov	r1, r7
   91d94:	f000 fcf2 	bl	9277c <__aeabi_dmul>
   91d98:	a33b      	add	r3, pc, #236	; (adr r3, 91e88 <__kernel_sin+0x140>)
   91d9a:	e9d3 2300 	ldrd	r2, r3, [r3]
   91d9e:	f000 fb39 	bl	92414 <__aeabi_dsub>
   91da2:	4632      	mov	r2, r6
   91da4:	463b      	mov	r3, r7
   91da6:	f000 fce9 	bl	9277c <__aeabi_dmul>
   91daa:	a339      	add	r3, pc, #228	; (adr r3, 91e90 <__kernel_sin+0x148>)
   91dac:	e9d3 2300 	ldrd	r2, r3, [r3]
   91db0:	f000 fb32 	bl	92418 <__adddf3>
   91db4:	4632      	mov	r2, r6
   91db6:	463b      	mov	r3, r7
   91db8:	f000 fce0 	bl	9277c <__aeabi_dmul>
   91dbc:	a336      	add	r3, pc, #216	; (adr r3, 91e98 <__kernel_sin+0x150>)
   91dbe:	e9d3 2300 	ldrd	r2, r3, [r3]
   91dc2:	f000 fb27 	bl	92414 <__aeabi_dsub>
   91dc6:	4632      	mov	r2, r6
   91dc8:	463b      	mov	r3, r7
   91dca:	f000 fcd7 	bl	9277c <__aeabi_dmul>
   91dce:	a334      	add	r3, pc, #208	; (adr r3, 91ea0 <__kernel_sin+0x158>)
   91dd0:	e9d3 2300 	ldrd	r2, r3, [r3]
   91dd4:	f000 fb20 	bl	92418 <__adddf3>
   91dd8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   91dda:	e9cd 0100 	strd	r0, r1, [sp]
   91dde:	b39b      	cbz	r3, 91e48 <__kernel_sin+0x100>
   91de0:	2200      	movs	r2, #0
   91de2:	4b33      	ldr	r3, [pc, #204]	; (91eb0 <__kernel_sin+0x168>)
   91de4:	4640      	mov	r0, r8
   91de6:	4649      	mov	r1, r9
   91de8:	f000 fcc8 	bl	9277c <__aeabi_dmul>
   91dec:	e9dd 2300 	ldrd	r2, r3, [sp]
   91df0:	e9cd 0102 	strd	r0, r1, [sp, #8]
   91df4:	4650      	mov	r0, sl
   91df6:	4659      	mov	r1, fp
   91df8:	f000 fcc0 	bl	9277c <__aeabi_dmul>
   91dfc:	4602      	mov	r2, r0
   91dfe:	460b      	mov	r3, r1
   91e00:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   91e04:	f000 fb06 	bl	92414 <__aeabi_dsub>
   91e08:	4632      	mov	r2, r6
   91e0a:	463b      	mov	r3, r7
   91e0c:	f000 fcb6 	bl	9277c <__aeabi_dmul>
   91e10:	4642      	mov	r2, r8
   91e12:	464b      	mov	r3, r9
   91e14:	f000 fafe 	bl	92414 <__aeabi_dsub>
   91e18:	a323      	add	r3, pc, #140	; (adr r3, 91ea8 <__kernel_sin+0x160>)
   91e1a:	e9d3 2300 	ldrd	r2, r3, [r3]
   91e1e:	4606      	mov	r6, r0
   91e20:	460f      	mov	r7, r1
   91e22:	4650      	mov	r0, sl
   91e24:	4659      	mov	r1, fp
   91e26:	f000 fca9 	bl	9277c <__aeabi_dmul>
   91e2a:	4602      	mov	r2, r0
   91e2c:	460b      	mov	r3, r1
   91e2e:	4630      	mov	r0, r6
   91e30:	4639      	mov	r1, r7
   91e32:	f000 faf1 	bl	92418 <__adddf3>
   91e36:	4602      	mov	r2, r0
   91e38:	460b      	mov	r3, r1
   91e3a:	4628      	mov	r0, r5
   91e3c:	4621      	mov	r1, r4
   91e3e:	f000 fae9 	bl	92414 <__aeabi_dsub>
   91e42:	b005      	add	sp, #20
   91e44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   91e48:	4602      	mov	r2, r0
   91e4a:	460b      	mov	r3, r1
   91e4c:	4630      	mov	r0, r6
   91e4e:	4639      	mov	r1, r7
   91e50:	f000 fc94 	bl	9277c <__aeabi_dmul>
   91e54:	a314      	add	r3, pc, #80	; (adr r3, 91ea8 <__kernel_sin+0x160>)
   91e56:	e9d3 2300 	ldrd	r2, r3, [r3]
   91e5a:	f000 fadb 	bl	92414 <__aeabi_dsub>
   91e5e:	4652      	mov	r2, sl
   91e60:	465b      	mov	r3, fp
   91e62:	f000 fc8b 	bl	9277c <__aeabi_dmul>
   91e66:	462a      	mov	r2, r5
   91e68:	4623      	mov	r3, r4
   91e6a:	f000 fad5 	bl	92418 <__adddf3>
   91e6e:	b005      	add	sp, #20
   91e70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   91e74:	4628      	mov	r0, r5
   91e76:	4621      	mov	r1, r4
   91e78:	b005      	add	sp, #20
   91e7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   91e7e:	bf00      	nop
   91e80:	5acfd57c 	.word	0x5acfd57c
   91e84:	3de5d93a 	.word	0x3de5d93a
   91e88:	8a2b9ceb 	.word	0x8a2b9ceb
   91e8c:	3e5ae5e6 	.word	0x3e5ae5e6
   91e90:	57b1fe7d 	.word	0x57b1fe7d
   91e94:	3ec71de3 	.word	0x3ec71de3
   91e98:	19c161d5 	.word	0x19c161d5
   91e9c:	3f2a01a0 	.word	0x3f2a01a0
   91ea0:	1110f8a6 	.word	0x1110f8a6
   91ea4:	3f811111 	.word	0x3f811111
   91ea8:	55555549 	.word	0x55555549
   91eac:	3fc55555 	.word	0x3fc55555
   91eb0:	3fe00000 	.word	0x3fe00000
   91eb4:	00000000 	.word	0x00000000

00091eb8 <atan>:
   91eb8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   91ebc:	4bc0      	ldr	r3, [pc, #768]	; (921c0 <atan+0x308>)
   91ebe:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
   91ec2:	429e      	cmp	r6, r3
   91ec4:	460d      	mov	r5, r1
   91ec6:	468a      	mov	sl, r1
   91ec8:	4604      	mov	r4, r0
   91eca:	dd0f      	ble.n	91eec <atan+0x34>
   91ecc:	4bbd      	ldr	r3, [pc, #756]	; (921c4 <atan+0x30c>)
   91ece:	429e      	cmp	r6, r3
   91ed0:	f300 80b2 	bgt.w	92038 <atan+0x180>
   91ed4:	f000 80ad 	beq.w	92032 <atan+0x17a>
   91ed8:	4bbb      	ldr	r3, [pc, #748]	; (921c8 <atan+0x310>)
   91eda:	49bc      	ldr	r1, [pc, #752]	; (921cc <atan+0x314>)
   91edc:	4cbc      	ldr	r4, [pc, #752]	; (921d0 <atan+0x318>)
   91ede:	f1ba 0f00 	cmp.w	sl, #0
   91ee2:	bfc8      	it	gt
   91ee4:	4619      	movgt	r1, r3
   91ee6:	4620      	mov	r0, r4
   91ee8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   91eec:	4bb9      	ldr	r3, [pc, #740]	; (921d4 <atan+0x31c>)
   91eee:	429e      	cmp	r6, r3
   91ef0:	f300 80bc 	bgt.w	9206c <atan+0x1b4>
   91ef4:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
   91ef8:	429e      	cmp	r6, r3
   91efa:	f340 80a7 	ble.w	9204c <atan+0x194>
   91efe:	f04f 3bff 	mov.w	fp, #4294967295
   91f02:	4622      	mov	r2, r4
   91f04:	462b      	mov	r3, r5
   91f06:	4620      	mov	r0, r4
   91f08:	4629      	mov	r1, r5
   91f0a:	f000 fc37 	bl	9277c <__aeabi_dmul>
   91f0e:	4602      	mov	r2, r0
   91f10:	460b      	mov	r3, r1
   91f12:	4680      	mov	r8, r0
   91f14:	4689      	mov	r9, r1
   91f16:	f000 fc31 	bl	9277c <__aeabi_dmul>
   91f1a:	a391      	add	r3, pc, #580	; (adr r3, 92160 <atan+0x2a8>)
   91f1c:	e9d3 2300 	ldrd	r2, r3, [r3]
   91f20:	4606      	mov	r6, r0
   91f22:	460f      	mov	r7, r1
   91f24:	f000 fc2a 	bl	9277c <__aeabi_dmul>
   91f28:	a38f      	add	r3, pc, #572	; (adr r3, 92168 <atan+0x2b0>)
   91f2a:	e9d3 2300 	ldrd	r2, r3, [r3]
   91f2e:	f000 fa73 	bl	92418 <__adddf3>
   91f32:	4632      	mov	r2, r6
   91f34:	463b      	mov	r3, r7
   91f36:	f000 fc21 	bl	9277c <__aeabi_dmul>
   91f3a:	a38d      	add	r3, pc, #564	; (adr r3, 92170 <atan+0x2b8>)
   91f3c:	e9d3 2300 	ldrd	r2, r3, [r3]
   91f40:	f000 fa6a 	bl	92418 <__adddf3>
   91f44:	4632      	mov	r2, r6
   91f46:	463b      	mov	r3, r7
   91f48:	f000 fc18 	bl	9277c <__aeabi_dmul>
   91f4c:	a38a      	add	r3, pc, #552	; (adr r3, 92178 <atan+0x2c0>)
   91f4e:	e9d3 2300 	ldrd	r2, r3, [r3]
   91f52:	f000 fa61 	bl	92418 <__adddf3>
   91f56:	4632      	mov	r2, r6
   91f58:	463b      	mov	r3, r7
   91f5a:	f000 fc0f 	bl	9277c <__aeabi_dmul>
   91f5e:	a388      	add	r3, pc, #544	; (adr r3, 92180 <atan+0x2c8>)
   91f60:	e9d3 2300 	ldrd	r2, r3, [r3]
   91f64:	f000 fa58 	bl	92418 <__adddf3>
   91f68:	4632      	mov	r2, r6
   91f6a:	463b      	mov	r3, r7
   91f6c:	f000 fc06 	bl	9277c <__aeabi_dmul>
   91f70:	a385      	add	r3, pc, #532	; (adr r3, 92188 <atan+0x2d0>)
   91f72:	e9d3 2300 	ldrd	r2, r3, [r3]
   91f76:	f000 fa4f 	bl	92418 <__adddf3>
   91f7a:	4642      	mov	r2, r8
   91f7c:	464b      	mov	r3, r9
   91f7e:	f000 fbfd 	bl	9277c <__aeabi_dmul>
   91f82:	a383      	add	r3, pc, #524	; (adr r3, 92190 <atan+0x2d8>)
   91f84:	e9d3 2300 	ldrd	r2, r3, [r3]
   91f88:	4680      	mov	r8, r0
   91f8a:	4689      	mov	r9, r1
   91f8c:	4630      	mov	r0, r6
   91f8e:	4639      	mov	r1, r7
   91f90:	f000 fbf4 	bl	9277c <__aeabi_dmul>
   91f94:	a380      	add	r3, pc, #512	; (adr r3, 92198 <atan+0x2e0>)
   91f96:	e9d3 2300 	ldrd	r2, r3, [r3]
   91f9a:	f000 fa3b 	bl	92414 <__aeabi_dsub>
   91f9e:	4632      	mov	r2, r6
   91fa0:	463b      	mov	r3, r7
   91fa2:	f000 fbeb 	bl	9277c <__aeabi_dmul>
   91fa6:	a37e      	add	r3, pc, #504	; (adr r3, 921a0 <atan+0x2e8>)
   91fa8:	e9d3 2300 	ldrd	r2, r3, [r3]
   91fac:	f000 fa32 	bl	92414 <__aeabi_dsub>
   91fb0:	4632      	mov	r2, r6
   91fb2:	463b      	mov	r3, r7
   91fb4:	f000 fbe2 	bl	9277c <__aeabi_dmul>
   91fb8:	a37b      	add	r3, pc, #492	; (adr r3, 921a8 <atan+0x2f0>)
   91fba:	e9d3 2300 	ldrd	r2, r3, [r3]
   91fbe:	f000 fa29 	bl	92414 <__aeabi_dsub>
   91fc2:	4632      	mov	r2, r6
   91fc4:	463b      	mov	r3, r7
   91fc6:	f000 fbd9 	bl	9277c <__aeabi_dmul>
   91fca:	a379      	add	r3, pc, #484	; (adr r3, 921b0 <atan+0x2f8>)
   91fcc:	e9d3 2300 	ldrd	r2, r3, [r3]
   91fd0:	f000 fa20 	bl	92414 <__aeabi_dsub>
   91fd4:	4632      	mov	r2, r6
   91fd6:	463b      	mov	r3, r7
   91fd8:	f000 fbd0 	bl	9277c <__aeabi_dmul>
   91fdc:	f1bb 3fff 	cmp.w	fp, #4294967295
   91fe0:	4602      	mov	r2, r0
   91fe2:	460b      	mov	r3, r1
   91fe4:	d069      	beq.n	920ba <atan+0x202>
   91fe6:	4640      	mov	r0, r8
   91fe8:	4649      	mov	r1, r9
   91fea:	f000 fa15 	bl	92418 <__adddf3>
   91fee:	4622      	mov	r2, r4
   91ff0:	462b      	mov	r3, r5
   91ff2:	f000 fbc3 	bl	9277c <__aeabi_dmul>
   91ff6:	4e78      	ldr	r6, [pc, #480]	; (921d8 <atan+0x320>)
   91ff8:	4b78      	ldr	r3, [pc, #480]	; (921dc <atan+0x324>)
   91ffa:	ea4f 0bcb 	mov.w	fp, fp, lsl #3
   91ffe:	445e      	add	r6, fp
   92000:	449b      	add	fp, r3
   92002:	e9db 2300 	ldrd	r2, r3, [fp]
   92006:	f000 fa05 	bl	92414 <__aeabi_dsub>
   9200a:	4622      	mov	r2, r4
   9200c:	462b      	mov	r3, r5
   9200e:	f000 fa01 	bl	92414 <__aeabi_dsub>
   92012:	4602      	mov	r2, r0
   92014:	460b      	mov	r3, r1
   92016:	e9d6 0100 	ldrd	r0, r1, [r6]
   9201a:	f000 f9fb 	bl	92414 <__aeabi_dsub>
   9201e:	f1ba 0f00 	cmp.w	sl, #0
   92022:	4604      	mov	r4, r0
   92024:	f6bf af5f 	bge.w	91ee6 <atan+0x2e>
   92028:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
   9202c:	4620      	mov	r0, r4
   9202e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   92032:	2800      	cmp	r0, #0
   92034:	f43f af50 	beq.w	91ed8 <atan+0x20>
   92038:	4622      	mov	r2, r4
   9203a:	4620      	mov	r0, r4
   9203c:	462b      	mov	r3, r5
   9203e:	4629      	mov	r1, r5
   92040:	f000 f9ea 	bl	92418 <__adddf3>
   92044:	4604      	mov	r4, r0
   92046:	4620      	mov	r0, r4
   92048:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   9204c:	a35a      	add	r3, pc, #360	; (adr r3, 921b8 <atan+0x300>)
   9204e:	e9d3 2300 	ldrd	r2, r3, [r3]
   92052:	f000 f9e1 	bl	92418 <__adddf3>
   92056:	2200      	movs	r2, #0
   92058:	4b61      	ldr	r3, [pc, #388]	; (921e0 <atan+0x328>)
   9205a:	f000 fe1f 	bl	92c9c <__aeabi_dcmpgt>
   9205e:	2800      	cmp	r0, #0
   92060:	f43f af4d 	beq.w	91efe <atan+0x46>
   92064:	4629      	mov	r1, r5
   92066:	4620      	mov	r0, r4
   92068:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   9206c:	f000 f8c2 	bl	921f4 <fabs>
   92070:	4b5c      	ldr	r3, [pc, #368]	; (921e4 <atan+0x32c>)
   92072:	4604      	mov	r4, r0
   92074:	429e      	cmp	r6, r3
   92076:	460d      	mov	r5, r1
   92078:	dc2f      	bgt.n	920da <atan+0x222>
   9207a:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
   9207e:	429e      	cmp	r6, r3
   92080:	dc54      	bgt.n	9212c <atan+0x274>
   92082:	4602      	mov	r2, r0
   92084:	460b      	mov	r3, r1
   92086:	f000 f9c7 	bl	92418 <__adddf3>
   9208a:	2200      	movs	r2, #0
   9208c:	4b54      	ldr	r3, [pc, #336]	; (921e0 <atan+0x328>)
   9208e:	f000 f9c1 	bl	92414 <__aeabi_dsub>
   92092:	2200      	movs	r2, #0
   92094:	4606      	mov	r6, r0
   92096:	460f      	mov	r7, r1
   92098:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   9209c:	4620      	mov	r0, r4
   9209e:	4629      	mov	r1, r5
   920a0:	f000 f9ba 	bl	92418 <__adddf3>
   920a4:	4602      	mov	r2, r0
   920a6:	460b      	mov	r3, r1
   920a8:	4630      	mov	r0, r6
   920aa:	4639      	mov	r1, r7
   920ac:	f000 fc90 	bl	929d0 <__aeabi_ddiv>
   920b0:	f04f 0b00 	mov.w	fp, #0
   920b4:	4604      	mov	r4, r0
   920b6:	460d      	mov	r5, r1
   920b8:	e723      	b.n	91f02 <atan+0x4a>
   920ba:	4640      	mov	r0, r8
   920bc:	4649      	mov	r1, r9
   920be:	f000 f9ab 	bl	92418 <__adddf3>
   920c2:	4622      	mov	r2, r4
   920c4:	462b      	mov	r3, r5
   920c6:	f000 fb59 	bl	9277c <__aeabi_dmul>
   920ca:	4602      	mov	r2, r0
   920cc:	460b      	mov	r3, r1
   920ce:	4620      	mov	r0, r4
   920d0:	4629      	mov	r1, r5
   920d2:	f000 f99f 	bl	92414 <__aeabi_dsub>
   920d6:	4604      	mov	r4, r0
   920d8:	e705      	b.n	91ee6 <atan+0x2e>
   920da:	4b43      	ldr	r3, [pc, #268]	; (921e8 <atan+0x330>)
   920dc:	429e      	cmp	r6, r3
   920de:	dc1a      	bgt.n	92116 <atan+0x25e>
   920e0:	2200      	movs	r2, #0
   920e2:	4b42      	ldr	r3, [pc, #264]	; (921ec <atan+0x334>)
   920e4:	f000 f996 	bl	92414 <__aeabi_dsub>
   920e8:	2200      	movs	r2, #0
   920ea:	4606      	mov	r6, r0
   920ec:	460f      	mov	r7, r1
   920ee:	4b3f      	ldr	r3, [pc, #252]	; (921ec <atan+0x334>)
   920f0:	4620      	mov	r0, r4
   920f2:	4629      	mov	r1, r5
   920f4:	f000 fb42 	bl	9277c <__aeabi_dmul>
   920f8:	2200      	movs	r2, #0
   920fa:	4b39      	ldr	r3, [pc, #228]	; (921e0 <atan+0x328>)
   920fc:	f000 f98c 	bl	92418 <__adddf3>
   92100:	4602      	mov	r2, r0
   92102:	460b      	mov	r3, r1
   92104:	4630      	mov	r0, r6
   92106:	4639      	mov	r1, r7
   92108:	f000 fc62 	bl	929d0 <__aeabi_ddiv>
   9210c:	f04f 0b02 	mov.w	fp, #2
   92110:	4604      	mov	r4, r0
   92112:	460d      	mov	r5, r1
   92114:	e6f5      	b.n	91f02 <atan+0x4a>
   92116:	4602      	mov	r2, r0
   92118:	460b      	mov	r3, r1
   9211a:	2000      	movs	r0, #0
   9211c:	4934      	ldr	r1, [pc, #208]	; (921f0 <atan+0x338>)
   9211e:	f000 fc57 	bl	929d0 <__aeabi_ddiv>
   92122:	f04f 0b03 	mov.w	fp, #3
   92126:	4604      	mov	r4, r0
   92128:	460d      	mov	r5, r1
   9212a:	e6ea      	b.n	91f02 <atan+0x4a>
   9212c:	2200      	movs	r2, #0
   9212e:	4b2c      	ldr	r3, [pc, #176]	; (921e0 <atan+0x328>)
   92130:	f000 f970 	bl	92414 <__aeabi_dsub>
   92134:	2200      	movs	r2, #0
   92136:	4606      	mov	r6, r0
   92138:	460f      	mov	r7, r1
   9213a:	4b29      	ldr	r3, [pc, #164]	; (921e0 <atan+0x328>)
   9213c:	4620      	mov	r0, r4
   9213e:	4629      	mov	r1, r5
   92140:	f000 f96a 	bl	92418 <__adddf3>
   92144:	4602      	mov	r2, r0
   92146:	460b      	mov	r3, r1
   92148:	4630      	mov	r0, r6
   9214a:	4639      	mov	r1, r7
   9214c:	f000 fc40 	bl	929d0 <__aeabi_ddiv>
   92150:	f04f 0b01 	mov.w	fp, #1
   92154:	4604      	mov	r4, r0
   92156:	460d      	mov	r5, r1
   92158:	e6d3      	b.n	91f02 <atan+0x4a>
   9215a:	bf00      	nop
   9215c:	f3af 8000 	nop.w
   92160:	e322da11 	.word	0xe322da11
   92164:	3f90ad3a 	.word	0x3f90ad3a
   92168:	24760deb 	.word	0x24760deb
   9216c:	3fa97b4b 	.word	0x3fa97b4b
   92170:	a0d03d51 	.word	0xa0d03d51
   92174:	3fb10d66 	.word	0x3fb10d66
   92178:	c54c206e 	.word	0xc54c206e
   9217c:	3fb745cd 	.word	0x3fb745cd
   92180:	920083ff 	.word	0x920083ff
   92184:	3fc24924 	.word	0x3fc24924
   92188:	5555550d 	.word	0x5555550d
   9218c:	3fd55555 	.word	0x3fd55555
   92190:	2c6a6c2f 	.word	0x2c6a6c2f
   92194:	bfa2b444 	.word	0xbfa2b444
   92198:	52defd9a 	.word	0x52defd9a
   9219c:	3fadde2d 	.word	0x3fadde2d
   921a0:	af749a6d 	.word	0xaf749a6d
   921a4:	3fb3b0f2 	.word	0x3fb3b0f2
   921a8:	fe231671 	.word	0xfe231671
   921ac:	3fbc71c6 	.word	0x3fbc71c6
   921b0:	9998ebc4 	.word	0x9998ebc4
   921b4:	3fc99999 	.word	0x3fc99999
   921b8:	8800759c 	.word	0x8800759c
   921bc:	7e37e43c 	.word	0x7e37e43c
   921c0:	440fffff 	.word	0x440fffff
   921c4:	7ff00000 	.word	0x7ff00000
   921c8:	3ff921fb 	.word	0x3ff921fb
   921cc:	bff921fb 	.word	0xbff921fb
   921d0:	54442d18 	.word	0x54442d18
   921d4:	3fdbffff 	.word	0x3fdbffff
   921d8:	0009b110 	.word	0x0009b110
   921dc:	0009b0f0 	.word	0x0009b0f0
   921e0:	3ff00000 	.word	0x3ff00000
   921e4:	3ff2ffff 	.word	0x3ff2ffff
   921e8:	40037fff 	.word	0x40037fff
   921ec:	3ff80000 	.word	0x3ff80000
   921f0:	bff00000 	.word	0xbff00000

000921f4 <fabs>:
   921f4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   921f8:	4770      	bx	lr
   921fa:	bf00      	nop
   921fc:	0000      	movs	r0, r0
	...

00092200 <floor>:
   92200:	f3c1 520a 	ubfx	r2, r1, #20, #11
   92204:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   92208:	f2a2 36ff 	subw	r6, r2, #1023	; 0x3ff
   9220c:	2e13      	cmp	r6, #19
   9220e:	460b      	mov	r3, r1
   92210:	4604      	mov	r4, r0
   92212:	460d      	mov	r5, r1
   92214:	4688      	mov	r8, r1
   92216:	4607      	mov	r7, r0
   92218:	dc1c      	bgt.n	92254 <floor+0x54>
   9221a:	2e00      	cmp	r6, #0
   9221c:	db3f      	blt.n	9229e <floor+0x9e>
   9221e:	4a3a      	ldr	r2, [pc, #232]	; (92308 <floor+0x108>)
   92220:	4686      	mov	lr, r0
   92222:	fa42 f906 	asr.w	r9, r2, r6
   92226:	ea01 0209 	and.w	r2, r1, r9
   9222a:	4302      	orrs	r2, r0
   9222c:	d017      	beq.n	9225e <floor+0x5e>
   9222e:	a334      	add	r3, pc, #208	; (adr r3, 92300 <floor+0x100>)
   92230:	e9d3 2300 	ldrd	r2, r3, [r3]
   92234:	f000 f8f0 	bl	92418 <__adddf3>
   92238:	2200      	movs	r2, #0
   9223a:	2300      	movs	r3, #0
   9223c:	f000 fd2e 	bl	92c9c <__aeabi_dcmpgt>
   92240:	b120      	cbz	r0, 9224c <floor+0x4c>
   92242:	2d00      	cmp	r5, #0
   92244:	db40      	blt.n	922c8 <floor+0xc8>
   92246:	ea28 0509 	bic.w	r5, r8, r9
   9224a:	2700      	movs	r7, #0
   9224c:	4638      	mov	r0, r7
   9224e:	4629      	mov	r1, r5
   92250:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   92254:	2e33      	cmp	r6, #51	; 0x33
   92256:	dd06      	ble.n	92266 <floor+0x66>
   92258:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
   9225c:	d02f      	beq.n	922be <floor+0xbe>
   9225e:	4620      	mov	r0, r4
   92260:	4619      	mov	r1, r3
   92262:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   92266:	f2a2 4213 	subw	r2, r2, #1043	; 0x413
   9226a:	f04f 39ff 	mov.w	r9, #4294967295
   9226e:	fa29 f902 	lsr.w	r9, r9, r2
   92272:	ea10 0f09 	tst.w	r0, r9
   92276:	d0f2      	beq.n	9225e <floor+0x5e>
   92278:	a321      	add	r3, pc, #132	; (adr r3, 92300 <floor+0x100>)
   9227a:	e9d3 2300 	ldrd	r2, r3, [r3]
   9227e:	f000 f8cb 	bl	92418 <__adddf3>
   92282:	2200      	movs	r2, #0
   92284:	2300      	movs	r3, #0
   92286:	f000 fd09 	bl	92c9c <__aeabi_dcmpgt>
   9228a:	2800      	cmp	r0, #0
   9228c:	d0de      	beq.n	9224c <floor+0x4c>
   9228e:	2d00      	cmp	r5, #0
   92290:	db20      	blt.n	922d4 <floor+0xd4>
   92292:	4645      	mov	r5, r8
   92294:	ea27 0709 	bic.w	r7, r7, r9
   92298:	4638      	mov	r0, r7
   9229a:	4629      	mov	r1, r5
   9229c:	e7d8      	b.n	92250 <floor+0x50>
   9229e:	a318      	add	r3, pc, #96	; (adr r3, 92300 <floor+0x100>)
   922a0:	e9d3 2300 	ldrd	r2, r3, [r3]
   922a4:	f000 f8b8 	bl	92418 <__adddf3>
   922a8:	2200      	movs	r2, #0
   922aa:	2300      	movs	r3, #0
   922ac:	f000 fcf6 	bl	92c9c <__aeabi_dcmpgt>
   922b0:	2800      	cmp	r0, #0
   922b2:	d0cb      	beq.n	9224c <floor+0x4c>
   922b4:	2d00      	cmp	r5, #0
   922b6:	db18      	blt.n	922ea <floor+0xea>
   922b8:	2700      	movs	r7, #0
   922ba:	463d      	mov	r5, r7
   922bc:	e7c6      	b.n	9224c <floor+0x4c>
   922be:	4602      	mov	r2, r0
   922c0:	460b      	mov	r3, r1
   922c2:	f000 f8a9 	bl	92418 <__adddf3>
   922c6:	e7cc      	b.n	92262 <floor+0x62>
   922c8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   922cc:	fa43 f606 	asr.w	r6, r3, r6
   922d0:	44b0      	add	r8, r6
   922d2:	e7b8      	b.n	92246 <floor+0x46>
   922d4:	2e14      	cmp	r6, #20
   922d6:	d010      	beq.n	922fa <floor+0xfa>
   922d8:	2301      	movs	r3, #1
   922da:	f1c6 0634 	rsb	r6, r6, #52	; 0x34
   922de:	fa03 f606 	lsl.w	r6, r3, r6
   922e2:	1937      	adds	r7, r6, r4
   922e4:	bf28      	it	cs
   922e6:	4498      	addcs	r8, r3
   922e8:	e7d3      	b.n	92292 <floor+0x92>
   922ea:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
   922ee:	4b07      	ldr	r3, [pc, #28]	; (9230c <floor+0x10c>)
   922f0:	4322      	orrs	r2, r4
   922f2:	bf18      	it	ne
   922f4:	461d      	movne	r5, r3
   922f6:	2700      	movs	r7, #0
   922f8:	e7a8      	b.n	9224c <floor+0x4c>
   922fa:	f105 0801 	add.w	r8, r5, #1
   922fe:	e7c8      	b.n	92292 <floor+0x92>
   92300:	8800759c 	.word	0x8800759c
   92304:	7e37e43c 	.word	0x7e37e43c
   92308:	000fffff 	.word	0x000fffff
   9230c:	bff00000 	.word	0xbff00000

00092310 <matherr>:
   92310:	2000      	movs	r0, #0
   92312:	4770      	bx	lr
   92314:	0000      	movs	r0, r0
	...

00092318 <scalbn>:
   92318:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   9231a:	f3c1 560a 	ubfx	r6, r1, #20, #11
   9231e:	4604      	mov	r4, r0
   92320:	460d      	mov	r5, r1
   92322:	460b      	mov	r3, r1
   92324:	4617      	mov	r7, r2
   92326:	bb06      	cbnz	r6, 9236a <scalbn+0x52>
   92328:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   9232c:	4303      	orrs	r3, r0
   9232e:	d025      	beq.n	9237c <scalbn+0x64>
   92330:	2200      	movs	r2, #0
   92332:	4b2f      	ldr	r3, [pc, #188]	; (923f0 <scalbn+0xd8>)
   92334:	f000 fa22 	bl	9277c <__aeabi_dmul>
   92338:	4a2e      	ldr	r2, [pc, #184]	; (923f4 <scalbn+0xdc>)
   9233a:	4604      	mov	r4, r0
   9233c:	4297      	cmp	r7, r2
   9233e:	460d      	mov	r5, r1
   92340:	460b      	mov	r3, r1
   92342:	db2a      	blt.n	9239a <scalbn+0x82>
   92344:	f3c1 560a 	ubfx	r6, r1, #20, #11
   92348:	3e36      	subs	r6, #54	; 0x36
   9234a:	f240 72fe 	movw	r2, #2046	; 0x7fe
   9234e:	443e      	add	r6, r7
   92350:	4296      	cmp	r6, r2
   92352:	dc28      	bgt.n	923a6 <scalbn+0x8e>
   92354:	2e00      	cmp	r6, #0
   92356:	dd12      	ble.n	9237e <scalbn+0x66>
   92358:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   9235c:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
   92360:	ea43 5506 	orr.w	r5, r3, r6, lsl #20
   92364:	4620      	mov	r0, r4
   92366:	4629      	mov	r1, r5
   92368:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   9236a:	f240 72ff 	movw	r2, #2047	; 0x7ff
   9236e:	4296      	cmp	r6, r2
   92370:	d1eb      	bne.n	9234a <scalbn+0x32>
   92372:	4602      	mov	r2, r0
   92374:	460b      	mov	r3, r1
   92376:	f000 f84f 	bl	92418 <__adddf3>
   9237a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   9237c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   9237e:	f116 0f35 	cmn.w	r6, #53	; 0x35
   92382:	da1d      	bge.n	923c0 <scalbn+0xa8>
   92384:	f24c 3350 	movw	r3, #50000	; 0xc350
   92388:	429f      	cmp	r7, r3
   9238a:	dc0c      	bgt.n	923a6 <scalbn+0x8e>
   9238c:	a114      	add	r1, pc, #80	; (adr r1, 923e0 <scalbn+0xc8>)
   9238e:	e9d1 0100 	ldrd	r0, r1, [r1]
   92392:	4622      	mov	r2, r4
   92394:	462b      	mov	r3, r5
   92396:	f000 f831 	bl	923fc <copysign>
   9239a:	a311      	add	r3, pc, #68	; (adr r3, 923e0 <scalbn+0xc8>)
   9239c:	e9d3 2300 	ldrd	r2, r3, [r3]
   923a0:	f000 f9ec 	bl	9277c <__aeabi_dmul>
   923a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   923a6:	4622      	mov	r2, r4
   923a8:	a10f      	add	r1, pc, #60	; (adr r1, 923e8 <scalbn+0xd0>)
   923aa:	e9d1 0100 	ldrd	r0, r1, [r1]
   923ae:	462b      	mov	r3, r5
   923b0:	f000 f824 	bl	923fc <copysign>
   923b4:	a30c      	add	r3, pc, #48	; (adr r3, 923e8 <scalbn+0xd0>)
   923b6:	e9d3 2300 	ldrd	r2, r3, [r3]
   923ba:	f000 f9df 	bl	9277c <__aeabi_dmul>
   923be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   923c0:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   923c4:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
   923c8:	3636      	adds	r6, #54	; 0x36
   923ca:	ea43 5506 	orr.w	r5, r3, r6, lsl #20
   923ce:	4620      	mov	r0, r4
   923d0:	4629      	mov	r1, r5
   923d2:	2200      	movs	r2, #0
   923d4:	4b08      	ldr	r3, [pc, #32]	; (923f8 <scalbn+0xe0>)
   923d6:	f000 f9d1 	bl	9277c <__aeabi_dmul>
   923da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   923dc:	f3af 8000 	nop.w
   923e0:	c2f8f359 	.word	0xc2f8f359
   923e4:	01a56e1f 	.word	0x01a56e1f
   923e8:	8800759c 	.word	0x8800759c
   923ec:	7e37e43c 	.word	0x7e37e43c
   923f0:	43500000 	.word	0x43500000
   923f4:	ffff3cb0 	.word	0xffff3cb0
   923f8:	3c900000 	.word	0x3c900000

000923fc <copysign>:
   923fc:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
   92400:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
   92404:	ea42 0103 	orr.w	r1, r2, r3
   92408:	4770      	bx	lr
   9240a:	bf00      	nop

0009240c <__aeabi_drsub>:
   9240c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   92410:	e002      	b.n	92418 <__adddf3>
   92412:	bf00      	nop

00092414 <__aeabi_dsub>:
   92414:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00092418 <__adddf3>:
   92418:	b530      	push	{r4, r5, lr}
   9241a:	ea4f 0441 	mov.w	r4, r1, lsl #1
   9241e:	ea4f 0543 	mov.w	r5, r3, lsl #1
   92422:	ea94 0f05 	teq	r4, r5
   92426:	bf08      	it	eq
   92428:	ea90 0f02 	teqeq	r0, r2
   9242c:	bf1f      	itttt	ne
   9242e:	ea54 0c00 	orrsne.w	ip, r4, r0
   92432:	ea55 0c02 	orrsne.w	ip, r5, r2
   92436:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   9243a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   9243e:	f000 80e2 	beq.w	92606 <__adddf3+0x1ee>
   92442:	ea4f 5454 	mov.w	r4, r4, lsr #21
   92446:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   9244a:	bfb8      	it	lt
   9244c:	426d      	neglt	r5, r5
   9244e:	dd0c      	ble.n	9246a <__adddf3+0x52>
   92450:	442c      	add	r4, r5
   92452:	ea80 0202 	eor.w	r2, r0, r2
   92456:	ea81 0303 	eor.w	r3, r1, r3
   9245a:	ea82 0000 	eor.w	r0, r2, r0
   9245e:	ea83 0101 	eor.w	r1, r3, r1
   92462:	ea80 0202 	eor.w	r2, r0, r2
   92466:	ea81 0303 	eor.w	r3, r1, r3
   9246a:	2d36      	cmp	r5, #54	; 0x36
   9246c:	bf88      	it	hi
   9246e:	bd30      	pophi	{r4, r5, pc}
   92470:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   92474:	ea4f 3101 	mov.w	r1, r1, lsl #12
   92478:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   9247c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   92480:	d002      	beq.n	92488 <__adddf3+0x70>
   92482:	4240      	negs	r0, r0
   92484:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   92488:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   9248c:	ea4f 3303 	mov.w	r3, r3, lsl #12
   92490:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   92494:	d002      	beq.n	9249c <__adddf3+0x84>
   92496:	4252      	negs	r2, r2
   92498:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   9249c:	ea94 0f05 	teq	r4, r5
   924a0:	f000 80a7 	beq.w	925f2 <__adddf3+0x1da>
   924a4:	f1a4 0401 	sub.w	r4, r4, #1
   924a8:	f1d5 0e20 	rsbs	lr, r5, #32
   924ac:	db0d      	blt.n	924ca <__adddf3+0xb2>
   924ae:	fa02 fc0e 	lsl.w	ip, r2, lr
   924b2:	fa22 f205 	lsr.w	r2, r2, r5
   924b6:	1880      	adds	r0, r0, r2
   924b8:	f141 0100 	adc.w	r1, r1, #0
   924bc:	fa03 f20e 	lsl.w	r2, r3, lr
   924c0:	1880      	adds	r0, r0, r2
   924c2:	fa43 f305 	asr.w	r3, r3, r5
   924c6:	4159      	adcs	r1, r3
   924c8:	e00e      	b.n	924e8 <__adddf3+0xd0>
   924ca:	f1a5 0520 	sub.w	r5, r5, #32
   924ce:	f10e 0e20 	add.w	lr, lr, #32
   924d2:	2a01      	cmp	r2, #1
   924d4:	fa03 fc0e 	lsl.w	ip, r3, lr
   924d8:	bf28      	it	cs
   924da:	f04c 0c02 	orrcs.w	ip, ip, #2
   924de:	fa43 f305 	asr.w	r3, r3, r5
   924e2:	18c0      	adds	r0, r0, r3
   924e4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   924e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   924ec:	d507      	bpl.n	924fe <__adddf3+0xe6>
   924ee:	f04f 0e00 	mov.w	lr, #0
   924f2:	f1dc 0c00 	rsbs	ip, ip, #0
   924f6:	eb7e 0000 	sbcs.w	r0, lr, r0
   924fa:	eb6e 0101 	sbc.w	r1, lr, r1
   924fe:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   92502:	d31b      	bcc.n	9253c <__adddf3+0x124>
   92504:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   92508:	d30c      	bcc.n	92524 <__adddf3+0x10c>
   9250a:	0849      	lsrs	r1, r1, #1
   9250c:	ea5f 0030 	movs.w	r0, r0, rrx
   92510:	ea4f 0c3c 	mov.w	ip, ip, rrx
   92514:	f104 0401 	add.w	r4, r4, #1
   92518:	ea4f 5244 	mov.w	r2, r4, lsl #21
   9251c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   92520:	f080 809a 	bcs.w	92658 <__adddf3+0x240>
   92524:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   92528:	bf08      	it	eq
   9252a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   9252e:	f150 0000 	adcs.w	r0, r0, #0
   92532:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   92536:	ea41 0105 	orr.w	r1, r1, r5
   9253a:	bd30      	pop	{r4, r5, pc}
   9253c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   92540:	4140      	adcs	r0, r0
   92542:	eb41 0101 	adc.w	r1, r1, r1
   92546:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   9254a:	f1a4 0401 	sub.w	r4, r4, #1
   9254e:	d1e9      	bne.n	92524 <__adddf3+0x10c>
   92550:	f091 0f00 	teq	r1, #0
   92554:	bf04      	itt	eq
   92556:	4601      	moveq	r1, r0
   92558:	2000      	moveq	r0, #0
   9255a:	fab1 f381 	clz	r3, r1
   9255e:	bf08      	it	eq
   92560:	3320      	addeq	r3, #32
   92562:	f1a3 030b 	sub.w	r3, r3, #11
   92566:	f1b3 0220 	subs.w	r2, r3, #32
   9256a:	da0c      	bge.n	92586 <__adddf3+0x16e>
   9256c:	320c      	adds	r2, #12
   9256e:	dd08      	ble.n	92582 <__adddf3+0x16a>
   92570:	f102 0c14 	add.w	ip, r2, #20
   92574:	f1c2 020c 	rsb	r2, r2, #12
   92578:	fa01 f00c 	lsl.w	r0, r1, ip
   9257c:	fa21 f102 	lsr.w	r1, r1, r2
   92580:	e00c      	b.n	9259c <__adddf3+0x184>
   92582:	f102 0214 	add.w	r2, r2, #20
   92586:	bfd8      	it	le
   92588:	f1c2 0c20 	rsble	ip, r2, #32
   9258c:	fa01 f102 	lsl.w	r1, r1, r2
   92590:	fa20 fc0c 	lsr.w	ip, r0, ip
   92594:	bfdc      	itt	le
   92596:	ea41 010c 	orrle.w	r1, r1, ip
   9259a:	4090      	lslle	r0, r2
   9259c:	1ae4      	subs	r4, r4, r3
   9259e:	bfa2      	ittt	ge
   925a0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   925a4:	4329      	orrge	r1, r5
   925a6:	bd30      	popge	{r4, r5, pc}
   925a8:	ea6f 0404 	mvn.w	r4, r4
   925ac:	3c1f      	subs	r4, #31
   925ae:	da1c      	bge.n	925ea <__adddf3+0x1d2>
   925b0:	340c      	adds	r4, #12
   925b2:	dc0e      	bgt.n	925d2 <__adddf3+0x1ba>
   925b4:	f104 0414 	add.w	r4, r4, #20
   925b8:	f1c4 0220 	rsb	r2, r4, #32
   925bc:	fa20 f004 	lsr.w	r0, r0, r4
   925c0:	fa01 f302 	lsl.w	r3, r1, r2
   925c4:	ea40 0003 	orr.w	r0, r0, r3
   925c8:	fa21 f304 	lsr.w	r3, r1, r4
   925cc:	ea45 0103 	orr.w	r1, r5, r3
   925d0:	bd30      	pop	{r4, r5, pc}
   925d2:	f1c4 040c 	rsb	r4, r4, #12
   925d6:	f1c4 0220 	rsb	r2, r4, #32
   925da:	fa20 f002 	lsr.w	r0, r0, r2
   925de:	fa01 f304 	lsl.w	r3, r1, r4
   925e2:	ea40 0003 	orr.w	r0, r0, r3
   925e6:	4629      	mov	r1, r5
   925e8:	bd30      	pop	{r4, r5, pc}
   925ea:	fa21 f004 	lsr.w	r0, r1, r4
   925ee:	4629      	mov	r1, r5
   925f0:	bd30      	pop	{r4, r5, pc}
   925f2:	f094 0f00 	teq	r4, #0
   925f6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   925fa:	bf06      	itte	eq
   925fc:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   92600:	3401      	addeq	r4, #1
   92602:	3d01      	subne	r5, #1
   92604:	e74e      	b.n	924a4 <__adddf3+0x8c>
   92606:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   9260a:	bf18      	it	ne
   9260c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   92610:	d029      	beq.n	92666 <__adddf3+0x24e>
   92612:	ea94 0f05 	teq	r4, r5
   92616:	bf08      	it	eq
   92618:	ea90 0f02 	teqeq	r0, r2
   9261c:	d005      	beq.n	9262a <__adddf3+0x212>
   9261e:	ea54 0c00 	orrs.w	ip, r4, r0
   92622:	bf04      	itt	eq
   92624:	4619      	moveq	r1, r3
   92626:	4610      	moveq	r0, r2
   92628:	bd30      	pop	{r4, r5, pc}
   9262a:	ea91 0f03 	teq	r1, r3
   9262e:	bf1e      	ittt	ne
   92630:	2100      	movne	r1, #0
   92632:	2000      	movne	r0, #0
   92634:	bd30      	popne	{r4, r5, pc}
   92636:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   9263a:	d105      	bne.n	92648 <__adddf3+0x230>
   9263c:	0040      	lsls	r0, r0, #1
   9263e:	4149      	adcs	r1, r1
   92640:	bf28      	it	cs
   92642:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   92646:	bd30      	pop	{r4, r5, pc}
   92648:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   9264c:	bf3c      	itt	cc
   9264e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   92652:	bd30      	popcc	{r4, r5, pc}
   92654:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   92658:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   9265c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   92660:	f04f 0000 	mov.w	r0, #0
   92664:	bd30      	pop	{r4, r5, pc}
   92666:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   9266a:	bf1a      	itte	ne
   9266c:	4619      	movne	r1, r3
   9266e:	4610      	movne	r0, r2
   92670:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   92674:	bf1c      	itt	ne
   92676:	460b      	movne	r3, r1
   92678:	4602      	movne	r2, r0
   9267a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   9267e:	bf06      	itte	eq
   92680:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   92684:	ea91 0f03 	teqeq	r1, r3
   92688:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   9268c:	bd30      	pop	{r4, r5, pc}
   9268e:	bf00      	nop

00092690 <__aeabi_ui2d>:
   92690:	f090 0f00 	teq	r0, #0
   92694:	bf04      	itt	eq
   92696:	2100      	moveq	r1, #0
   92698:	4770      	bxeq	lr
   9269a:	b530      	push	{r4, r5, lr}
   9269c:	f44f 6480 	mov.w	r4, #1024	; 0x400
   926a0:	f104 0432 	add.w	r4, r4, #50	; 0x32
   926a4:	f04f 0500 	mov.w	r5, #0
   926a8:	f04f 0100 	mov.w	r1, #0
   926ac:	e750      	b.n	92550 <__adddf3+0x138>
   926ae:	bf00      	nop

000926b0 <__aeabi_i2d>:
   926b0:	f090 0f00 	teq	r0, #0
   926b4:	bf04      	itt	eq
   926b6:	2100      	moveq	r1, #0
   926b8:	4770      	bxeq	lr
   926ba:	b530      	push	{r4, r5, lr}
   926bc:	f44f 6480 	mov.w	r4, #1024	; 0x400
   926c0:	f104 0432 	add.w	r4, r4, #50	; 0x32
   926c4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   926c8:	bf48      	it	mi
   926ca:	4240      	negmi	r0, r0
   926cc:	f04f 0100 	mov.w	r1, #0
   926d0:	e73e      	b.n	92550 <__adddf3+0x138>
   926d2:	bf00      	nop

000926d4 <__aeabi_f2d>:
   926d4:	0042      	lsls	r2, r0, #1
   926d6:	ea4f 01e2 	mov.w	r1, r2, asr #3
   926da:	ea4f 0131 	mov.w	r1, r1, rrx
   926de:	ea4f 7002 	mov.w	r0, r2, lsl #28
   926e2:	bf1f      	itttt	ne
   926e4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   926e8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   926ec:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   926f0:	4770      	bxne	lr
   926f2:	f092 0f00 	teq	r2, #0
   926f6:	bf14      	ite	ne
   926f8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   926fc:	4770      	bxeq	lr
   926fe:	b530      	push	{r4, r5, lr}
   92700:	f44f 7460 	mov.w	r4, #896	; 0x380
   92704:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   92708:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   9270c:	e720      	b.n	92550 <__adddf3+0x138>
   9270e:	bf00      	nop

00092710 <__aeabi_ul2d>:
   92710:	ea50 0201 	orrs.w	r2, r0, r1
   92714:	bf08      	it	eq
   92716:	4770      	bxeq	lr
   92718:	b530      	push	{r4, r5, lr}
   9271a:	f04f 0500 	mov.w	r5, #0
   9271e:	e00a      	b.n	92736 <__aeabi_l2d+0x16>

00092720 <__aeabi_l2d>:
   92720:	ea50 0201 	orrs.w	r2, r0, r1
   92724:	bf08      	it	eq
   92726:	4770      	bxeq	lr
   92728:	b530      	push	{r4, r5, lr}
   9272a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   9272e:	d502      	bpl.n	92736 <__aeabi_l2d+0x16>
   92730:	4240      	negs	r0, r0
   92732:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   92736:	f44f 6480 	mov.w	r4, #1024	; 0x400
   9273a:	f104 0432 	add.w	r4, r4, #50	; 0x32
   9273e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   92742:	f43f aedc 	beq.w	924fe <__adddf3+0xe6>
   92746:	f04f 0203 	mov.w	r2, #3
   9274a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   9274e:	bf18      	it	ne
   92750:	3203      	addne	r2, #3
   92752:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   92756:	bf18      	it	ne
   92758:	3203      	addne	r2, #3
   9275a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   9275e:	f1c2 0320 	rsb	r3, r2, #32
   92762:	fa00 fc03 	lsl.w	ip, r0, r3
   92766:	fa20 f002 	lsr.w	r0, r0, r2
   9276a:	fa01 fe03 	lsl.w	lr, r1, r3
   9276e:	ea40 000e 	orr.w	r0, r0, lr
   92772:	fa21 f102 	lsr.w	r1, r1, r2
   92776:	4414      	add	r4, r2
   92778:	e6c1      	b.n	924fe <__adddf3+0xe6>
   9277a:	bf00      	nop

0009277c <__aeabi_dmul>:
   9277c:	b570      	push	{r4, r5, r6, lr}
   9277e:	f04f 0cff 	mov.w	ip, #255	; 0xff
   92782:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   92786:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   9278a:	bf1d      	ittte	ne
   9278c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   92790:	ea94 0f0c 	teqne	r4, ip
   92794:	ea95 0f0c 	teqne	r5, ip
   92798:	f000 f8de 	bleq	92958 <__aeabi_dmul+0x1dc>
   9279c:	442c      	add	r4, r5
   9279e:	ea81 0603 	eor.w	r6, r1, r3
   927a2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   927a6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   927aa:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   927ae:	bf18      	it	ne
   927b0:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   927b4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   927b8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   927bc:	d038      	beq.n	92830 <__aeabi_dmul+0xb4>
   927be:	fba0 ce02 	umull	ip, lr, r0, r2
   927c2:	f04f 0500 	mov.w	r5, #0
   927c6:	fbe1 e502 	umlal	lr, r5, r1, r2
   927ca:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   927ce:	fbe0 e503 	umlal	lr, r5, r0, r3
   927d2:	f04f 0600 	mov.w	r6, #0
   927d6:	fbe1 5603 	umlal	r5, r6, r1, r3
   927da:	f09c 0f00 	teq	ip, #0
   927de:	bf18      	it	ne
   927e0:	f04e 0e01 	orrne.w	lr, lr, #1
   927e4:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   927e8:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   927ec:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   927f0:	d204      	bcs.n	927fc <__aeabi_dmul+0x80>
   927f2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   927f6:	416d      	adcs	r5, r5
   927f8:	eb46 0606 	adc.w	r6, r6, r6
   927fc:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   92800:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   92804:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   92808:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   9280c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   92810:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   92814:	bf88      	it	hi
   92816:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   9281a:	d81e      	bhi.n	9285a <__aeabi_dmul+0xde>
   9281c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   92820:	bf08      	it	eq
   92822:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   92826:	f150 0000 	adcs.w	r0, r0, #0
   9282a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   9282e:	bd70      	pop	{r4, r5, r6, pc}
   92830:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   92834:	ea46 0101 	orr.w	r1, r6, r1
   92838:	ea40 0002 	orr.w	r0, r0, r2
   9283c:	ea81 0103 	eor.w	r1, r1, r3
   92840:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   92844:	bfc2      	ittt	gt
   92846:	ebd4 050c 	rsbsgt	r5, r4, ip
   9284a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   9284e:	bd70      	popgt	{r4, r5, r6, pc}
   92850:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   92854:	f04f 0e00 	mov.w	lr, #0
   92858:	3c01      	subs	r4, #1
   9285a:	f300 80ab 	bgt.w	929b4 <__aeabi_dmul+0x238>
   9285e:	f114 0f36 	cmn.w	r4, #54	; 0x36
   92862:	bfde      	ittt	le
   92864:	2000      	movle	r0, #0
   92866:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   9286a:	bd70      	pople	{r4, r5, r6, pc}
   9286c:	f1c4 0400 	rsb	r4, r4, #0
   92870:	3c20      	subs	r4, #32
   92872:	da35      	bge.n	928e0 <__aeabi_dmul+0x164>
   92874:	340c      	adds	r4, #12
   92876:	dc1b      	bgt.n	928b0 <__aeabi_dmul+0x134>
   92878:	f104 0414 	add.w	r4, r4, #20
   9287c:	f1c4 0520 	rsb	r5, r4, #32
   92880:	fa00 f305 	lsl.w	r3, r0, r5
   92884:	fa20 f004 	lsr.w	r0, r0, r4
   92888:	fa01 f205 	lsl.w	r2, r1, r5
   9288c:	ea40 0002 	orr.w	r0, r0, r2
   92890:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   92894:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   92898:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   9289c:	fa21 f604 	lsr.w	r6, r1, r4
   928a0:	eb42 0106 	adc.w	r1, r2, r6
   928a4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   928a8:	bf08      	it	eq
   928aa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   928ae:	bd70      	pop	{r4, r5, r6, pc}
   928b0:	f1c4 040c 	rsb	r4, r4, #12
   928b4:	f1c4 0520 	rsb	r5, r4, #32
   928b8:	fa00 f304 	lsl.w	r3, r0, r4
   928bc:	fa20 f005 	lsr.w	r0, r0, r5
   928c0:	fa01 f204 	lsl.w	r2, r1, r4
   928c4:	ea40 0002 	orr.w	r0, r0, r2
   928c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   928cc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   928d0:	f141 0100 	adc.w	r1, r1, #0
   928d4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   928d8:	bf08      	it	eq
   928da:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   928de:	bd70      	pop	{r4, r5, r6, pc}
   928e0:	f1c4 0520 	rsb	r5, r4, #32
   928e4:	fa00 f205 	lsl.w	r2, r0, r5
   928e8:	ea4e 0e02 	orr.w	lr, lr, r2
   928ec:	fa20 f304 	lsr.w	r3, r0, r4
   928f0:	fa01 f205 	lsl.w	r2, r1, r5
   928f4:	ea43 0302 	orr.w	r3, r3, r2
   928f8:	fa21 f004 	lsr.w	r0, r1, r4
   928fc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   92900:	fa21 f204 	lsr.w	r2, r1, r4
   92904:	ea20 0002 	bic.w	r0, r0, r2
   92908:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   9290c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   92910:	bf08      	it	eq
   92912:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   92916:	bd70      	pop	{r4, r5, r6, pc}
   92918:	f094 0f00 	teq	r4, #0
   9291c:	d10f      	bne.n	9293e <__aeabi_dmul+0x1c2>
   9291e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   92922:	0040      	lsls	r0, r0, #1
   92924:	eb41 0101 	adc.w	r1, r1, r1
   92928:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   9292c:	bf08      	it	eq
   9292e:	3c01      	subeq	r4, #1
   92930:	d0f7      	beq.n	92922 <__aeabi_dmul+0x1a6>
   92932:	ea41 0106 	orr.w	r1, r1, r6
   92936:	f095 0f00 	teq	r5, #0
   9293a:	bf18      	it	ne
   9293c:	4770      	bxne	lr
   9293e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   92942:	0052      	lsls	r2, r2, #1
   92944:	eb43 0303 	adc.w	r3, r3, r3
   92948:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   9294c:	bf08      	it	eq
   9294e:	3d01      	subeq	r5, #1
   92950:	d0f7      	beq.n	92942 <__aeabi_dmul+0x1c6>
   92952:	ea43 0306 	orr.w	r3, r3, r6
   92956:	4770      	bx	lr
   92958:	ea94 0f0c 	teq	r4, ip
   9295c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   92960:	bf18      	it	ne
   92962:	ea95 0f0c 	teqne	r5, ip
   92966:	d00c      	beq.n	92982 <__aeabi_dmul+0x206>
   92968:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   9296c:	bf18      	it	ne
   9296e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   92972:	d1d1      	bne.n	92918 <__aeabi_dmul+0x19c>
   92974:	ea81 0103 	eor.w	r1, r1, r3
   92978:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   9297c:	f04f 0000 	mov.w	r0, #0
   92980:	bd70      	pop	{r4, r5, r6, pc}
   92982:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   92986:	bf06      	itte	eq
   92988:	4610      	moveq	r0, r2
   9298a:	4619      	moveq	r1, r3
   9298c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   92990:	d019      	beq.n	929c6 <__aeabi_dmul+0x24a>
   92992:	ea94 0f0c 	teq	r4, ip
   92996:	d102      	bne.n	9299e <__aeabi_dmul+0x222>
   92998:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   9299c:	d113      	bne.n	929c6 <__aeabi_dmul+0x24a>
   9299e:	ea95 0f0c 	teq	r5, ip
   929a2:	d105      	bne.n	929b0 <__aeabi_dmul+0x234>
   929a4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   929a8:	bf1c      	itt	ne
   929aa:	4610      	movne	r0, r2
   929ac:	4619      	movne	r1, r3
   929ae:	d10a      	bne.n	929c6 <__aeabi_dmul+0x24a>
   929b0:	ea81 0103 	eor.w	r1, r1, r3
   929b4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   929b8:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   929bc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   929c0:	f04f 0000 	mov.w	r0, #0
   929c4:	bd70      	pop	{r4, r5, r6, pc}
   929c6:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   929ca:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   929ce:	bd70      	pop	{r4, r5, r6, pc}

000929d0 <__aeabi_ddiv>:
   929d0:	b570      	push	{r4, r5, r6, lr}
   929d2:	f04f 0cff 	mov.w	ip, #255	; 0xff
   929d6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   929da:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   929de:	bf1d      	ittte	ne
   929e0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   929e4:	ea94 0f0c 	teqne	r4, ip
   929e8:	ea95 0f0c 	teqne	r5, ip
   929ec:	f000 f8a7 	bleq	92b3e <__aeabi_ddiv+0x16e>
   929f0:	eba4 0405 	sub.w	r4, r4, r5
   929f4:	ea81 0e03 	eor.w	lr, r1, r3
   929f8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   929fc:	ea4f 3101 	mov.w	r1, r1, lsl #12
   92a00:	f000 8088 	beq.w	92b14 <__aeabi_ddiv+0x144>
   92a04:	ea4f 3303 	mov.w	r3, r3, lsl #12
   92a08:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   92a0c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   92a10:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   92a14:	ea4f 2202 	mov.w	r2, r2, lsl #8
   92a18:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   92a1c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   92a20:	ea4f 2600 	mov.w	r6, r0, lsl #8
   92a24:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   92a28:	429d      	cmp	r5, r3
   92a2a:	bf08      	it	eq
   92a2c:	4296      	cmpeq	r6, r2
   92a2e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   92a32:	f504 7440 	add.w	r4, r4, #768	; 0x300
   92a36:	d202      	bcs.n	92a3e <__aeabi_ddiv+0x6e>
   92a38:	085b      	lsrs	r3, r3, #1
   92a3a:	ea4f 0232 	mov.w	r2, r2, rrx
   92a3e:	1ab6      	subs	r6, r6, r2
   92a40:	eb65 0503 	sbc.w	r5, r5, r3
   92a44:	085b      	lsrs	r3, r3, #1
   92a46:	ea4f 0232 	mov.w	r2, r2, rrx
   92a4a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   92a4e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   92a52:	ebb6 0e02 	subs.w	lr, r6, r2
   92a56:	eb75 0e03 	sbcs.w	lr, r5, r3
   92a5a:	bf22      	ittt	cs
   92a5c:	1ab6      	subcs	r6, r6, r2
   92a5e:	4675      	movcs	r5, lr
   92a60:	ea40 000c 	orrcs.w	r0, r0, ip
   92a64:	085b      	lsrs	r3, r3, #1
   92a66:	ea4f 0232 	mov.w	r2, r2, rrx
   92a6a:	ebb6 0e02 	subs.w	lr, r6, r2
   92a6e:	eb75 0e03 	sbcs.w	lr, r5, r3
   92a72:	bf22      	ittt	cs
   92a74:	1ab6      	subcs	r6, r6, r2
   92a76:	4675      	movcs	r5, lr
   92a78:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   92a7c:	085b      	lsrs	r3, r3, #1
   92a7e:	ea4f 0232 	mov.w	r2, r2, rrx
   92a82:	ebb6 0e02 	subs.w	lr, r6, r2
   92a86:	eb75 0e03 	sbcs.w	lr, r5, r3
   92a8a:	bf22      	ittt	cs
   92a8c:	1ab6      	subcs	r6, r6, r2
   92a8e:	4675      	movcs	r5, lr
   92a90:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   92a94:	085b      	lsrs	r3, r3, #1
   92a96:	ea4f 0232 	mov.w	r2, r2, rrx
   92a9a:	ebb6 0e02 	subs.w	lr, r6, r2
   92a9e:	eb75 0e03 	sbcs.w	lr, r5, r3
   92aa2:	bf22      	ittt	cs
   92aa4:	1ab6      	subcs	r6, r6, r2
   92aa6:	4675      	movcs	r5, lr
   92aa8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   92aac:	ea55 0e06 	orrs.w	lr, r5, r6
   92ab0:	d018      	beq.n	92ae4 <__aeabi_ddiv+0x114>
   92ab2:	ea4f 1505 	mov.w	r5, r5, lsl #4
   92ab6:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   92aba:	ea4f 1606 	mov.w	r6, r6, lsl #4
   92abe:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   92ac2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   92ac6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   92aca:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   92ace:	d1c0      	bne.n	92a52 <__aeabi_ddiv+0x82>
   92ad0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   92ad4:	d10b      	bne.n	92aee <__aeabi_ddiv+0x11e>
   92ad6:	ea41 0100 	orr.w	r1, r1, r0
   92ada:	f04f 0000 	mov.w	r0, #0
   92ade:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   92ae2:	e7b6      	b.n	92a52 <__aeabi_ddiv+0x82>
   92ae4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   92ae8:	bf04      	itt	eq
   92aea:	4301      	orreq	r1, r0
   92aec:	2000      	moveq	r0, #0
   92aee:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   92af2:	bf88      	it	hi
   92af4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   92af8:	f63f aeaf 	bhi.w	9285a <__aeabi_dmul+0xde>
   92afc:	ebb5 0c03 	subs.w	ip, r5, r3
   92b00:	bf04      	itt	eq
   92b02:	ebb6 0c02 	subseq.w	ip, r6, r2
   92b06:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   92b0a:	f150 0000 	adcs.w	r0, r0, #0
   92b0e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   92b12:	bd70      	pop	{r4, r5, r6, pc}
   92b14:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   92b18:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   92b1c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   92b20:	bfc2      	ittt	gt
   92b22:	ebd4 050c 	rsbsgt	r5, r4, ip
   92b26:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   92b2a:	bd70      	popgt	{r4, r5, r6, pc}
   92b2c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   92b30:	f04f 0e00 	mov.w	lr, #0
   92b34:	3c01      	subs	r4, #1
   92b36:	e690      	b.n	9285a <__aeabi_dmul+0xde>
   92b38:	ea45 0e06 	orr.w	lr, r5, r6
   92b3c:	e68d      	b.n	9285a <__aeabi_dmul+0xde>
   92b3e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   92b42:	ea94 0f0c 	teq	r4, ip
   92b46:	bf08      	it	eq
   92b48:	ea95 0f0c 	teqeq	r5, ip
   92b4c:	f43f af3b 	beq.w	929c6 <__aeabi_dmul+0x24a>
   92b50:	ea94 0f0c 	teq	r4, ip
   92b54:	d10a      	bne.n	92b6c <__aeabi_ddiv+0x19c>
   92b56:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   92b5a:	f47f af34 	bne.w	929c6 <__aeabi_dmul+0x24a>
   92b5e:	ea95 0f0c 	teq	r5, ip
   92b62:	f47f af25 	bne.w	929b0 <__aeabi_dmul+0x234>
   92b66:	4610      	mov	r0, r2
   92b68:	4619      	mov	r1, r3
   92b6a:	e72c      	b.n	929c6 <__aeabi_dmul+0x24a>
   92b6c:	ea95 0f0c 	teq	r5, ip
   92b70:	d106      	bne.n	92b80 <__aeabi_ddiv+0x1b0>
   92b72:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   92b76:	f43f aefd 	beq.w	92974 <__aeabi_dmul+0x1f8>
   92b7a:	4610      	mov	r0, r2
   92b7c:	4619      	mov	r1, r3
   92b7e:	e722      	b.n	929c6 <__aeabi_dmul+0x24a>
   92b80:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   92b84:	bf18      	it	ne
   92b86:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   92b8a:	f47f aec5 	bne.w	92918 <__aeabi_dmul+0x19c>
   92b8e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   92b92:	f47f af0d 	bne.w	929b0 <__aeabi_dmul+0x234>
   92b96:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   92b9a:	f47f aeeb 	bne.w	92974 <__aeabi_dmul+0x1f8>
   92b9e:	e712      	b.n	929c6 <__aeabi_dmul+0x24a>

00092ba0 <__gedf2>:
   92ba0:	f04f 3cff 	mov.w	ip, #4294967295
   92ba4:	e006      	b.n	92bb4 <__cmpdf2+0x4>
   92ba6:	bf00      	nop

00092ba8 <__ledf2>:
   92ba8:	f04f 0c01 	mov.w	ip, #1
   92bac:	e002      	b.n	92bb4 <__cmpdf2+0x4>
   92bae:	bf00      	nop

00092bb0 <__cmpdf2>:
   92bb0:	f04f 0c01 	mov.w	ip, #1
   92bb4:	f84d cd04 	str.w	ip, [sp, #-4]!
   92bb8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   92bbc:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   92bc0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   92bc4:	bf18      	it	ne
   92bc6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
   92bca:	d01b      	beq.n	92c04 <__cmpdf2+0x54>
   92bcc:	b001      	add	sp, #4
   92bce:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
   92bd2:	bf0c      	ite	eq
   92bd4:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
   92bd8:	ea91 0f03 	teqne	r1, r3
   92bdc:	bf02      	ittt	eq
   92bde:	ea90 0f02 	teqeq	r0, r2
   92be2:	2000      	moveq	r0, #0
   92be4:	4770      	bxeq	lr
   92be6:	f110 0f00 	cmn.w	r0, #0
   92bea:	ea91 0f03 	teq	r1, r3
   92bee:	bf58      	it	pl
   92bf0:	4299      	cmppl	r1, r3
   92bf2:	bf08      	it	eq
   92bf4:	4290      	cmpeq	r0, r2
   92bf6:	bf2c      	ite	cs
   92bf8:	17d8      	asrcs	r0, r3, #31
   92bfa:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
   92bfe:	f040 0001 	orr.w	r0, r0, #1
   92c02:	4770      	bx	lr
   92c04:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   92c08:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   92c0c:	d102      	bne.n	92c14 <__cmpdf2+0x64>
   92c0e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   92c12:	d107      	bne.n	92c24 <__cmpdf2+0x74>
   92c14:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   92c18:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   92c1c:	d1d6      	bne.n	92bcc <__cmpdf2+0x1c>
   92c1e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   92c22:	d0d3      	beq.n	92bcc <__cmpdf2+0x1c>
   92c24:	f85d 0b04 	ldr.w	r0, [sp], #4
   92c28:	4770      	bx	lr
   92c2a:	bf00      	nop

00092c2c <__aeabi_cdrcmple>:
   92c2c:	4684      	mov	ip, r0
   92c2e:	4610      	mov	r0, r2
   92c30:	4662      	mov	r2, ip
   92c32:	468c      	mov	ip, r1
   92c34:	4619      	mov	r1, r3
   92c36:	4663      	mov	r3, ip
   92c38:	e000      	b.n	92c3c <__aeabi_cdcmpeq>
   92c3a:	bf00      	nop

00092c3c <__aeabi_cdcmpeq>:
   92c3c:	b501      	push	{r0, lr}
   92c3e:	f7ff ffb7 	bl	92bb0 <__cmpdf2>
   92c42:	2800      	cmp	r0, #0
   92c44:	bf48      	it	mi
   92c46:	f110 0f00 	cmnmi.w	r0, #0
   92c4a:	bd01      	pop	{r0, pc}

00092c4c <__aeabi_dcmpeq>:
   92c4c:	f84d ed08 	str.w	lr, [sp, #-8]!
   92c50:	f7ff fff4 	bl	92c3c <__aeabi_cdcmpeq>
   92c54:	bf0c      	ite	eq
   92c56:	2001      	moveq	r0, #1
   92c58:	2000      	movne	r0, #0
   92c5a:	f85d fb08 	ldr.w	pc, [sp], #8
   92c5e:	bf00      	nop

00092c60 <__aeabi_dcmplt>:
   92c60:	f84d ed08 	str.w	lr, [sp, #-8]!
   92c64:	f7ff ffea 	bl	92c3c <__aeabi_cdcmpeq>
   92c68:	bf34      	ite	cc
   92c6a:	2001      	movcc	r0, #1
   92c6c:	2000      	movcs	r0, #0
   92c6e:	f85d fb08 	ldr.w	pc, [sp], #8
   92c72:	bf00      	nop

00092c74 <__aeabi_dcmple>:
   92c74:	f84d ed08 	str.w	lr, [sp, #-8]!
   92c78:	f7ff ffe0 	bl	92c3c <__aeabi_cdcmpeq>
   92c7c:	bf94      	ite	ls
   92c7e:	2001      	movls	r0, #1
   92c80:	2000      	movhi	r0, #0
   92c82:	f85d fb08 	ldr.w	pc, [sp], #8
   92c86:	bf00      	nop

00092c88 <__aeabi_dcmpge>:
   92c88:	f84d ed08 	str.w	lr, [sp, #-8]!
   92c8c:	f7ff ffce 	bl	92c2c <__aeabi_cdrcmple>
   92c90:	bf94      	ite	ls
   92c92:	2001      	movls	r0, #1
   92c94:	2000      	movhi	r0, #0
   92c96:	f85d fb08 	ldr.w	pc, [sp], #8
   92c9a:	bf00      	nop

00092c9c <__aeabi_dcmpgt>:
   92c9c:	f84d ed08 	str.w	lr, [sp, #-8]!
   92ca0:	f7ff ffc4 	bl	92c2c <__aeabi_cdrcmple>
   92ca4:	bf34      	ite	cc
   92ca6:	2001      	movcc	r0, #1
   92ca8:	2000      	movcs	r0, #0
   92caa:	f85d fb08 	ldr.w	pc, [sp], #8
   92cae:	bf00      	nop

00092cb0 <__aeabi_dcmpun>:
   92cb0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   92cb4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   92cb8:	d102      	bne.n	92cc0 <__aeabi_dcmpun+0x10>
   92cba:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   92cbe:	d10a      	bne.n	92cd6 <__aeabi_dcmpun+0x26>
   92cc0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   92cc4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   92cc8:	d102      	bne.n	92cd0 <__aeabi_dcmpun+0x20>
   92cca:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   92cce:	d102      	bne.n	92cd6 <__aeabi_dcmpun+0x26>
   92cd0:	f04f 0000 	mov.w	r0, #0
   92cd4:	4770      	bx	lr
   92cd6:	f04f 0001 	mov.w	r0, #1
   92cda:	4770      	bx	lr

00092cdc <__aeabi_d2iz>:
   92cdc:	ea4f 0241 	mov.w	r2, r1, lsl #1
   92ce0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   92ce4:	d215      	bcs.n	92d12 <__aeabi_d2iz+0x36>
   92ce6:	d511      	bpl.n	92d0c <__aeabi_d2iz+0x30>
   92ce8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   92cec:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   92cf0:	d912      	bls.n	92d18 <__aeabi_d2iz+0x3c>
   92cf2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   92cf6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   92cfa:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   92cfe:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   92d02:	fa23 f002 	lsr.w	r0, r3, r2
   92d06:	bf18      	it	ne
   92d08:	4240      	negne	r0, r0
   92d0a:	4770      	bx	lr
   92d0c:	f04f 0000 	mov.w	r0, #0
   92d10:	4770      	bx	lr
   92d12:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   92d16:	d105      	bne.n	92d24 <__aeabi_d2iz+0x48>
   92d18:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
   92d1c:	bf08      	it	eq
   92d1e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   92d22:	4770      	bx	lr
   92d24:	f04f 0000 	mov.w	r0, #0
   92d28:	4770      	bx	lr
   92d2a:	bf00      	nop

00092d2c <__aeabi_d2uiz>:
   92d2c:	004a      	lsls	r2, r1, #1
   92d2e:	d211      	bcs.n	92d54 <__aeabi_d2uiz+0x28>
   92d30:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   92d34:	d211      	bcs.n	92d5a <__aeabi_d2uiz+0x2e>
   92d36:	d50d      	bpl.n	92d54 <__aeabi_d2uiz+0x28>
   92d38:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   92d3c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   92d40:	d40e      	bmi.n	92d60 <__aeabi_d2uiz+0x34>
   92d42:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   92d46:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   92d4a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   92d4e:	fa23 f002 	lsr.w	r0, r3, r2
   92d52:	4770      	bx	lr
   92d54:	f04f 0000 	mov.w	r0, #0
   92d58:	4770      	bx	lr
   92d5a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   92d5e:	d102      	bne.n	92d66 <__aeabi_d2uiz+0x3a>
   92d60:	f04f 30ff 	mov.w	r0, #4294967295
   92d64:	4770      	bx	lr
   92d66:	f04f 0000 	mov.w	r0, #0
   92d6a:	4770      	bx	lr

00092d6c <__aeabi_d2f>:
   92d6c:	ea4f 0241 	mov.w	r2, r1, lsl #1
   92d70:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   92d74:	bf24      	itt	cs
   92d76:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   92d7a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   92d7e:	d90d      	bls.n	92d9c <__aeabi_d2f+0x30>
   92d80:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   92d84:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   92d88:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   92d8c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   92d90:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   92d94:	bf08      	it	eq
   92d96:	f020 0001 	biceq.w	r0, r0, #1
   92d9a:	4770      	bx	lr
   92d9c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   92da0:	d121      	bne.n	92de6 <__aeabi_d2f+0x7a>
   92da2:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   92da6:	bfbc      	itt	lt
   92da8:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   92dac:	4770      	bxlt	lr
   92dae:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   92db2:	ea4f 5252 	mov.w	r2, r2, lsr #21
   92db6:	f1c2 0218 	rsb	r2, r2, #24
   92dba:	f1c2 0c20 	rsb	ip, r2, #32
   92dbe:	fa10 f30c 	lsls.w	r3, r0, ip
   92dc2:	fa20 f002 	lsr.w	r0, r0, r2
   92dc6:	bf18      	it	ne
   92dc8:	f040 0001 	orrne.w	r0, r0, #1
   92dcc:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   92dd0:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   92dd4:	fa03 fc0c 	lsl.w	ip, r3, ip
   92dd8:	ea40 000c 	orr.w	r0, r0, ip
   92ddc:	fa23 f302 	lsr.w	r3, r3, r2
   92de0:	ea4f 0343 	mov.w	r3, r3, lsl #1
   92de4:	e7cc      	b.n	92d80 <__aeabi_d2f+0x14>
   92de6:	ea7f 5362 	mvns.w	r3, r2, asr #21
   92dea:	d107      	bne.n	92dfc <__aeabi_d2f+0x90>
   92dec:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   92df0:	bf1e      	ittt	ne
   92df2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   92df6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   92dfa:	4770      	bxne	lr
   92dfc:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   92e00:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   92e04:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   92e08:	4770      	bx	lr
   92e0a:	bf00      	nop

00092e0c <__aeabi_frsub>:
   92e0c:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
   92e10:	e002      	b.n	92e18 <__addsf3>
   92e12:	bf00      	nop

00092e14 <__aeabi_fsub>:
   92e14:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

00092e18 <__addsf3>:
   92e18:	0042      	lsls	r2, r0, #1
   92e1a:	bf1f      	itttt	ne
   92e1c:	ea5f 0341 	movsne.w	r3, r1, lsl #1
   92e20:	ea92 0f03 	teqne	r2, r3
   92e24:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
   92e28:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   92e2c:	d06a      	beq.n	92f04 <__addsf3+0xec>
   92e2e:	ea4f 6212 	mov.w	r2, r2, lsr #24
   92e32:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
   92e36:	bfc1      	itttt	gt
   92e38:	18d2      	addgt	r2, r2, r3
   92e3a:	4041      	eorgt	r1, r0
   92e3c:	4048      	eorgt	r0, r1
   92e3e:	4041      	eorgt	r1, r0
   92e40:	bfb8      	it	lt
   92e42:	425b      	neglt	r3, r3
   92e44:	2b19      	cmp	r3, #25
   92e46:	bf88      	it	hi
   92e48:	4770      	bxhi	lr
   92e4a:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   92e4e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   92e52:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   92e56:	bf18      	it	ne
   92e58:	4240      	negne	r0, r0
   92e5a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   92e5e:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
   92e62:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
   92e66:	bf18      	it	ne
   92e68:	4249      	negne	r1, r1
   92e6a:	ea92 0f03 	teq	r2, r3
   92e6e:	d03f      	beq.n	92ef0 <__addsf3+0xd8>
   92e70:	f1a2 0201 	sub.w	r2, r2, #1
   92e74:	fa41 fc03 	asr.w	ip, r1, r3
   92e78:	eb10 000c 	adds.w	r0, r0, ip
   92e7c:	f1c3 0320 	rsb	r3, r3, #32
   92e80:	fa01 f103 	lsl.w	r1, r1, r3
   92e84:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   92e88:	d502      	bpl.n	92e90 <__addsf3+0x78>
   92e8a:	4249      	negs	r1, r1
   92e8c:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
   92e90:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   92e94:	d313      	bcc.n	92ebe <__addsf3+0xa6>
   92e96:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
   92e9a:	d306      	bcc.n	92eaa <__addsf3+0x92>
   92e9c:	0840      	lsrs	r0, r0, #1
   92e9e:	ea4f 0131 	mov.w	r1, r1, rrx
   92ea2:	f102 0201 	add.w	r2, r2, #1
   92ea6:	2afe      	cmp	r2, #254	; 0xfe
   92ea8:	d251      	bcs.n	92f4e <__addsf3+0x136>
   92eaa:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
   92eae:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   92eb2:	bf08      	it	eq
   92eb4:	f020 0001 	biceq.w	r0, r0, #1
   92eb8:	ea40 0003 	orr.w	r0, r0, r3
   92ebc:	4770      	bx	lr
   92ebe:	0049      	lsls	r1, r1, #1
   92ec0:	eb40 0000 	adc.w	r0, r0, r0
   92ec4:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
   92ec8:	f1a2 0201 	sub.w	r2, r2, #1
   92ecc:	d1ed      	bne.n	92eaa <__addsf3+0x92>
   92ece:	fab0 fc80 	clz	ip, r0
   92ed2:	f1ac 0c08 	sub.w	ip, ip, #8
   92ed6:	ebb2 020c 	subs.w	r2, r2, ip
   92eda:	fa00 f00c 	lsl.w	r0, r0, ip
   92ede:	bfaa      	itet	ge
   92ee0:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
   92ee4:	4252      	neglt	r2, r2
   92ee6:	4318      	orrge	r0, r3
   92ee8:	bfbc      	itt	lt
   92eea:	40d0      	lsrlt	r0, r2
   92eec:	4318      	orrlt	r0, r3
   92eee:	4770      	bx	lr
   92ef0:	f092 0f00 	teq	r2, #0
   92ef4:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
   92ef8:	bf06      	itte	eq
   92efa:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
   92efe:	3201      	addeq	r2, #1
   92f00:	3b01      	subne	r3, #1
   92f02:	e7b5      	b.n	92e70 <__addsf3+0x58>
   92f04:	ea4f 0341 	mov.w	r3, r1, lsl #1
   92f08:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   92f0c:	bf18      	it	ne
   92f0e:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   92f12:	d021      	beq.n	92f58 <__addsf3+0x140>
   92f14:	ea92 0f03 	teq	r2, r3
   92f18:	d004      	beq.n	92f24 <__addsf3+0x10c>
   92f1a:	f092 0f00 	teq	r2, #0
   92f1e:	bf08      	it	eq
   92f20:	4608      	moveq	r0, r1
   92f22:	4770      	bx	lr
   92f24:	ea90 0f01 	teq	r0, r1
   92f28:	bf1c      	itt	ne
   92f2a:	2000      	movne	r0, #0
   92f2c:	4770      	bxne	lr
   92f2e:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
   92f32:	d104      	bne.n	92f3e <__addsf3+0x126>
   92f34:	0040      	lsls	r0, r0, #1
   92f36:	bf28      	it	cs
   92f38:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
   92f3c:	4770      	bx	lr
   92f3e:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
   92f42:	bf3c      	itt	cc
   92f44:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
   92f48:	4770      	bxcc	lr
   92f4a:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   92f4e:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
   92f52:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   92f56:	4770      	bx	lr
   92f58:	ea7f 6222 	mvns.w	r2, r2, asr #24
   92f5c:	bf16      	itet	ne
   92f5e:	4608      	movne	r0, r1
   92f60:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
   92f64:	4601      	movne	r1, r0
   92f66:	0242      	lsls	r2, r0, #9
   92f68:	bf06      	itte	eq
   92f6a:	ea5f 2341 	movseq.w	r3, r1, lsl #9
   92f6e:	ea90 0f01 	teqeq	r0, r1
   92f72:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
   92f76:	4770      	bx	lr

00092f78 <__aeabi_ui2f>:
   92f78:	f04f 0300 	mov.w	r3, #0
   92f7c:	e004      	b.n	92f88 <__aeabi_i2f+0x8>
   92f7e:	bf00      	nop

00092f80 <__aeabi_i2f>:
   92f80:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
   92f84:	bf48      	it	mi
   92f86:	4240      	negmi	r0, r0
   92f88:	ea5f 0c00 	movs.w	ip, r0
   92f8c:	bf08      	it	eq
   92f8e:	4770      	bxeq	lr
   92f90:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
   92f94:	4601      	mov	r1, r0
   92f96:	f04f 0000 	mov.w	r0, #0
   92f9a:	e01c      	b.n	92fd6 <__aeabi_l2f+0x2a>

00092f9c <__aeabi_ul2f>:
   92f9c:	ea50 0201 	orrs.w	r2, r0, r1
   92fa0:	bf08      	it	eq
   92fa2:	4770      	bxeq	lr
   92fa4:	f04f 0300 	mov.w	r3, #0
   92fa8:	e00a      	b.n	92fc0 <__aeabi_l2f+0x14>
   92faa:	bf00      	nop

00092fac <__aeabi_l2f>:
   92fac:	ea50 0201 	orrs.w	r2, r0, r1
   92fb0:	bf08      	it	eq
   92fb2:	4770      	bxeq	lr
   92fb4:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
   92fb8:	d502      	bpl.n	92fc0 <__aeabi_l2f+0x14>
   92fba:	4240      	negs	r0, r0
   92fbc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   92fc0:	ea5f 0c01 	movs.w	ip, r1
   92fc4:	bf02      	ittt	eq
   92fc6:	4684      	moveq	ip, r0
   92fc8:	4601      	moveq	r1, r0
   92fca:	2000      	moveq	r0, #0
   92fcc:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
   92fd0:	bf08      	it	eq
   92fd2:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
   92fd6:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   92fda:	fabc f28c 	clz	r2, ip
   92fde:	3a08      	subs	r2, #8
   92fe0:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
   92fe4:	db10      	blt.n	93008 <__aeabi_l2f+0x5c>
   92fe6:	fa01 fc02 	lsl.w	ip, r1, r2
   92fea:	4463      	add	r3, ip
   92fec:	fa00 fc02 	lsl.w	ip, r0, r2
   92ff0:	f1c2 0220 	rsb	r2, r2, #32
   92ff4:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   92ff8:	fa20 f202 	lsr.w	r2, r0, r2
   92ffc:	eb43 0002 	adc.w	r0, r3, r2
   93000:	bf08      	it	eq
   93002:	f020 0001 	biceq.w	r0, r0, #1
   93006:	4770      	bx	lr
   93008:	f102 0220 	add.w	r2, r2, #32
   9300c:	fa01 fc02 	lsl.w	ip, r1, r2
   93010:	f1c2 0220 	rsb	r2, r2, #32
   93014:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
   93018:	fa21 f202 	lsr.w	r2, r1, r2
   9301c:	eb43 0002 	adc.w	r0, r3, r2
   93020:	bf08      	it	eq
   93022:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   93026:	4770      	bx	lr

00093028 <__aeabi_fmul>:
   93028:	f04f 0cff 	mov.w	ip, #255	; 0xff
   9302c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
   93030:	bf1e      	ittt	ne
   93032:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
   93036:	ea92 0f0c 	teqne	r2, ip
   9303a:	ea93 0f0c 	teqne	r3, ip
   9303e:	d06f      	beq.n	93120 <__aeabi_fmul+0xf8>
   93040:	441a      	add	r2, r3
   93042:	ea80 0c01 	eor.w	ip, r0, r1
   93046:	0240      	lsls	r0, r0, #9
   93048:	bf18      	it	ne
   9304a:	ea5f 2141 	movsne.w	r1, r1, lsl #9
   9304e:	d01e      	beq.n	9308e <__aeabi_fmul+0x66>
   93050:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   93054:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
   93058:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
   9305c:	fba0 3101 	umull	r3, r1, r0, r1
   93060:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
   93064:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
   93068:	bf3e      	ittt	cc
   9306a:	0049      	lslcc	r1, r1, #1
   9306c:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
   93070:	005b      	lslcc	r3, r3, #1
   93072:	ea40 0001 	orr.w	r0, r0, r1
   93076:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
   9307a:	2afd      	cmp	r2, #253	; 0xfd
   9307c:	d81d      	bhi.n	930ba <__aeabi_fmul+0x92>
   9307e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   93082:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   93086:	bf08      	it	eq
   93088:	f020 0001 	biceq.w	r0, r0, #1
   9308c:	4770      	bx	lr
   9308e:	f090 0f00 	teq	r0, #0
   93092:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
   93096:	bf08      	it	eq
   93098:	0249      	lsleq	r1, r1, #9
   9309a:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
   9309e:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
   930a2:	3a7f      	subs	r2, #127	; 0x7f
   930a4:	bfc2      	ittt	gt
   930a6:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
   930aa:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
   930ae:	4770      	bxgt	lr
   930b0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   930b4:	f04f 0300 	mov.w	r3, #0
   930b8:	3a01      	subs	r2, #1
   930ba:	dc5d      	bgt.n	93178 <__aeabi_fmul+0x150>
   930bc:	f112 0f19 	cmn.w	r2, #25
   930c0:	bfdc      	itt	le
   930c2:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
   930c6:	4770      	bxle	lr
   930c8:	f1c2 0200 	rsb	r2, r2, #0
   930cc:	0041      	lsls	r1, r0, #1
   930ce:	fa21 f102 	lsr.w	r1, r1, r2
   930d2:	f1c2 0220 	rsb	r2, r2, #32
   930d6:	fa00 fc02 	lsl.w	ip, r0, r2
   930da:	ea5f 0031 	movs.w	r0, r1, rrx
   930de:	f140 0000 	adc.w	r0, r0, #0
   930e2:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
   930e6:	bf08      	it	eq
   930e8:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   930ec:	4770      	bx	lr
   930ee:	f092 0f00 	teq	r2, #0
   930f2:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
   930f6:	bf02      	ittt	eq
   930f8:	0040      	lsleq	r0, r0, #1
   930fa:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
   930fe:	3a01      	subeq	r2, #1
   93100:	d0f9      	beq.n	930f6 <__aeabi_fmul+0xce>
   93102:	ea40 000c 	orr.w	r0, r0, ip
   93106:	f093 0f00 	teq	r3, #0
   9310a:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   9310e:	bf02      	ittt	eq
   93110:	0049      	lsleq	r1, r1, #1
   93112:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
   93116:	3b01      	subeq	r3, #1
   93118:	d0f9      	beq.n	9310e <__aeabi_fmul+0xe6>
   9311a:	ea41 010c 	orr.w	r1, r1, ip
   9311e:	e78f      	b.n	93040 <__aeabi_fmul+0x18>
   93120:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
   93124:	ea92 0f0c 	teq	r2, ip
   93128:	bf18      	it	ne
   9312a:	ea93 0f0c 	teqne	r3, ip
   9312e:	d00a      	beq.n	93146 <__aeabi_fmul+0x11e>
   93130:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
   93134:	bf18      	it	ne
   93136:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
   9313a:	d1d8      	bne.n	930ee <__aeabi_fmul+0xc6>
   9313c:	ea80 0001 	eor.w	r0, r0, r1
   93140:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   93144:	4770      	bx	lr
   93146:	f090 0f00 	teq	r0, #0
   9314a:	bf17      	itett	ne
   9314c:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
   93150:	4608      	moveq	r0, r1
   93152:	f091 0f00 	teqne	r1, #0
   93156:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
   9315a:	d014      	beq.n	93186 <__aeabi_fmul+0x15e>
   9315c:	ea92 0f0c 	teq	r2, ip
   93160:	d101      	bne.n	93166 <__aeabi_fmul+0x13e>
   93162:	0242      	lsls	r2, r0, #9
   93164:	d10f      	bne.n	93186 <__aeabi_fmul+0x15e>
   93166:	ea93 0f0c 	teq	r3, ip
   9316a:	d103      	bne.n	93174 <__aeabi_fmul+0x14c>
   9316c:	024b      	lsls	r3, r1, #9
   9316e:	bf18      	it	ne
   93170:	4608      	movne	r0, r1
   93172:	d108      	bne.n	93186 <__aeabi_fmul+0x15e>
   93174:	ea80 0001 	eor.w	r0, r0, r1
   93178:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   9317c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   93180:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   93184:	4770      	bx	lr
   93186:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   9318a:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
   9318e:	4770      	bx	lr

00093190 <__aeabi_fdiv>:
   93190:	f04f 0cff 	mov.w	ip, #255	; 0xff
   93194:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
   93198:	bf1e      	ittt	ne
   9319a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
   9319e:	ea92 0f0c 	teqne	r2, ip
   931a2:	ea93 0f0c 	teqne	r3, ip
   931a6:	d069      	beq.n	9327c <__aeabi_fdiv+0xec>
   931a8:	eba2 0203 	sub.w	r2, r2, r3
   931ac:	ea80 0c01 	eor.w	ip, r0, r1
   931b0:	0249      	lsls	r1, r1, #9
   931b2:	ea4f 2040 	mov.w	r0, r0, lsl #9
   931b6:	d037      	beq.n	93228 <__aeabi_fdiv+0x98>
   931b8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   931bc:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
   931c0:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
   931c4:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
   931c8:	428b      	cmp	r3, r1
   931ca:	bf38      	it	cc
   931cc:	005b      	lslcc	r3, r3, #1
   931ce:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
   931d2:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
   931d6:	428b      	cmp	r3, r1
   931d8:	bf24      	itt	cs
   931da:	1a5b      	subcs	r3, r3, r1
   931dc:	ea40 000c 	orrcs.w	r0, r0, ip
   931e0:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
   931e4:	bf24      	itt	cs
   931e6:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
   931ea:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   931ee:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
   931f2:	bf24      	itt	cs
   931f4:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
   931f8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   931fc:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   93200:	bf24      	itt	cs
   93202:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
   93206:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   9320a:	011b      	lsls	r3, r3, #4
   9320c:	bf18      	it	ne
   9320e:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
   93212:	d1e0      	bne.n	931d6 <__aeabi_fdiv+0x46>
   93214:	2afd      	cmp	r2, #253	; 0xfd
   93216:	f63f af50 	bhi.w	930ba <__aeabi_fmul+0x92>
   9321a:	428b      	cmp	r3, r1
   9321c:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   93220:	bf08      	it	eq
   93222:	f020 0001 	biceq.w	r0, r0, #1
   93226:	4770      	bx	lr
   93228:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
   9322c:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
   93230:	327f      	adds	r2, #127	; 0x7f
   93232:	bfc2      	ittt	gt
   93234:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
   93238:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
   9323c:	4770      	bxgt	lr
   9323e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   93242:	f04f 0300 	mov.w	r3, #0
   93246:	3a01      	subs	r2, #1
   93248:	e737      	b.n	930ba <__aeabi_fmul+0x92>
   9324a:	f092 0f00 	teq	r2, #0
   9324e:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
   93252:	bf02      	ittt	eq
   93254:	0040      	lsleq	r0, r0, #1
   93256:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
   9325a:	3a01      	subeq	r2, #1
   9325c:	d0f9      	beq.n	93252 <__aeabi_fdiv+0xc2>
   9325e:	ea40 000c 	orr.w	r0, r0, ip
   93262:	f093 0f00 	teq	r3, #0
   93266:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   9326a:	bf02      	ittt	eq
   9326c:	0049      	lsleq	r1, r1, #1
   9326e:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
   93272:	3b01      	subeq	r3, #1
   93274:	d0f9      	beq.n	9326a <__aeabi_fdiv+0xda>
   93276:	ea41 010c 	orr.w	r1, r1, ip
   9327a:	e795      	b.n	931a8 <__aeabi_fdiv+0x18>
   9327c:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
   93280:	ea92 0f0c 	teq	r2, ip
   93284:	d108      	bne.n	93298 <__aeabi_fdiv+0x108>
   93286:	0242      	lsls	r2, r0, #9
   93288:	f47f af7d 	bne.w	93186 <__aeabi_fmul+0x15e>
   9328c:	ea93 0f0c 	teq	r3, ip
   93290:	f47f af70 	bne.w	93174 <__aeabi_fmul+0x14c>
   93294:	4608      	mov	r0, r1
   93296:	e776      	b.n	93186 <__aeabi_fmul+0x15e>
   93298:	ea93 0f0c 	teq	r3, ip
   9329c:	d104      	bne.n	932a8 <__aeabi_fdiv+0x118>
   9329e:	024b      	lsls	r3, r1, #9
   932a0:	f43f af4c 	beq.w	9313c <__aeabi_fmul+0x114>
   932a4:	4608      	mov	r0, r1
   932a6:	e76e      	b.n	93186 <__aeabi_fmul+0x15e>
   932a8:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
   932ac:	bf18      	it	ne
   932ae:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
   932b2:	d1ca      	bne.n	9324a <__aeabi_fdiv+0xba>
   932b4:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
   932b8:	f47f af5c 	bne.w	93174 <__aeabi_fmul+0x14c>
   932bc:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
   932c0:	f47f af3c 	bne.w	9313c <__aeabi_fmul+0x114>
   932c4:	e75f      	b.n	93186 <__aeabi_fmul+0x15e>
   932c6:	bf00      	nop

000932c8 <__gesf2>:
   932c8:	f04f 3cff 	mov.w	ip, #4294967295
   932cc:	e006      	b.n	932dc <__cmpsf2+0x4>
   932ce:	bf00      	nop

000932d0 <__lesf2>:
   932d0:	f04f 0c01 	mov.w	ip, #1
   932d4:	e002      	b.n	932dc <__cmpsf2+0x4>
   932d6:	bf00      	nop

000932d8 <__cmpsf2>:
   932d8:	f04f 0c01 	mov.w	ip, #1
   932dc:	f84d cd04 	str.w	ip, [sp, #-4]!
   932e0:	ea4f 0240 	mov.w	r2, r0, lsl #1
   932e4:	ea4f 0341 	mov.w	r3, r1, lsl #1
   932e8:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   932ec:	bf18      	it	ne
   932ee:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   932f2:	d011      	beq.n	93318 <__cmpsf2+0x40>
   932f4:	b001      	add	sp, #4
   932f6:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
   932fa:	bf18      	it	ne
   932fc:	ea90 0f01 	teqne	r0, r1
   93300:	bf58      	it	pl
   93302:	ebb2 0003 	subspl.w	r0, r2, r3
   93306:	bf88      	it	hi
   93308:	17c8      	asrhi	r0, r1, #31
   9330a:	bf38      	it	cc
   9330c:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
   93310:	bf18      	it	ne
   93312:	f040 0001 	orrne.w	r0, r0, #1
   93316:	4770      	bx	lr
   93318:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   9331c:	d102      	bne.n	93324 <__cmpsf2+0x4c>
   9331e:	ea5f 2c40 	movs.w	ip, r0, lsl #9
   93322:	d105      	bne.n	93330 <__cmpsf2+0x58>
   93324:	ea7f 6c23 	mvns.w	ip, r3, asr #24
   93328:	d1e4      	bne.n	932f4 <__cmpsf2+0x1c>
   9332a:	ea5f 2c41 	movs.w	ip, r1, lsl #9
   9332e:	d0e1      	beq.n	932f4 <__cmpsf2+0x1c>
   93330:	f85d 0b04 	ldr.w	r0, [sp], #4
   93334:	4770      	bx	lr
   93336:	bf00      	nop

00093338 <__aeabi_cfrcmple>:
   93338:	4684      	mov	ip, r0
   9333a:	4608      	mov	r0, r1
   9333c:	4661      	mov	r1, ip
   9333e:	e7ff      	b.n	93340 <__aeabi_cfcmpeq>

00093340 <__aeabi_cfcmpeq>:
   93340:	b50f      	push	{r0, r1, r2, r3, lr}
   93342:	f7ff ffc9 	bl	932d8 <__cmpsf2>
   93346:	2800      	cmp	r0, #0
   93348:	bf48      	it	mi
   9334a:	f110 0f00 	cmnmi.w	r0, #0
   9334e:	bd0f      	pop	{r0, r1, r2, r3, pc}

00093350 <__aeabi_fcmpeq>:
   93350:	f84d ed08 	str.w	lr, [sp, #-8]!
   93354:	f7ff fff4 	bl	93340 <__aeabi_cfcmpeq>
   93358:	bf0c      	ite	eq
   9335a:	2001      	moveq	r0, #1
   9335c:	2000      	movne	r0, #0
   9335e:	f85d fb08 	ldr.w	pc, [sp], #8
   93362:	bf00      	nop

00093364 <__aeabi_fcmplt>:
   93364:	f84d ed08 	str.w	lr, [sp, #-8]!
   93368:	f7ff ffea 	bl	93340 <__aeabi_cfcmpeq>
   9336c:	bf34      	ite	cc
   9336e:	2001      	movcc	r0, #1
   93370:	2000      	movcs	r0, #0
   93372:	f85d fb08 	ldr.w	pc, [sp], #8
   93376:	bf00      	nop

00093378 <__aeabi_fcmple>:
   93378:	f84d ed08 	str.w	lr, [sp, #-8]!
   9337c:	f7ff ffe0 	bl	93340 <__aeabi_cfcmpeq>
   93380:	bf94      	ite	ls
   93382:	2001      	movls	r0, #1
   93384:	2000      	movhi	r0, #0
   93386:	f85d fb08 	ldr.w	pc, [sp], #8
   9338a:	bf00      	nop

0009338c <__aeabi_fcmpge>:
   9338c:	f84d ed08 	str.w	lr, [sp, #-8]!
   93390:	f7ff ffd2 	bl	93338 <__aeabi_cfrcmple>
   93394:	bf94      	ite	ls
   93396:	2001      	movls	r0, #1
   93398:	2000      	movhi	r0, #0
   9339a:	f85d fb08 	ldr.w	pc, [sp], #8
   9339e:	bf00      	nop

000933a0 <__aeabi_fcmpgt>:
   933a0:	f84d ed08 	str.w	lr, [sp, #-8]!
   933a4:	f7ff ffc8 	bl	93338 <__aeabi_cfrcmple>
   933a8:	bf34      	ite	cc
   933aa:	2001      	movcc	r0, #1
   933ac:	2000      	movcs	r0, #0
   933ae:	f85d fb08 	ldr.w	pc, [sp], #8
   933b2:	bf00      	nop

000933b4 <__aeabi_f2iz>:
   933b4:	ea4f 0240 	mov.w	r2, r0, lsl #1
   933b8:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
   933bc:	d30f      	bcc.n	933de <__aeabi_f2iz+0x2a>
   933be:	f04f 039e 	mov.w	r3, #158	; 0x9e
   933c2:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
   933c6:	d90d      	bls.n	933e4 <__aeabi_f2iz+0x30>
   933c8:	ea4f 2300 	mov.w	r3, r0, lsl #8
   933cc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   933d0:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   933d4:	fa23 f002 	lsr.w	r0, r3, r2
   933d8:	bf18      	it	ne
   933da:	4240      	negne	r0, r0
   933dc:	4770      	bx	lr
   933de:	f04f 0000 	mov.w	r0, #0
   933e2:	4770      	bx	lr
   933e4:	f112 0f61 	cmn.w	r2, #97	; 0x61
   933e8:	d101      	bne.n	933ee <__aeabi_f2iz+0x3a>
   933ea:	0242      	lsls	r2, r0, #9
   933ec:	d105      	bne.n	933fa <__aeabi_f2iz+0x46>
   933ee:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
   933f2:	bf08      	it	eq
   933f4:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
   933f8:	4770      	bx	lr
   933fa:	f04f 0000 	mov.w	r0, #0
   933fe:	4770      	bx	lr

00093400 <__aeabi_f2uiz>:
   93400:	0042      	lsls	r2, r0, #1
   93402:	d20e      	bcs.n	93422 <__aeabi_f2uiz+0x22>
   93404:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
   93408:	d30b      	bcc.n	93422 <__aeabi_f2uiz+0x22>
   9340a:	f04f 039e 	mov.w	r3, #158	; 0x9e
   9340e:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
   93412:	d409      	bmi.n	93428 <__aeabi_f2uiz+0x28>
   93414:	ea4f 2300 	mov.w	r3, r0, lsl #8
   93418:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   9341c:	fa23 f002 	lsr.w	r0, r3, r2
   93420:	4770      	bx	lr
   93422:	f04f 0000 	mov.w	r0, #0
   93426:	4770      	bx	lr
   93428:	f112 0f61 	cmn.w	r2, #97	; 0x61
   9342c:	d101      	bne.n	93432 <__aeabi_f2uiz+0x32>
   9342e:	0242      	lsls	r2, r0, #9
   93430:	d102      	bne.n	93438 <__aeabi_f2uiz+0x38>
   93432:	f04f 30ff 	mov.w	r0, #4294967295
   93436:	4770      	bx	lr
   93438:	f04f 0000 	mov.w	r0, #0
   9343c:	4770      	bx	lr
   9343e:	bf00      	nop

00093440 <__assert_func>:
   93440:	b500      	push	{lr}
   93442:	4c0a      	ldr	r4, [pc, #40]	; (9346c <__assert_func+0x2c>)
   93444:	4605      	mov	r5, r0
   93446:	6820      	ldr	r0, [r4, #0]
   93448:	b085      	sub	sp, #20
   9344a:	461c      	mov	r4, r3
   9344c:	68c0      	ldr	r0, [r0, #12]
   9344e:	b152      	cbz	r2, 93466 <__assert_func+0x26>
   93450:	4b07      	ldr	r3, [pc, #28]	; (93470 <__assert_func+0x30>)
   93452:	e88d 000a 	stmia.w	sp, {r1, r3}
   93456:	9202      	str	r2, [sp, #8]
   93458:	462b      	mov	r3, r5
   9345a:	4622      	mov	r2, r4
   9345c:	4905      	ldr	r1, [pc, #20]	; (93474 <__assert_func+0x34>)
   9345e:	f000 f819 	bl	93494 <fiprintf>
   93462:	f003 fbaf 	bl	96bc4 <abort>
   93466:	4b04      	ldr	r3, [pc, #16]	; (93478 <__assert_func+0x38>)
   93468:	461a      	mov	r2, r3
   9346a:	e7f2      	b.n	93452 <__assert_func+0x12>
   9346c:	20070548 	.word	0x20070548
   93470:	0009b130 	.word	0x0009b130
   93474:	0009b140 	.word	0x0009b140
   93478:	0009b13c 	.word	0x0009b13c

0009347c <__cxa_atexit>:
   9347c:	4613      	mov	r3, r2
   9347e:	460a      	mov	r2, r1
   93480:	4601      	mov	r1, r0
   93482:	2002      	movs	r0, #2
   93484:	f003 bb42 	b.w	96b0c <__register_exitproc>

00093488 <__errno>:
   93488:	4b01      	ldr	r3, [pc, #4]	; (93490 <__errno+0x8>)
   9348a:	6818      	ldr	r0, [r3, #0]
   9348c:	4770      	bx	lr
   9348e:	bf00      	nop
   93490:	20070548 	.word	0x20070548

00093494 <fiprintf>:
   93494:	b40e      	push	{r1, r2, r3}
   93496:	b530      	push	{r4, r5, lr}
   93498:	b082      	sub	sp, #8
   9349a:	ac05      	add	r4, sp, #20
   9349c:	f854 2b04 	ldr.w	r2, [r4], #4
   934a0:	4d05      	ldr	r5, [pc, #20]	; (934b8 <fiprintf+0x24>)
   934a2:	4601      	mov	r1, r0
   934a4:	4623      	mov	r3, r4
   934a6:	6828      	ldr	r0, [r5, #0]
   934a8:	9401      	str	r4, [sp, #4]
   934aa:	f002 fba1 	bl	95bf0 <_vfiprintf_r>
   934ae:	b002      	add	sp, #8
   934b0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   934b4:	b003      	add	sp, #12
   934b6:	4770      	bx	lr
   934b8:	20070548 	.word	0x20070548

000934bc <__libc_init_array>:
   934bc:	b570      	push	{r4, r5, r6, lr}
   934be:	4e0f      	ldr	r6, [pc, #60]	; (934fc <__libc_init_array+0x40>)
   934c0:	4d0f      	ldr	r5, [pc, #60]	; (93500 <__libc_init_array+0x44>)
   934c2:	1b76      	subs	r6, r6, r5
   934c4:	10b6      	asrs	r6, r6, #2
   934c6:	bf18      	it	ne
   934c8:	2400      	movne	r4, #0
   934ca:	d005      	beq.n	934d8 <__libc_init_array+0x1c>
   934cc:	3401      	adds	r4, #1
   934ce:	f855 3b04 	ldr.w	r3, [r5], #4
   934d2:	4798      	blx	r3
   934d4:	42a6      	cmp	r6, r4
   934d6:	d1f9      	bne.n	934cc <__libc_init_array+0x10>
   934d8:	4e0a      	ldr	r6, [pc, #40]	; (93504 <__libc_init_array+0x48>)
   934da:	4d0b      	ldr	r5, [pc, #44]	; (93508 <__libc_init_array+0x4c>)
   934dc:	f007 ff1a 	bl	9b314 <_init>
   934e0:	1b76      	subs	r6, r6, r5
   934e2:	10b6      	asrs	r6, r6, #2
   934e4:	bf18      	it	ne
   934e6:	2400      	movne	r4, #0
   934e8:	d006      	beq.n	934f8 <__libc_init_array+0x3c>
   934ea:	3401      	adds	r4, #1
   934ec:	f855 3b04 	ldr.w	r3, [r5], #4
   934f0:	4798      	blx	r3
   934f2:	42a6      	cmp	r6, r4
   934f4:	d1f9      	bne.n	934ea <__libc_init_array+0x2e>
   934f6:	bd70      	pop	{r4, r5, r6, pc}
   934f8:	bd70      	pop	{r4, r5, r6, pc}
   934fa:	bf00      	nop
   934fc:	0009b320 	.word	0x0009b320
   93500:	0009b320 	.word	0x0009b320
   93504:	0009b350 	.word	0x0009b350
   93508:	0009b320 	.word	0x0009b320

0009350c <iprintf>:
   9350c:	b40f      	push	{r0, r1, r2, r3}
   9350e:	b510      	push	{r4, lr}
   93510:	4b07      	ldr	r3, [pc, #28]	; (93530 <iprintf+0x24>)
   93512:	b082      	sub	sp, #8
   93514:	ac04      	add	r4, sp, #16
   93516:	f854 2b04 	ldr.w	r2, [r4], #4
   9351a:	6818      	ldr	r0, [r3, #0]
   9351c:	4623      	mov	r3, r4
   9351e:	6881      	ldr	r1, [r0, #8]
   93520:	9401      	str	r4, [sp, #4]
   93522:	f002 fb65 	bl	95bf0 <_vfiprintf_r>
   93526:	b002      	add	sp, #8
   93528:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   9352c:	b004      	add	sp, #16
   9352e:	4770      	bx	lr
   93530:	20070548 	.word	0x20070548

00093534 <malloc>:
   93534:	4b02      	ldr	r3, [pc, #8]	; (93540 <malloc+0xc>)
   93536:	4601      	mov	r1, r0
   93538:	6818      	ldr	r0, [r3, #0]
   9353a:	f000 b80b 	b.w	93554 <_malloc_r>
   9353e:	bf00      	nop
   93540:	20070548 	.word	0x20070548

00093544 <free>:
   93544:	4b02      	ldr	r3, [pc, #8]	; (93550 <free+0xc>)
   93546:	4601      	mov	r1, r0
   93548:	6818      	ldr	r0, [r3, #0]
   9354a:	f004 bd07 	b.w	97f5c <_free_r>
   9354e:	bf00      	nop
   93550:	20070548 	.word	0x20070548

00093554 <_malloc_r>:
   93554:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   93558:	f101 050b 	add.w	r5, r1, #11
   9355c:	2d16      	cmp	r5, #22
   9355e:	b083      	sub	sp, #12
   93560:	4606      	mov	r6, r0
   93562:	f240 80a0 	bls.w	936a6 <_malloc_r+0x152>
   93566:	f035 0507 	bics.w	r5, r5, #7
   9356a:	f100 80c0 	bmi.w	936ee <_malloc_r+0x19a>
   9356e:	42a9      	cmp	r1, r5
   93570:	f200 80bd 	bhi.w	936ee <_malloc_r+0x19a>
   93574:	f000 fbf4 	bl	93d60 <__malloc_lock>
   93578:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
   9357c:	f0c0 8290 	bcc.w	93aa0 <_malloc_r+0x54c>
   93580:	0a6b      	lsrs	r3, r5, #9
   93582:	f000 80bb 	beq.w	936fc <_malloc_r+0x1a8>
   93586:	2b04      	cmp	r3, #4
   93588:	f200 8177 	bhi.w	9387a <_malloc_r+0x326>
   9358c:	09a8      	lsrs	r0, r5, #6
   9358e:	f100 0e39 	add.w	lr, r0, #57	; 0x39
   93592:	ea4f 014e 	mov.w	r1, lr, lsl #1
   93596:	3038      	adds	r0, #56	; 0x38
   93598:	4fbe      	ldr	r7, [pc, #760]	; (93894 <_malloc_r+0x340>)
   9359a:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   9359e:	684c      	ldr	r4, [r1, #4]
   935a0:	3908      	subs	r1, #8
   935a2:	42a1      	cmp	r1, r4
   935a4:	d107      	bne.n	935b6 <_malloc_r+0x62>
   935a6:	e0ae      	b.n	93706 <_malloc_r+0x1b2>
   935a8:	2a00      	cmp	r2, #0
   935aa:	f280 80ae 	bge.w	9370a <_malloc_r+0x1b6>
   935ae:	68e4      	ldr	r4, [r4, #12]
   935b0:	42a1      	cmp	r1, r4
   935b2:	f000 80a8 	beq.w	93706 <_malloc_r+0x1b2>
   935b6:	6863      	ldr	r3, [r4, #4]
   935b8:	f023 0303 	bic.w	r3, r3, #3
   935bc:	1b5a      	subs	r2, r3, r5
   935be:	2a0f      	cmp	r2, #15
   935c0:	ddf2      	ble.n	935a8 <_malloc_r+0x54>
   935c2:	49b4      	ldr	r1, [pc, #720]	; (93894 <_malloc_r+0x340>)
   935c4:	693c      	ldr	r4, [r7, #16]
   935c6:	f101 0e08 	add.w	lr, r1, #8
   935ca:	4574      	cmp	r4, lr
   935cc:	f000 81a8 	beq.w	93920 <_malloc_r+0x3cc>
   935d0:	6863      	ldr	r3, [r4, #4]
   935d2:	f023 0303 	bic.w	r3, r3, #3
   935d6:	1b5a      	subs	r2, r3, r5
   935d8:	2a0f      	cmp	r2, #15
   935da:	f300 818e 	bgt.w	938fa <_malloc_r+0x3a6>
   935de:	2a00      	cmp	r2, #0
   935e0:	f8c1 e014 	str.w	lr, [r1, #20]
   935e4:	f8c1 e010 	str.w	lr, [r1, #16]
   935e8:	f280 8093 	bge.w	93712 <_malloc_r+0x1be>
   935ec:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   935f0:	f080 815c 	bcs.w	938ac <_malloc_r+0x358>
   935f4:	08db      	lsrs	r3, r3, #3
   935f6:	684a      	ldr	r2, [r1, #4]
   935f8:	ea4f 09a3 	mov.w	r9, r3, asr #2
   935fc:	f04f 0c01 	mov.w	ip, #1
   93600:	3301      	adds	r3, #1
   93602:	f851 8033 	ldr.w	r8, [r1, r3, lsl #3]
   93606:	fa0c f909 	lsl.w	r9, ip, r9
   9360a:	eb01 0cc3 	add.w	ip, r1, r3, lsl #3
   9360e:	ea49 0202 	orr.w	r2, r9, r2
   93612:	f1ac 0c08 	sub.w	ip, ip, #8
   93616:	f8c4 c00c 	str.w	ip, [r4, #12]
   9361a:	f8c4 8008 	str.w	r8, [r4, #8]
   9361e:	604a      	str	r2, [r1, #4]
   93620:	f841 4033 	str.w	r4, [r1, r3, lsl #3]
   93624:	f8c8 400c 	str.w	r4, [r8, #12]
   93628:	1083      	asrs	r3, r0, #2
   9362a:	2401      	movs	r4, #1
   9362c:	409c      	lsls	r4, r3
   9362e:	4294      	cmp	r4, r2
   93630:	d87c      	bhi.n	9372c <_malloc_r+0x1d8>
   93632:	4214      	tst	r4, r2
   93634:	d106      	bne.n	93644 <_malloc_r+0xf0>
   93636:	f020 0003 	bic.w	r0, r0, #3
   9363a:	0064      	lsls	r4, r4, #1
   9363c:	4214      	tst	r4, r2
   9363e:	f100 0004 	add.w	r0, r0, #4
   93642:	d0fa      	beq.n	9363a <_malloc_r+0xe6>
   93644:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
   93648:	46cc      	mov	ip, r9
   9364a:	4680      	mov	r8, r0
   9364c:	f8dc 100c 	ldr.w	r1, [ip, #12]
   93650:	458c      	cmp	ip, r1
   93652:	d107      	bne.n	93664 <_malloc_r+0x110>
   93654:	e166      	b.n	93924 <_malloc_r+0x3d0>
   93656:	2a00      	cmp	r2, #0
   93658:	f280 8174 	bge.w	93944 <_malloc_r+0x3f0>
   9365c:	68c9      	ldr	r1, [r1, #12]
   9365e:	458c      	cmp	ip, r1
   93660:	f000 8160 	beq.w	93924 <_malloc_r+0x3d0>
   93664:	684b      	ldr	r3, [r1, #4]
   93666:	f023 0303 	bic.w	r3, r3, #3
   9366a:	1b5a      	subs	r2, r3, r5
   9366c:	2a0f      	cmp	r2, #15
   9366e:	ddf2      	ble.n	93656 <_malloc_r+0x102>
   93670:	460c      	mov	r4, r1
   93672:	68cb      	ldr	r3, [r1, #12]
   93674:	f854 cf08 	ldr.w	ip, [r4, #8]!
   93678:	f045 0801 	orr.w	r8, r5, #1
   9367c:	f8c1 8004 	str.w	r8, [r1, #4]
   93680:	440d      	add	r5, r1
   93682:	f042 0101 	orr.w	r1, r2, #1
   93686:	f8cc 300c 	str.w	r3, [ip, #12]
   9368a:	4630      	mov	r0, r6
   9368c:	f8c3 c008 	str.w	ip, [r3, #8]
   93690:	617d      	str	r5, [r7, #20]
   93692:	613d      	str	r5, [r7, #16]
   93694:	f8c5 e00c 	str.w	lr, [r5, #12]
   93698:	f8c5 e008 	str.w	lr, [r5, #8]
   9369c:	6069      	str	r1, [r5, #4]
   9369e:	50aa      	str	r2, [r5, r2]
   936a0:	f000 fb60 	bl	93d64 <__malloc_unlock>
   936a4:	e01f      	b.n	936e6 <_malloc_r+0x192>
   936a6:	2910      	cmp	r1, #16
   936a8:	d821      	bhi.n	936ee <_malloc_r+0x19a>
   936aa:	f000 fb59 	bl	93d60 <__malloc_lock>
   936ae:	2510      	movs	r5, #16
   936b0:	2306      	movs	r3, #6
   936b2:	2002      	movs	r0, #2
   936b4:	4f77      	ldr	r7, [pc, #476]	; (93894 <_malloc_r+0x340>)
   936b6:	eb07 0383 	add.w	r3, r7, r3, lsl #2
   936ba:	685c      	ldr	r4, [r3, #4]
   936bc:	f1a3 0208 	sub.w	r2, r3, #8
   936c0:	4294      	cmp	r4, r2
   936c2:	f000 8138 	beq.w	93936 <_malloc_r+0x3e2>
   936c6:	6863      	ldr	r3, [r4, #4]
   936c8:	68e1      	ldr	r1, [r4, #12]
   936ca:	f023 0303 	bic.w	r3, r3, #3
   936ce:	4423      	add	r3, r4
   936d0:	685a      	ldr	r2, [r3, #4]
   936d2:	68a5      	ldr	r5, [r4, #8]
   936d4:	f042 0201 	orr.w	r2, r2, #1
   936d8:	60e9      	str	r1, [r5, #12]
   936da:	4630      	mov	r0, r6
   936dc:	608d      	str	r5, [r1, #8]
   936de:	605a      	str	r2, [r3, #4]
   936e0:	f000 fb40 	bl	93d64 <__malloc_unlock>
   936e4:	3408      	adds	r4, #8
   936e6:	4620      	mov	r0, r4
   936e8:	b003      	add	sp, #12
   936ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   936ee:	2400      	movs	r4, #0
   936f0:	4620      	mov	r0, r4
   936f2:	230c      	movs	r3, #12
   936f4:	6033      	str	r3, [r6, #0]
   936f6:	b003      	add	sp, #12
   936f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   936fc:	2180      	movs	r1, #128	; 0x80
   936fe:	f04f 0e40 	mov.w	lr, #64	; 0x40
   93702:	203f      	movs	r0, #63	; 0x3f
   93704:	e748      	b.n	93598 <_malloc_r+0x44>
   93706:	4670      	mov	r0, lr
   93708:	e75b      	b.n	935c2 <_malloc_r+0x6e>
   9370a:	4423      	add	r3, r4
   9370c:	685a      	ldr	r2, [r3, #4]
   9370e:	68e1      	ldr	r1, [r4, #12]
   93710:	e7df      	b.n	936d2 <_malloc_r+0x17e>
   93712:	4423      	add	r3, r4
   93714:	685a      	ldr	r2, [r3, #4]
   93716:	4630      	mov	r0, r6
   93718:	f042 0201 	orr.w	r2, r2, #1
   9371c:	605a      	str	r2, [r3, #4]
   9371e:	3408      	adds	r4, #8
   93720:	f000 fb20 	bl	93d64 <__malloc_unlock>
   93724:	4620      	mov	r0, r4
   93726:	b003      	add	sp, #12
   93728:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   9372c:	68bc      	ldr	r4, [r7, #8]
   9372e:	6863      	ldr	r3, [r4, #4]
   93730:	f023 0803 	bic.w	r8, r3, #3
   93734:	45a8      	cmp	r8, r5
   93736:	d304      	bcc.n	93742 <_malloc_r+0x1ee>
   93738:	ebc5 0308 	rsb	r3, r5, r8
   9373c:	2b0f      	cmp	r3, #15
   9373e:	f300 808c 	bgt.w	9385a <_malloc_r+0x306>
   93742:	4b55      	ldr	r3, [pc, #340]	; (93898 <_malloc_r+0x344>)
   93744:	f8df 9160 	ldr.w	r9, [pc, #352]	; 938a8 <_malloc_r+0x354>
   93748:	681a      	ldr	r2, [r3, #0]
   9374a:	f8d9 3000 	ldr.w	r3, [r9]
   9374e:	442a      	add	r2, r5
   93750:	3301      	adds	r3, #1
   93752:	eb04 0a08 	add.w	sl, r4, r8
   93756:	f000 8160 	beq.w	93a1a <_malloc_r+0x4c6>
   9375a:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
   9375e:	320f      	adds	r2, #15
   93760:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
   93764:	f022 020f 	bic.w	r2, r2, #15
   93768:	4611      	mov	r1, r2
   9376a:	4630      	mov	r0, r6
   9376c:	9201      	str	r2, [sp, #4]
   9376e:	f000 fced 	bl	9414c <_sbrk_r>
   93772:	f1b0 3fff 	cmp.w	r0, #4294967295
   93776:	4683      	mov	fp, r0
   93778:	9a01      	ldr	r2, [sp, #4]
   9377a:	f000 8158 	beq.w	93a2e <_malloc_r+0x4da>
   9377e:	4582      	cmp	sl, r0
   93780:	f200 80fc 	bhi.w	9397c <_malloc_r+0x428>
   93784:	4b45      	ldr	r3, [pc, #276]	; (9389c <_malloc_r+0x348>)
   93786:	45da      	cmp	sl, fp
   93788:	6819      	ldr	r1, [r3, #0]
   9378a:	4411      	add	r1, r2
   9378c:	6019      	str	r1, [r3, #0]
   9378e:	f000 8153 	beq.w	93a38 <_malloc_r+0x4e4>
   93792:	f8d9 0000 	ldr.w	r0, [r9]
   93796:	f8df e110 	ldr.w	lr, [pc, #272]	; 938a8 <_malloc_r+0x354>
   9379a:	3001      	adds	r0, #1
   9379c:	bf1b      	ittet	ne
   9379e:	ebca 0a0b 	rsbne	sl, sl, fp
   937a2:	4451      	addne	r1, sl
   937a4:	f8ce b000 	streq.w	fp, [lr]
   937a8:	6019      	strne	r1, [r3, #0]
   937aa:	f01b 0107 	ands.w	r1, fp, #7
   937ae:	f000 8117 	beq.w	939e0 <_malloc_r+0x48c>
   937b2:	f1c1 0008 	rsb	r0, r1, #8
   937b6:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
   937ba:	4483      	add	fp, r0
   937bc:	3108      	adds	r1, #8
   937be:	445a      	add	r2, fp
   937c0:	f3c2 020b 	ubfx	r2, r2, #0, #12
   937c4:	ebc2 0901 	rsb	r9, r2, r1
   937c8:	4649      	mov	r1, r9
   937ca:	4630      	mov	r0, r6
   937cc:	9301      	str	r3, [sp, #4]
   937ce:	f000 fcbd 	bl	9414c <_sbrk_r>
   937d2:	1c43      	adds	r3, r0, #1
   937d4:	9b01      	ldr	r3, [sp, #4]
   937d6:	f000 813f 	beq.w	93a58 <_malloc_r+0x504>
   937da:	ebcb 0200 	rsb	r2, fp, r0
   937de:	444a      	add	r2, r9
   937e0:	f042 0201 	orr.w	r2, r2, #1
   937e4:	6819      	ldr	r1, [r3, #0]
   937e6:	42bc      	cmp	r4, r7
   937e8:	4449      	add	r1, r9
   937ea:	f8c7 b008 	str.w	fp, [r7, #8]
   937ee:	6019      	str	r1, [r3, #0]
   937f0:	f8cb 2004 	str.w	r2, [fp, #4]
   937f4:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 9389c <_malloc_r+0x348>
   937f8:	d016      	beq.n	93828 <_malloc_r+0x2d4>
   937fa:	f1b8 0f0f 	cmp.w	r8, #15
   937fe:	f240 80fd 	bls.w	939fc <_malloc_r+0x4a8>
   93802:	6862      	ldr	r2, [r4, #4]
   93804:	f1a8 030c 	sub.w	r3, r8, #12
   93808:	f023 0307 	bic.w	r3, r3, #7
   9380c:	f002 0201 	and.w	r2, r2, #1
   93810:	18e0      	adds	r0, r4, r3
   93812:	f04f 0e05 	mov.w	lr, #5
   93816:	431a      	orrs	r2, r3
   93818:	2b0f      	cmp	r3, #15
   9381a:	6062      	str	r2, [r4, #4]
   9381c:	f8c0 e004 	str.w	lr, [r0, #4]
   93820:	f8c0 e008 	str.w	lr, [r0, #8]
   93824:	f200 811c 	bhi.w	93a60 <_malloc_r+0x50c>
   93828:	4b1d      	ldr	r3, [pc, #116]	; (938a0 <_malloc_r+0x34c>)
   9382a:	68bc      	ldr	r4, [r7, #8]
   9382c:	681a      	ldr	r2, [r3, #0]
   9382e:	4291      	cmp	r1, r2
   93830:	bf88      	it	hi
   93832:	6019      	strhi	r1, [r3, #0]
   93834:	4b1b      	ldr	r3, [pc, #108]	; (938a4 <_malloc_r+0x350>)
   93836:	681a      	ldr	r2, [r3, #0]
   93838:	4291      	cmp	r1, r2
   9383a:	6862      	ldr	r2, [r4, #4]
   9383c:	bf88      	it	hi
   9383e:	6019      	strhi	r1, [r3, #0]
   93840:	f022 0203 	bic.w	r2, r2, #3
   93844:	4295      	cmp	r5, r2
   93846:	eba2 0305 	sub.w	r3, r2, r5
   9384a:	d801      	bhi.n	93850 <_malloc_r+0x2fc>
   9384c:	2b0f      	cmp	r3, #15
   9384e:	dc04      	bgt.n	9385a <_malloc_r+0x306>
   93850:	4630      	mov	r0, r6
   93852:	f000 fa87 	bl	93d64 <__malloc_unlock>
   93856:	2400      	movs	r4, #0
   93858:	e745      	b.n	936e6 <_malloc_r+0x192>
   9385a:	f045 0201 	orr.w	r2, r5, #1
   9385e:	f043 0301 	orr.w	r3, r3, #1
   93862:	4425      	add	r5, r4
   93864:	6062      	str	r2, [r4, #4]
   93866:	4630      	mov	r0, r6
   93868:	60bd      	str	r5, [r7, #8]
   9386a:	3408      	adds	r4, #8
   9386c:	606b      	str	r3, [r5, #4]
   9386e:	f000 fa79 	bl	93d64 <__malloc_unlock>
   93872:	4620      	mov	r0, r4
   93874:	b003      	add	sp, #12
   93876:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   9387a:	2b14      	cmp	r3, #20
   9387c:	d971      	bls.n	93962 <_malloc_r+0x40e>
   9387e:	2b54      	cmp	r3, #84	; 0x54
   93880:	f200 80a4 	bhi.w	939cc <_malloc_r+0x478>
   93884:	0b28      	lsrs	r0, r5, #12
   93886:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
   9388a:	ea4f 014e 	mov.w	r1, lr, lsl #1
   9388e:	306e      	adds	r0, #110	; 0x6e
   93890:	e682      	b.n	93598 <_malloc_r+0x44>
   93892:	bf00      	nop
   93894:	2007054c 	.word	0x2007054c
   93898:	20071cd4 	.word	0x20071cd4
   9389c:	20071cd8 	.word	0x20071cd8
   938a0:	20071cd0 	.word	0x20071cd0
   938a4:	20071ccc 	.word	0x20071ccc
   938a8:	20070958 	.word	0x20070958
   938ac:	0a5a      	lsrs	r2, r3, #9
   938ae:	2a04      	cmp	r2, #4
   938b0:	d95e      	bls.n	93970 <_malloc_r+0x41c>
   938b2:	2a14      	cmp	r2, #20
   938b4:	f200 80b3 	bhi.w	93a1e <_malloc_r+0x4ca>
   938b8:	f102 015c 	add.w	r1, r2, #92	; 0x5c
   938bc:	0049      	lsls	r1, r1, #1
   938be:	325b      	adds	r2, #91	; 0x5b
   938c0:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
   938c4:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
   938c8:	f1ac 0c08 	sub.w	ip, ip, #8
   938cc:	458c      	cmp	ip, r1
   938ce:	f8df 81d8 	ldr.w	r8, [pc, #472]	; 93aa8 <_malloc_r+0x554>
   938d2:	f000 8088 	beq.w	939e6 <_malloc_r+0x492>
   938d6:	684a      	ldr	r2, [r1, #4]
   938d8:	f022 0203 	bic.w	r2, r2, #3
   938dc:	4293      	cmp	r3, r2
   938de:	d202      	bcs.n	938e6 <_malloc_r+0x392>
   938e0:	6889      	ldr	r1, [r1, #8]
   938e2:	458c      	cmp	ip, r1
   938e4:	d1f7      	bne.n	938d6 <_malloc_r+0x382>
   938e6:	f8d1 c00c 	ldr.w	ip, [r1, #12]
   938ea:	687a      	ldr	r2, [r7, #4]
   938ec:	f8c4 c00c 	str.w	ip, [r4, #12]
   938f0:	60a1      	str	r1, [r4, #8]
   938f2:	f8cc 4008 	str.w	r4, [ip, #8]
   938f6:	60cc      	str	r4, [r1, #12]
   938f8:	e696      	b.n	93628 <_malloc_r+0xd4>
   938fa:	f045 0701 	orr.w	r7, r5, #1
   938fe:	f042 0301 	orr.w	r3, r2, #1
   93902:	4425      	add	r5, r4
   93904:	6067      	str	r7, [r4, #4]
   93906:	4630      	mov	r0, r6
   93908:	614d      	str	r5, [r1, #20]
   9390a:	610d      	str	r5, [r1, #16]
   9390c:	f8c5 e00c 	str.w	lr, [r5, #12]
   93910:	f8c5 e008 	str.w	lr, [r5, #8]
   93914:	606b      	str	r3, [r5, #4]
   93916:	50aa      	str	r2, [r5, r2]
   93918:	3408      	adds	r4, #8
   9391a:	f000 fa23 	bl	93d64 <__malloc_unlock>
   9391e:	e6e2      	b.n	936e6 <_malloc_r+0x192>
   93920:	684a      	ldr	r2, [r1, #4]
   93922:	e681      	b.n	93628 <_malloc_r+0xd4>
   93924:	f108 0801 	add.w	r8, r8, #1
   93928:	f018 0f03 	tst.w	r8, #3
   9392c:	f10c 0c08 	add.w	ip, ip, #8
   93930:	f47f ae8c 	bne.w	9364c <_malloc_r+0xf8>
   93934:	e030      	b.n	93998 <_malloc_r+0x444>
   93936:	68dc      	ldr	r4, [r3, #12]
   93938:	42a3      	cmp	r3, r4
   9393a:	bf08      	it	eq
   9393c:	3002      	addeq	r0, #2
   9393e:	f43f ae40 	beq.w	935c2 <_malloc_r+0x6e>
   93942:	e6c0      	b.n	936c6 <_malloc_r+0x172>
   93944:	460c      	mov	r4, r1
   93946:	440b      	add	r3, r1
   93948:	685a      	ldr	r2, [r3, #4]
   9394a:	68c9      	ldr	r1, [r1, #12]
   9394c:	f854 5f08 	ldr.w	r5, [r4, #8]!
   93950:	f042 0201 	orr.w	r2, r2, #1
   93954:	605a      	str	r2, [r3, #4]
   93956:	4630      	mov	r0, r6
   93958:	60e9      	str	r1, [r5, #12]
   9395a:	608d      	str	r5, [r1, #8]
   9395c:	f000 fa02 	bl	93d64 <__malloc_unlock>
   93960:	e6c1      	b.n	936e6 <_malloc_r+0x192>
   93962:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
   93966:	f103 005b 	add.w	r0, r3, #91	; 0x5b
   9396a:	ea4f 014e 	mov.w	r1, lr, lsl #1
   9396e:	e613      	b.n	93598 <_malloc_r+0x44>
   93970:	099a      	lsrs	r2, r3, #6
   93972:	f102 0139 	add.w	r1, r2, #57	; 0x39
   93976:	0049      	lsls	r1, r1, #1
   93978:	3238      	adds	r2, #56	; 0x38
   9397a:	e7a1      	b.n	938c0 <_malloc_r+0x36c>
   9397c:	42bc      	cmp	r4, r7
   9397e:	4b4a      	ldr	r3, [pc, #296]	; (93aa8 <_malloc_r+0x554>)
   93980:	f43f af00 	beq.w	93784 <_malloc_r+0x230>
   93984:	689c      	ldr	r4, [r3, #8]
   93986:	6862      	ldr	r2, [r4, #4]
   93988:	f022 0203 	bic.w	r2, r2, #3
   9398c:	e75a      	b.n	93844 <_malloc_r+0x2f0>
   9398e:	f859 3908 	ldr.w	r3, [r9], #-8
   93992:	4599      	cmp	r9, r3
   93994:	f040 8082 	bne.w	93a9c <_malloc_r+0x548>
   93998:	f010 0f03 	tst.w	r0, #3
   9399c:	f100 30ff 	add.w	r0, r0, #4294967295
   939a0:	d1f5      	bne.n	9398e <_malloc_r+0x43a>
   939a2:	687b      	ldr	r3, [r7, #4]
   939a4:	ea23 0304 	bic.w	r3, r3, r4
   939a8:	607b      	str	r3, [r7, #4]
   939aa:	0064      	lsls	r4, r4, #1
   939ac:	429c      	cmp	r4, r3
   939ae:	f63f aebd 	bhi.w	9372c <_malloc_r+0x1d8>
   939b2:	2c00      	cmp	r4, #0
   939b4:	f43f aeba 	beq.w	9372c <_malloc_r+0x1d8>
   939b8:	421c      	tst	r4, r3
   939ba:	4640      	mov	r0, r8
   939bc:	f47f ae42 	bne.w	93644 <_malloc_r+0xf0>
   939c0:	0064      	lsls	r4, r4, #1
   939c2:	421c      	tst	r4, r3
   939c4:	f100 0004 	add.w	r0, r0, #4
   939c8:	d0fa      	beq.n	939c0 <_malloc_r+0x46c>
   939ca:	e63b      	b.n	93644 <_malloc_r+0xf0>
   939cc:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
   939d0:	d818      	bhi.n	93a04 <_malloc_r+0x4b0>
   939d2:	0be8      	lsrs	r0, r5, #15
   939d4:	f100 0e78 	add.w	lr, r0, #120	; 0x78
   939d8:	ea4f 014e 	mov.w	r1, lr, lsl #1
   939dc:	3077      	adds	r0, #119	; 0x77
   939de:	e5db      	b.n	93598 <_malloc_r+0x44>
   939e0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   939e4:	e6eb      	b.n	937be <_malloc_r+0x26a>
   939e6:	2101      	movs	r1, #1
   939e8:	f8d8 3004 	ldr.w	r3, [r8, #4]
   939ec:	1092      	asrs	r2, r2, #2
   939ee:	fa01 f202 	lsl.w	r2, r1, r2
   939f2:	431a      	orrs	r2, r3
   939f4:	f8c8 2004 	str.w	r2, [r8, #4]
   939f8:	4661      	mov	r1, ip
   939fa:	e777      	b.n	938ec <_malloc_r+0x398>
   939fc:	2301      	movs	r3, #1
   939fe:	f8cb 3004 	str.w	r3, [fp, #4]
   93a02:	e725      	b.n	93850 <_malloc_r+0x2fc>
   93a04:	f240 5254 	movw	r2, #1364	; 0x554
   93a08:	4293      	cmp	r3, r2
   93a0a:	d820      	bhi.n	93a4e <_malloc_r+0x4fa>
   93a0c:	0ca8      	lsrs	r0, r5, #18
   93a0e:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
   93a12:	ea4f 014e 	mov.w	r1, lr, lsl #1
   93a16:	307c      	adds	r0, #124	; 0x7c
   93a18:	e5be      	b.n	93598 <_malloc_r+0x44>
   93a1a:	3210      	adds	r2, #16
   93a1c:	e6a4      	b.n	93768 <_malloc_r+0x214>
   93a1e:	2a54      	cmp	r2, #84	; 0x54
   93a20:	d826      	bhi.n	93a70 <_malloc_r+0x51c>
   93a22:	0b1a      	lsrs	r2, r3, #12
   93a24:	f102 016f 	add.w	r1, r2, #111	; 0x6f
   93a28:	0049      	lsls	r1, r1, #1
   93a2a:	326e      	adds	r2, #110	; 0x6e
   93a2c:	e748      	b.n	938c0 <_malloc_r+0x36c>
   93a2e:	68bc      	ldr	r4, [r7, #8]
   93a30:	6862      	ldr	r2, [r4, #4]
   93a32:	f022 0203 	bic.w	r2, r2, #3
   93a36:	e705      	b.n	93844 <_malloc_r+0x2f0>
   93a38:	f3ca 000b 	ubfx	r0, sl, #0, #12
   93a3c:	2800      	cmp	r0, #0
   93a3e:	f47f aea8 	bne.w	93792 <_malloc_r+0x23e>
   93a42:	4442      	add	r2, r8
   93a44:	68bb      	ldr	r3, [r7, #8]
   93a46:	f042 0201 	orr.w	r2, r2, #1
   93a4a:	605a      	str	r2, [r3, #4]
   93a4c:	e6ec      	b.n	93828 <_malloc_r+0x2d4>
   93a4e:	21fe      	movs	r1, #254	; 0xfe
   93a50:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
   93a54:	207e      	movs	r0, #126	; 0x7e
   93a56:	e59f      	b.n	93598 <_malloc_r+0x44>
   93a58:	2201      	movs	r2, #1
   93a5a:	f04f 0900 	mov.w	r9, #0
   93a5e:	e6c1      	b.n	937e4 <_malloc_r+0x290>
   93a60:	f104 0108 	add.w	r1, r4, #8
   93a64:	4630      	mov	r0, r6
   93a66:	f004 fa79 	bl	97f5c <_free_r>
   93a6a:	f8d9 1000 	ldr.w	r1, [r9]
   93a6e:	e6db      	b.n	93828 <_malloc_r+0x2d4>
   93a70:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
   93a74:	d805      	bhi.n	93a82 <_malloc_r+0x52e>
   93a76:	0bda      	lsrs	r2, r3, #15
   93a78:	f102 0178 	add.w	r1, r2, #120	; 0x78
   93a7c:	0049      	lsls	r1, r1, #1
   93a7e:	3277      	adds	r2, #119	; 0x77
   93a80:	e71e      	b.n	938c0 <_malloc_r+0x36c>
   93a82:	f240 5154 	movw	r1, #1364	; 0x554
   93a86:	428a      	cmp	r2, r1
   93a88:	d805      	bhi.n	93a96 <_malloc_r+0x542>
   93a8a:	0c9a      	lsrs	r2, r3, #18
   93a8c:	f102 017d 	add.w	r1, r2, #125	; 0x7d
   93a90:	0049      	lsls	r1, r1, #1
   93a92:	327c      	adds	r2, #124	; 0x7c
   93a94:	e714      	b.n	938c0 <_malloc_r+0x36c>
   93a96:	21fe      	movs	r1, #254	; 0xfe
   93a98:	227e      	movs	r2, #126	; 0x7e
   93a9a:	e711      	b.n	938c0 <_malloc_r+0x36c>
   93a9c:	687b      	ldr	r3, [r7, #4]
   93a9e:	e784      	b.n	939aa <_malloc_r+0x456>
   93aa0:	08e8      	lsrs	r0, r5, #3
   93aa2:	1c43      	adds	r3, r0, #1
   93aa4:	005b      	lsls	r3, r3, #1
   93aa6:	e605      	b.n	936b4 <_malloc_r+0x160>
   93aa8:	2007054c 	.word	0x2007054c

00093aac <memcmp>:
   93aac:	2a03      	cmp	r2, #3
   93aae:	b470      	push	{r4, r5, r6}
   93ab0:	d926      	bls.n	93b00 <memcmp+0x54>
   93ab2:	ea40 0301 	orr.w	r3, r0, r1
   93ab6:	079b      	lsls	r3, r3, #30
   93ab8:	d011      	beq.n	93ade <memcmp+0x32>
   93aba:	7804      	ldrb	r4, [r0, #0]
   93abc:	780d      	ldrb	r5, [r1, #0]
   93abe:	42ac      	cmp	r4, r5
   93ac0:	d122      	bne.n	93b08 <memcmp+0x5c>
   93ac2:	4402      	add	r2, r0
   93ac4:	1c43      	adds	r3, r0, #1
   93ac6:	e005      	b.n	93ad4 <memcmp+0x28>
   93ac8:	f813 4b01 	ldrb.w	r4, [r3], #1
   93acc:	f811 5f01 	ldrb.w	r5, [r1, #1]!
   93ad0:	42ac      	cmp	r4, r5
   93ad2:	d119      	bne.n	93b08 <memcmp+0x5c>
   93ad4:	4293      	cmp	r3, r2
   93ad6:	d1f7      	bne.n	93ac8 <memcmp+0x1c>
   93ad8:	2000      	movs	r0, #0
   93ada:	bc70      	pop	{r4, r5, r6}
   93adc:	4770      	bx	lr
   93ade:	460c      	mov	r4, r1
   93ae0:	4603      	mov	r3, r0
   93ae2:	681e      	ldr	r6, [r3, #0]
   93ae4:	6825      	ldr	r5, [r4, #0]
   93ae6:	4618      	mov	r0, r3
   93ae8:	42ae      	cmp	r6, r5
   93aea:	4621      	mov	r1, r4
   93aec:	f103 0304 	add.w	r3, r3, #4
   93af0:	f104 0404 	add.w	r4, r4, #4
   93af4:	d1e1      	bne.n	93aba <memcmp+0xe>
   93af6:	3a04      	subs	r2, #4
   93af8:	2a03      	cmp	r2, #3
   93afa:	4618      	mov	r0, r3
   93afc:	4621      	mov	r1, r4
   93afe:	d8f0      	bhi.n	93ae2 <memcmp+0x36>
   93b00:	2a00      	cmp	r2, #0
   93b02:	d1da      	bne.n	93aba <memcmp+0xe>
   93b04:	4610      	mov	r0, r2
   93b06:	e7e8      	b.n	93ada <memcmp+0x2e>
   93b08:	1b60      	subs	r0, r4, r5
   93b0a:	bc70      	pop	{r4, r5, r6}
   93b0c:	4770      	bx	lr
   93b0e:	bf00      	nop

00093b10 <memcpy>:
   93b10:	4684      	mov	ip, r0
   93b12:	ea41 0300 	orr.w	r3, r1, r0
   93b16:	f013 0303 	ands.w	r3, r3, #3
   93b1a:	d149      	bne.n	93bb0 <memcpy+0xa0>
   93b1c:	3a40      	subs	r2, #64	; 0x40
   93b1e:	d323      	bcc.n	93b68 <memcpy+0x58>
   93b20:	680b      	ldr	r3, [r1, #0]
   93b22:	6003      	str	r3, [r0, #0]
   93b24:	684b      	ldr	r3, [r1, #4]
   93b26:	6043      	str	r3, [r0, #4]
   93b28:	688b      	ldr	r3, [r1, #8]
   93b2a:	6083      	str	r3, [r0, #8]
   93b2c:	68cb      	ldr	r3, [r1, #12]
   93b2e:	60c3      	str	r3, [r0, #12]
   93b30:	690b      	ldr	r3, [r1, #16]
   93b32:	6103      	str	r3, [r0, #16]
   93b34:	694b      	ldr	r3, [r1, #20]
   93b36:	6143      	str	r3, [r0, #20]
   93b38:	698b      	ldr	r3, [r1, #24]
   93b3a:	6183      	str	r3, [r0, #24]
   93b3c:	69cb      	ldr	r3, [r1, #28]
   93b3e:	61c3      	str	r3, [r0, #28]
   93b40:	6a0b      	ldr	r3, [r1, #32]
   93b42:	6203      	str	r3, [r0, #32]
   93b44:	6a4b      	ldr	r3, [r1, #36]	; 0x24
   93b46:	6243      	str	r3, [r0, #36]	; 0x24
   93b48:	6a8b      	ldr	r3, [r1, #40]	; 0x28
   93b4a:	6283      	str	r3, [r0, #40]	; 0x28
   93b4c:	6acb      	ldr	r3, [r1, #44]	; 0x2c
   93b4e:	62c3      	str	r3, [r0, #44]	; 0x2c
   93b50:	6b0b      	ldr	r3, [r1, #48]	; 0x30
   93b52:	6303      	str	r3, [r0, #48]	; 0x30
   93b54:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   93b56:	6343      	str	r3, [r0, #52]	; 0x34
   93b58:	6b8b      	ldr	r3, [r1, #56]	; 0x38
   93b5a:	6383      	str	r3, [r0, #56]	; 0x38
   93b5c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   93b5e:	63c3      	str	r3, [r0, #60]	; 0x3c
   93b60:	3040      	adds	r0, #64	; 0x40
   93b62:	3140      	adds	r1, #64	; 0x40
   93b64:	3a40      	subs	r2, #64	; 0x40
   93b66:	d2db      	bcs.n	93b20 <memcpy+0x10>
   93b68:	3230      	adds	r2, #48	; 0x30
   93b6a:	d30b      	bcc.n	93b84 <memcpy+0x74>
   93b6c:	680b      	ldr	r3, [r1, #0]
   93b6e:	6003      	str	r3, [r0, #0]
   93b70:	684b      	ldr	r3, [r1, #4]
   93b72:	6043      	str	r3, [r0, #4]
   93b74:	688b      	ldr	r3, [r1, #8]
   93b76:	6083      	str	r3, [r0, #8]
   93b78:	68cb      	ldr	r3, [r1, #12]
   93b7a:	60c3      	str	r3, [r0, #12]
   93b7c:	3010      	adds	r0, #16
   93b7e:	3110      	adds	r1, #16
   93b80:	3a10      	subs	r2, #16
   93b82:	d2f3      	bcs.n	93b6c <memcpy+0x5c>
   93b84:	320c      	adds	r2, #12
   93b86:	d305      	bcc.n	93b94 <memcpy+0x84>
   93b88:	f851 3b04 	ldr.w	r3, [r1], #4
   93b8c:	f840 3b04 	str.w	r3, [r0], #4
   93b90:	3a04      	subs	r2, #4
   93b92:	d2f9      	bcs.n	93b88 <memcpy+0x78>
   93b94:	3204      	adds	r2, #4
   93b96:	d008      	beq.n	93baa <memcpy+0x9a>
   93b98:	07d2      	lsls	r2, r2, #31
   93b9a:	bf1c      	itt	ne
   93b9c:	f811 3b01 	ldrbne.w	r3, [r1], #1
   93ba0:	f800 3b01 	strbne.w	r3, [r0], #1
   93ba4:	d301      	bcc.n	93baa <memcpy+0x9a>
   93ba6:	880b      	ldrh	r3, [r1, #0]
   93ba8:	8003      	strh	r3, [r0, #0]
   93baa:	4660      	mov	r0, ip
   93bac:	4770      	bx	lr
   93bae:	bf00      	nop
   93bb0:	2a08      	cmp	r2, #8
   93bb2:	d313      	bcc.n	93bdc <memcpy+0xcc>
   93bb4:	078b      	lsls	r3, r1, #30
   93bb6:	d0b1      	beq.n	93b1c <memcpy+0xc>
   93bb8:	f010 0303 	ands.w	r3, r0, #3
   93bbc:	d0ae      	beq.n	93b1c <memcpy+0xc>
   93bbe:	f1c3 0304 	rsb	r3, r3, #4
   93bc2:	1ad2      	subs	r2, r2, r3
   93bc4:	07db      	lsls	r3, r3, #31
   93bc6:	bf1c      	itt	ne
   93bc8:	f811 3b01 	ldrbne.w	r3, [r1], #1
   93bcc:	f800 3b01 	strbne.w	r3, [r0], #1
   93bd0:	d3a4      	bcc.n	93b1c <memcpy+0xc>
   93bd2:	f831 3b02 	ldrh.w	r3, [r1], #2
   93bd6:	f820 3b02 	strh.w	r3, [r0], #2
   93bda:	e79f      	b.n	93b1c <memcpy+0xc>
   93bdc:	3a04      	subs	r2, #4
   93bde:	d3d9      	bcc.n	93b94 <memcpy+0x84>
   93be0:	3a01      	subs	r2, #1
   93be2:	f811 3b01 	ldrb.w	r3, [r1], #1
   93be6:	f800 3b01 	strb.w	r3, [r0], #1
   93bea:	d2f9      	bcs.n	93be0 <memcpy+0xd0>
   93bec:	780b      	ldrb	r3, [r1, #0]
   93bee:	7003      	strb	r3, [r0, #0]
   93bf0:	784b      	ldrb	r3, [r1, #1]
   93bf2:	7043      	strb	r3, [r0, #1]
   93bf4:	788b      	ldrb	r3, [r1, #2]
   93bf6:	7083      	strb	r3, [r0, #2]
   93bf8:	4660      	mov	r0, ip
   93bfa:	4770      	bx	lr

00093bfc <memmove>:
   93bfc:	4288      	cmp	r0, r1
   93bfe:	b5f0      	push	{r4, r5, r6, r7, lr}
   93c00:	d90d      	bls.n	93c1e <memmove+0x22>
   93c02:	188b      	adds	r3, r1, r2
   93c04:	4298      	cmp	r0, r3
   93c06:	d20a      	bcs.n	93c1e <memmove+0x22>
   93c08:	1881      	adds	r1, r0, r2
   93c0a:	2a00      	cmp	r2, #0
   93c0c:	d051      	beq.n	93cb2 <memmove+0xb6>
   93c0e:	1a9a      	subs	r2, r3, r2
   93c10:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   93c14:	4293      	cmp	r3, r2
   93c16:	f801 4d01 	strb.w	r4, [r1, #-1]!
   93c1a:	d1f9      	bne.n	93c10 <memmove+0x14>
   93c1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   93c1e:	2a0f      	cmp	r2, #15
   93c20:	d948      	bls.n	93cb4 <memmove+0xb8>
   93c22:	ea41 0300 	orr.w	r3, r1, r0
   93c26:	079b      	lsls	r3, r3, #30
   93c28:	d146      	bne.n	93cb8 <memmove+0xbc>
   93c2a:	4615      	mov	r5, r2
   93c2c:	f100 0410 	add.w	r4, r0, #16
   93c30:	f101 0310 	add.w	r3, r1, #16
   93c34:	f853 6c10 	ldr.w	r6, [r3, #-16]
   93c38:	3d10      	subs	r5, #16
   93c3a:	f844 6c10 	str.w	r6, [r4, #-16]
   93c3e:	f853 6c0c 	ldr.w	r6, [r3, #-12]
   93c42:	2d0f      	cmp	r5, #15
   93c44:	f844 6c0c 	str.w	r6, [r4, #-12]
   93c48:	f853 6c08 	ldr.w	r6, [r3, #-8]
   93c4c:	f104 0410 	add.w	r4, r4, #16
   93c50:	f844 6c18 	str.w	r6, [r4, #-24]
   93c54:	f853 6c04 	ldr.w	r6, [r3, #-4]
   93c58:	f103 0310 	add.w	r3, r3, #16
   93c5c:	f844 6c14 	str.w	r6, [r4, #-20]
   93c60:	d8e8      	bhi.n	93c34 <memmove+0x38>
   93c62:	f1a2 0310 	sub.w	r3, r2, #16
   93c66:	f023 030f 	bic.w	r3, r3, #15
   93c6a:	f002 0e0f 	and.w	lr, r2, #15
   93c6e:	3310      	adds	r3, #16
   93c70:	f1be 0f03 	cmp.w	lr, #3
   93c74:	4419      	add	r1, r3
   93c76:	4403      	add	r3, r0
   93c78:	d921      	bls.n	93cbe <memmove+0xc2>
   93c7a:	460e      	mov	r6, r1
   93c7c:	4674      	mov	r4, lr
   93c7e:	1f1d      	subs	r5, r3, #4
   93c80:	f856 7b04 	ldr.w	r7, [r6], #4
   93c84:	3c04      	subs	r4, #4
   93c86:	2c03      	cmp	r4, #3
   93c88:	f845 7f04 	str.w	r7, [r5, #4]!
   93c8c:	d8f8      	bhi.n	93c80 <memmove+0x84>
   93c8e:	f1ae 0404 	sub.w	r4, lr, #4
   93c92:	f024 0403 	bic.w	r4, r4, #3
   93c96:	3404      	adds	r4, #4
   93c98:	4423      	add	r3, r4
   93c9a:	4421      	add	r1, r4
   93c9c:	f002 0203 	and.w	r2, r2, #3
   93ca0:	b162      	cbz	r2, 93cbc <memmove+0xc0>
   93ca2:	3b01      	subs	r3, #1
   93ca4:	440a      	add	r2, r1
   93ca6:	f811 4b01 	ldrb.w	r4, [r1], #1
   93caa:	428a      	cmp	r2, r1
   93cac:	f803 4f01 	strb.w	r4, [r3, #1]!
   93cb0:	d1f9      	bne.n	93ca6 <memmove+0xaa>
   93cb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   93cb4:	4603      	mov	r3, r0
   93cb6:	e7f3      	b.n	93ca0 <memmove+0xa4>
   93cb8:	4603      	mov	r3, r0
   93cba:	e7f2      	b.n	93ca2 <memmove+0xa6>
   93cbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   93cbe:	4672      	mov	r2, lr
   93cc0:	e7ee      	b.n	93ca0 <memmove+0xa4>
   93cc2:	bf00      	nop

00093cc4 <memset>:
   93cc4:	b470      	push	{r4, r5, r6}
   93cc6:	0784      	lsls	r4, r0, #30
   93cc8:	d046      	beq.n	93d58 <memset+0x94>
   93cca:	1e54      	subs	r4, r2, #1
   93ccc:	2a00      	cmp	r2, #0
   93cce:	d041      	beq.n	93d54 <memset+0x90>
   93cd0:	b2cd      	uxtb	r5, r1
   93cd2:	4603      	mov	r3, r0
   93cd4:	e002      	b.n	93cdc <memset+0x18>
   93cd6:	1e62      	subs	r2, r4, #1
   93cd8:	b3e4      	cbz	r4, 93d54 <memset+0x90>
   93cda:	4614      	mov	r4, r2
   93cdc:	f803 5b01 	strb.w	r5, [r3], #1
   93ce0:	079a      	lsls	r2, r3, #30
   93ce2:	d1f8      	bne.n	93cd6 <memset+0x12>
   93ce4:	2c03      	cmp	r4, #3
   93ce6:	d92e      	bls.n	93d46 <memset+0x82>
   93ce8:	b2cd      	uxtb	r5, r1
   93cea:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   93cee:	2c0f      	cmp	r4, #15
   93cf0:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   93cf4:	d919      	bls.n	93d2a <memset+0x66>
   93cf6:	4626      	mov	r6, r4
   93cf8:	f103 0210 	add.w	r2, r3, #16
   93cfc:	3e10      	subs	r6, #16
   93cfe:	2e0f      	cmp	r6, #15
   93d00:	f842 5c10 	str.w	r5, [r2, #-16]
   93d04:	f842 5c0c 	str.w	r5, [r2, #-12]
   93d08:	f842 5c08 	str.w	r5, [r2, #-8]
   93d0c:	f842 5c04 	str.w	r5, [r2, #-4]
   93d10:	f102 0210 	add.w	r2, r2, #16
   93d14:	d8f2      	bhi.n	93cfc <memset+0x38>
   93d16:	f1a4 0210 	sub.w	r2, r4, #16
   93d1a:	f022 020f 	bic.w	r2, r2, #15
   93d1e:	f004 040f 	and.w	r4, r4, #15
   93d22:	3210      	adds	r2, #16
   93d24:	2c03      	cmp	r4, #3
   93d26:	4413      	add	r3, r2
   93d28:	d90d      	bls.n	93d46 <memset+0x82>
   93d2a:	461e      	mov	r6, r3
   93d2c:	4622      	mov	r2, r4
   93d2e:	3a04      	subs	r2, #4
   93d30:	2a03      	cmp	r2, #3
   93d32:	f846 5b04 	str.w	r5, [r6], #4
   93d36:	d8fa      	bhi.n	93d2e <memset+0x6a>
   93d38:	1f22      	subs	r2, r4, #4
   93d3a:	f022 0203 	bic.w	r2, r2, #3
   93d3e:	3204      	adds	r2, #4
   93d40:	4413      	add	r3, r2
   93d42:	f004 0403 	and.w	r4, r4, #3
   93d46:	b12c      	cbz	r4, 93d54 <memset+0x90>
   93d48:	b2c9      	uxtb	r1, r1
   93d4a:	441c      	add	r4, r3
   93d4c:	f803 1b01 	strb.w	r1, [r3], #1
   93d50:	42a3      	cmp	r3, r4
   93d52:	d1fb      	bne.n	93d4c <memset+0x88>
   93d54:	bc70      	pop	{r4, r5, r6}
   93d56:	4770      	bx	lr
   93d58:	4614      	mov	r4, r2
   93d5a:	4603      	mov	r3, r0
   93d5c:	e7c2      	b.n	93ce4 <memset+0x20>
   93d5e:	bf00      	nop

00093d60 <__malloc_lock>:
   93d60:	4770      	bx	lr
   93d62:	bf00      	nop

00093d64 <__malloc_unlock>:
   93d64:	4770      	bx	lr
   93d66:	bf00      	nop

00093d68 <realloc>:
   93d68:	4b02      	ldr	r3, [pc, #8]	; (93d74 <realloc+0xc>)
   93d6a:	460a      	mov	r2, r1
   93d6c:	4601      	mov	r1, r0
   93d6e:	6818      	ldr	r0, [r3, #0]
   93d70:	f000 b802 	b.w	93d78 <_realloc_r>
   93d74:	20070548 	.word	0x20070548

00093d78 <_realloc_r>:
   93d78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   93d7c:	4617      	mov	r7, r2
   93d7e:	b083      	sub	sp, #12
   93d80:	2900      	cmp	r1, #0
   93d82:	f000 808f 	beq.w	93ea4 <_realloc_r+0x12c>
   93d86:	460d      	mov	r5, r1
   93d88:	4681      	mov	r9, r0
   93d8a:	f107 040b 	add.w	r4, r7, #11
   93d8e:	f7ff ffe7 	bl	93d60 <__malloc_lock>
   93d92:	f855 ec04 	ldr.w	lr, [r5, #-4]
   93d96:	2c16      	cmp	r4, #22
   93d98:	f02e 0603 	bic.w	r6, lr, #3
   93d9c:	f1a5 0808 	sub.w	r8, r5, #8
   93da0:	d83c      	bhi.n	93e1c <_realloc_r+0xa4>
   93da2:	2210      	movs	r2, #16
   93da4:	4614      	mov	r4, r2
   93da6:	42a7      	cmp	r7, r4
   93da8:	d83d      	bhi.n	93e26 <_realloc_r+0xae>
   93daa:	4296      	cmp	r6, r2
   93dac:	da42      	bge.n	93e34 <_realloc_r+0xbc>
   93dae:	4bc6      	ldr	r3, [pc, #792]	; (940c8 <_realloc_r+0x350>)
   93db0:	eb08 0006 	add.w	r0, r8, r6
   93db4:	6899      	ldr	r1, [r3, #8]
   93db6:	4288      	cmp	r0, r1
   93db8:	6841      	ldr	r1, [r0, #4]
   93dba:	f000 80d7 	beq.w	93f6c <_realloc_r+0x1f4>
   93dbe:	f021 0301 	bic.w	r3, r1, #1
   93dc2:	4403      	add	r3, r0
   93dc4:	685b      	ldr	r3, [r3, #4]
   93dc6:	07db      	lsls	r3, r3, #31
   93dc8:	d54c      	bpl.n	93e64 <_realloc_r+0xec>
   93dca:	f01e 0f01 	tst.w	lr, #1
   93dce:	f000 809d 	beq.w	93f0c <_realloc_r+0x194>
   93dd2:	4639      	mov	r1, r7
   93dd4:	4648      	mov	r0, r9
   93dd6:	f7ff fbbd 	bl	93554 <_malloc_r>
   93dda:	4607      	mov	r7, r0
   93ddc:	2800      	cmp	r0, #0
   93dde:	d03a      	beq.n	93e56 <_realloc_r+0xde>
   93de0:	f855 3c04 	ldr.w	r3, [r5, #-4]
   93de4:	f1a0 0208 	sub.w	r2, r0, #8
   93de8:	f023 0301 	bic.w	r3, r3, #1
   93dec:	4443      	add	r3, r8
   93dee:	429a      	cmp	r2, r3
   93df0:	f000 813e 	beq.w	94070 <_realloc_r+0x2f8>
   93df4:	1f32      	subs	r2, r6, #4
   93df6:	2a24      	cmp	r2, #36	; 0x24
   93df8:	f200 812b 	bhi.w	94052 <_realloc_r+0x2da>
   93dfc:	2a13      	cmp	r2, #19
   93dfe:	f200 80ff 	bhi.w	94000 <_realloc_r+0x288>
   93e02:	4603      	mov	r3, r0
   93e04:	462a      	mov	r2, r5
   93e06:	6811      	ldr	r1, [r2, #0]
   93e08:	6019      	str	r1, [r3, #0]
   93e0a:	6851      	ldr	r1, [r2, #4]
   93e0c:	6059      	str	r1, [r3, #4]
   93e0e:	6892      	ldr	r2, [r2, #8]
   93e10:	609a      	str	r2, [r3, #8]
   93e12:	4629      	mov	r1, r5
   93e14:	4648      	mov	r0, r9
   93e16:	f004 f8a1 	bl	97f5c <_free_r>
   93e1a:	e01c      	b.n	93e56 <_realloc_r+0xde>
   93e1c:	f024 0407 	bic.w	r4, r4, #7
   93e20:	2c00      	cmp	r4, #0
   93e22:	4622      	mov	r2, r4
   93e24:	dabf      	bge.n	93da6 <_realloc_r+0x2e>
   93e26:	230c      	movs	r3, #12
   93e28:	2000      	movs	r0, #0
   93e2a:	f8c9 3000 	str.w	r3, [r9]
   93e2e:	b003      	add	sp, #12
   93e30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   93e34:	462f      	mov	r7, r5
   93e36:	1b33      	subs	r3, r6, r4
   93e38:	2b0f      	cmp	r3, #15
   93e3a:	f8d8 2004 	ldr.w	r2, [r8, #4]
   93e3e:	d81d      	bhi.n	93e7c <_realloc_r+0x104>
   93e40:	f002 0201 	and.w	r2, r2, #1
   93e44:	4332      	orrs	r2, r6
   93e46:	eb08 0106 	add.w	r1, r8, r6
   93e4a:	f8c8 2004 	str.w	r2, [r8, #4]
   93e4e:	684b      	ldr	r3, [r1, #4]
   93e50:	f043 0301 	orr.w	r3, r3, #1
   93e54:	604b      	str	r3, [r1, #4]
   93e56:	4648      	mov	r0, r9
   93e58:	f7ff ff84 	bl	93d64 <__malloc_unlock>
   93e5c:	4638      	mov	r0, r7
   93e5e:	b003      	add	sp, #12
   93e60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   93e64:	f021 0103 	bic.w	r1, r1, #3
   93e68:	4431      	add	r1, r6
   93e6a:	4291      	cmp	r1, r2
   93e6c:	db20      	blt.n	93eb0 <_realloc_r+0x138>
   93e6e:	68c3      	ldr	r3, [r0, #12]
   93e70:	6882      	ldr	r2, [r0, #8]
   93e72:	462f      	mov	r7, r5
   93e74:	60d3      	str	r3, [r2, #12]
   93e76:	460e      	mov	r6, r1
   93e78:	609a      	str	r2, [r3, #8]
   93e7a:	e7dc      	b.n	93e36 <_realloc_r+0xbe>
   93e7c:	f002 0201 	and.w	r2, r2, #1
   93e80:	eb08 0104 	add.w	r1, r8, r4
   93e84:	4314      	orrs	r4, r2
   93e86:	f043 0201 	orr.w	r2, r3, #1
   93e8a:	f8c8 4004 	str.w	r4, [r8, #4]
   93e8e:	440b      	add	r3, r1
   93e90:	604a      	str	r2, [r1, #4]
   93e92:	685a      	ldr	r2, [r3, #4]
   93e94:	3108      	adds	r1, #8
   93e96:	f042 0201 	orr.w	r2, r2, #1
   93e9a:	605a      	str	r2, [r3, #4]
   93e9c:	4648      	mov	r0, r9
   93e9e:	f004 f85d 	bl	97f5c <_free_r>
   93ea2:	e7d8      	b.n	93e56 <_realloc_r+0xde>
   93ea4:	4611      	mov	r1, r2
   93ea6:	b003      	add	sp, #12
   93ea8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   93eac:	f7ff bb52 	b.w	93554 <_malloc_r>
   93eb0:	f01e 0f01 	tst.w	lr, #1
   93eb4:	d18d      	bne.n	93dd2 <_realloc_r+0x5a>
   93eb6:	f855 3c08 	ldr.w	r3, [r5, #-8]
   93eba:	ebc3 0a08 	rsb	sl, r3, r8
   93ebe:	f8da 3004 	ldr.w	r3, [sl, #4]
   93ec2:	f023 0c03 	bic.w	ip, r3, #3
   93ec6:	eb01 0e0c 	add.w	lr, r1, ip
   93eca:	4596      	cmp	lr, r2
   93ecc:	db26      	blt.n	93f1c <_realloc_r+0x1a4>
   93ece:	4657      	mov	r7, sl
   93ed0:	68c3      	ldr	r3, [r0, #12]
   93ed2:	6881      	ldr	r1, [r0, #8]
   93ed4:	1f32      	subs	r2, r6, #4
   93ed6:	60cb      	str	r3, [r1, #12]
   93ed8:	6099      	str	r1, [r3, #8]
   93eda:	f857 1f08 	ldr.w	r1, [r7, #8]!
   93ede:	f8da 300c 	ldr.w	r3, [sl, #12]
   93ee2:	2a24      	cmp	r2, #36	; 0x24
   93ee4:	60cb      	str	r3, [r1, #12]
   93ee6:	6099      	str	r1, [r3, #8]
   93ee8:	f200 80c9 	bhi.w	9407e <_realloc_r+0x306>
   93eec:	2a13      	cmp	r2, #19
   93eee:	f240 8092 	bls.w	94016 <_realloc_r+0x29e>
   93ef2:	682b      	ldr	r3, [r5, #0]
   93ef4:	2a1b      	cmp	r2, #27
   93ef6:	f8ca 3008 	str.w	r3, [sl, #8]
   93efa:	686b      	ldr	r3, [r5, #4]
   93efc:	f8ca 300c 	str.w	r3, [sl, #12]
   93f00:	f200 80cd 	bhi.w	9409e <_realloc_r+0x326>
   93f04:	3508      	adds	r5, #8
   93f06:	f10a 0310 	add.w	r3, sl, #16
   93f0a:	e085      	b.n	94018 <_realloc_r+0x2a0>
   93f0c:	f855 3c08 	ldr.w	r3, [r5, #-8]
   93f10:	ebc3 0a08 	rsb	sl, r3, r8
   93f14:	f8da 3004 	ldr.w	r3, [sl, #4]
   93f18:	f023 0c03 	bic.w	ip, r3, #3
   93f1c:	eb06 030c 	add.w	r3, r6, ip
   93f20:	4293      	cmp	r3, r2
   93f22:	f6ff af56 	blt.w	93dd2 <_realloc_r+0x5a>
   93f26:	4657      	mov	r7, sl
   93f28:	f8da 100c 	ldr.w	r1, [sl, #12]
   93f2c:	f857 0f08 	ldr.w	r0, [r7, #8]!
   93f30:	1f32      	subs	r2, r6, #4
   93f32:	2a24      	cmp	r2, #36	; 0x24
   93f34:	60c1      	str	r1, [r0, #12]
   93f36:	6088      	str	r0, [r1, #8]
   93f38:	f200 80aa 	bhi.w	94090 <_realloc_r+0x318>
   93f3c:	2a13      	cmp	r2, #19
   93f3e:	f240 80a5 	bls.w	9408c <_realloc_r+0x314>
   93f42:	6829      	ldr	r1, [r5, #0]
   93f44:	2a1b      	cmp	r2, #27
   93f46:	f8ca 1008 	str.w	r1, [sl, #8]
   93f4a:	6869      	ldr	r1, [r5, #4]
   93f4c:	f8ca 100c 	str.w	r1, [sl, #12]
   93f50:	f200 80bc 	bhi.w	940cc <_realloc_r+0x354>
   93f54:	3508      	adds	r5, #8
   93f56:	f10a 0210 	add.w	r2, sl, #16
   93f5a:	6829      	ldr	r1, [r5, #0]
   93f5c:	461e      	mov	r6, r3
   93f5e:	6011      	str	r1, [r2, #0]
   93f60:	6869      	ldr	r1, [r5, #4]
   93f62:	46d0      	mov	r8, sl
   93f64:	6051      	str	r1, [r2, #4]
   93f66:	68ab      	ldr	r3, [r5, #8]
   93f68:	6093      	str	r3, [r2, #8]
   93f6a:	e764      	b.n	93e36 <_realloc_r+0xbe>
   93f6c:	f021 0b03 	bic.w	fp, r1, #3
   93f70:	f104 0010 	add.w	r0, r4, #16
   93f74:	44b3      	add	fp, r6
   93f76:	4583      	cmp	fp, r0
   93f78:	da57      	bge.n	9402a <_realloc_r+0x2b2>
   93f7a:	f01e 0f01 	tst.w	lr, #1
   93f7e:	f47f af28 	bne.w	93dd2 <_realloc_r+0x5a>
   93f82:	f855 1c08 	ldr.w	r1, [r5, #-8]
   93f86:	ebc1 0a08 	rsb	sl, r1, r8
   93f8a:	f8da 1004 	ldr.w	r1, [sl, #4]
   93f8e:	f021 0c03 	bic.w	ip, r1, #3
   93f92:	44e3      	add	fp, ip
   93f94:	4558      	cmp	r0, fp
   93f96:	dcc1      	bgt.n	93f1c <_realloc_r+0x1a4>
   93f98:	4657      	mov	r7, sl
   93f9a:	f8da 100c 	ldr.w	r1, [sl, #12]
   93f9e:	f857 0f08 	ldr.w	r0, [r7, #8]!
   93fa2:	1f32      	subs	r2, r6, #4
   93fa4:	2a24      	cmp	r2, #36	; 0x24
   93fa6:	60c1      	str	r1, [r0, #12]
   93fa8:	6088      	str	r0, [r1, #8]
   93faa:	f200 80b1 	bhi.w	94110 <_realloc_r+0x398>
   93fae:	2a13      	cmp	r2, #19
   93fb0:	f240 80a2 	bls.w	940f8 <_realloc_r+0x380>
   93fb4:	6829      	ldr	r1, [r5, #0]
   93fb6:	2a1b      	cmp	r2, #27
   93fb8:	f8ca 1008 	str.w	r1, [sl, #8]
   93fbc:	6869      	ldr	r1, [r5, #4]
   93fbe:	f8ca 100c 	str.w	r1, [sl, #12]
   93fc2:	f200 80ac 	bhi.w	9411e <_realloc_r+0x3a6>
   93fc6:	3508      	adds	r5, #8
   93fc8:	f10a 0210 	add.w	r2, sl, #16
   93fcc:	6829      	ldr	r1, [r5, #0]
   93fce:	6011      	str	r1, [r2, #0]
   93fd0:	6869      	ldr	r1, [r5, #4]
   93fd2:	6051      	str	r1, [r2, #4]
   93fd4:	68a9      	ldr	r1, [r5, #8]
   93fd6:	6091      	str	r1, [r2, #8]
   93fd8:	ebc4 020b 	rsb	r2, r4, fp
   93fdc:	eb0a 0104 	add.w	r1, sl, r4
   93fe0:	f042 0201 	orr.w	r2, r2, #1
   93fe4:	6099      	str	r1, [r3, #8]
   93fe6:	604a      	str	r2, [r1, #4]
   93fe8:	f8da 3004 	ldr.w	r3, [sl, #4]
   93fec:	4648      	mov	r0, r9
   93fee:	f003 0301 	and.w	r3, r3, #1
   93ff2:	431c      	orrs	r4, r3
   93ff4:	f8ca 4004 	str.w	r4, [sl, #4]
   93ff8:	f7ff feb4 	bl	93d64 <__malloc_unlock>
   93ffc:	4638      	mov	r0, r7
   93ffe:	e72e      	b.n	93e5e <_realloc_r+0xe6>
   94000:	682b      	ldr	r3, [r5, #0]
   94002:	2a1b      	cmp	r2, #27
   94004:	6003      	str	r3, [r0, #0]
   94006:	686b      	ldr	r3, [r5, #4]
   94008:	6043      	str	r3, [r0, #4]
   9400a:	d826      	bhi.n	9405a <_realloc_r+0x2e2>
   9400c:	f100 0308 	add.w	r3, r0, #8
   94010:	f105 0208 	add.w	r2, r5, #8
   94014:	e6f7      	b.n	93e06 <_realloc_r+0x8e>
   94016:	463b      	mov	r3, r7
   94018:	682a      	ldr	r2, [r5, #0]
   9401a:	4676      	mov	r6, lr
   9401c:	601a      	str	r2, [r3, #0]
   9401e:	686a      	ldr	r2, [r5, #4]
   94020:	46d0      	mov	r8, sl
   94022:	605a      	str	r2, [r3, #4]
   94024:	68aa      	ldr	r2, [r5, #8]
   94026:	609a      	str	r2, [r3, #8]
   94028:	e705      	b.n	93e36 <_realloc_r+0xbe>
   9402a:	ebc4 0b0b 	rsb	fp, r4, fp
   9402e:	eb08 0104 	add.w	r1, r8, r4
   94032:	f04b 0201 	orr.w	r2, fp, #1
   94036:	6099      	str	r1, [r3, #8]
   94038:	604a      	str	r2, [r1, #4]
   9403a:	f855 3c04 	ldr.w	r3, [r5, #-4]
   9403e:	4648      	mov	r0, r9
   94040:	f003 0301 	and.w	r3, r3, #1
   94044:	431c      	orrs	r4, r3
   94046:	f845 4c04 	str.w	r4, [r5, #-4]
   9404a:	f7ff fe8b 	bl	93d64 <__malloc_unlock>
   9404e:	4628      	mov	r0, r5
   94050:	e705      	b.n	93e5e <_realloc_r+0xe6>
   94052:	4629      	mov	r1, r5
   94054:	f7ff fdd2 	bl	93bfc <memmove>
   94058:	e6db      	b.n	93e12 <_realloc_r+0x9a>
   9405a:	68ab      	ldr	r3, [r5, #8]
   9405c:	2a24      	cmp	r2, #36	; 0x24
   9405e:	6083      	str	r3, [r0, #8]
   94060:	68eb      	ldr	r3, [r5, #12]
   94062:	60c3      	str	r3, [r0, #12]
   94064:	d027      	beq.n	940b6 <_realloc_r+0x33e>
   94066:	f100 0310 	add.w	r3, r0, #16
   9406a:	f105 0210 	add.w	r2, r5, #16
   9406e:	e6ca      	b.n	93e06 <_realloc_r+0x8e>
   94070:	f850 3c04 	ldr.w	r3, [r0, #-4]
   94074:	462f      	mov	r7, r5
   94076:	f023 0303 	bic.w	r3, r3, #3
   9407a:	441e      	add	r6, r3
   9407c:	e6db      	b.n	93e36 <_realloc_r+0xbe>
   9407e:	4629      	mov	r1, r5
   94080:	4638      	mov	r0, r7
   94082:	4676      	mov	r6, lr
   94084:	46d0      	mov	r8, sl
   94086:	f7ff fdb9 	bl	93bfc <memmove>
   9408a:	e6d4      	b.n	93e36 <_realloc_r+0xbe>
   9408c:	463a      	mov	r2, r7
   9408e:	e764      	b.n	93f5a <_realloc_r+0x1e2>
   94090:	4629      	mov	r1, r5
   94092:	4638      	mov	r0, r7
   94094:	461e      	mov	r6, r3
   94096:	46d0      	mov	r8, sl
   94098:	f7ff fdb0 	bl	93bfc <memmove>
   9409c:	e6cb      	b.n	93e36 <_realloc_r+0xbe>
   9409e:	68ab      	ldr	r3, [r5, #8]
   940a0:	2a24      	cmp	r2, #36	; 0x24
   940a2:	f8ca 3010 	str.w	r3, [sl, #16]
   940a6:	68eb      	ldr	r3, [r5, #12]
   940a8:	f8ca 3014 	str.w	r3, [sl, #20]
   940ac:	d01a      	beq.n	940e4 <_realloc_r+0x36c>
   940ae:	3510      	adds	r5, #16
   940b0:	f10a 0318 	add.w	r3, sl, #24
   940b4:	e7b0      	b.n	94018 <_realloc_r+0x2a0>
   940b6:	692a      	ldr	r2, [r5, #16]
   940b8:	f100 0318 	add.w	r3, r0, #24
   940bc:	6102      	str	r2, [r0, #16]
   940be:	6969      	ldr	r1, [r5, #20]
   940c0:	f105 0218 	add.w	r2, r5, #24
   940c4:	6141      	str	r1, [r0, #20]
   940c6:	e69e      	b.n	93e06 <_realloc_r+0x8e>
   940c8:	2007054c 	.word	0x2007054c
   940cc:	68a9      	ldr	r1, [r5, #8]
   940ce:	2a24      	cmp	r2, #36	; 0x24
   940d0:	f8ca 1010 	str.w	r1, [sl, #16]
   940d4:	68e9      	ldr	r1, [r5, #12]
   940d6:	f8ca 1014 	str.w	r1, [sl, #20]
   940da:	d00f      	beq.n	940fc <_realloc_r+0x384>
   940dc:	3510      	adds	r5, #16
   940de:	f10a 0218 	add.w	r2, sl, #24
   940e2:	e73a      	b.n	93f5a <_realloc_r+0x1e2>
   940e4:	692a      	ldr	r2, [r5, #16]
   940e6:	f10a 0320 	add.w	r3, sl, #32
   940ea:	f8ca 2018 	str.w	r2, [sl, #24]
   940ee:	696a      	ldr	r2, [r5, #20]
   940f0:	3518      	adds	r5, #24
   940f2:	f8ca 201c 	str.w	r2, [sl, #28]
   940f6:	e78f      	b.n	94018 <_realloc_r+0x2a0>
   940f8:	463a      	mov	r2, r7
   940fa:	e767      	b.n	93fcc <_realloc_r+0x254>
   940fc:	6929      	ldr	r1, [r5, #16]
   940fe:	f10a 0220 	add.w	r2, sl, #32
   94102:	f8ca 1018 	str.w	r1, [sl, #24]
   94106:	6969      	ldr	r1, [r5, #20]
   94108:	3518      	adds	r5, #24
   9410a:	f8ca 101c 	str.w	r1, [sl, #28]
   9410e:	e724      	b.n	93f5a <_realloc_r+0x1e2>
   94110:	4629      	mov	r1, r5
   94112:	4638      	mov	r0, r7
   94114:	9301      	str	r3, [sp, #4]
   94116:	f7ff fd71 	bl	93bfc <memmove>
   9411a:	9b01      	ldr	r3, [sp, #4]
   9411c:	e75c      	b.n	93fd8 <_realloc_r+0x260>
   9411e:	68a9      	ldr	r1, [r5, #8]
   94120:	2a24      	cmp	r2, #36	; 0x24
   94122:	f8ca 1010 	str.w	r1, [sl, #16]
   94126:	68e9      	ldr	r1, [r5, #12]
   94128:	f8ca 1014 	str.w	r1, [sl, #20]
   9412c:	d003      	beq.n	94136 <_realloc_r+0x3be>
   9412e:	3510      	adds	r5, #16
   94130:	f10a 0218 	add.w	r2, sl, #24
   94134:	e74a      	b.n	93fcc <_realloc_r+0x254>
   94136:	6929      	ldr	r1, [r5, #16]
   94138:	f10a 0220 	add.w	r2, sl, #32
   9413c:	f8ca 1018 	str.w	r1, [sl, #24]
   94140:	6969      	ldr	r1, [r5, #20]
   94142:	3518      	adds	r5, #24
   94144:	f8ca 101c 	str.w	r1, [sl, #28]
   94148:	e740      	b.n	93fcc <_realloc_r+0x254>
   9414a:	bf00      	nop

0009414c <_sbrk_r>:
   9414c:	b538      	push	{r3, r4, r5, lr}
   9414e:	4c07      	ldr	r4, [pc, #28]	; (9416c <_sbrk_r+0x20>)
   94150:	2300      	movs	r3, #0
   94152:	4605      	mov	r5, r0
   94154:	4608      	mov	r0, r1
   94156:	6023      	str	r3, [r4, #0]
   94158:	f7ec f8f0 	bl	8033c <_sbrk>
   9415c:	1c43      	adds	r3, r0, #1
   9415e:	d000      	beq.n	94162 <_sbrk_r+0x16>
   94160:	bd38      	pop	{r3, r4, r5, pc}
   94162:	6823      	ldr	r3, [r4, #0]
   94164:	2b00      	cmp	r3, #0
   94166:	d0fb      	beq.n	94160 <_sbrk_r+0x14>
   94168:	602b      	str	r3, [r5, #0]
   9416a:	bd38      	pop	{r3, r4, r5, pc}
   9416c:	20071d00 	.word	0x20071d00

00094170 <sprintf>:
   94170:	b40e      	push	{r1, r2, r3}
   94172:	4601      	mov	r1, r0
   94174:	b5f0      	push	{r4, r5, r6, r7, lr}
   94176:	f64f 77ff 	movw	r7, #65535	; 0xffff
   9417a:	b09c      	sub	sp, #112	; 0x70
   9417c:	ac21      	add	r4, sp, #132	; 0x84
   9417e:	f854 2b04 	ldr.w	r2, [r4], #4
   94182:	480d      	ldr	r0, [pc, #52]	; (941b8 <sprintf+0x48>)
   94184:	4623      	mov	r3, r4
   94186:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
   9418a:	9102      	str	r1, [sp, #8]
   9418c:	9106      	str	r1, [sp, #24]
   9418e:	f44f 7602 	mov.w	r6, #520	; 0x208
   94192:	a902      	add	r1, sp, #8
   94194:	6800      	ldr	r0, [r0, #0]
   94196:	9401      	str	r4, [sp, #4]
   94198:	f8ad 7016 	strh.w	r7, [sp, #22]
   9419c:	f8ad 6014 	strh.w	r6, [sp, #20]
   941a0:	9504      	str	r5, [sp, #16]
   941a2:	9507      	str	r5, [sp, #28]
   941a4:	f000 f932 	bl	9440c <_svfprintf_r>
   941a8:	9b02      	ldr	r3, [sp, #8]
   941aa:	2200      	movs	r2, #0
   941ac:	701a      	strb	r2, [r3, #0]
   941ae:	b01c      	add	sp, #112	; 0x70
   941b0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   941b4:	b003      	add	sp, #12
   941b6:	4770      	bx	lr
   941b8:	20070548 	.word	0x20070548

000941bc <strchr>:
   941bc:	b470      	push	{r4, r5, r6}
   941be:	f011 04ff 	ands.w	r4, r1, #255	; 0xff
   941c2:	d034      	beq.n	9422e <strchr+0x72>
   941c4:	0785      	lsls	r5, r0, #30
   941c6:	d00f      	beq.n	941e8 <strchr+0x2c>
   941c8:	7803      	ldrb	r3, [r0, #0]
   941ca:	2b00      	cmp	r3, #0
   941cc:	d05a      	beq.n	94284 <strchr+0xc8>
   941ce:	429c      	cmp	r4, r3
   941d0:	d02b      	beq.n	9422a <strchr+0x6e>
   941d2:	1c43      	adds	r3, r0, #1
   941d4:	e005      	b.n	941e2 <strchr+0x26>
   941d6:	f813 2b01 	ldrb.w	r2, [r3], #1
   941da:	2a00      	cmp	r2, #0
   941dc:	d04f      	beq.n	9427e <strchr+0xc2>
   941de:	4294      	cmp	r4, r2
   941e0:	d023      	beq.n	9422a <strchr+0x6e>
   941e2:	079a      	lsls	r2, r3, #30
   941e4:	4618      	mov	r0, r3
   941e6:	d1f6      	bne.n	941d6 <strchr+0x1a>
   941e8:	020e      	lsls	r6, r1, #8
   941ea:	f406 467f 	and.w	r6, r6, #65280	; 0xff00
   941ee:	4326      	orrs	r6, r4
   941f0:	6803      	ldr	r3, [r0, #0]
   941f2:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
   941f6:	e001      	b.n	941fc <strchr+0x40>
   941f8:	f850 3f04 	ldr.w	r3, [r0, #4]!
   941fc:	ea86 0503 	eor.w	r5, r6, r3
   94200:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
   94204:	f1a3 3101 	sub.w	r1, r3, #16843009	; 0x1010101
   94208:	ea22 0205 	bic.w	r2, r2, r5
   9420c:	ea21 0303 	bic.w	r3, r1, r3
   94210:	4313      	orrs	r3, r2
   94212:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   94216:	d0ef      	beq.n	941f8 <strchr+0x3c>
   94218:	7803      	ldrb	r3, [r0, #0]
   9421a:	b923      	cbnz	r3, 94226 <strchr+0x6a>
   9421c:	e032      	b.n	94284 <strchr+0xc8>
   9421e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   94222:	2b00      	cmp	r3, #0
   94224:	d02e      	beq.n	94284 <strchr+0xc8>
   94226:	429c      	cmp	r4, r3
   94228:	d1f9      	bne.n	9421e <strchr+0x62>
   9422a:	bc70      	pop	{r4, r5, r6}
   9422c:	4770      	bx	lr
   9422e:	0784      	lsls	r4, r0, #30
   94230:	d00b      	beq.n	9424a <strchr+0x8e>
   94232:	7803      	ldrb	r3, [r0, #0]
   94234:	2b00      	cmp	r3, #0
   94236:	d0f8      	beq.n	9422a <strchr+0x6e>
   94238:	1c43      	adds	r3, r0, #1
   9423a:	e003      	b.n	94244 <strchr+0x88>
   9423c:	7802      	ldrb	r2, [r0, #0]
   9423e:	3301      	adds	r3, #1
   94240:	2a00      	cmp	r2, #0
   94242:	d0f2      	beq.n	9422a <strchr+0x6e>
   94244:	0799      	lsls	r1, r3, #30
   94246:	4618      	mov	r0, r3
   94248:	d1f8      	bne.n	9423c <strchr+0x80>
   9424a:	6802      	ldr	r2, [r0, #0]
   9424c:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
   94250:	ea23 0302 	bic.w	r3, r3, r2
   94254:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   94258:	d108      	bne.n	9426c <strchr+0xb0>
   9425a:	f850 2f04 	ldr.w	r2, [r0, #4]!
   9425e:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
   94262:	ea23 0302 	bic.w	r3, r3, r2
   94266:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   9426a:	d0f6      	beq.n	9425a <strchr+0x9e>
   9426c:	7803      	ldrb	r3, [r0, #0]
   9426e:	2b00      	cmp	r3, #0
   94270:	d0db      	beq.n	9422a <strchr+0x6e>
   94272:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   94276:	2b00      	cmp	r3, #0
   94278:	d1fb      	bne.n	94272 <strchr+0xb6>
   9427a:	bc70      	pop	{r4, r5, r6}
   9427c:	4770      	bx	lr
   9427e:	4610      	mov	r0, r2
   94280:	bc70      	pop	{r4, r5, r6}
   94282:	4770      	bx	lr
   94284:	4618      	mov	r0, r3
   94286:	bc70      	pop	{r4, r5, r6}
   94288:	4770      	bx	lr
   9428a:	bf00      	nop

0009428c <strcpy>:
   9428c:	ea80 0201 	eor.w	r2, r0, r1
   94290:	4684      	mov	ip, r0
   94292:	f012 0f03 	tst.w	r2, #3
   94296:	d14f      	bne.n	94338 <strcpy+0xac>
   94298:	f011 0f03 	tst.w	r1, #3
   9429c:	d132      	bne.n	94304 <strcpy+0x78>
   9429e:	f84d 4d04 	str.w	r4, [sp, #-4]!
   942a2:	f011 0f04 	tst.w	r1, #4
   942a6:	f851 3b04 	ldr.w	r3, [r1], #4
   942aa:	d00b      	beq.n	942c4 <strcpy+0x38>
   942ac:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   942b0:	439a      	bics	r2, r3
   942b2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   942b6:	bf04      	itt	eq
   942b8:	f84c 3b04 	streq.w	r3, [ip], #4
   942bc:	f851 3b04 	ldreq.w	r3, [r1], #4
   942c0:	d116      	bne.n	942f0 <strcpy+0x64>
   942c2:	bf00      	nop
   942c4:	f851 4b04 	ldr.w	r4, [r1], #4
   942c8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   942cc:	439a      	bics	r2, r3
   942ce:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   942d2:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
   942d6:	d10b      	bne.n	942f0 <strcpy+0x64>
   942d8:	f84c 3b04 	str.w	r3, [ip], #4
   942dc:	43a2      	bics	r2, r4
   942de:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   942e2:	bf04      	itt	eq
   942e4:	f851 3b04 	ldreq.w	r3, [r1], #4
   942e8:	f84c 4b04 	streq.w	r4, [ip], #4
   942ec:	d0ea      	beq.n	942c4 <strcpy+0x38>
   942ee:	4623      	mov	r3, r4
   942f0:	f80c 3b01 	strb.w	r3, [ip], #1
   942f4:	f013 0fff 	tst.w	r3, #255	; 0xff
   942f8:	ea4f 2333 	mov.w	r3, r3, ror #8
   942fc:	d1f8      	bne.n	942f0 <strcpy+0x64>
   942fe:	f85d 4b04 	ldr.w	r4, [sp], #4
   94302:	4770      	bx	lr
   94304:	f011 0f01 	tst.w	r1, #1
   94308:	d006      	beq.n	94318 <strcpy+0x8c>
   9430a:	f811 2b01 	ldrb.w	r2, [r1], #1
   9430e:	f80c 2b01 	strb.w	r2, [ip], #1
   94312:	2a00      	cmp	r2, #0
   94314:	bf08      	it	eq
   94316:	4770      	bxeq	lr
   94318:	f011 0f02 	tst.w	r1, #2
   9431c:	d0bf      	beq.n	9429e <strcpy+0x12>
   9431e:	f831 2b02 	ldrh.w	r2, [r1], #2
   94322:	f012 0fff 	tst.w	r2, #255	; 0xff
   94326:	bf16      	itet	ne
   94328:	f82c 2b02 	strhne.w	r2, [ip], #2
   9432c:	f88c 2000 	strbeq.w	r2, [ip]
   94330:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
   94334:	d1b3      	bne.n	9429e <strcpy+0x12>
   94336:	4770      	bx	lr
   94338:	f811 2b01 	ldrb.w	r2, [r1], #1
   9433c:	f80c 2b01 	strb.w	r2, [ip], #1
   94340:	2a00      	cmp	r2, #0
   94342:	d1f9      	bne.n	94338 <strcpy+0xac>
   94344:	4770      	bx	lr
   94346:	bf00      	nop

00094348 <strlen>:
   94348:	f020 0103 	bic.w	r1, r0, #3
   9434c:	f010 0003 	ands.w	r0, r0, #3
   94350:	f1c0 0000 	rsb	r0, r0, #0
   94354:	f851 3b04 	ldr.w	r3, [r1], #4
   94358:	f100 0c04 	add.w	ip, r0, #4
   9435c:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   94360:	f06f 0200 	mvn.w	r2, #0
   94364:	bf1c      	itt	ne
   94366:	fa22 f20c 	lsrne.w	r2, r2, ip
   9436a:	4313      	orrne	r3, r2
   9436c:	f04f 0c01 	mov.w	ip, #1
   94370:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
   94374:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
   94378:	eba3 020c 	sub.w	r2, r3, ip
   9437c:	ea22 0203 	bic.w	r2, r2, r3
   94380:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
   94384:	bf04      	itt	eq
   94386:	f851 3b04 	ldreq.w	r3, [r1], #4
   9438a:	3004      	addeq	r0, #4
   9438c:	d0f4      	beq.n	94378 <strlen+0x30>
   9438e:	f1c2 0100 	rsb	r1, r2, #0
   94392:	ea02 0201 	and.w	r2, r2, r1
   94396:	fab2 f282 	clz	r2, r2
   9439a:	f1c2 021f 	rsb	r2, r2, #31
   9439e:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
   943a2:	4770      	bx	lr

000943a4 <strncpy>:
   943a4:	ea40 0301 	orr.w	r3, r0, r1
   943a8:	079b      	lsls	r3, r3, #30
   943aa:	b470      	push	{r4, r5, r6}
   943ac:	d12b      	bne.n	94406 <strncpy+0x62>
   943ae:	2a03      	cmp	r2, #3
   943b0:	d929      	bls.n	94406 <strncpy+0x62>
   943b2:	460c      	mov	r4, r1
   943b4:	4603      	mov	r3, r0
   943b6:	4621      	mov	r1, r4
   943b8:	f854 6b04 	ldr.w	r6, [r4], #4
   943bc:	f1a6 3501 	sub.w	r5, r6, #16843009	; 0x1010101
   943c0:	ea25 0506 	bic.w	r5, r5, r6
   943c4:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
   943c8:	d106      	bne.n	943d8 <strncpy+0x34>
   943ca:	3a04      	subs	r2, #4
   943cc:	2a03      	cmp	r2, #3
   943ce:	f843 6b04 	str.w	r6, [r3], #4
   943d2:	4621      	mov	r1, r4
   943d4:	d8ef      	bhi.n	943b6 <strncpy+0x12>
   943d6:	b1a2      	cbz	r2, 94402 <strncpy+0x5e>
   943d8:	780c      	ldrb	r4, [r1, #0]
   943da:	3a01      	subs	r2, #1
   943dc:	701c      	strb	r4, [r3, #0]
   943de:	3101      	adds	r1, #1
   943e0:	3301      	adds	r3, #1
   943e2:	b13c      	cbz	r4, 943f4 <strncpy+0x50>
   943e4:	b16a      	cbz	r2, 94402 <strncpy+0x5e>
   943e6:	f811 4b01 	ldrb.w	r4, [r1], #1
   943ea:	3a01      	subs	r2, #1
   943ec:	f803 4b01 	strb.w	r4, [r3], #1
   943f0:	2c00      	cmp	r4, #0
   943f2:	d1f7      	bne.n	943e4 <strncpy+0x40>
   943f4:	b12a      	cbz	r2, 94402 <strncpy+0x5e>
   943f6:	441a      	add	r2, r3
   943f8:	2100      	movs	r1, #0
   943fa:	f803 1b01 	strb.w	r1, [r3], #1
   943fe:	429a      	cmp	r2, r3
   94400:	d1fb      	bne.n	943fa <strncpy+0x56>
   94402:	bc70      	pop	{r4, r5, r6}
   94404:	4770      	bx	lr
   94406:	4603      	mov	r3, r0
   94408:	e7e5      	b.n	943d6 <strncpy+0x32>
   9440a:	bf00      	nop

0009440c <_svfprintf_r>:
   9440c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   94410:	b0c1      	sub	sp, #260	; 0x104
   94412:	460c      	mov	r4, r1
   94414:	9109      	str	r1, [sp, #36]	; 0x24
   94416:	4615      	mov	r5, r2
   94418:	930e      	str	r3, [sp, #56]	; 0x38
   9441a:	900a      	str	r0, [sp, #40]	; 0x28
   9441c:	f004 f83c 	bl	98498 <_localeconv_r>
   94420:	6803      	ldr	r3, [r0, #0]
   94422:	4618      	mov	r0, r3
   94424:	9317      	str	r3, [sp, #92]	; 0x5c
   94426:	f7ff ff8f 	bl	94348 <strlen>
   9442a:	89a3      	ldrh	r3, [r4, #12]
   9442c:	9016      	str	r0, [sp, #88]	; 0x58
   9442e:	061e      	lsls	r6, r3, #24
   94430:	d503      	bpl.n	9443a <_svfprintf_r+0x2e>
   94432:	6923      	ldr	r3, [r4, #16]
   94434:	2b00      	cmp	r3, #0
   94436:	f001 815d 	beq.w	956f4 <_svfprintf_r+0x12e8>
   9443a:	2300      	movs	r3, #0
   9443c:	461a      	mov	r2, r3
   9443e:	46a8      	mov	r8, r5
   94440:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94444:	f8df a460 	ldr.w	sl, [pc, #1120]	; 948a8 <_svfprintf_r+0x49c>
   94448:	9312      	str	r3, [sp, #72]	; 0x48
   9444a:	9319      	str	r3, [sp, #100]	; 0x64
   9444c:	930b      	str	r3, [sp, #44]	; 0x2c
   9444e:	9325      	str	r3, [sp, #148]	; 0x94
   94450:	9324      	str	r3, [sp, #144]	; 0x90
   94452:	f8cd 908c 	str.w	r9, [sp, #140]	; 0x8c
   94456:	9214      	str	r2, [sp, #80]	; 0x50
   94458:	9215      	str	r2, [sp, #84]	; 0x54
   9445a:	f898 3000 	ldrb.w	r3, [r8]
   9445e:	4644      	mov	r4, r8
   94460:	b1eb      	cbz	r3, 9449e <_svfprintf_r+0x92>
   94462:	2b25      	cmp	r3, #37	; 0x25
   94464:	d102      	bne.n	9446c <_svfprintf_r+0x60>
   94466:	e01a      	b.n	9449e <_svfprintf_r+0x92>
   94468:	2b25      	cmp	r3, #37	; 0x25
   9446a:	d003      	beq.n	94474 <_svfprintf_r+0x68>
   9446c:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   94470:	2b00      	cmp	r3, #0
   94472:	d1f9      	bne.n	94468 <_svfprintf_r+0x5c>
   94474:	ebc8 0504 	rsb	r5, r8, r4
   94478:	b18d      	cbz	r5, 9449e <_svfprintf_r+0x92>
   9447a:	9b24      	ldr	r3, [sp, #144]	; 0x90
   9447c:	9a25      	ldr	r2, [sp, #148]	; 0x94
   9447e:	3301      	adds	r3, #1
   94480:	442a      	add	r2, r5
   94482:	2b07      	cmp	r3, #7
   94484:	f8c9 8000 	str.w	r8, [r9]
   94488:	f8c9 5004 	str.w	r5, [r9, #4]
   9448c:	9225      	str	r2, [sp, #148]	; 0x94
   9448e:	9324      	str	r3, [sp, #144]	; 0x90
   94490:	f300 8332 	bgt.w	94af8 <_svfprintf_r+0x6ec>
   94494:	f109 0908 	add.w	r9, r9, #8
   94498:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   9449a:	442b      	add	r3, r5
   9449c:	930b      	str	r3, [sp, #44]	; 0x2c
   9449e:	7823      	ldrb	r3, [r4, #0]
   944a0:	2b00      	cmp	r3, #0
   944a2:	f000 81ea 	beq.w	9487a <_svfprintf_r+0x46e>
   944a6:	f04f 3bff 	mov.w	fp, #4294967295
   944aa:	465d      	mov	r5, fp
   944ac:	2300      	movs	r3, #0
   944ae:	461a      	mov	r2, r3
   944b0:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
   944b4:	4619      	mov	r1, r3
   944b6:	930c      	str	r3, [sp, #48]	; 0x30
   944b8:	9307      	str	r3, [sp, #28]
   944ba:	7863      	ldrb	r3, [r4, #1]
   944bc:	f104 0801 	add.w	r8, r4, #1
   944c0:	f108 0801 	add.w	r8, r8, #1
   944c4:	f1a3 0020 	sub.w	r0, r3, #32
   944c8:	2858      	cmp	r0, #88	; 0x58
   944ca:	f200 8645 	bhi.w	95158 <_svfprintf_r+0xd4c>
   944ce:	e8df f010 	tbh	[pc, r0, lsl #1]
   944d2:	03f3      	.short	0x03f3
   944d4:	06430643 	.word	0x06430643
   944d8:	064303fc 	.word	0x064303fc
   944dc:	06430643 	.word	0x06430643
   944e0:	06430643 	.word	0x06430643
   944e4:	00590643 	.word	0x00590643
   944e8:	06430404 	.word	0x06430404
   944ec:	03d00066 	.word	0x03d00066
   944f0:	03ec0643 	.word	0x03ec0643
   944f4:	05bc05bc 	.word	0x05bc05bc
   944f8:	05bc05bc 	.word	0x05bc05bc
   944fc:	05bc05bc 	.word	0x05bc05bc
   94500:	05bc05bc 	.word	0x05bc05bc
   94504:	064305bc 	.word	0x064305bc
   94508:	06430643 	.word	0x06430643
   9450c:	06430643 	.word	0x06430643
   94510:	06430643 	.word	0x06430643
   94514:	06430643 	.word	0x06430643
   94518:	05e20643 	.word	0x05e20643
   9451c:	064304f7 	.word	0x064304f7
   94520:	064304f7 	.word	0x064304f7
   94524:	06430643 	.word	0x06430643
   94528:	05420643 	.word	0x05420643
   9452c:	06430643 	.word	0x06430643
   94530:	0643054a 	.word	0x0643054a
   94534:	06430643 	.word	0x06430643
   94538:	06430643 	.word	0x06430643
   9453c:	06430574 	.word	0x06430574
   94540:	05cd0643 	.word	0x05cd0643
   94544:	06430643 	.word	0x06430643
   94548:	06430643 	.word	0x06430643
   9454c:	06430643 	.word	0x06430643
   94550:	06430643 	.word	0x06430643
   94554:	06430643 	.word	0x06430643
   94558:	060e061d 	.word	0x060e061d
   9455c:	04f704f7 	.word	0x04f704f7
   94560:	061504f7 	.word	0x061504f7
   94564:	0643060e 	.word	0x0643060e
   94568:	04a30643 	.word	0x04a30643
   9456c:	05a80643 	.word	0x05a80643
   94570:	006d04ae 	.word	0x006d04ae
   94574:	0643040a 	.word	0x0643040a
   94578:	06430412 	.word	0x06430412
   9457c:	06430435 	.word	0x06430435
   94580:	04700643 	.word	0x04700643
   94584:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   94586:	6823      	ldr	r3, [r4, #0]
   94588:	4618      	mov	r0, r3
   9458a:	930c      	str	r3, [sp, #48]	; 0x30
   9458c:	4623      	mov	r3, r4
   9458e:	2800      	cmp	r0, #0
   94590:	f103 0304 	add.w	r3, r3, #4
   94594:	930e      	str	r3, [sp, #56]	; 0x38
   94596:	da06      	bge.n	945a6 <_svfprintf_r+0x19a>
   94598:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   9459a:	425b      	negs	r3, r3
   9459c:	930c      	str	r3, [sp, #48]	; 0x30
   9459e:	9b07      	ldr	r3, [sp, #28]
   945a0:	f043 0304 	orr.w	r3, r3, #4
   945a4:	9307      	str	r3, [sp, #28]
   945a6:	f898 3000 	ldrb.w	r3, [r8]
   945aa:	e789      	b.n	944c0 <_svfprintf_r+0xb4>
   945ac:	46ab      	mov	fp, r5
   945ae:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   945b0:	2700      	movs	r7, #0
   945b2:	9807      	ldr	r0, [sp, #28]
   945b4:	2130      	movs	r1, #48	; 0x30
   945b6:	2378      	movs	r3, #120	; 0x78
   945b8:	45bb      	cmp	fp, r7
   945ba:	6814      	ldr	r4, [r2, #0]
   945bc:	f88d 1070 	strb.w	r1, [sp, #112]	; 0x70
   945c0:	f102 0204 	add.w	r2, r2, #4
   945c4:	f04f 0500 	mov.w	r5, #0
   945c8:	f88d 3071 	strb.w	r3, [sp, #113]	; 0x71
   945cc:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
   945d0:	f040 0102 	orr.w	r1, r0, #2
   945d4:	f2c0 863d 	blt.w	95252 <_svfprintf_r+0xe46>
   945d8:	f020 0180 	bic.w	r1, r0, #128	; 0x80
   945dc:	f041 0102 	orr.w	r1, r1, #2
   945e0:	9107      	str	r1, [sp, #28]
   945e2:	ea54 0105 	orrs.w	r1, r4, r5
   945e6:	920e      	str	r2, [sp, #56]	; 0x38
   945e8:	9311      	str	r3, [sp, #68]	; 0x44
   945ea:	48ad      	ldr	r0, [pc, #692]	; (948a0 <_svfprintf_r+0x494>)
   945ec:	f000 8131 	beq.w	94852 <_svfprintf_r+0x446>
   945f0:	ae30      	add	r6, sp, #192	; 0xc0
   945f2:	0923      	lsrs	r3, r4, #4
   945f4:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
   945f8:	0929      	lsrs	r1, r5, #4
   945fa:	f004 020f 	and.w	r2, r4, #15
   945fe:	460d      	mov	r5, r1
   94600:	461c      	mov	r4, r3
   94602:	5c83      	ldrb	r3, [r0, r2]
   94604:	f806 3d01 	strb.w	r3, [r6, #-1]!
   94608:	ea54 0305 	orrs.w	r3, r4, r5
   9460c:	d1f1      	bne.n	945f2 <_svfprintf_r+0x1e6>
   9460e:	ab30      	add	r3, sp, #192	; 0xc0
   94610:	1b9b      	subs	r3, r3, r6
   94612:	930d      	str	r3, [sp, #52]	; 0x34
   94614:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   94616:	455b      	cmp	r3, fp
   94618:	bfb8      	it	lt
   9461a:	465b      	movlt	r3, fp
   9461c:	9308      	str	r3, [sp, #32]
   9461e:	2300      	movs	r3, #0
   94620:	9313      	str	r3, [sp, #76]	; 0x4c
   94622:	b117      	cbz	r7, 9462a <_svfprintf_r+0x21e>
   94624:	9b08      	ldr	r3, [sp, #32]
   94626:	3301      	adds	r3, #1
   94628:	9308      	str	r3, [sp, #32]
   9462a:	9b07      	ldr	r3, [sp, #28]
   9462c:	f013 0302 	ands.w	r3, r3, #2
   94630:	930f      	str	r3, [sp, #60]	; 0x3c
   94632:	d002      	beq.n	9463a <_svfprintf_r+0x22e>
   94634:	9b08      	ldr	r3, [sp, #32]
   94636:	3302      	adds	r3, #2
   94638:	9308      	str	r3, [sp, #32]
   9463a:	9b07      	ldr	r3, [sp, #28]
   9463c:	f013 0384 	ands.w	r3, r3, #132	; 0x84
   94640:	9310      	str	r3, [sp, #64]	; 0x40
   94642:	f040 8118 	bne.w	94876 <_svfprintf_r+0x46a>
   94646:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   94648:	9a08      	ldr	r2, [sp, #32]
   9464a:	1a9d      	subs	r5, r3, r2
   9464c:	2d00      	cmp	r5, #0
   9464e:	f340 8112 	ble.w	94876 <_svfprintf_r+0x46a>
   94652:	2d10      	cmp	r5, #16
   94654:	9925      	ldr	r1, [sp, #148]	; 0x94
   94656:	9a24      	ldr	r2, [sp, #144]	; 0x90
   94658:	4f92      	ldr	r7, [pc, #584]	; (948a4 <_svfprintf_r+0x498>)
   9465a:	dd27      	ble.n	946ac <_svfprintf_r+0x2a0>
   9465c:	9618      	str	r6, [sp, #96]	; 0x60
   9465e:	4648      	mov	r0, r9
   94660:	2410      	movs	r4, #16
   94662:	46b9      	mov	r9, r7
   94664:	9e09      	ldr	r6, [sp, #36]	; 0x24
   94666:	462f      	mov	r7, r5
   94668:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   9466a:	e004      	b.n	94676 <_svfprintf_r+0x26a>
   9466c:	3f10      	subs	r7, #16
   9466e:	2f10      	cmp	r7, #16
   94670:	f100 0008 	add.w	r0, r0, #8
   94674:	dd16      	ble.n	946a4 <_svfprintf_r+0x298>
   94676:	3201      	adds	r2, #1
   94678:	4b8a      	ldr	r3, [pc, #552]	; (948a4 <_svfprintf_r+0x498>)
   9467a:	3110      	adds	r1, #16
   9467c:	2a07      	cmp	r2, #7
   9467e:	9125      	str	r1, [sp, #148]	; 0x94
   94680:	9224      	str	r2, [sp, #144]	; 0x90
   94682:	e880 0018 	stmia.w	r0, {r3, r4}
   94686:	ddf1      	ble.n	9466c <_svfprintf_r+0x260>
   94688:	aa23      	add	r2, sp, #140	; 0x8c
   9468a:	4631      	mov	r1, r6
   9468c:	4628      	mov	r0, r5
   9468e:	f004 fb65 	bl	98d5c <__ssprint_r>
   94692:	2800      	cmp	r0, #0
   94694:	f040 80f8 	bne.w	94888 <_svfprintf_r+0x47c>
   94698:	3f10      	subs	r7, #16
   9469a:	2f10      	cmp	r7, #16
   9469c:	a830      	add	r0, sp, #192	; 0xc0
   9469e:	9925      	ldr	r1, [sp, #148]	; 0x94
   946a0:	9a24      	ldr	r2, [sp, #144]	; 0x90
   946a2:	dce8      	bgt.n	94676 <_svfprintf_r+0x26a>
   946a4:	463d      	mov	r5, r7
   946a6:	464f      	mov	r7, r9
   946a8:	4681      	mov	r9, r0
   946aa:	9e18      	ldr	r6, [sp, #96]	; 0x60
   946ac:	3201      	adds	r2, #1
   946ae:	186c      	adds	r4, r5, r1
   946b0:	2a07      	cmp	r2, #7
   946b2:	9425      	str	r4, [sp, #148]	; 0x94
   946b4:	9224      	str	r2, [sp, #144]	; 0x90
   946b6:	f8c9 7000 	str.w	r7, [r9]
   946ba:	f8c9 5004 	str.w	r5, [r9, #4]
   946be:	f300 80d0 	bgt.w	94862 <_svfprintf_r+0x456>
   946c2:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
   946c6:	f109 0908 	add.w	r9, r9, #8
   946ca:	b177      	cbz	r7, 946ea <_svfprintf_r+0x2de>
   946cc:	9b24      	ldr	r3, [sp, #144]	; 0x90
   946ce:	3401      	adds	r4, #1
   946d0:	3301      	adds	r3, #1
   946d2:	f10d 016f 	add.w	r1, sp, #111	; 0x6f
   946d6:	2201      	movs	r2, #1
   946d8:	2b07      	cmp	r3, #7
   946da:	9425      	str	r4, [sp, #148]	; 0x94
   946dc:	9324      	str	r3, [sp, #144]	; 0x90
   946de:	e889 0006 	stmia.w	r9, {r1, r2}
   946e2:	f300 8220 	bgt.w	94b26 <_svfprintf_r+0x71a>
   946e6:	f109 0908 	add.w	r9, r9, #8
   946ea:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   946ec:	b16b      	cbz	r3, 9470a <_svfprintf_r+0x2fe>
   946ee:	9b24      	ldr	r3, [sp, #144]	; 0x90
   946f0:	3402      	adds	r4, #2
   946f2:	3301      	adds	r3, #1
   946f4:	a91c      	add	r1, sp, #112	; 0x70
   946f6:	2202      	movs	r2, #2
   946f8:	2b07      	cmp	r3, #7
   946fa:	9425      	str	r4, [sp, #148]	; 0x94
   946fc:	9324      	str	r3, [sp, #144]	; 0x90
   946fe:	e889 0006 	stmia.w	r9, {r1, r2}
   94702:	f300 821c 	bgt.w	94b3e <_svfprintf_r+0x732>
   94706:	f109 0908 	add.w	r9, r9, #8
   9470a:	9b10      	ldr	r3, [sp, #64]	; 0x40
   9470c:	2b80      	cmp	r3, #128	; 0x80
   9470e:	f000 812c 	beq.w	9496a <_svfprintf_r+0x55e>
   94712:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   94714:	ebc3 070b 	rsb	r7, r3, fp
   94718:	2f00      	cmp	r7, #0
   9471a:	dd33      	ble.n	94784 <_svfprintf_r+0x378>
   9471c:	4a62      	ldr	r2, [pc, #392]	; (948a8 <_svfprintf_r+0x49c>)
   9471e:	2f10      	cmp	r7, #16
   94720:	9b24      	ldr	r3, [sp, #144]	; 0x90
   94722:	920f      	str	r2, [sp, #60]	; 0x3c
   94724:	dd22      	ble.n	9476c <_svfprintf_r+0x360>
   94726:	4622      	mov	r2, r4
   94728:	f04f 0b10 	mov.w	fp, #16
   9472c:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   9472e:	9c09      	ldr	r4, [sp, #36]	; 0x24
   94730:	e004      	b.n	9473c <_svfprintf_r+0x330>
   94732:	3f10      	subs	r7, #16
   94734:	2f10      	cmp	r7, #16
   94736:	f109 0908 	add.w	r9, r9, #8
   9473a:	dd16      	ble.n	9476a <_svfprintf_r+0x35e>
   9473c:	3301      	adds	r3, #1
   9473e:	3210      	adds	r2, #16
   94740:	2b07      	cmp	r3, #7
   94742:	9225      	str	r2, [sp, #148]	; 0x94
   94744:	9324      	str	r3, [sp, #144]	; 0x90
   94746:	e889 0c00 	stmia.w	r9, {sl, fp}
   9474a:	ddf2      	ble.n	94732 <_svfprintf_r+0x326>
   9474c:	aa23      	add	r2, sp, #140	; 0x8c
   9474e:	4621      	mov	r1, r4
   94750:	4628      	mov	r0, r5
   94752:	f004 fb03 	bl	98d5c <__ssprint_r>
   94756:	2800      	cmp	r0, #0
   94758:	f040 8096 	bne.w	94888 <_svfprintf_r+0x47c>
   9475c:	3f10      	subs	r7, #16
   9475e:	2f10      	cmp	r7, #16
   94760:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94764:	9a25      	ldr	r2, [sp, #148]	; 0x94
   94766:	9b24      	ldr	r3, [sp, #144]	; 0x90
   94768:	dce8      	bgt.n	9473c <_svfprintf_r+0x330>
   9476a:	4614      	mov	r4, r2
   9476c:	3301      	adds	r3, #1
   9476e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   94770:	443c      	add	r4, r7
   94772:	2b07      	cmp	r3, #7
   94774:	9425      	str	r4, [sp, #148]	; 0x94
   94776:	9324      	str	r3, [sp, #144]	; 0x90
   94778:	e889 0084 	stmia.w	r9, {r2, r7}
   9477c:	f300 81c7 	bgt.w	94b0e <_svfprintf_r+0x702>
   94780:	f109 0908 	add.w	r9, r9, #8
   94784:	9b07      	ldr	r3, [sp, #28]
   94786:	05da      	lsls	r2, r3, #23
   94788:	f100 8090 	bmi.w	948ac <_svfprintf_r+0x4a0>
   9478c:	9b24      	ldr	r3, [sp, #144]	; 0x90
   9478e:	990d      	ldr	r1, [sp, #52]	; 0x34
   94790:	3301      	adds	r3, #1
   94792:	440c      	add	r4, r1
   94794:	2b07      	cmp	r3, #7
   94796:	9425      	str	r4, [sp, #148]	; 0x94
   94798:	f8c9 6000 	str.w	r6, [r9]
   9479c:	f8c9 1004 	str.w	r1, [r9, #4]
   947a0:	9324      	str	r3, [sp, #144]	; 0x90
   947a2:	f300 81e2 	bgt.w	94b6a <_svfprintf_r+0x75e>
   947a6:	f109 0908 	add.w	r9, r9, #8
   947aa:	9b07      	ldr	r3, [sp, #28]
   947ac:	0759      	lsls	r1, r3, #29
   947ae:	d536      	bpl.n	9481e <_svfprintf_r+0x412>
   947b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   947b2:	9a08      	ldr	r2, [sp, #32]
   947b4:	1a9d      	subs	r5, r3, r2
   947b6:	2d00      	cmp	r5, #0
   947b8:	dd31      	ble.n	9481e <_svfprintf_r+0x412>
   947ba:	2d10      	cmp	r5, #16
   947bc:	9b24      	ldr	r3, [sp, #144]	; 0x90
   947be:	4f39      	ldr	r7, [pc, #228]	; (948a4 <_svfprintf_r+0x498>)
   947c0:	dd22      	ble.n	94808 <_svfprintf_r+0x3fc>
   947c2:	4622      	mov	r2, r4
   947c4:	2610      	movs	r6, #16
   947c6:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
   947ca:	9c09      	ldr	r4, [sp, #36]	; 0x24
   947cc:	e004      	b.n	947d8 <_svfprintf_r+0x3cc>
   947ce:	3d10      	subs	r5, #16
   947d0:	2d10      	cmp	r5, #16
   947d2:	f109 0908 	add.w	r9, r9, #8
   947d6:	dd16      	ble.n	94806 <_svfprintf_r+0x3fa>
   947d8:	3301      	adds	r3, #1
   947da:	4932      	ldr	r1, [pc, #200]	; (948a4 <_svfprintf_r+0x498>)
   947dc:	3210      	adds	r2, #16
   947de:	2b07      	cmp	r3, #7
   947e0:	9225      	str	r2, [sp, #148]	; 0x94
   947e2:	9324      	str	r3, [sp, #144]	; 0x90
   947e4:	e889 0042 	stmia.w	r9, {r1, r6}
   947e8:	ddf1      	ble.n	947ce <_svfprintf_r+0x3c2>
   947ea:	aa23      	add	r2, sp, #140	; 0x8c
   947ec:	4621      	mov	r1, r4
   947ee:	4658      	mov	r0, fp
   947f0:	f004 fab4 	bl	98d5c <__ssprint_r>
   947f4:	2800      	cmp	r0, #0
   947f6:	d147      	bne.n	94888 <_svfprintf_r+0x47c>
   947f8:	3d10      	subs	r5, #16
   947fa:	2d10      	cmp	r5, #16
   947fc:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94800:	9a25      	ldr	r2, [sp, #148]	; 0x94
   94802:	9b24      	ldr	r3, [sp, #144]	; 0x90
   94804:	dce8      	bgt.n	947d8 <_svfprintf_r+0x3cc>
   94806:	4614      	mov	r4, r2
   94808:	3301      	adds	r3, #1
   9480a:	442c      	add	r4, r5
   9480c:	2b07      	cmp	r3, #7
   9480e:	9425      	str	r4, [sp, #148]	; 0x94
   94810:	9324      	str	r3, [sp, #144]	; 0x90
   94812:	f8c9 7000 	str.w	r7, [r9]
   94816:	f8c9 5004 	str.w	r5, [r9, #4]
   9481a:	f300 8492 	bgt.w	95142 <_svfprintf_r+0xd36>
   9481e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   94820:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   94822:	9908      	ldr	r1, [sp, #32]
   94824:	428a      	cmp	r2, r1
   94826:	bfac      	ite	ge
   94828:	189b      	addge	r3, r3, r2
   9482a:	185b      	addlt	r3, r3, r1
   9482c:	930b      	str	r3, [sp, #44]	; 0x2c
   9482e:	2c00      	cmp	r4, #0
   94830:	f040 8159 	bne.w	94ae6 <_svfprintf_r+0x6da>
   94834:	2300      	movs	r3, #0
   94836:	9324      	str	r3, [sp, #144]	; 0x90
   94838:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   9483c:	e60d      	b.n	9445a <_svfprintf_r+0x4e>
   9483e:	2700      	movs	r7, #0
   94840:	45bb      	cmp	fp, r7
   94842:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
   94846:	f2c0 850e 	blt.w	95266 <_svfprintf_r+0xe5a>
   9484a:	9b07      	ldr	r3, [sp, #28]
   9484c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   94850:	9307      	str	r3, [sp, #28]
   94852:	f1bb 0f00 	cmp.w	fp, #0
   94856:	f000 846c 	beq.w	95132 <_svfprintf_r+0xd26>
   9485a:	2400      	movs	r4, #0
   9485c:	2500      	movs	r5, #0
   9485e:	2700      	movs	r7, #0
   94860:	e6c6      	b.n	945f0 <_svfprintf_r+0x1e4>
   94862:	aa23      	add	r2, sp, #140	; 0x8c
   94864:	9909      	ldr	r1, [sp, #36]	; 0x24
   94866:	980a      	ldr	r0, [sp, #40]	; 0x28
   94868:	f004 fa78 	bl	98d5c <__ssprint_r>
   9486c:	b960      	cbnz	r0, 94888 <_svfprintf_r+0x47c>
   9486e:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
   94872:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94876:	9c25      	ldr	r4, [sp, #148]	; 0x94
   94878:	e727      	b.n	946ca <_svfprintf_r+0x2be>
   9487a:	9b25      	ldr	r3, [sp, #148]	; 0x94
   9487c:	b123      	cbz	r3, 94888 <_svfprintf_r+0x47c>
   9487e:	980a      	ldr	r0, [sp, #40]	; 0x28
   94880:	aa23      	add	r2, sp, #140	; 0x8c
   94882:	9909      	ldr	r1, [sp, #36]	; 0x24
   94884:	f004 fa6a 	bl	98d5c <__ssprint_r>
   94888:	9b09      	ldr	r3, [sp, #36]	; 0x24
   9488a:	899b      	ldrh	r3, [r3, #12]
   9488c:	f013 0f40 	tst.w	r3, #64	; 0x40
   94890:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   94892:	bf18      	it	ne
   94894:	f04f 33ff 	movne.w	r3, #4294967295
   94898:	4618      	mov	r0, r3
   9489a:	b041      	add	sp, #260	; 0x104
   9489c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   948a0:	0009b1ac 	.word	0x0009b1ac
   948a4:	0009b1cc 	.word	0x0009b1cc
   948a8:	0009b178 	.word	0x0009b178
   948ac:	9b11      	ldr	r3, [sp, #68]	; 0x44
   948ae:	2b65      	cmp	r3, #101	; 0x65
   948b0:	f340 809f 	ble.w	949f2 <_svfprintf_r+0x5e6>
   948b4:	9814      	ldr	r0, [sp, #80]	; 0x50
   948b6:	9915      	ldr	r1, [sp, #84]	; 0x54
   948b8:	2200      	movs	r2, #0
   948ba:	2300      	movs	r3, #0
   948bc:	f7fe f9c6 	bl	92c4c <__aeabi_dcmpeq>
   948c0:	2800      	cmp	r0, #0
   948c2:	f000 8163 	beq.w	94b8c <_svfprintf_r+0x780>
   948c6:	9b24      	ldr	r3, [sp, #144]	; 0x90
   948c8:	49ae      	ldr	r1, [pc, #696]	; (94b84 <_svfprintf_r+0x778>)
   948ca:	3301      	adds	r3, #1
   948cc:	3401      	adds	r4, #1
   948ce:	2201      	movs	r2, #1
   948d0:	2b07      	cmp	r3, #7
   948d2:	9425      	str	r4, [sp, #148]	; 0x94
   948d4:	9324      	str	r3, [sp, #144]	; 0x90
   948d6:	e889 0006 	stmia.w	r9, {r1, r2}
   948da:	f300 8453 	bgt.w	95184 <_svfprintf_r+0xd78>
   948de:	f109 0908 	add.w	r9, r9, #8
   948e2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   948e4:	9a12      	ldr	r2, [sp, #72]	; 0x48
   948e6:	4293      	cmp	r3, r2
   948e8:	db03      	blt.n	948f2 <_svfprintf_r+0x4e6>
   948ea:	9b07      	ldr	r3, [sp, #28]
   948ec:	07db      	lsls	r3, r3, #31
   948ee:	f57f af5c 	bpl.w	947aa <_svfprintf_r+0x39e>
   948f2:	9b24      	ldr	r3, [sp, #144]	; 0x90
   948f4:	9916      	ldr	r1, [sp, #88]	; 0x58
   948f6:	3301      	adds	r3, #1
   948f8:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   948fa:	440c      	add	r4, r1
   948fc:	2b07      	cmp	r3, #7
   948fe:	9425      	str	r4, [sp, #148]	; 0x94
   94900:	f8c9 2000 	str.w	r2, [r9]
   94904:	f8c9 1004 	str.w	r1, [r9, #4]
   94908:	9324      	str	r3, [sp, #144]	; 0x90
   9490a:	f300 86e6 	bgt.w	956da <_svfprintf_r+0x12ce>
   9490e:	f109 0908 	add.w	r9, r9, #8
   94912:	9b12      	ldr	r3, [sp, #72]	; 0x48
   94914:	1e5d      	subs	r5, r3, #1
   94916:	2d00      	cmp	r5, #0
   94918:	f77f af47 	ble.w	947aa <_svfprintf_r+0x39e>
   9491c:	4a9a      	ldr	r2, [pc, #616]	; (94b88 <_svfprintf_r+0x77c>)
   9491e:	2d10      	cmp	r5, #16
   94920:	9b24      	ldr	r3, [sp, #144]	; 0x90
   94922:	920f      	str	r2, [sp, #60]	; 0x3c
   94924:	f340 8117 	ble.w	94b56 <_svfprintf_r+0x74a>
   94928:	2610      	movs	r6, #16
   9492a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   9492c:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
   94930:	e005      	b.n	9493e <_svfprintf_r+0x532>
   94932:	f109 0908 	add.w	r9, r9, #8
   94936:	3d10      	subs	r5, #16
   94938:	2d10      	cmp	r5, #16
   9493a:	f340 810c 	ble.w	94b56 <_svfprintf_r+0x74a>
   9493e:	3301      	adds	r3, #1
   94940:	3410      	adds	r4, #16
   94942:	2b07      	cmp	r3, #7
   94944:	9425      	str	r4, [sp, #148]	; 0x94
   94946:	9324      	str	r3, [sp, #144]	; 0x90
   94948:	f8c9 a000 	str.w	sl, [r9]
   9494c:	f8c9 6004 	str.w	r6, [r9, #4]
   94950:	ddef      	ble.n	94932 <_svfprintf_r+0x526>
   94952:	aa23      	add	r2, sp, #140	; 0x8c
   94954:	4659      	mov	r1, fp
   94956:	4638      	mov	r0, r7
   94958:	f004 fa00 	bl	98d5c <__ssprint_r>
   9495c:	2800      	cmp	r0, #0
   9495e:	d193      	bne.n	94888 <_svfprintf_r+0x47c>
   94960:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94964:	9c25      	ldr	r4, [sp, #148]	; 0x94
   94966:	9b24      	ldr	r3, [sp, #144]	; 0x90
   94968:	e7e5      	b.n	94936 <_svfprintf_r+0x52a>
   9496a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   9496c:	9a08      	ldr	r2, [sp, #32]
   9496e:	1a9f      	subs	r7, r3, r2
   94970:	2f00      	cmp	r7, #0
   94972:	f77f aece 	ble.w	94712 <_svfprintf_r+0x306>
   94976:	4a84      	ldr	r2, [pc, #528]	; (94b88 <_svfprintf_r+0x77c>)
   94978:	2f10      	cmp	r7, #16
   9497a:	9b24      	ldr	r3, [sp, #144]	; 0x90
   9497c:	920f      	str	r2, [sp, #60]	; 0x3c
   9497e:	dd2b      	ble.n	949d8 <_svfprintf_r+0x5cc>
   94980:	464a      	mov	r2, r9
   94982:	4621      	mov	r1, r4
   94984:	46b9      	mov	r9, r7
   94986:	2510      	movs	r5, #16
   94988:	4637      	mov	r7, r6
   9498a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   9498c:	9e09      	ldr	r6, [sp, #36]	; 0x24
   9498e:	e006      	b.n	9499e <_svfprintf_r+0x592>
   94990:	f1a9 0910 	sub.w	r9, r9, #16
   94994:	f1b9 0f10 	cmp.w	r9, #16
   94998:	f102 0208 	add.w	r2, r2, #8
   9499c:	dd18      	ble.n	949d0 <_svfprintf_r+0x5c4>
   9499e:	3301      	adds	r3, #1
   949a0:	3110      	adds	r1, #16
   949a2:	2b07      	cmp	r3, #7
   949a4:	9125      	str	r1, [sp, #148]	; 0x94
   949a6:	9324      	str	r3, [sp, #144]	; 0x90
   949a8:	f8c2 a000 	str.w	sl, [r2]
   949ac:	6055      	str	r5, [r2, #4]
   949ae:	ddef      	ble.n	94990 <_svfprintf_r+0x584>
   949b0:	aa23      	add	r2, sp, #140	; 0x8c
   949b2:	4631      	mov	r1, r6
   949b4:	4620      	mov	r0, r4
   949b6:	f004 f9d1 	bl	98d5c <__ssprint_r>
   949ba:	2800      	cmp	r0, #0
   949bc:	f47f af64 	bne.w	94888 <_svfprintf_r+0x47c>
   949c0:	f1a9 0910 	sub.w	r9, r9, #16
   949c4:	f1b9 0f10 	cmp.w	r9, #16
   949c8:	aa30      	add	r2, sp, #192	; 0xc0
   949ca:	9925      	ldr	r1, [sp, #148]	; 0x94
   949cc:	9b24      	ldr	r3, [sp, #144]	; 0x90
   949ce:	dce6      	bgt.n	9499e <_svfprintf_r+0x592>
   949d0:	463e      	mov	r6, r7
   949d2:	460c      	mov	r4, r1
   949d4:	464f      	mov	r7, r9
   949d6:	4691      	mov	r9, r2
   949d8:	3301      	adds	r3, #1
   949da:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   949dc:	443c      	add	r4, r7
   949de:	2b07      	cmp	r3, #7
   949e0:	9425      	str	r4, [sp, #148]	; 0x94
   949e2:	9324      	str	r3, [sp, #144]	; 0x90
   949e4:	e889 0084 	stmia.w	r9, {r2, r7}
   949e8:	f300 852b 	bgt.w	95442 <_svfprintf_r+0x1036>
   949ec:	f109 0908 	add.w	r9, r9, #8
   949f0:	e68f      	b.n	94712 <_svfprintf_r+0x306>
   949f2:	9b12      	ldr	r3, [sp, #72]	; 0x48
   949f4:	9d24      	ldr	r5, [sp, #144]	; 0x90
   949f6:	2b01      	cmp	r3, #1
   949f8:	f104 0401 	add.w	r4, r4, #1
   949fc:	f105 0501 	add.w	r5, r5, #1
   94a00:	f340 84e8 	ble.w	953d4 <_svfprintf_r+0xfc8>
   94a04:	2301      	movs	r3, #1
   94a06:	2d07      	cmp	r5, #7
   94a08:	9425      	str	r4, [sp, #148]	; 0x94
   94a0a:	f8c9 6000 	str.w	r6, [r9]
   94a0e:	9524      	str	r5, [sp, #144]	; 0x90
   94a10:	f8c9 3004 	str.w	r3, [r9, #4]
   94a14:	f300 84f9 	bgt.w	9540a <_svfprintf_r+0xffe>
   94a18:	f109 0908 	add.w	r9, r9, #8
   94a1c:	9a16      	ldr	r2, [sp, #88]	; 0x58
   94a1e:	3501      	adds	r5, #1
   94a20:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   94a22:	4414      	add	r4, r2
   94a24:	2d07      	cmp	r5, #7
   94a26:	9425      	str	r4, [sp, #148]	; 0x94
   94a28:	9524      	str	r5, [sp, #144]	; 0x90
   94a2a:	f8c9 3000 	str.w	r3, [r9]
   94a2e:	f8c9 2004 	str.w	r2, [r9, #4]
   94a32:	f300 84f8 	bgt.w	95426 <_svfprintf_r+0x101a>
   94a36:	f109 0908 	add.w	r9, r9, #8
   94a3a:	2300      	movs	r3, #0
   94a3c:	9814      	ldr	r0, [sp, #80]	; 0x50
   94a3e:	9915      	ldr	r1, [sp, #84]	; 0x54
   94a40:	2200      	movs	r2, #0
   94a42:	f7fe f903 	bl	92c4c <__aeabi_dcmpeq>
   94a46:	9b12      	ldr	r3, [sp, #72]	; 0x48
   94a48:	2800      	cmp	r0, #0
   94a4a:	f000 80ea 	beq.w	94c22 <_svfprintf_r+0x816>
   94a4e:	1e5e      	subs	r6, r3, #1
   94a50:	2e00      	cmp	r6, #0
   94a52:	f340 80f5 	ble.w	94c40 <_svfprintf_r+0x834>
   94a56:	4b4c      	ldr	r3, [pc, #304]	; (94b88 <_svfprintf_r+0x77c>)
   94a58:	2e10      	cmp	r6, #16
   94a5a:	930f      	str	r3, [sp, #60]	; 0x3c
   94a5c:	dd2c      	ble.n	94ab8 <_svfprintf_r+0x6ac>
   94a5e:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
   94a62:	2710      	movs	r7, #16
   94a64:	46b0      	mov	r8, r6
   94a66:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
   94a6a:	9e09      	ldr	r6, [sp, #36]	; 0x24
   94a6c:	e006      	b.n	94a7c <_svfprintf_r+0x670>
   94a6e:	f1a8 0810 	sub.w	r8, r8, #16
   94a72:	f1b8 0f10 	cmp.w	r8, #16
   94a76:	f109 0908 	add.w	r9, r9, #8
   94a7a:	dd1a      	ble.n	94ab2 <_svfprintf_r+0x6a6>
   94a7c:	3501      	adds	r5, #1
   94a7e:	3410      	adds	r4, #16
   94a80:	2d07      	cmp	r5, #7
   94a82:	9425      	str	r4, [sp, #148]	; 0x94
   94a84:	9524      	str	r5, [sp, #144]	; 0x90
   94a86:	f8c9 a000 	str.w	sl, [r9]
   94a8a:	f8c9 7004 	str.w	r7, [r9, #4]
   94a8e:	ddee      	ble.n	94a6e <_svfprintf_r+0x662>
   94a90:	aa23      	add	r2, sp, #140	; 0x8c
   94a92:	4631      	mov	r1, r6
   94a94:	4658      	mov	r0, fp
   94a96:	f004 f961 	bl	98d5c <__ssprint_r>
   94a9a:	2800      	cmp	r0, #0
   94a9c:	f47f aef4 	bne.w	94888 <_svfprintf_r+0x47c>
   94aa0:	f1a8 0810 	sub.w	r8, r8, #16
   94aa4:	f1b8 0f10 	cmp.w	r8, #16
   94aa8:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94aac:	9c25      	ldr	r4, [sp, #148]	; 0x94
   94aae:	9d24      	ldr	r5, [sp, #144]	; 0x90
   94ab0:	dce4      	bgt.n	94a7c <_svfprintf_r+0x670>
   94ab2:	4646      	mov	r6, r8
   94ab4:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
   94ab8:	3501      	adds	r5, #1
   94aba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   94abc:	4434      	add	r4, r6
   94abe:	2d07      	cmp	r5, #7
   94ac0:	9425      	str	r4, [sp, #148]	; 0x94
   94ac2:	9524      	str	r5, [sp, #144]	; 0x90
   94ac4:	e889 0048 	stmia.w	r9, {r3, r6}
   94ac8:	f340 80b8 	ble.w	94c3c <_svfprintf_r+0x830>
   94acc:	aa23      	add	r2, sp, #140	; 0x8c
   94ace:	9909      	ldr	r1, [sp, #36]	; 0x24
   94ad0:	980a      	ldr	r0, [sp, #40]	; 0x28
   94ad2:	f004 f943 	bl	98d5c <__ssprint_r>
   94ad6:	2800      	cmp	r0, #0
   94ad8:	f47f aed6 	bne.w	94888 <_svfprintf_r+0x47c>
   94adc:	9c25      	ldr	r4, [sp, #148]	; 0x94
   94ade:	9d24      	ldr	r5, [sp, #144]	; 0x90
   94ae0:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94ae4:	e0ac      	b.n	94c40 <_svfprintf_r+0x834>
   94ae6:	aa23      	add	r2, sp, #140	; 0x8c
   94ae8:	9909      	ldr	r1, [sp, #36]	; 0x24
   94aea:	980a      	ldr	r0, [sp, #40]	; 0x28
   94aec:	f004 f936 	bl	98d5c <__ssprint_r>
   94af0:	2800      	cmp	r0, #0
   94af2:	f43f ae9f 	beq.w	94834 <_svfprintf_r+0x428>
   94af6:	e6c7      	b.n	94888 <_svfprintf_r+0x47c>
   94af8:	aa23      	add	r2, sp, #140	; 0x8c
   94afa:	9909      	ldr	r1, [sp, #36]	; 0x24
   94afc:	980a      	ldr	r0, [sp, #40]	; 0x28
   94afe:	f004 f92d 	bl	98d5c <__ssprint_r>
   94b02:	2800      	cmp	r0, #0
   94b04:	f47f aec0 	bne.w	94888 <_svfprintf_r+0x47c>
   94b08:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94b0c:	e4c4      	b.n	94498 <_svfprintf_r+0x8c>
   94b0e:	aa23      	add	r2, sp, #140	; 0x8c
   94b10:	9909      	ldr	r1, [sp, #36]	; 0x24
   94b12:	980a      	ldr	r0, [sp, #40]	; 0x28
   94b14:	f004 f922 	bl	98d5c <__ssprint_r>
   94b18:	2800      	cmp	r0, #0
   94b1a:	f47f aeb5 	bne.w	94888 <_svfprintf_r+0x47c>
   94b1e:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94b22:	9c25      	ldr	r4, [sp, #148]	; 0x94
   94b24:	e62e      	b.n	94784 <_svfprintf_r+0x378>
   94b26:	aa23      	add	r2, sp, #140	; 0x8c
   94b28:	9909      	ldr	r1, [sp, #36]	; 0x24
   94b2a:	980a      	ldr	r0, [sp, #40]	; 0x28
   94b2c:	f004 f916 	bl	98d5c <__ssprint_r>
   94b30:	2800      	cmp	r0, #0
   94b32:	f47f aea9 	bne.w	94888 <_svfprintf_r+0x47c>
   94b36:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94b3a:	9c25      	ldr	r4, [sp, #148]	; 0x94
   94b3c:	e5d5      	b.n	946ea <_svfprintf_r+0x2de>
   94b3e:	aa23      	add	r2, sp, #140	; 0x8c
   94b40:	9909      	ldr	r1, [sp, #36]	; 0x24
   94b42:	980a      	ldr	r0, [sp, #40]	; 0x28
   94b44:	f004 f90a 	bl	98d5c <__ssprint_r>
   94b48:	2800      	cmp	r0, #0
   94b4a:	f47f ae9d 	bne.w	94888 <_svfprintf_r+0x47c>
   94b4e:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94b52:	9c25      	ldr	r4, [sp, #148]	; 0x94
   94b54:	e5d9      	b.n	9470a <_svfprintf_r+0x2fe>
   94b56:	3301      	adds	r3, #1
   94b58:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   94b5a:	442c      	add	r4, r5
   94b5c:	2b07      	cmp	r3, #7
   94b5e:	9425      	str	r4, [sp, #148]	; 0x94
   94b60:	9324      	str	r3, [sp, #144]	; 0x90
   94b62:	e889 0024 	stmia.w	r9, {r2, r5}
   94b66:	f77f ae1e 	ble.w	947a6 <_svfprintf_r+0x39a>
   94b6a:	aa23      	add	r2, sp, #140	; 0x8c
   94b6c:	9909      	ldr	r1, [sp, #36]	; 0x24
   94b6e:	980a      	ldr	r0, [sp, #40]	; 0x28
   94b70:	f004 f8f4 	bl	98d5c <__ssprint_r>
   94b74:	2800      	cmp	r0, #0
   94b76:	f47f ae87 	bne.w	94888 <_svfprintf_r+0x47c>
   94b7a:	9c25      	ldr	r4, [sp, #148]	; 0x94
   94b7c:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94b80:	e613      	b.n	947aa <_svfprintf_r+0x39e>
   94b82:	bf00      	nop
   94b84:	0009b1c8 	.word	0x0009b1c8
   94b88:	0009b178 	.word	0x0009b178
   94b8c:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   94b8e:	2d00      	cmp	r5, #0
   94b90:	f340 830e 	ble.w	951b0 <_svfprintf_r+0xda4>
   94b94:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   94b96:	9a12      	ldr	r2, [sp, #72]	; 0x48
   94b98:	4293      	cmp	r3, r2
   94b9a:	bfa8      	it	ge
   94b9c:	4613      	movge	r3, r2
   94b9e:	2b00      	cmp	r3, #0
   94ba0:	461d      	mov	r5, r3
   94ba2:	dd0d      	ble.n	94bc0 <_svfprintf_r+0x7b4>
   94ba4:	9b24      	ldr	r3, [sp, #144]	; 0x90
   94ba6:	442c      	add	r4, r5
   94ba8:	3301      	adds	r3, #1
   94baa:	2b07      	cmp	r3, #7
   94bac:	9425      	str	r4, [sp, #148]	; 0x94
   94bae:	f8c9 6000 	str.w	r6, [r9]
   94bb2:	f8c9 5004 	str.w	r5, [r9, #4]
   94bb6:	9324      	str	r3, [sp, #144]	; 0x90
   94bb8:	f300 8615 	bgt.w	957e6 <_svfprintf_r+0x13da>
   94bbc:	f109 0908 	add.w	r9, r9, #8
   94bc0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   94bc2:	2d00      	cmp	r5, #0
   94bc4:	bfa8      	it	ge
   94bc6:	1b5b      	subge	r3, r3, r5
   94bc8:	2b00      	cmp	r3, #0
   94bca:	461d      	mov	r5, r3
   94bcc:	f340 83a0 	ble.w	95310 <_svfprintf_r+0xf04>
   94bd0:	4ab9      	ldr	r2, [pc, #740]	; (94eb8 <_svfprintf_r+0xaac>)
   94bd2:	2d10      	cmp	r5, #16
   94bd4:	9b24      	ldr	r3, [sp, #144]	; 0x90
   94bd6:	920f      	str	r2, [sp, #60]	; 0x3c
   94bd8:	f340 8545 	ble.w	95666 <_svfprintf_r+0x125a>
   94bdc:	4622      	mov	r2, r4
   94bde:	2710      	movs	r7, #16
   94be0:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
   94be4:	9c09      	ldr	r4, [sp, #36]	; 0x24
   94be6:	e005      	b.n	94bf4 <_svfprintf_r+0x7e8>
   94be8:	f109 0908 	add.w	r9, r9, #8
   94bec:	3d10      	subs	r5, #16
   94bee:	2d10      	cmp	r5, #16
   94bf0:	f340 8538 	ble.w	95664 <_svfprintf_r+0x1258>
   94bf4:	3301      	adds	r3, #1
   94bf6:	3210      	adds	r2, #16
   94bf8:	2b07      	cmp	r3, #7
   94bfa:	9225      	str	r2, [sp, #148]	; 0x94
   94bfc:	9324      	str	r3, [sp, #144]	; 0x90
   94bfe:	f8c9 a000 	str.w	sl, [r9]
   94c02:	f8c9 7004 	str.w	r7, [r9, #4]
   94c06:	ddef      	ble.n	94be8 <_svfprintf_r+0x7dc>
   94c08:	aa23      	add	r2, sp, #140	; 0x8c
   94c0a:	4621      	mov	r1, r4
   94c0c:	4658      	mov	r0, fp
   94c0e:	f004 f8a5 	bl	98d5c <__ssprint_r>
   94c12:	2800      	cmp	r0, #0
   94c14:	f47f ae38 	bne.w	94888 <_svfprintf_r+0x47c>
   94c18:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94c1c:	9a25      	ldr	r2, [sp, #148]	; 0x94
   94c1e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   94c20:	e7e4      	b.n	94bec <_svfprintf_r+0x7e0>
   94c22:	3b01      	subs	r3, #1
   94c24:	3501      	adds	r5, #1
   94c26:	3601      	adds	r6, #1
   94c28:	441c      	add	r4, r3
   94c2a:	2d07      	cmp	r5, #7
   94c2c:	f8c9 6000 	str.w	r6, [r9]
   94c30:	9524      	str	r5, [sp, #144]	; 0x90
   94c32:	9425      	str	r4, [sp, #148]	; 0x94
   94c34:	f8c9 3004 	str.w	r3, [r9, #4]
   94c38:	f73f af48 	bgt.w	94acc <_svfprintf_r+0x6c0>
   94c3c:	f109 0908 	add.w	r9, r9, #8
   94c40:	9a19      	ldr	r2, [sp, #100]	; 0x64
   94c42:	3501      	adds	r5, #1
   94c44:	4414      	add	r4, r2
   94c46:	ab1f      	add	r3, sp, #124	; 0x7c
   94c48:	2d07      	cmp	r5, #7
   94c4a:	9425      	str	r4, [sp, #148]	; 0x94
   94c4c:	9524      	str	r5, [sp, #144]	; 0x90
   94c4e:	f8c9 2004 	str.w	r2, [r9, #4]
   94c52:	f8c9 3000 	str.w	r3, [r9]
   94c56:	f77f ada6 	ble.w	947a6 <_svfprintf_r+0x39a>
   94c5a:	aa23      	add	r2, sp, #140	; 0x8c
   94c5c:	9909      	ldr	r1, [sp, #36]	; 0x24
   94c5e:	980a      	ldr	r0, [sp, #40]	; 0x28
   94c60:	f004 f87c 	bl	98d5c <__ssprint_r>
   94c64:	2800      	cmp	r0, #0
   94c66:	f47f ae0f 	bne.w	94888 <_svfprintf_r+0x47c>
   94c6a:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   94c6e:	9c25      	ldr	r4, [sp, #148]	; 0x94
   94c70:	e59b      	b.n	947aa <_svfprintf_r+0x39e>
   94c72:	f898 3000 	ldrb.w	r3, [r8]
   94c76:	f108 0401 	add.w	r4, r8, #1
   94c7a:	2b2a      	cmp	r3, #42	; 0x2a
   94c7c:	f000 872b 	beq.w	95ad6 <_svfprintf_r+0x16ca>
   94c80:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
   94c84:	2809      	cmp	r0, #9
   94c86:	bf98      	it	ls
   94c88:	2500      	movls	r5, #0
   94c8a:	f200 86af 	bhi.w	959ec <_svfprintf_r+0x15e0>
   94c8e:	f814 3b01 	ldrb.w	r3, [r4], #1
   94c92:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   94c96:	eb00 0545 	add.w	r5, r0, r5, lsl #1
   94c9a:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
   94c9e:	2809      	cmp	r0, #9
   94ca0:	d9f5      	bls.n	94c8e <_svfprintf_r+0x882>
   94ca2:	ea45 75e5 	orr.w	r5, r5, r5, asr #31
   94ca6:	46a0      	mov	r8, r4
   94ca8:	e40c      	b.n	944c4 <_svfprintf_r+0xb8>
   94caa:	9b07      	ldr	r3, [sp, #28]
   94cac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   94cb0:	9307      	str	r3, [sp, #28]
   94cb2:	f898 3000 	ldrb.w	r3, [r8]
   94cb6:	e403      	b.n	944c0 <_svfprintf_r+0xb4>
   94cb8:	f898 3000 	ldrb.w	r3, [r8]
   94cbc:	2900      	cmp	r1, #0
   94cbe:	f47f abff 	bne.w	944c0 <_svfprintf_r+0xb4>
   94cc2:	2201      	movs	r2, #1
   94cc4:	2120      	movs	r1, #32
   94cc6:	f7ff bbfb 	b.w	944c0 <_svfprintf_r+0xb4>
   94cca:	9b07      	ldr	r3, [sp, #28]
   94ccc:	f043 0301 	orr.w	r3, r3, #1
   94cd0:	9307      	str	r3, [sp, #28]
   94cd2:	f898 3000 	ldrb.w	r3, [r8]
   94cd6:	f7ff bbf3 	b.w	944c0 <_svfprintf_r+0xb4>
   94cda:	f898 3000 	ldrb.w	r3, [r8]
   94cde:	2201      	movs	r2, #1
   94ce0:	212b      	movs	r1, #43	; 0x2b
   94ce2:	f7ff bbed 	b.w	944c0 <_svfprintf_r+0xb4>
   94ce6:	9b07      	ldr	r3, [sp, #28]
   94ce8:	f043 0320 	orr.w	r3, r3, #32
   94cec:	9307      	str	r3, [sp, #28]
   94cee:	f898 3000 	ldrb.w	r3, [r8]
   94cf2:	f7ff bbe5 	b.w	944c0 <_svfprintf_r+0xb4>
   94cf6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   94cf8:	46ab      	mov	fp, r5
   94cfa:	6816      	ldr	r6, [r2, #0]
   94cfc:	2500      	movs	r5, #0
   94cfe:	9311      	str	r3, [sp, #68]	; 0x44
   94d00:	f88d 506f 	strb.w	r5, [sp, #111]	; 0x6f
   94d04:	1d14      	adds	r4, r2, #4
   94d06:	2e00      	cmp	r6, #0
   94d08:	f000 85e5 	beq.w	958d6 <_svfprintf_r+0x14ca>
   94d0c:	f1bb 0f00 	cmp.w	fp, #0
   94d10:	f2c0 853f 	blt.w	95792 <_svfprintf_r+0x1386>
   94d14:	465a      	mov	r2, fp
   94d16:	4629      	mov	r1, r5
   94d18:	4630      	mov	r0, r6
   94d1a:	f003 fc35 	bl	98588 <memchr>
   94d1e:	2800      	cmp	r0, #0
   94d20:	f000 8658 	beq.w	959d4 <_svfprintf_r+0x15c8>
   94d24:	46ab      	mov	fp, r5
   94d26:	1b83      	subs	r3, r0, r6
   94d28:	930d      	str	r3, [sp, #52]	; 0x34
   94d2a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   94d2e:	940e      	str	r4, [sp, #56]	; 0x38
   94d30:	9308      	str	r3, [sp, #32]
   94d32:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
   94d36:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
   94d3a:	e472      	b.n	94622 <_svfprintf_r+0x216>
   94d3c:	9311      	str	r3, [sp, #68]	; 0x44
   94d3e:	46ab      	mov	fp, r5
   94d40:	2a00      	cmp	r2, #0
   94d42:	f040 86ed 	bne.w	95b20 <_svfprintf_r+0x1714>
   94d46:	9a07      	ldr	r2, [sp, #28]
   94d48:	f012 0320 	ands.w	r3, r2, #32
   94d4c:	f000 8143 	beq.w	94fd6 <_svfprintf_r+0xbca>
   94d50:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   94d52:	2700      	movs	r7, #0
   94d54:	3407      	adds	r4, #7
   94d56:	f024 0307 	bic.w	r3, r4, #7
   94d5a:	f103 0108 	add.w	r1, r3, #8
   94d5e:	45bb      	cmp	fp, r7
   94d60:	910e      	str	r1, [sp, #56]	; 0x38
   94d62:	e9d3 4500 	ldrd	r4, r5, [r3]
   94d66:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
   94d6a:	f2c0 82c1 	blt.w	952f0 <_svfprintf_r+0xee4>
   94d6e:	f022 0380 	bic.w	r3, r2, #128	; 0x80
   94d72:	9307      	str	r3, [sp, #28]
   94d74:	ea54 0305 	orrs.w	r3, r4, r5
   94d78:	f000 8148 	beq.w	9500c <_svfprintf_r+0xc00>
   94d7c:	2d00      	cmp	r5, #0
   94d7e:	bf08      	it	eq
   94d80:	2c0a      	cmpeq	r4, #10
   94d82:	f0c0 8148 	bcc.w	95016 <_svfprintf_r+0xc0a>
   94d86:	ae30      	add	r6, sp, #192	; 0xc0
   94d88:	4620      	mov	r0, r4
   94d8a:	4629      	mov	r1, r5
   94d8c:	220a      	movs	r2, #10
   94d8e:	2300      	movs	r3, #0
   94d90:	f004 f9de 	bl	99150 <__aeabi_uldivmod>
   94d94:	3230      	adds	r2, #48	; 0x30
   94d96:	f806 2d01 	strb.w	r2, [r6, #-1]!
   94d9a:	4620      	mov	r0, r4
   94d9c:	4629      	mov	r1, r5
   94d9e:	2300      	movs	r3, #0
   94da0:	220a      	movs	r2, #10
   94da2:	f004 f9d5 	bl	99150 <__aeabi_uldivmod>
   94da6:	4604      	mov	r4, r0
   94da8:	460d      	mov	r5, r1
   94daa:	ea54 0305 	orrs.w	r3, r4, r5
   94dae:	d1eb      	bne.n	94d88 <_svfprintf_r+0x97c>
   94db0:	e42d      	b.n	9460e <_svfprintf_r+0x202>
   94db2:	9311      	str	r3, [sp, #68]	; 0x44
   94db4:	46ab      	mov	fp, r5
   94db6:	2a00      	cmp	r2, #0
   94db8:	f040 86ca 	bne.w	95b50 <_svfprintf_r+0x1744>
   94dbc:	9b07      	ldr	r3, [sp, #28]
   94dbe:	483f      	ldr	r0, [pc, #252]	; (94ebc <_svfprintf_r+0xab0>)
   94dc0:	069d      	lsls	r5, r3, #26
   94dc2:	f140 815d 	bpl.w	95080 <_svfprintf_r+0xc74>
   94dc6:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   94dc8:	3407      	adds	r4, #7
   94dca:	f024 0307 	bic.w	r3, r4, #7
   94dce:	f103 0208 	add.w	r2, r3, #8
   94dd2:	920e      	str	r2, [sp, #56]	; 0x38
   94dd4:	e9d3 4500 	ldrd	r4, r5, [r3]
   94dd8:	9a07      	ldr	r2, [sp, #28]
   94dda:	f012 0701 	ands.w	r7, r2, #1
   94dde:	f000 8246 	beq.w	9526e <_svfprintf_r+0xe62>
   94de2:	ea54 0305 	orrs.w	r3, r4, r5
   94de6:	f43f ad2a 	beq.w	9483e <_svfprintf_r+0x432>
   94dea:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
   94dee:	2700      	movs	r7, #0
   94df0:	f88d 2071 	strb.w	r2, [sp, #113]	; 0x71
   94df4:	9a07      	ldr	r2, [sp, #28]
   94df6:	2330      	movs	r3, #48	; 0x30
   94df8:	45bb      	cmp	fp, r7
   94dfa:	f88d 3070 	strb.w	r3, [sp, #112]	; 0x70
   94dfe:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
   94e02:	f042 0302 	orr.w	r3, r2, #2
   94e06:	f2c0 858d 	blt.w	95924 <_svfprintf_r+0x1518>
   94e0a:	f022 0380 	bic.w	r3, r2, #128	; 0x80
   94e0e:	f043 0302 	orr.w	r3, r3, #2
   94e12:	9307      	str	r3, [sp, #28]
   94e14:	f7ff bbec 	b.w	945f0 <_svfprintf_r+0x1e4>
   94e18:	f898 3000 	ldrb.w	r3, [r8]
   94e1c:	2b6c      	cmp	r3, #108	; 0x6c
   94e1e:	f000 8452 	beq.w	956c6 <_svfprintf_r+0x12ba>
   94e22:	9807      	ldr	r0, [sp, #28]
   94e24:	f040 0010 	orr.w	r0, r0, #16
   94e28:	9007      	str	r0, [sp, #28]
   94e2a:	f7ff bb49 	b.w	944c0 <_svfprintf_r+0xb4>
   94e2e:	9311      	str	r3, [sp, #68]	; 0x44
   94e30:	46ab      	mov	fp, r5
   94e32:	2a00      	cmp	r2, #0
   94e34:	f040 8694 	bne.w	95b60 <_svfprintf_r+0x1754>
   94e38:	9a07      	ldr	r2, [sp, #28]
   94e3a:	f012 0320 	ands.w	r3, r2, #32
   94e3e:	f000 80a0 	beq.w	94f82 <_svfprintf_r+0xb76>
   94e42:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   94e44:	2700      	movs	r7, #0
   94e46:	3407      	adds	r4, #7
   94e48:	f024 0307 	bic.w	r3, r4, #7
   94e4c:	f103 0108 	add.w	r1, r3, #8
   94e50:	45bb      	cmp	fp, r7
   94e52:	910e      	str	r1, [sp, #56]	; 0x38
   94e54:	e9d3 4500 	ldrd	r4, r5, [r3]
   94e58:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
   94e5c:	db0b      	blt.n	94e76 <_svfprintf_r+0xa6a>
   94e5e:	f022 0380 	bic.w	r3, r2, #128	; 0x80
   94e62:	9307      	str	r3, [sp, #28]
   94e64:	ea54 0305 	orrs.w	r3, r4, r5
   94e68:	d106      	bne.n	94e78 <_svfprintf_r+0xa6c>
   94e6a:	f1bb 0f00 	cmp.w	fp, #0
   94e6e:	f000 85a2 	beq.w	959b6 <_svfprintf_r+0x15aa>
   94e72:	2400      	movs	r4, #0
   94e74:	2500      	movs	r5, #0
   94e76:	2700      	movs	r7, #0
   94e78:	ae30      	add	r6, sp, #192	; 0xc0
   94e7a:	08e2      	lsrs	r2, r4, #3
   94e7c:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
   94e80:	08e9      	lsrs	r1, r5, #3
   94e82:	f004 0307 	and.w	r3, r4, #7
   94e86:	460d      	mov	r5, r1
   94e88:	4614      	mov	r4, r2
   94e8a:	3330      	adds	r3, #48	; 0x30
   94e8c:	ea54 0205 	orrs.w	r2, r4, r5
   94e90:	f806 3d01 	strb.w	r3, [r6, #-1]!
   94e94:	d1f1      	bne.n	94e7a <_svfprintf_r+0xa6e>
   94e96:	9a07      	ldr	r2, [sp, #28]
   94e98:	07d1      	lsls	r1, r2, #31
   94e9a:	f57f abb8 	bpl.w	9460e <_svfprintf_r+0x202>
   94e9e:	2b30      	cmp	r3, #48	; 0x30
   94ea0:	f43f abb5 	beq.w	9460e <_svfprintf_r+0x202>
   94ea4:	2230      	movs	r2, #48	; 0x30
   94ea6:	1e73      	subs	r3, r6, #1
   94ea8:	f806 2c01 	strb.w	r2, [r6, #-1]
   94eac:	aa30      	add	r2, sp, #192	; 0xc0
   94eae:	1ad2      	subs	r2, r2, r3
   94eb0:	920d      	str	r2, [sp, #52]	; 0x34
   94eb2:	461e      	mov	r6, r3
   94eb4:	f7ff bbae 	b.w	94614 <_svfprintf_r+0x208>
   94eb8:	0009b178 	.word	0x0009b178
   94ebc:	0009b1ac 	.word	0x0009b1ac
   94ec0:	9311      	str	r3, [sp, #68]	; 0x44
   94ec2:	46ab      	mov	fp, r5
   94ec4:	2a00      	cmp	r2, #0
   94ec6:	f040 8647 	bne.w	95b58 <_svfprintf_r+0x174c>
   94eca:	9b07      	ldr	r3, [sp, #28]
   94ecc:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   94ece:	071a      	lsls	r2, r3, #28
   94ed0:	f104 0407 	add.w	r4, r4, #7
   94ed4:	f140 836c 	bpl.w	955b0 <_svfprintf_r+0x11a4>
   94ed8:	f024 0307 	bic.w	r3, r4, #7
   94edc:	f103 0208 	add.w	r2, r3, #8
   94ee0:	920e      	str	r2, [sp, #56]	; 0x38
   94ee2:	681a      	ldr	r2, [r3, #0]
   94ee4:	685b      	ldr	r3, [r3, #4]
   94ee6:	9214      	str	r2, [sp, #80]	; 0x50
   94ee8:	9315      	str	r3, [sp, #84]	; 0x54
   94eea:	9b15      	ldr	r3, [sp, #84]	; 0x54
   94eec:	9d14      	ldr	r5, [sp, #80]	; 0x50
   94eee:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
   94ef2:	4628      	mov	r0, r5
   94ef4:	4621      	mov	r1, r4
   94ef6:	f04f 32ff 	mov.w	r2, #4294967295
   94efa:	4ba9      	ldr	r3, [pc, #676]	; (951a0 <_svfprintf_r+0xd94>)
   94efc:	f7fd fed8 	bl	92cb0 <__aeabi_dcmpun>
   94f00:	2800      	cmp	r0, #0
   94f02:	f040 82cd 	bne.w	954a0 <_svfprintf_r+0x1094>
   94f06:	4628      	mov	r0, r5
   94f08:	4621      	mov	r1, r4
   94f0a:	f04f 32ff 	mov.w	r2, #4294967295
   94f0e:	4ba4      	ldr	r3, [pc, #656]	; (951a0 <_svfprintf_r+0xd94>)
   94f10:	f7fd feb0 	bl	92c74 <__aeabi_dcmple>
   94f14:	2800      	cmp	r0, #0
   94f16:	f040 82c3 	bne.w	954a0 <_svfprintf_r+0x1094>
   94f1a:	9814      	ldr	r0, [sp, #80]	; 0x50
   94f1c:	9915      	ldr	r1, [sp, #84]	; 0x54
   94f1e:	2200      	movs	r2, #0
   94f20:	2300      	movs	r3, #0
   94f22:	f7fd fe9d 	bl	92c60 <__aeabi_dcmplt>
   94f26:	2800      	cmp	r0, #0
   94f28:	f040 84f6 	bne.w	95918 <_svfprintf_r+0x150c>
   94f2c:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
   94f30:	9907      	ldr	r1, [sp, #28]
   94f32:	4e9c      	ldr	r6, [pc, #624]	; (951a4 <_svfprintf_r+0xd98>)
   94f34:	f021 0180 	bic.w	r1, r1, #128	; 0x80
   94f38:	4b9b      	ldr	r3, [pc, #620]	; (951a8 <_svfprintf_r+0xd9c>)
   94f3a:	9107      	str	r1, [sp, #28]
   94f3c:	9911      	ldr	r1, [sp, #68]	; 0x44
   94f3e:	2203      	movs	r2, #3
   94f40:	f04f 0b00 	mov.w	fp, #0
   94f44:	9208      	str	r2, [sp, #32]
   94f46:	2947      	cmp	r1, #71	; 0x47
   94f48:	bfd8      	it	le
   94f4a:	461e      	movle	r6, r3
   94f4c:	920d      	str	r2, [sp, #52]	; 0x34
   94f4e:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
   94f52:	f7ff bb66 	b.w	94622 <_svfprintf_r+0x216>
   94f56:	9b07      	ldr	r3, [sp, #28]
   94f58:	f043 0308 	orr.w	r3, r3, #8
   94f5c:	9307      	str	r3, [sp, #28]
   94f5e:	f898 3000 	ldrb.w	r3, [r8]
   94f62:	f7ff baad 	b.w	944c0 <_svfprintf_r+0xb4>
   94f66:	9311      	str	r3, [sp, #68]	; 0x44
   94f68:	46ab      	mov	fp, r5
   94f6a:	2a00      	cmp	r2, #0
   94f6c:	f040 85ec 	bne.w	95b48 <_svfprintf_r+0x173c>
   94f70:	9b07      	ldr	r3, [sp, #28]
   94f72:	f043 0310 	orr.w	r3, r3, #16
   94f76:	9307      	str	r3, [sp, #28]
   94f78:	9a07      	ldr	r2, [sp, #28]
   94f7a:	f012 0320 	ands.w	r3, r2, #32
   94f7e:	f47f af60 	bne.w	94e42 <_svfprintf_r+0xa36>
   94f82:	9907      	ldr	r1, [sp, #28]
   94f84:	f011 0210 	ands.w	r2, r1, #16
   94f88:	f000 8268 	beq.w	9545c <_svfprintf_r+0x1050>
   94f8c:	980e      	ldr	r0, [sp, #56]	; 0x38
   94f8e:	f1bb 0f00 	cmp.w	fp, #0
   94f92:	4602      	mov	r2, r0
   94f94:	6804      	ldr	r4, [r0, #0]
   94f96:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
   94f9a:	f102 0204 	add.w	r2, r2, #4
   94f9e:	f04f 0500 	mov.w	r5, #0
   94fa2:	f2c0 84c2 	blt.w	9592a <_svfprintf_r+0x151e>
   94fa6:	f021 0180 	bic.w	r1, r1, #128	; 0x80
   94faa:	9107      	str	r1, [sp, #28]
   94fac:	ea54 0105 	orrs.w	r1, r4, r5
   94fb0:	920e      	str	r2, [sp, #56]	; 0x38
   94fb2:	f43f af5a 	beq.w	94e6a <_svfprintf_r+0xa5e>
   94fb6:	461f      	mov	r7, r3
   94fb8:	e75e      	b.n	94e78 <_svfprintf_r+0xa6c>
   94fba:	9311      	str	r3, [sp, #68]	; 0x44
   94fbc:	46ab      	mov	fp, r5
   94fbe:	2a00      	cmp	r2, #0
   94fc0:	f040 85be 	bne.w	95b40 <_svfprintf_r+0x1734>
   94fc4:	9b07      	ldr	r3, [sp, #28]
   94fc6:	f043 0310 	orr.w	r3, r3, #16
   94fca:	9307      	str	r3, [sp, #28]
   94fcc:	9a07      	ldr	r2, [sp, #28]
   94fce:	f012 0320 	ands.w	r3, r2, #32
   94fd2:	f47f aebd 	bne.w	94d50 <_svfprintf_r+0x944>
   94fd6:	9907      	ldr	r1, [sp, #28]
   94fd8:	f011 0210 	ands.w	r2, r1, #16
   94fdc:	f000 8326 	beq.w	9562c <_svfprintf_r+0x1220>
   94fe0:	980e      	ldr	r0, [sp, #56]	; 0x38
   94fe2:	f1bb 0f00 	cmp.w	fp, #0
   94fe6:	4602      	mov	r2, r0
   94fe8:	6804      	ldr	r4, [r0, #0]
   94fea:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
   94fee:	f102 0204 	add.w	r2, r2, #4
   94ff2:	f04f 0500 	mov.w	r5, #0
   94ff6:	f2c0 848c 	blt.w	95912 <_svfprintf_r+0x1506>
   94ffa:	f021 0180 	bic.w	r1, r1, #128	; 0x80
   94ffe:	9107      	str	r1, [sp, #28]
   95000:	ea54 0105 	orrs.w	r1, r4, r5
   95004:	920e      	str	r2, [sp, #56]	; 0x38
   95006:	461f      	mov	r7, r3
   95008:	f47f aeb8 	bne.w	94d7c <_svfprintf_r+0x970>
   9500c:	f1bb 0f00 	cmp.w	fp, #0
   95010:	f000 8090 	beq.w	95134 <_svfprintf_r+0xd28>
   95014:	2400      	movs	r4, #0
   95016:	ae40      	add	r6, sp, #256	; 0x100
   95018:	3430      	adds	r4, #48	; 0x30
   9501a:	f806 4d41 	strb.w	r4, [r6, #-65]!
   9501e:	f7ff baf6 	b.w	9460e <_svfprintf_r+0x202>
   95022:	2a00      	cmp	r2, #0
   95024:	f040 8588 	bne.w	95b38 <_svfprintf_r+0x172c>
   95028:	9b07      	ldr	r3, [sp, #28]
   9502a:	069b      	lsls	r3, r3, #26
   9502c:	f140 82ca 	bpl.w	955c4 <_svfprintf_r+0x11b8>
   95030:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   95032:	4613      	mov	r3, r2
   95034:	3304      	adds	r3, #4
   95036:	930e      	str	r3, [sp, #56]	; 0x38
   95038:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   9503a:	6811      	ldr	r1, [r2, #0]
   9503c:	17dd      	asrs	r5, r3, #31
   9503e:	461a      	mov	r2, r3
   95040:	462b      	mov	r3, r5
   95042:	e9c1 2300 	strd	r2, r3, [r1]
   95046:	f7ff ba08 	b.w	9445a <_svfprintf_r+0x4e>
   9504a:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
   9504e:	2300      	movs	r3, #0
   95050:	461c      	mov	r4, r3
   95052:	f818 3b01 	ldrb.w	r3, [r8], #1
   95056:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   9505a:	eb00 0444 	add.w	r4, r0, r4, lsl #1
   9505e:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
   95062:	2809      	cmp	r0, #9
   95064:	d9f5      	bls.n	95052 <_svfprintf_r+0xc46>
   95066:	940c      	str	r4, [sp, #48]	; 0x30
   95068:	f7ff ba2c 	b.w	944c4 <_svfprintf_r+0xb8>
   9506c:	9311      	str	r3, [sp, #68]	; 0x44
   9506e:	46ab      	mov	fp, r5
   95070:	2a00      	cmp	r2, #0
   95072:	f040 855d 	bne.w	95b30 <_svfprintf_r+0x1724>
   95076:	9b07      	ldr	r3, [sp, #28]
   95078:	484c      	ldr	r0, [pc, #304]	; (951ac <_svfprintf_r+0xda0>)
   9507a:	069d      	lsls	r5, r3, #26
   9507c:	f53f aea3 	bmi.w	94dc6 <_svfprintf_r+0x9ba>
   95080:	9b07      	ldr	r3, [sp, #28]
   95082:	06dc      	lsls	r4, r3, #27
   95084:	f140 82b5 	bpl.w	955f2 <_svfprintf_r+0x11e6>
   95088:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   9508a:	2500      	movs	r5, #0
   9508c:	4613      	mov	r3, r2
   9508e:	3304      	adds	r3, #4
   95090:	6814      	ldr	r4, [r2, #0]
   95092:	930e      	str	r3, [sp, #56]	; 0x38
   95094:	e6a0      	b.n	94dd8 <_svfprintf_r+0x9cc>
   95096:	9311      	str	r3, [sp, #68]	; 0x44
   95098:	46ab      	mov	fp, r5
   9509a:	2a00      	cmp	r2, #0
   9509c:	f040 8544 	bne.w	95b28 <_svfprintf_r+0x171c>
   950a0:	9b07      	ldr	r3, [sp, #28]
   950a2:	f043 0310 	orr.w	r3, r3, #16
   950a6:	9307      	str	r3, [sp, #28]
   950a8:	9b07      	ldr	r3, [sp, #28]
   950aa:	0698      	lsls	r0, r3, #26
   950ac:	f140 80f1 	bpl.w	95292 <_svfprintf_r+0xe86>
   950b0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   950b2:	3407      	adds	r4, #7
   950b4:	f024 0407 	bic.w	r4, r4, #7
   950b8:	e9d4 2300 	ldrd	r2, r3, [r4]
   950bc:	f104 0108 	add.w	r1, r4, #8
   950c0:	461d      	mov	r5, r3
   950c2:	4614      	mov	r4, r2
   950c4:	910e      	str	r1, [sp, #56]	; 0x38
   950c6:	2a00      	cmp	r2, #0
   950c8:	f173 0300 	sbcs.w	r3, r3, #0
   950cc:	f2c0 80f2 	blt.w	952b4 <_svfprintf_r+0xea8>
   950d0:	f1bb 0f00 	cmp.w	fp, #0
   950d4:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
   950d8:	f2c0 810a 	blt.w	952f0 <_svfprintf_r+0xee4>
   950dc:	9b07      	ldr	r3, [sp, #28]
   950de:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   950e2:	9307      	str	r3, [sp, #28]
   950e4:	ea54 0305 	orrs.w	r3, r4, r5
   950e8:	f47f ae48 	bne.w	94d7c <_svfprintf_r+0x970>
   950ec:	e78e      	b.n	9500c <_svfprintf_r+0xc00>
   950ee:	9311      	str	r3, [sp, #68]	; 0x44
   950f0:	46ab      	mov	fp, r5
   950f2:	2a00      	cmp	r2, #0
   950f4:	d0d8      	beq.n	950a8 <_svfprintf_r+0xc9c>
   950f6:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   950fa:	e7d5      	b.n	950a8 <_svfprintf_r+0xc9c>
   950fc:	9b07      	ldr	r3, [sp, #28]
   950fe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   95102:	9307      	str	r3, [sp, #28]
   95104:	f898 3000 	ldrb.w	r3, [r8]
   95108:	f7ff b9da 	b.w	944c0 <_svfprintf_r+0xb4>
   9510c:	990e      	ldr	r1, [sp, #56]	; 0x38
   9510e:	9311      	str	r3, [sp, #68]	; 0x44
   95110:	680a      	ldr	r2, [r1, #0]
   95112:	2300      	movs	r3, #0
   95114:	2001      	movs	r0, #1
   95116:	461f      	mov	r7, r3
   95118:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
   9511c:	469b      	mov	fp, r3
   9511e:	9313      	str	r3, [sp, #76]	; 0x4c
   95120:	1d0b      	adds	r3, r1, #4
   95122:	9008      	str	r0, [sp, #32]
   95124:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
   95128:	930e      	str	r3, [sp, #56]	; 0x38
   9512a:	900d      	str	r0, [sp, #52]	; 0x34
   9512c:	ae26      	add	r6, sp, #152	; 0x98
   9512e:	f7ff ba7c 	b.w	9462a <_svfprintf_r+0x21e>
   95132:	465f      	mov	r7, fp
   95134:	f04f 0b00 	mov.w	fp, #0
   95138:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
   9513c:	ae30      	add	r6, sp, #192	; 0xc0
   9513e:	f7ff ba69 	b.w	94614 <_svfprintf_r+0x208>
   95142:	aa23      	add	r2, sp, #140	; 0x8c
   95144:	9909      	ldr	r1, [sp, #36]	; 0x24
   95146:	980a      	ldr	r0, [sp, #40]	; 0x28
   95148:	f003 fe08 	bl	98d5c <__ssprint_r>
   9514c:	2800      	cmp	r0, #0
   9514e:	f47f ab9b 	bne.w	94888 <_svfprintf_r+0x47c>
   95152:	9c25      	ldr	r4, [sp, #148]	; 0x94
   95154:	f7ff bb63 	b.w	9481e <_svfprintf_r+0x412>
   95158:	9311      	str	r3, [sp, #68]	; 0x44
   9515a:	2a00      	cmp	r2, #0
   9515c:	f040 84d3 	bne.w	95b06 <_svfprintf_r+0x16fa>
   95160:	9a11      	ldr	r2, [sp, #68]	; 0x44
   95162:	2a00      	cmp	r2, #0
   95164:	f43f ab89 	beq.w	9487a <_svfprintf_r+0x46e>
   95168:	2300      	movs	r3, #0
   9516a:	2101      	movs	r1, #1
   9516c:	461f      	mov	r7, r3
   9516e:	9108      	str	r1, [sp, #32]
   95170:	f88d 2098 	strb.w	r2, [sp, #152]	; 0x98
   95174:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
   95178:	469b      	mov	fp, r3
   9517a:	9313      	str	r3, [sp, #76]	; 0x4c
   9517c:	910d      	str	r1, [sp, #52]	; 0x34
   9517e:	ae26      	add	r6, sp, #152	; 0x98
   95180:	f7ff ba53 	b.w	9462a <_svfprintf_r+0x21e>
   95184:	aa23      	add	r2, sp, #140	; 0x8c
   95186:	9909      	ldr	r1, [sp, #36]	; 0x24
   95188:	980a      	ldr	r0, [sp, #40]	; 0x28
   9518a:	f003 fde7 	bl	98d5c <__ssprint_r>
   9518e:	2800      	cmp	r0, #0
   95190:	f47f ab7a 	bne.w	94888 <_svfprintf_r+0x47c>
   95194:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   95198:	9c25      	ldr	r4, [sp, #148]	; 0x94
   9519a:	f7ff bba2 	b.w	948e2 <_svfprintf_r+0x4d6>
   9519e:	bf00      	nop
   951a0:	7fefffff 	.word	0x7fefffff
   951a4:	0009b18c 	.word	0x0009b18c
   951a8:	0009b188 	.word	0x0009b188
   951ac:	0009b198 	.word	0x0009b198
   951b0:	9b24      	ldr	r3, [sp, #144]	; 0x90
   951b2:	49b8      	ldr	r1, [pc, #736]	; (95494 <_svfprintf_r+0x1088>)
   951b4:	3301      	adds	r3, #1
   951b6:	3401      	adds	r4, #1
   951b8:	2201      	movs	r2, #1
   951ba:	2b07      	cmp	r3, #7
   951bc:	9425      	str	r4, [sp, #148]	; 0x94
   951be:	9324      	str	r3, [sp, #144]	; 0x90
   951c0:	e889 0006 	stmia.w	r9, {r1, r2}
   951c4:	f300 82c2 	bgt.w	9574c <_svfprintf_r+0x1340>
   951c8:	f109 0908 	add.w	r9, r9, #8
   951cc:	b92d      	cbnz	r5, 951da <_svfprintf_r+0xdce>
   951ce:	9b12      	ldr	r3, [sp, #72]	; 0x48
   951d0:	b91b      	cbnz	r3, 951da <_svfprintf_r+0xdce>
   951d2:	9b07      	ldr	r3, [sp, #28]
   951d4:	07df      	lsls	r7, r3, #31
   951d6:	f57f aae8 	bpl.w	947aa <_svfprintf_r+0x39e>
   951da:	9b24      	ldr	r3, [sp, #144]	; 0x90
   951dc:	9916      	ldr	r1, [sp, #88]	; 0x58
   951de:	3301      	adds	r3, #1
   951e0:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   951e2:	440c      	add	r4, r1
   951e4:	2b07      	cmp	r3, #7
   951e6:	9425      	str	r4, [sp, #148]	; 0x94
   951e8:	f8c9 2000 	str.w	r2, [r9]
   951ec:	f8c9 1004 	str.w	r1, [r9, #4]
   951f0:	9324      	str	r3, [sp, #144]	; 0x90
   951f2:	f300 83ff 	bgt.w	959f4 <_svfprintf_r+0x15e8>
   951f6:	f109 0908 	add.w	r9, r9, #8
   951fa:	426d      	negs	r5, r5
   951fc:	2d00      	cmp	r5, #0
   951fe:	f340 82db 	ble.w	957b8 <_svfprintf_r+0x13ac>
   95202:	4aa5      	ldr	r2, [pc, #660]	; (95498 <_svfprintf_r+0x108c>)
   95204:	2d10      	cmp	r5, #16
   95206:	920f      	str	r2, [sp, #60]	; 0x3c
   95208:	f340 834b 	ble.w	958a2 <_svfprintf_r+0x1496>
   9520c:	4622      	mov	r2, r4
   9520e:	2710      	movs	r7, #16
   95210:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
   95214:	9c09      	ldr	r4, [sp, #36]	; 0x24
   95216:	e005      	b.n	95224 <_svfprintf_r+0xe18>
   95218:	f109 0908 	add.w	r9, r9, #8
   9521c:	3d10      	subs	r5, #16
   9521e:	2d10      	cmp	r5, #16
   95220:	f340 833e 	ble.w	958a0 <_svfprintf_r+0x1494>
   95224:	3301      	adds	r3, #1
   95226:	3210      	adds	r2, #16
   95228:	2b07      	cmp	r3, #7
   9522a:	9225      	str	r2, [sp, #148]	; 0x94
   9522c:	9324      	str	r3, [sp, #144]	; 0x90
   9522e:	f8c9 a000 	str.w	sl, [r9]
   95232:	f8c9 7004 	str.w	r7, [r9, #4]
   95236:	ddef      	ble.n	95218 <_svfprintf_r+0xe0c>
   95238:	aa23      	add	r2, sp, #140	; 0x8c
   9523a:	4621      	mov	r1, r4
   9523c:	4658      	mov	r0, fp
   9523e:	f003 fd8d 	bl	98d5c <__ssprint_r>
   95242:	2800      	cmp	r0, #0
   95244:	f47f ab20 	bne.w	94888 <_svfprintf_r+0x47c>
   95248:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   9524c:	9a25      	ldr	r2, [sp, #148]	; 0x94
   9524e:	9b24      	ldr	r3, [sp, #144]	; 0x90
   95250:	e7e4      	b.n	9521c <_svfprintf_r+0xe10>
   95252:	4892      	ldr	r0, [pc, #584]	; (9549c <_svfprintf_r+0x1090>)
   95254:	9107      	str	r1, [sp, #28]
   95256:	9311      	str	r3, [sp, #68]	; 0x44
   95258:	ea54 0305 	orrs.w	r3, r4, r5
   9525c:	920e      	str	r2, [sp, #56]	; 0x38
   9525e:	f04f 0700 	mov.w	r7, #0
   95262:	f47f a9c5 	bne.w	945f0 <_svfprintf_r+0x1e4>
   95266:	2400      	movs	r4, #0
   95268:	2500      	movs	r5, #0
   9526a:	f7ff b9c1 	b.w	945f0 <_svfprintf_r+0x1e4>
   9526e:	f1bb 0f00 	cmp.w	fp, #0
   95272:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
   95276:	f2c0 8203 	blt.w	95680 <_svfprintf_r+0x1274>
   9527a:	f022 0380 	bic.w	r3, r2, #128	; 0x80
   9527e:	9307      	str	r3, [sp, #28]
   95280:	ea54 0305 	orrs.w	r3, r4, r5
   95284:	f47f a9b4 	bne.w	945f0 <_svfprintf_r+0x1e4>
   95288:	f1bb 0f00 	cmp.w	fp, #0
   9528c:	f47f aae5 	bne.w	9485a <_svfprintf_r+0x44e>
   95290:	e74f      	b.n	95132 <_svfprintf_r+0xd26>
   95292:	9b07      	ldr	r3, [sp, #28]
   95294:	06d9      	lsls	r1, r3, #27
   95296:	f140 81ba 	bpl.w	9560e <_svfprintf_r+0x1202>
   9529a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   9529c:	4613      	mov	r3, r2
   9529e:	681c      	ldr	r4, [r3, #0]
   952a0:	3304      	adds	r3, #4
   952a2:	17e5      	asrs	r5, r4, #31
   952a4:	4622      	mov	r2, r4
   952a6:	930e      	str	r3, [sp, #56]	; 0x38
   952a8:	462b      	mov	r3, r5
   952aa:	2a00      	cmp	r2, #0
   952ac:	f173 0300 	sbcs.w	r3, r3, #0
   952b0:	f6bf af0e 	bge.w	950d0 <_svfprintf_r+0xcc4>
   952b4:	4264      	negs	r4, r4
   952b6:	f04f 072d 	mov.w	r7, #45	; 0x2d
   952ba:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
   952be:	f1bb 0f00 	cmp.w	fp, #0
   952c2:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
   952c6:	f6ff ad59 	blt.w	94d7c <_svfprintf_r+0x970>
   952ca:	9b07      	ldr	r3, [sp, #28]
   952cc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   952d0:	9307      	str	r3, [sp, #28]
   952d2:	e553      	b.n	94d7c <_svfprintf_r+0x970>
   952d4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   952d6:	f1bb 0f00 	cmp.w	fp, #0
   952da:	4613      	mov	r3, r2
   952dc:	6814      	ldr	r4, [r2, #0]
   952de:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
   952e2:	f103 0304 	add.w	r3, r3, #4
   952e6:	f04f 0500 	mov.w	r5, #0
   952ea:	f280 81e2 	bge.w	956b2 <_svfprintf_r+0x12a6>
   952ee:	930e      	str	r3, [sp, #56]	; 0x38
   952f0:	ea54 0305 	orrs.w	r3, r4, r5
   952f4:	f47f ad42 	bne.w	94d7c <_svfprintf_r+0x970>
   952f8:	e68d      	b.n	95016 <_svfprintf_r+0xc0a>
   952fa:	aa23      	add	r2, sp, #140	; 0x8c
   952fc:	9909      	ldr	r1, [sp, #36]	; 0x24
   952fe:	980a      	ldr	r0, [sp, #40]	; 0x28
   95300:	f003 fd2c 	bl	98d5c <__ssprint_r>
   95304:	2800      	cmp	r0, #0
   95306:	f47f aabf 	bne.w	94888 <_svfprintf_r+0x47c>
   9530a:	9c25      	ldr	r4, [sp, #148]	; 0x94
   9530c:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   95310:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   95312:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   95314:	4432      	add	r2, r6
   95316:	4617      	mov	r7, r2
   95318:	9a12      	ldr	r2, [sp, #72]	; 0x48
   9531a:	4293      	cmp	r3, r2
   9531c:	db49      	blt.n	953b2 <_svfprintf_r+0xfa6>
   9531e:	9a07      	ldr	r2, [sp, #28]
   95320:	07d5      	lsls	r5, r2, #31
   95322:	d446      	bmi.n	953b2 <_svfprintf_r+0xfa6>
   95324:	9912      	ldr	r1, [sp, #72]	; 0x48
   95326:	440e      	add	r6, r1
   95328:	1bf5      	subs	r5, r6, r7
   9532a:	1acb      	subs	r3, r1, r3
   9532c:	429d      	cmp	r5, r3
   9532e:	bfa8      	it	ge
   95330:	461d      	movge	r5, r3
   95332:	2d00      	cmp	r5, #0
   95334:	462e      	mov	r6, r5
   95336:	dd0d      	ble.n	95354 <_svfprintf_r+0xf48>
   95338:	9a24      	ldr	r2, [sp, #144]	; 0x90
   9533a:	442c      	add	r4, r5
   9533c:	3201      	adds	r2, #1
   9533e:	2a07      	cmp	r2, #7
   95340:	9425      	str	r4, [sp, #148]	; 0x94
   95342:	f8c9 7000 	str.w	r7, [r9]
   95346:	f8c9 5004 	str.w	r5, [r9, #4]
   9534a:	9224      	str	r2, [sp, #144]	; 0x90
   9534c:	f300 82d2 	bgt.w	958f4 <_svfprintf_r+0x14e8>
   95350:	f109 0908 	add.w	r9, r9, #8
   95354:	2e00      	cmp	r6, #0
   95356:	bfb4      	ite	lt
   95358:	461d      	movlt	r5, r3
   9535a:	1b9d      	subge	r5, r3, r6
   9535c:	2d00      	cmp	r5, #0
   9535e:	f77f aa24 	ble.w	947aa <_svfprintf_r+0x39e>
   95362:	4a4d      	ldr	r2, [pc, #308]	; (95498 <_svfprintf_r+0x108c>)
   95364:	2d10      	cmp	r5, #16
   95366:	9b24      	ldr	r3, [sp, #144]	; 0x90
   95368:	920f      	str	r2, [sp, #60]	; 0x3c
   9536a:	f77f abf4 	ble.w	94b56 <_svfprintf_r+0x74a>
   9536e:	2610      	movs	r6, #16
   95370:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   95372:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
   95376:	e005      	b.n	95384 <_svfprintf_r+0xf78>
   95378:	f109 0908 	add.w	r9, r9, #8
   9537c:	3d10      	subs	r5, #16
   9537e:	2d10      	cmp	r5, #16
   95380:	f77f abe9 	ble.w	94b56 <_svfprintf_r+0x74a>
   95384:	3301      	adds	r3, #1
   95386:	3410      	adds	r4, #16
   95388:	2b07      	cmp	r3, #7
   9538a:	9425      	str	r4, [sp, #148]	; 0x94
   9538c:	9324      	str	r3, [sp, #144]	; 0x90
   9538e:	f8c9 a000 	str.w	sl, [r9]
   95392:	f8c9 6004 	str.w	r6, [r9, #4]
   95396:	ddef      	ble.n	95378 <_svfprintf_r+0xf6c>
   95398:	aa23      	add	r2, sp, #140	; 0x8c
   9539a:	4659      	mov	r1, fp
   9539c:	4638      	mov	r0, r7
   9539e:	f003 fcdd 	bl	98d5c <__ssprint_r>
   953a2:	2800      	cmp	r0, #0
   953a4:	f47f aa70 	bne.w	94888 <_svfprintf_r+0x47c>
   953a8:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   953ac:	9c25      	ldr	r4, [sp, #148]	; 0x94
   953ae:	9b24      	ldr	r3, [sp, #144]	; 0x90
   953b0:	e7e4      	b.n	9537c <_svfprintf_r+0xf70>
   953b2:	9a24      	ldr	r2, [sp, #144]	; 0x90
   953b4:	9816      	ldr	r0, [sp, #88]	; 0x58
   953b6:	3201      	adds	r2, #1
   953b8:	9917      	ldr	r1, [sp, #92]	; 0x5c
   953ba:	4404      	add	r4, r0
   953bc:	2a07      	cmp	r2, #7
   953be:	9425      	str	r4, [sp, #148]	; 0x94
   953c0:	f8c9 1000 	str.w	r1, [r9]
   953c4:	f8c9 0004 	str.w	r0, [r9, #4]
   953c8:	9224      	str	r2, [sp, #144]	; 0x90
   953ca:	f300 8277 	bgt.w	958bc <_svfprintf_r+0x14b0>
   953ce:	f109 0908 	add.w	r9, r9, #8
   953d2:	e7a7      	b.n	95324 <_svfprintf_r+0xf18>
   953d4:	9b07      	ldr	r3, [sp, #28]
   953d6:	07d8      	lsls	r0, r3, #31
   953d8:	f53f ab14 	bmi.w	94a04 <_svfprintf_r+0x5f8>
   953dc:	2301      	movs	r3, #1
   953de:	2d07      	cmp	r5, #7
   953e0:	9425      	str	r4, [sp, #148]	; 0x94
   953e2:	f8c9 6000 	str.w	r6, [r9]
   953e6:	9524      	str	r5, [sp, #144]	; 0x90
   953e8:	f8c9 3004 	str.w	r3, [r9, #4]
   953ec:	f77f ac26 	ble.w	94c3c <_svfprintf_r+0x830>
   953f0:	aa23      	add	r2, sp, #140	; 0x8c
   953f2:	9909      	ldr	r1, [sp, #36]	; 0x24
   953f4:	980a      	ldr	r0, [sp, #40]	; 0x28
   953f6:	f003 fcb1 	bl	98d5c <__ssprint_r>
   953fa:	2800      	cmp	r0, #0
   953fc:	f47f aa44 	bne.w	94888 <_svfprintf_r+0x47c>
   95400:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   95404:	9c25      	ldr	r4, [sp, #148]	; 0x94
   95406:	9d24      	ldr	r5, [sp, #144]	; 0x90
   95408:	e41a      	b.n	94c40 <_svfprintf_r+0x834>
   9540a:	aa23      	add	r2, sp, #140	; 0x8c
   9540c:	9909      	ldr	r1, [sp, #36]	; 0x24
   9540e:	980a      	ldr	r0, [sp, #40]	; 0x28
   95410:	f003 fca4 	bl	98d5c <__ssprint_r>
   95414:	2800      	cmp	r0, #0
   95416:	f47f aa37 	bne.w	94888 <_svfprintf_r+0x47c>
   9541a:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   9541e:	9c25      	ldr	r4, [sp, #148]	; 0x94
   95420:	9d24      	ldr	r5, [sp, #144]	; 0x90
   95422:	f7ff bafb 	b.w	94a1c <_svfprintf_r+0x610>
   95426:	aa23      	add	r2, sp, #140	; 0x8c
   95428:	9909      	ldr	r1, [sp, #36]	; 0x24
   9542a:	980a      	ldr	r0, [sp, #40]	; 0x28
   9542c:	f003 fc96 	bl	98d5c <__ssprint_r>
   95430:	2800      	cmp	r0, #0
   95432:	f47f aa29 	bne.w	94888 <_svfprintf_r+0x47c>
   95436:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   9543a:	9c25      	ldr	r4, [sp, #148]	; 0x94
   9543c:	9d24      	ldr	r5, [sp, #144]	; 0x90
   9543e:	f7ff bafc 	b.w	94a3a <_svfprintf_r+0x62e>
   95442:	aa23      	add	r2, sp, #140	; 0x8c
   95444:	9909      	ldr	r1, [sp, #36]	; 0x24
   95446:	980a      	ldr	r0, [sp, #40]	; 0x28
   95448:	f003 fc88 	bl	98d5c <__ssprint_r>
   9544c:	2800      	cmp	r0, #0
   9544e:	f47f aa1b 	bne.w	94888 <_svfprintf_r+0x47c>
   95452:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   95456:	9c25      	ldr	r4, [sp, #148]	; 0x94
   95458:	f7ff b95b 	b.w	94712 <_svfprintf_r+0x306>
   9545c:	9907      	ldr	r1, [sp, #28]
   9545e:	f011 0740 	ands.w	r7, r1, #64	; 0x40
   95462:	f000 810f 	beq.w	95684 <_svfprintf_r+0x1278>
   95466:	980e      	ldr	r0, [sp, #56]	; 0x38
   95468:	f1bb 0f00 	cmp.w	fp, #0
   9546c:	4603      	mov	r3, r0
   9546e:	8804      	ldrh	r4, [r0, #0]
   95470:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
   95474:	f103 0304 	add.w	r3, r3, #4
   95478:	f04f 0500 	mov.w	r5, #0
   9547c:	f2c0 8173 	blt.w	95766 <_svfprintf_r+0x135a>
   95480:	f021 0180 	bic.w	r1, r1, #128	; 0x80
   95484:	9107      	str	r1, [sp, #28]
   95486:	ea54 0105 	orrs.w	r1, r4, r5
   9548a:	930e      	str	r3, [sp, #56]	; 0x38
   9548c:	f43f aced 	beq.w	94e6a <_svfprintf_r+0xa5e>
   95490:	4617      	mov	r7, r2
   95492:	e4f1      	b.n	94e78 <_svfprintf_r+0xa6c>
   95494:	0009b1c8 	.word	0x0009b1c8
   95498:	0009b178 	.word	0x0009b178
   9549c:	0009b1ac 	.word	0x0009b1ac
   954a0:	9c14      	ldr	r4, [sp, #80]	; 0x50
   954a2:	4622      	mov	r2, r4
   954a4:	4620      	mov	r0, r4
   954a6:	9c15      	ldr	r4, [sp, #84]	; 0x54
   954a8:	4623      	mov	r3, r4
   954aa:	4621      	mov	r1, r4
   954ac:	f7fd fc00 	bl	92cb0 <__aeabi_dcmpun>
   954b0:	2800      	cmp	r0, #0
   954b2:	f040 82c1 	bne.w	95a38 <_svfprintf_r+0x162c>
   954b6:	9b11      	ldr	r3, [sp, #68]	; 0x44
   954b8:	f1bb 3fff 	cmp.w	fp, #4294967295
   954bc:	f023 0320 	bic.w	r3, r3, #32
   954c0:	930d      	str	r3, [sp, #52]	; 0x34
   954c2:	f000 8249 	beq.w	95958 <_svfprintf_r+0x154c>
   954c6:	2b47      	cmp	r3, #71	; 0x47
   954c8:	f000 8150 	beq.w	9576c <_svfprintf_r+0x1360>
   954cc:	9b07      	ldr	r3, [sp, #28]
   954ce:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   954d2:	9310      	str	r3, [sp, #64]	; 0x40
   954d4:	9b15      	ldr	r3, [sp, #84]	; 0x54
   954d6:	1e1f      	subs	r7, r3, #0
   954d8:	9b14      	ldr	r3, [sp, #80]	; 0x50
   954da:	9308      	str	r3, [sp, #32]
   954dc:	bfb7      	itett	lt
   954de:	463b      	movlt	r3, r7
   954e0:	2300      	movge	r3, #0
   954e2:	f103 4700 	addlt.w	r7, r3, #2147483648	; 0x80000000
   954e6:	232d      	movlt	r3, #45	; 0x2d
   954e8:	930f      	str	r3, [sp, #60]	; 0x3c
   954ea:	9b11      	ldr	r3, [sp, #68]	; 0x44
   954ec:	2b66      	cmp	r3, #102	; 0x66
   954ee:	f000 821f 	beq.w	95930 <_svfprintf_r+0x1524>
   954f2:	2b46      	cmp	r3, #70	; 0x46
   954f4:	f000 810d 	beq.w	95712 <_svfprintf_r+0x1306>
   954f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   954fa:	a821      	add	r0, sp, #132	; 0x84
   954fc:	2b45      	cmp	r3, #69	; 0x45
   954fe:	bf18      	it	ne
   95500:	465d      	movne	r5, fp
   95502:	a91e      	add	r1, sp, #120	; 0x78
   95504:	bf08      	it	eq
   95506:	f10b 0501 	addeq.w	r5, fp, #1
   9550a:	9004      	str	r0, [sp, #16]
   9550c:	9103      	str	r1, [sp, #12]
   9550e:	a81d      	add	r0, sp, #116	; 0x74
   95510:	2102      	movs	r1, #2
   95512:	463b      	mov	r3, r7
   95514:	9002      	str	r0, [sp, #8]
   95516:	9a08      	ldr	r2, [sp, #32]
   95518:	9501      	str	r5, [sp, #4]
   9551a:	9100      	str	r1, [sp, #0]
   9551c:	980a      	ldr	r0, [sp, #40]	; 0x28
   9551e:	f001 fbf7 	bl	96d10 <_dtoa_r>
   95522:	9b11      	ldr	r3, [sp, #68]	; 0x44
   95524:	4606      	mov	r6, r0
   95526:	2b67      	cmp	r3, #103	; 0x67
   95528:	f040 8234 	bne.w	95994 <_svfprintf_r+0x1588>
   9552c:	9b07      	ldr	r3, [sp, #28]
   9552e:	07da      	lsls	r2, r3, #31
   95530:	f140 826f 	bpl.w	95a12 <_svfprintf_r+0x1606>
   95534:	1974      	adds	r4, r6, r5
   95536:	9808      	ldr	r0, [sp, #32]
   95538:	4639      	mov	r1, r7
   9553a:	2200      	movs	r2, #0
   9553c:	2300      	movs	r3, #0
   9553e:	f7fd fb85 	bl	92c4c <__aeabi_dcmpeq>
   95542:	2800      	cmp	r0, #0
   95544:	f040 814d 	bne.w	957e2 <_svfprintf_r+0x13d6>
   95548:	9b21      	ldr	r3, [sp, #132]	; 0x84
   9554a:	429c      	cmp	r4, r3
   9554c:	d906      	bls.n	9555c <_svfprintf_r+0x1150>
   9554e:	2130      	movs	r1, #48	; 0x30
   95550:	1c5a      	adds	r2, r3, #1
   95552:	9221      	str	r2, [sp, #132]	; 0x84
   95554:	7019      	strb	r1, [r3, #0]
   95556:	9b21      	ldr	r3, [sp, #132]	; 0x84
   95558:	429c      	cmp	r4, r3
   9555a:	d8f9      	bhi.n	95550 <_svfprintf_r+0x1144>
   9555c:	1b9b      	subs	r3, r3, r6
   9555e:	9312      	str	r3, [sp, #72]	; 0x48
   95560:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   95562:	2b47      	cmp	r3, #71	; 0x47
   95564:	f000 8136 	beq.w	957d4 <_svfprintf_r+0x13c8>
   95568:	9b11      	ldr	r3, [sp, #68]	; 0x44
   9556a:	2b65      	cmp	r3, #101	; 0x65
   9556c:	f340 8221 	ble.w	959b2 <_svfprintf_r+0x15a6>
   95570:	9b11      	ldr	r3, [sp, #68]	; 0x44
   95572:	2b66      	cmp	r3, #102	; 0x66
   95574:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   95576:	9313      	str	r3, [sp, #76]	; 0x4c
   95578:	f000 81fe 	beq.w	95978 <_svfprintf_r+0x156c>
   9557c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   9557e:	9912      	ldr	r1, [sp, #72]	; 0x48
   95580:	428a      	cmp	r2, r1
   95582:	f2c0 81ec 	blt.w	9595e <_svfprintf_r+0x1552>
   95586:	9b07      	ldr	r3, [sp, #28]
   95588:	07d9      	lsls	r1, r3, #31
   9558a:	f100 8244 	bmi.w	95a16 <_svfprintf_r+0x160a>
   9558e:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
   95592:	920d      	str	r2, [sp, #52]	; 0x34
   95594:	2267      	movs	r2, #103	; 0x67
   95596:	9211      	str	r2, [sp, #68]	; 0x44
   95598:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   9559a:	2a00      	cmp	r2, #0
   9559c:	f040 80ef 	bne.w	9577e <_svfprintf_r+0x1372>
   955a0:	9308      	str	r3, [sp, #32]
   955a2:	9b10      	ldr	r3, [sp, #64]	; 0x40
   955a4:	4693      	mov	fp, r2
   955a6:	9307      	str	r3, [sp, #28]
   955a8:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
   955ac:	f7ff b839 	b.w	94622 <_svfprintf_r+0x216>
   955b0:	f024 0407 	bic.w	r4, r4, #7
   955b4:	6823      	ldr	r3, [r4, #0]
   955b6:	9314      	str	r3, [sp, #80]	; 0x50
   955b8:	6863      	ldr	r3, [r4, #4]
   955ba:	9315      	str	r3, [sp, #84]	; 0x54
   955bc:	f104 0308 	add.w	r3, r4, #8
   955c0:	930e      	str	r3, [sp, #56]	; 0x38
   955c2:	e492      	b.n	94eea <_svfprintf_r+0xade>
   955c4:	9b07      	ldr	r3, [sp, #28]
   955c6:	06df      	lsls	r7, r3, #27
   955c8:	d40b      	bmi.n	955e2 <_svfprintf_r+0x11d6>
   955ca:	9b07      	ldr	r3, [sp, #28]
   955cc:	065e      	lsls	r6, r3, #25
   955ce:	d508      	bpl.n	955e2 <_svfprintf_r+0x11d6>
   955d0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   955d2:	6813      	ldr	r3, [r2, #0]
   955d4:	3204      	adds	r2, #4
   955d6:	920e      	str	r2, [sp, #56]	; 0x38
   955d8:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
   955dc:	801a      	strh	r2, [r3, #0]
   955de:	f7fe bf3c 	b.w	9445a <_svfprintf_r+0x4e>
   955e2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   955e4:	6813      	ldr	r3, [r2, #0]
   955e6:	3204      	adds	r2, #4
   955e8:	920e      	str	r2, [sp, #56]	; 0x38
   955ea:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   955ec:	601a      	str	r2, [r3, #0]
   955ee:	f7fe bf34 	b.w	9445a <_svfprintf_r+0x4e>
   955f2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   955f4:	9b07      	ldr	r3, [sp, #28]
   955f6:	2500      	movs	r5, #0
   955f8:	f013 0f40 	tst.w	r3, #64	; 0x40
   955fc:	4613      	mov	r3, r2
   955fe:	f103 0304 	add.w	r3, r3, #4
   95602:	bf0c      	ite	eq
   95604:	6814      	ldreq	r4, [r2, #0]
   95606:	8814      	ldrhne	r4, [r2, #0]
   95608:	930e      	str	r3, [sp, #56]	; 0x38
   9560a:	f7ff bbe5 	b.w	94dd8 <_svfprintf_r+0x9cc>
   9560e:	9b07      	ldr	r3, [sp, #28]
   95610:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   95612:	f013 0f40 	tst.w	r3, #64	; 0x40
   95616:	4613      	mov	r3, r2
   95618:	f43f ae41 	beq.w	9529e <_svfprintf_r+0xe92>
   9561c:	f9b2 4000 	ldrsh.w	r4, [r2]
   95620:	3304      	adds	r3, #4
   95622:	17e5      	asrs	r5, r4, #31
   95624:	930e      	str	r3, [sp, #56]	; 0x38
   95626:	4622      	mov	r2, r4
   95628:	462b      	mov	r3, r5
   9562a:	e54c      	b.n	950c6 <_svfprintf_r+0xcba>
   9562c:	9907      	ldr	r1, [sp, #28]
   9562e:	f011 0740 	ands.w	r7, r1, #64	; 0x40
   95632:	f43f ae4f 	beq.w	952d4 <_svfprintf_r+0xec8>
   95636:	980e      	ldr	r0, [sp, #56]	; 0x38
   95638:	f1bb 0f00 	cmp.w	fp, #0
   9563c:	4603      	mov	r3, r0
   9563e:	8804      	ldrh	r4, [r0, #0]
   95640:	f88d 206f 	strb.w	r2, [sp, #111]	; 0x6f
   95644:	f103 0304 	add.w	r3, r3, #4
   95648:	f04f 0500 	mov.w	r5, #0
   9564c:	f2c0 8094 	blt.w	95778 <_svfprintf_r+0x136c>
   95650:	f021 0180 	bic.w	r1, r1, #128	; 0x80
   95654:	9107      	str	r1, [sp, #28]
   95656:	ea54 0105 	orrs.w	r1, r4, r5
   9565a:	930e      	str	r3, [sp, #56]	; 0x38
   9565c:	4617      	mov	r7, r2
   9565e:	f47f ab8d 	bne.w	94d7c <_svfprintf_r+0x970>
   95662:	e4d3      	b.n	9500c <_svfprintf_r+0xc00>
   95664:	4614      	mov	r4, r2
   95666:	3301      	adds	r3, #1
   95668:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   9566a:	442c      	add	r4, r5
   9566c:	2b07      	cmp	r3, #7
   9566e:	9425      	str	r4, [sp, #148]	; 0x94
   95670:	9324      	str	r3, [sp, #144]	; 0x90
   95672:	e889 0024 	stmia.w	r9, {r2, r5}
   95676:	f73f ae40 	bgt.w	952fa <_svfprintf_r+0xeee>
   9567a:	f109 0908 	add.w	r9, r9, #8
   9567e:	e647      	b.n	95310 <_svfprintf_r+0xf04>
   95680:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   95682:	e5e9      	b.n	95258 <_svfprintf_r+0xe4c>
   95684:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   95686:	f1bb 0f00 	cmp.w	fp, #0
   9568a:	4613      	mov	r3, r2
   9568c:	6814      	ldr	r4, [r2, #0]
   9568e:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
   95692:	f103 0304 	add.w	r3, r3, #4
   95696:	f04f 0500 	mov.w	r5, #0
   9569a:	db64      	blt.n	95766 <_svfprintf_r+0x135a>
   9569c:	9a07      	ldr	r2, [sp, #28]
   9569e:	930e      	str	r3, [sp, #56]	; 0x38
   956a0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   956a4:	9207      	str	r2, [sp, #28]
   956a6:	ea54 0205 	orrs.w	r2, r4, r5
   956aa:	f47f abe5 	bne.w	94e78 <_svfprintf_r+0xa6c>
   956ae:	f7ff bbdc 	b.w	94e6a <_svfprintf_r+0xa5e>
   956b2:	9a07      	ldr	r2, [sp, #28]
   956b4:	930e      	str	r3, [sp, #56]	; 0x38
   956b6:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   956ba:	9207      	str	r2, [sp, #28]
   956bc:	ea54 0205 	orrs.w	r2, r4, r5
   956c0:	f47f ab5c 	bne.w	94d7c <_svfprintf_r+0x970>
   956c4:	e4a2      	b.n	9500c <_svfprintf_r+0xc00>
   956c6:	9b07      	ldr	r3, [sp, #28]
   956c8:	f108 0801 	add.w	r8, r8, #1
   956cc:	f043 0320 	orr.w	r3, r3, #32
   956d0:	9307      	str	r3, [sp, #28]
   956d2:	f898 3000 	ldrb.w	r3, [r8]
   956d6:	f7fe bef3 	b.w	944c0 <_svfprintf_r+0xb4>
   956da:	aa23      	add	r2, sp, #140	; 0x8c
   956dc:	9909      	ldr	r1, [sp, #36]	; 0x24
   956de:	980a      	ldr	r0, [sp, #40]	; 0x28
   956e0:	f003 fb3c 	bl	98d5c <__ssprint_r>
   956e4:	2800      	cmp	r0, #0
   956e6:	f47f a8cf 	bne.w	94888 <_svfprintf_r+0x47c>
   956ea:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   956ee:	9c25      	ldr	r4, [sp, #148]	; 0x94
   956f0:	f7ff b90f 	b.w	94912 <_svfprintf_r+0x506>
   956f4:	2140      	movs	r1, #64	; 0x40
   956f6:	980a      	ldr	r0, [sp, #40]	; 0x28
   956f8:	f7fd ff2c 	bl	93554 <_malloc_r>
   956fc:	9a09      	ldr	r2, [sp, #36]	; 0x24
   956fe:	6010      	str	r0, [r2, #0]
   95700:	6110      	str	r0, [r2, #16]
   95702:	2800      	cmp	r0, #0
   95704:	f000 81f5 	beq.w	95af2 <_svfprintf_r+0x16e6>
   95708:	9a09      	ldr	r2, [sp, #36]	; 0x24
   9570a:	2340      	movs	r3, #64	; 0x40
   9570c:	6153      	str	r3, [r2, #20]
   9570e:	f7fe be94 	b.w	9443a <_svfprintf_r+0x2e>
   95712:	a821      	add	r0, sp, #132	; 0x84
   95714:	a91e      	add	r1, sp, #120	; 0x78
   95716:	9004      	str	r0, [sp, #16]
   95718:	9103      	str	r1, [sp, #12]
   9571a:	a81d      	add	r0, sp, #116	; 0x74
   9571c:	2103      	movs	r1, #3
   9571e:	9002      	str	r0, [sp, #8]
   95720:	9a08      	ldr	r2, [sp, #32]
   95722:	463b      	mov	r3, r7
   95724:	f8cd b004 	str.w	fp, [sp, #4]
   95728:	9100      	str	r1, [sp, #0]
   9572a:	980a      	ldr	r0, [sp, #40]	; 0x28
   9572c:	f001 faf0 	bl	96d10 <_dtoa_r>
   95730:	465d      	mov	r5, fp
   95732:	4606      	mov	r6, r0
   95734:	9b11      	ldr	r3, [sp, #68]	; 0x44
   95736:	1974      	adds	r4, r6, r5
   95738:	2b46      	cmp	r3, #70	; 0x46
   9573a:	f47f aefc 	bne.w	95536 <_svfprintf_r+0x112a>
   9573e:	7833      	ldrb	r3, [r6, #0]
   95740:	2b30      	cmp	r3, #48	; 0x30
   95742:	f000 8197 	beq.w	95a74 <_svfprintf_r+0x1668>
   95746:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   95748:	442c      	add	r4, r5
   9574a:	e6f4      	b.n	95536 <_svfprintf_r+0x112a>
   9574c:	aa23      	add	r2, sp, #140	; 0x8c
   9574e:	9909      	ldr	r1, [sp, #36]	; 0x24
   95750:	980a      	ldr	r0, [sp, #40]	; 0x28
   95752:	f003 fb03 	bl	98d5c <__ssprint_r>
   95756:	2800      	cmp	r0, #0
   95758:	f47f a896 	bne.w	94888 <_svfprintf_r+0x47c>
   9575c:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   95760:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   95762:	9c25      	ldr	r4, [sp, #148]	; 0x94
   95764:	e532      	b.n	951cc <_svfprintf_r+0xdc0>
   95766:	930e      	str	r3, [sp, #56]	; 0x38
   95768:	f7ff bb85 	b.w	94e76 <_svfprintf_r+0xa6a>
   9576c:	f1bb 0f00 	cmp.w	fp, #0
   95770:	bf08      	it	eq
   95772:	f04f 0b01 	moveq.w	fp, #1
   95776:	e6a9      	b.n	954cc <_svfprintf_r+0x10c0>
   95778:	930e      	str	r3, [sp, #56]	; 0x38
   9577a:	4617      	mov	r7, r2
   9577c:	e5b8      	b.n	952f0 <_svfprintf_r+0xee4>
   9577e:	9308      	str	r3, [sp, #32]
   95780:	9b10      	ldr	r3, [sp, #64]	; 0x40
   95782:	272d      	movs	r7, #45	; 0x2d
   95784:	9307      	str	r3, [sp, #28]
   95786:	f88d 706f 	strb.w	r7, [sp, #111]	; 0x6f
   9578a:	f04f 0b00 	mov.w	fp, #0
   9578e:	f7fe bf49 	b.w	94624 <_svfprintf_r+0x218>
   95792:	4630      	mov	r0, r6
   95794:	f7fe fdd8 	bl	94348 <strlen>
   95798:	46ab      	mov	fp, r5
   9579a:	4603      	mov	r3, r0
   9579c:	f7ff bac4 	b.w	94d28 <_svfprintf_r+0x91c>
   957a0:	aa23      	add	r2, sp, #140	; 0x8c
   957a2:	9909      	ldr	r1, [sp, #36]	; 0x24
   957a4:	980a      	ldr	r0, [sp, #40]	; 0x28
   957a6:	f003 fad9 	bl	98d5c <__ssprint_r>
   957aa:	2800      	cmp	r0, #0
   957ac:	f47f a86c 	bne.w	94888 <_svfprintf_r+0x47c>
   957b0:	9c25      	ldr	r4, [sp, #148]	; 0x94
   957b2:	9b24      	ldr	r3, [sp, #144]	; 0x90
   957b4:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   957b8:	9912      	ldr	r1, [sp, #72]	; 0x48
   957ba:	3301      	adds	r3, #1
   957bc:	440c      	add	r4, r1
   957be:	2b07      	cmp	r3, #7
   957c0:	9425      	str	r4, [sp, #148]	; 0x94
   957c2:	9324      	str	r3, [sp, #144]	; 0x90
   957c4:	f8c9 6000 	str.w	r6, [r9]
   957c8:	f8c9 1004 	str.w	r1, [r9, #4]
   957cc:	f77e afeb 	ble.w	947a6 <_svfprintf_r+0x39a>
   957d0:	f7ff b9cb 	b.w	94b6a <_svfprintf_r+0x75e>
   957d4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   957d6:	1cdd      	adds	r5, r3, #3
   957d8:	db12      	blt.n	95800 <_svfprintf_r+0x13f4>
   957da:	459b      	cmp	fp, r3
   957dc:	db10      	blt.n	95800 <_svfprintf_r+0x13f4>
   957de:	9313      	str	r3, [sp, #76]	; 0x4c
   957e0:	e6cc      	b.n	9557c <_svfprintf_r+0x1170>
   957e2:	4623      	mov	r3, r4
   957e4:	e6ba      	b.n	9555c <_svfprintf_r+0x1150>
   957e6:	aa23      	add	r2, sp, #140	; 0x8c
   957e8:	9909      	ldr	r1, [sp, #36]	; 0x24
   957ea:	980a      	ldr	r0, [sp, #40]	; 0x28
   957ec:	f003 fab6 	bl	98d5c <__ssprint_r>
   957f0:	2800      	cmp	r0, #0
   957f2:	f47f a849 	bne.w	94888 <_svfprintf_r+0x47c>
   957f6:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   957fa:	9c25      	ldr	r4, [sp, #148]	; 0x94
   957fc:	f7ff b9e0 	b.w	94bc0 <_svfprintf_r+0x7b4>
   95800:	9a11      	ldr	r2, [sp, #68]	; 0x44
   95802:	3a02      	subs	r2, #2
   95804:	9211      	str	r2, [sp, #68]	; 0x44
   95806:	3b01      	subs	r3, #1
   95808:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
   9580c:	2b00      	cmp	r3, #0
   9580e:	931d      	str	r3, [sp, #116]	; 0x74
   95810:	bfb8      	it	lt
   95812:	425b      	neglt	r3, r3
   95814:	f88d 207c 	strb.w	r2, [sp, #124]	; 0x7c
   95818:	bfb4      	ite	lt
   9581a:	222d      	movlt	r2, #45	; 0x2d
   9581c:	222b      	movge	r2, #43	; 0x2b
   9581e:	2b09      	cmp	r3, #9
   95820:	f88d 207d 	strb.w	r2, [sp, #125]	; 0x7d
   95824:	f340 8100 	ble.w	95a28 <_svfprintf_r+0x161c>
   95828:	f10d 008b 	add.w	r0, sp, #139	; 0x8b
   9582c:	4604      	mov	r4, r0
   9582e:	4ab8      	ldr	r2, [pc, #736]	; (95b10 <_svfprintf_r+0x1704>)
   95830:	fb82 2103 	smull	r2, r1, r2, r3
   95834:	17da      	asrs	r2, r3, #31
   95836:	ebc2 01a1 	rsb	r1, r2, r1, asr #2
   9583a:	eb01 0281 	add.w	r2, r1, r1, lsl #2
   9583e:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
   95842:	3230      	adds	r2, #48	; 0x30
   95844:	2909      	cmp	r1, #9
   95846:	460b      	mov	r3, r1
   95848:	f804 2d01 	strb.w	r2, [r4, #-1]!
   9584c:	dcef      	bgt.n	9582e <_svfprintf_r+0x1422>
   9584e:	4621      	mov	r1, r4
   95850:	3330      	adds	r3, #48	; 0x30
   95852:	b2da      	uxtb	r2, r3
   95854:	f801 2d01 	strb.w	r2, [r1, #-1]!
   95858:	4288      	cmp	r0, r1
   9585a:	f240 8151 	bls.w	95b00 <_svfprintf_r+0x16f4>
   9585e:	f10d 017e 	add.w	r1, sp, #126	; 0x7e
   95862:	4623      	mov	r3, r4
   95864:	e001      	b.n	9586a <_svfprintf_r+0x145e>
   95866:	f813 2b01 	ldrb.w	r2, [r3], #1
   9586a:	4298      	cmp	r0, r3
   9586c:	f801 2b01 	strb.w	r2, [r1], #1
   95870:	d1f9      	bne.n	95866 <_svfprintf_r+0x145a>
   95872:	1c43      	adds	r3, r0, #1
   95874:	1b1b      	subs	r3, r3, r4
   95876:	f10d 027e 	add.w	r2, sp, #126	; 0x7e
   9587a:	4413      	add	r3, r2
   9587c:	aa1f      	add	r2, sp, #124	; 0x7c
   9587e:	1a9b      	subs	r3, r3, r2
   95880:	9a12      	ldr	r2, [sp, #72]	; 0x48
   95882:	9319      	str	r3, [sp, #100]	; 0x64
   95884:	2a01      	cmp	r2, #1
   95886:	4413      	add	r3, r2
   95888:	930d      	str	r3, [sp, #52]	; 0x34
   9588a:	f340 8109 	ble.w	95aa0 <_svfprintf_r+0x1694>
   9588e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   95890:	9a16      	ldr	r2, [sp, #88]	; 0x58
   95892:	4413      	add	r3, r2
   95894:	2200      	movs	r2, #0
   95896:	930d      	str	r3, [sp, #52]	; 0x34
   95898:	9213      	str	r2, [sp, #76]	; 0x4c
   9589a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   9589e:	e67b      	b.n	95598 <_svfprintf_r+0x118c>
   958a0:	4614      	mov	r4, r2
   958a2:	3301      	adds	r3, #1
   958a4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   958a6:	442c      	add	r4, r5
   958a8:	2b07      	cmp	r3, #7
   958aa:	9425      	str	r4, [sp, #148]	; 0x94
   958ac:	9324      	str	r3, [sp, #144]	; 0x90
   958ae:	e889 0024 	stmia.w	r9, {r2, r5}
   958b2:	f73f af75 	bgt.w	957a0 <_svfprintf_r+0x1394>
   958b6:	f109 0908 	add.w	r9, r9, #8
   958ba:	e77d      	b.n	957b8 <_svfprintf_r+0x13ac>
   958bc:	aa23      	add	r2, sp, #140	; 0x8c
   958be:	9909      	ldr	r1, [sp, #36]	; 0x24
   958c0:	980a      	ldr	r0, [sp, #40]	; 0x28
   958c2:	f003 fa4b 	bl	98d5c <__ssprint_r>
   958c6:	2800      	cmp	r0, #0
   958c8:	f47e afde 	bne.w	94888 <_svfprintf_r+0x47c>
   958cc:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   958d0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   958d2:	9c25      	ldr	r4, [sp, #148]	; 0x94
   958d4:	e526      	b.n	95324 <_svfprintf_r+0xf18>
   958d6:	465b      	mov	r3, fp
   958d8:	2b06      	cmp	r3, #6
   958da:	bf28      	it	cs
   958dc:	2306      	movcs	r3, #6
   958de:	930d      	str	r3, [sp, #52]	; 0x34
   958e0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   958e4:	46b3      	mov	fp, r6
   958e6:	4637      	mov	r7, r6
   958e8:	9613      	str	r6, [sp, #76]	; 0x4c
   958ea:	940e      	str	r4, [sp, #56]	; 0x38
   958ec:	9308      	str	r3, [sp, #32]
   958ee:	4e89      	ldr	r6, [pc, #548]	; (95b14 <_svfprintf_r+0x1708>)
   958f0:	f7fe be97 	b.w	94622 <_svfprintf_r+0x216>
   958f4:	aa23      	add	r2, sp, #140	; 0x8c
   958f6:	9909      	ldr	r1, [sp, #36]	; 0x24
   958f8:	980a      	ldr	r0, [sp, #40]	; 0x28
   958fa:	f003 fa2f 	bl	98d5c <__ssprint_r>
   958fe:	2800      	cmp	r0, #0
   95900:	f47e afc2 	bne.w	94888 <_svfprintf_r+0x47c>
   95904:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   95906:	9a12      	ldr	r2, [sp, #72]	; 0x48
   95908:	9c25      	ldr	r4, [sp, #148]	; 0x94
   9590a:	1ad3      	subs	r3, r2, r3
   9590c:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   95910:	e520      	b.n	95354 <_svfprintf_r+0xf48>
   95912:	920e      	str	r2, [sp, #56]	; 0x38
   95914:	461f      	mov	r7, r3
   95916:	e4eb      	b.n	952f0 <_svfprintf_r+0xee4>
   95918:	232d      	movs	r3, #45	; 0x2d
   9591a:	461f      	mov	r7, r3
   9591c:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
   95920:	f7ff bb06 	b.w	94f30 <_svfprintf_r+0xb24>
   95924:	9307      	str	r3, [sp, #28]
   95926:	f7fe be63 	b.w	945f0 <_svfprintf_r+0x1e4>
   9592a:	920e      	str	r2, [sp, #56]	; 0x38
   9592c:	f7ff baa3 	b.w	94e76 <_svfprintf_r+0xa6a>
   95930:	a821      	add	r0, sp, #132	; 0x84
   95932:	a91e      	add	r1, sp, #120	; 0x78
   95934:	9004      	str	r0, [sp, #16]
   95936:	9103      	str	r1, [sp, #12]
   95938:	a81d      	add	r0, sp, #116	; 0x74
   9593a:	2103      	movs	r1, #3
   9593c:	9002      	str	r0, [sp, #8]
   9593e:	9a08      	ldr	r2, [sp, #32]
   95940:	463b      	mov	r3, r7
   95942:	f8cd b004 	str.w	fp, [sp, #4]
   95946:	9100      	str	r1, [sp, #0]
   95948:	980a      	ldr	r0, [sp, #40]	; 0x28
   9594a:	f001 f9e1 	bl	96d10 <_dtoa_r>
   9594e:	465d      	mov	r5, fp
   95950:	4606      	mov	r6, r0
   95952:	eb00 040b 	add.w	r4, r0, fp
   95956:	e6f2      	b.n	9573e <_svfprintf_r+0x1332>
   95958:	f04f 0b06 	mov.w	fp, #6
   9595c:	e5b6      	b.n	954cc <_svfprintf_r+0x10c0>
   9595e:	9a16      	ldr	r2, [sp, #88]	; 0x58
   95960:	9b12      	ldr	r3, [sp, #72]	; 0x48
   95962:	4413      	add	r3, r2
   95964:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   95966:	930d      	str	r3, [sp, #52]	; 0x34
   95968:	2a00      	cmp	r2, #0
   9596a:	f340 8091 	ble.w	95a90 <_svfprintf_r+0x1684>
   9596e:	2267      	movs	r2, #103	; 0x67
   95970:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   95974:	9211      	str	r2, [sp, #68]	; 0x44
   95976:	e60f      	b.n	95598 <_svfprintf_r+0x118c>
   95978:	2b00      	cmp	r3, #0
   9597a:	f340 809b 	ble.w	95ab4 <_svfprintf_r+0x16a8>
   9597e:	f1bb 0f00 	cmp.w	fp, #0
   95982:	d16e      	bne.n	95a62 <_svfprintf_r+0x1656>
   95984:	9a07      	ldr	r2, [sp, #28]
   95986:	07d4      	lsls	r4, r2, #31
   95988:	d46b      	bmi.n	95a62 <_svfprintf_r+0x1656>
   9598a:	461a      	mov	r2, r3
   9598c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   95990:	920d      	str	r2, [sp, #52]	; 0x34
   95992:	e601      	b.n	95598 <_svfprintf_r+0x118c>
   95994:	9b11      	ldr	r3, [sp, #68]	; 0x44
   95996:	2b47      	cmp	r3, #71	; 0x47
   95998:	f47f adcc 	bne.w	95534 <_svfprintf_r+0x1128>
   9599c:	9b07      	ldr	r3, [sp, #28]
   9599e:	07db      	lsls	r3, r3, #31
   959a0:	f53f aec8 	bmi.w	95734 <_svfprintf_r+0x1328>
   959a4:	9b21      	ldr	r3, [sp, #132]	; 0x84
   959a6:	1b9b      	subs	r3, r3, r6
   959a8:	9312      	str	r3, [sp, #72]	; 0x48
   959aa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   959ac:	2b47      	cmp	r3, #71	; 0x47
   959ae:	f43f af11 	beq.w	957d4 <_svfprintf_r+0x13c8>
   959b2:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   959b4:	e727      	b.n	95806 <_svfprintf_r+0x13fa>
   959b6:	9b07      	ldr	r3, [sp, #28]
   959b8:	465f      	mov	r7, fp
   959ba:	07db      	lsls	r3, r3, #31
   959bc:	d505      	bpl.n	959ca <_svfprintf_r+0x15be>
   959be:	ae40      	add	r6, sp, #256	; 0x100
   959c0:	2330      	movs	r3, #48	; 0x30
   959c2:	f806 3d41 	strb.w	r3, [r6, #-65]!
   959c6:	f7fe be22 	b.w	9460e <_svfprintf_r+0x202>
   959ca:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
   959ce:	ae30      	add	r6, sp, #192	; 0xc0
   959d0:	f7fe be20 	b.w	94614 <_svfprintf_r+0x208>
   959d4:	ea2b 73eb 	bic.w	r3, fp, fp, asr #31
   959d8:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
   959dc:	9308      	str	r3, [sp, #32]
   959de:	4683      	mov	fp, r0
   959e0:	940e      	str	r4, [sp, #56]	; 0x38
   959e2:	9013      	str	r0, [sp, #76]	; 0x4c
   959e4:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
   959e8:	f7fe be1b 	b.w	94622 <_svfprintf_r+0x216>
   959ec:	46a0      	mov	r8, r4
   959ee:	2500      	movs	r5, #0
   959f0:	f7fe bd68 	b.w	944c4 <_svfprintf_r+0xb8>
   959f4:	aa23      	add	r2, sp, #140	; 0x8c
   959f6:	9909      	ldr	r1, [sp, #36]	; 0x24
   959f8:	980a      	ldr	r0, [sp, #40]	; 0x28
   959fa:	f003 f9af 	bl	98d5c <__ssprint_r>
   959fe:	2800      	cmp	r0, #0
   95a00:	f47e af42 	bne.w	94888 <_svfprintf_r+0x47c>
   95a04:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
   95a08:	9d1d      	ldr	r5, [sp, #116]	; 0x74
   95a0a:	9c25      	ldr	r4, [sp, #148]	; 0x94
   95a0c:	9b24      	ldr	r3, [sp, #144]	; 0x90
   95a0e:	f7ff bbf4 	b.w	951fa <_svfprintf_r+0xdee>
   95a12:	9b21      	ldr	r3, [sp, #132]	; 0x84
   95a14:	e5a2      	b.n	9555c <_svfprintf_r+0x1150>
   95a16:	9a16      	ldr	r2, [sp, #88]	; 0x58
   95a18:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   95a1a:	4413      	add	r3, r2
   95a1c:	2267      	movs	r2, #103	; 0x67
   95a1e:	930d      	str	r3, [sp, #52]	; 0x34
   95a20:	9211      	str	r2, [sp, #68]	; 0x44
   95a22:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   95a26:	e5b7      	b.n	95598 <_svfprintf_r+0x118c>
   95a28:	3330      	adds	r3, #48	; 0x30
   95a2a:	2230      	movs	r2, #48	; 0x30
   95a2c:	f88d 307f 	strb.w	r3, [sp, #127]	; 0x7f
   95a30:	f88d 207e 	strb.w	r2, [sp, #126]	; 0x7e
   95a34:	ab20      	add	r3, sp, #128	; 0x80
   95a36:	e721      	b.n	9587c <_svfprintf_r+0x1470>
   95a38:	9907      	ldr	r1, [sp, #28]
   95a3a:	4e37      	ldr	r6, [pc, #220]	; (95b18 <_svfprintf_r+0x170c>)
   95a3c:	f021 0180 	bic.w	r1, r1, #128	; 0x80
   95a40:	4b36      	ldr	r3, [pc, #216]	; (95b1c <_svfprintf_r+0x1710>)
   95a42:	9107      	str	r1, [sp, #28]
   95a44:	9911      	ldr	r1, [sp, #68]	; 0x44
   95a46:	2203      	movs	r2, #3
   95a48:	f04f 0b00 	mov.w	fp, #0
   95a4c:	9208      	str	r2, [sp, #32]
   95a4e:	2947      	cmp	r1, #71	; 0x47
   95a50:	bfd8      	it	le
   95a52:	461e      	movle	r6, r3
   95a54:	920d      	str	r2, [sp, #52]	; 0x34
   95a56:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
   95a5a:	f89d 706f 	ldrb.w	r7, [sp, #111]	; 0x6f
   95a5e:	f7fe bde0 	b.w	94622 <_svfprintf_r+0x216>
   95a62:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   95a64:	9a16      	ldr	r2, [sp, #88]	; 0x58
   95a66:	189d      	adds	r5, r3, r2
   95a68:	eb05 030b 	add.w	r3, r5, fp
   95a6c:	930d      	str	r3, [sp, #52]	; 0x34
   95a6e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   95a72:	e591      	b.n	95598 <_svfprintf_r+0x118c>
   95a74:	9808      	ldr	r0, [sp, #32]
   95a76:	4639      	mov	r1, r7
   95a78:	2200      	movs	r2, #0
   95a7a:	2300      	movs	r3, #0
   95a7c:	f7fd f8e6 	bl	92c4c <__aeabi_dcmpeq>
   95a80:	2800      	cmp	r0, #0
   95a82:	f47f ae60 	bne.w	95746 <_svfprintf_r+0x133a>
   95a86:	f1c5 0501 	rsb	r5, r5, #1
   95a8a:	951d      	str	r5, [sp, #116]	; 0x74
   95a8c:	442c      	add	r4, r5
   95a8e:	e552      	b.n	95536 <_svfprintf_r+0x112a>
   95a90:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   95a92:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   95a94:	f1c3 0301 	rsb	r3, r3, #1
   95a98:	441a      	add	r2, r3
   95a9a:	4613      	mov	r3, r2
   95a9c:	920d      	str	r2, [sp, #52]	; 0x34
   95a9e:	e766      	b.n	9596e <_svfprintf_r+0x1562>
   95aa0:	9b07      	ldr	r3, [sp, #28]
   95aa2:	f013 0301 	ands.w	r3, r3, #1
   95aa6:	f47f aef2 	bne.w	9588e <_svfprintf_r+0x1482>
   95aaa:	9313      	str	r3, [sp, #76]	; 0x4c
   95aac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   95aae:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   95ab2:	e571      	b.n	95598 <_svfprintf_r+0x118c>
   95ab4:	f1bb 0f00 	cmp.w	fp, #0
   95ab8:	d102      	bne.n	95ac0 <_svfprintf_r+0x16b4>
   95aba:	9b07      	ldr	r3, [sp, #28]
   95abc:	07d8      	lsls	r0, r3, #31
   95abe:	d507      	bpl.n	95ad0 <_svfprintf_r+0x16c4>
   95ac0:	9b16      	ldr	r3, [sp, #88]	; 0x58
   95ac2:	1c5d      	adds	r5, r3, #1
   95ac4:	eb05 030b 	add.w	r3, r5, fp
   95ac8:	930d      	str	r3, [sp, #52]	; 0x34
   95aca:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   95ace:	e563      	b.n	95598 <_svfprintf_r+0x118c>
   95ad0:	2301      	movs	r3, #1
   95ad2:	930d      	str	r3, [sp, #52]	; 0x34
   95ad4:	e560      	b.n	95598 <_svfprintf_r+0x118c>
   95ad6:	980e      	ldr	r0, [sp, #56]	; 0x38
   95ad8:	f898 3001 	ldrb.w	r3, [r8, #1]
   95adc:	6805      	ldr	r5, [r0, #0]
   95ade:	3004      	adds	r0, #4
   95ae0:	2d00      	cmp	r5, #0
   95ae2:	900e      	str	r0, [sp, #56]	; 0x38
   95ae4:	46a0      	mov	r8, r4
   95ae6:	f6be aceb 	bge.w	944c0 <_svfprintf_r+0xb4>
   95aea:	f04f 35ff 	mov.w	r5, #4294967295
   95aee:	f7fe bce7 	b.w	944c0 <_svfprintf_r+0xb4>
   95af2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   95af4:	230c      	movs	r3, #12
   95af6:	6013      	str	r3, [r2, #0]
   95af8:	f04f 30ff 	mov.w	r0, #4294967295
   95afc:	f7fe becd 	b.w	9489a <_svfprintf_r+0x48e>
   95b00:	f10d 037e 	add.w	r3, sp, #126	; 0x7e
   95b04:	e6ba      	b.n	9587c <_svfprintf_r+0x1470>
   95b06:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   95b0a:	f7ff bb29 	b.w	95160 <_svfprintf_r+0xd54>
   95b0e:	bf00      	nop
   95b10:	66666667 	.word	0x66666667
   95b14:	0009b1c0 	.word	0x0009b1c0
   95b18:	0009b194 	.word	0x0009b194
   95b1c:	0009b190 	.word	0x0009b190
   95b20:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   95b24:	f7ff b90f 	b.w	94d46 <_svfprintf_r+0x93a>
   95b28:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   95b2c:	f7ff bab8 	b.w	950a0 <_svfprintf_r+0xc94>
   95b30:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   95b34:	f7ff ba9f 	b.w	95076 <_svfprintf_r+0xc6a>
   95b38:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   95b3c:	f7ff ba74 	b.w	95028 <_svfprintf_r+0xc1c>
   95b40:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   95b44:	f7ff ba3e 	b.w	94fc4 <_svfprintf_r+0xbb8>
   95b48:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   95b4c:	f7ff ba10 	b.w	94f70 <_svfprintf_r+0xb64>
   95b50:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   95b54:	f7ff b932 	b.w	94dbc <_svfprintf_r+0x9b0>
   95b58:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   95b5c:	f7ff b9b5 	b.w	94eca <_svfprintf_r+0xabe>
   95b60:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
   95b64:	f7ff b968 	b.w	94e38 <_svfprintf_r+0xa2c>

00095b68 <kill>:
   95b68:	4b02      	ldr	r3, [pc, #8]	; (95b74 <kill+0xc>)
   95b6a:	460a      	mov	r2, r1
   95b6c:	4601      	mov	r1, r0
   95b6e:	6818      	ldr	r0, [r3, #0]
   95b70:	f003 b89a 	b.w	98ca8 <_kill_r>
   95b74:	20070548 	.word	0x20070548

00095b78 <__sprint_r.part.0>:
   95b78:	6e4b      	ldr	r3, [r1, #100]	; 0x64
   95b7a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   95b7e:	049c      	lsls	r4, r3, #18
   95b80:	4692      	mov	sl, r2
   95b82:	d52c      	bpl.n	95bde <__sprint_r.part.0+0x66>
   95b84:	6893      	ldr	r3, [r2, #8]
   95b86:	6812      	ldr	r2, [r2, #0]
   95b88:	b33b      	cbz	r3, 95bda <__sprint_r.part.0+0x62>
   95b8a:	460f      	mov	r7, r1
   95b8c:	4680      	mov	r8, r0
   95b8e:	f102 0908 	add.w	r9, r2, #8
   95b92:	e919 0060 	ldmdb	r9, {r5, r6}
   95b96:	08b6      	lsrs	r6, r6, #2
   95b98:	d017      	beq.n	95bca <__sprint_r.part.0+0x52>
   95b9a:	3d04      	subs	r5, #4
   95b9c:	2400      	movs	r4, #0
   95b9e:	e001      	b.n	95ba4 <__sprint_r.part.0+0x2c>
   95ba0:	42a6      	cmp	r6, r4
   95ba2:	d010      	beq.n	95bc6 <__sprint_r.part.0+0x4e>
   95ba4:	463a      	mov	r2, r7
   95ba6:	f855 1f04 	ldr.w	r1, [r5, #4]!
   95baa:	4640      	mov	r0, r8
   95bac:	f002 f976 	bl	97e9c <_fputwc_r>
   95bb0:	1c43      	adds	r3, r0, #1
   95bb2:	f104 0401 	add.w	r4, r4, #1
   95bb6:	d1f3      	bne.n	95ba0 <__sprint_r.part.0+0x28>
   95bb8:	2300      	movs	r3, #0
   95bba:	f8ca 3008 	str.w	r3, [sl, #8]
   95bbe:	f8ca 3004 	str.w	r3, [sl, #4]
   95bc2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   95bc6:	f8da 3008 	ldr.w	r3, [sl, #8]
   95bca:	eba3 0386 	sub.w	r3, r3, r6, lsl #2
   95bce:	f8ca 3008 	str.w	r3, [sl, #8]
   95bd2:	f109 0908 	add.w	r9, r9, #8
   95bd6:	2b00      	cmp	r3, #0
   95bd8:	d1db      	bne.n	95b92 <__sprint_r.part.0+0x1a>
   95bda:	2000      	movs	r0, #0
   95bdc:	e7ec      	b.n	95bb8 <__sprint_r.part.0+0x40>
   95bde:	f002 faa5 	bl	9812c <__sfvwrite_r>
   95be2:	2300      	movs	r3, #0
   95be4:	f8ca 3008 	str.w	r3, [sl, #8]
   95be8:	f8ca 3004 	str.w	r3, [sl, #4]
   95bec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00095bf0 <_vfiprintf_r>:
   95bf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   95bf4:	b0ab      	sub	sp, #172	; 0xac
   95bf6:	461c      	mov	r4, r3
   95bf8:	9100      	str	r1, [sp, #0]
   95bfa:	4690      	mov	r8, r2
   95bfc:	9304      	str	r3, [sp, #16]
   95bfe:	9005      	str	r0, [sp, #20]
   95c00:	b118      	cbz	r0, 95c0a <_vfiprintf_r+0x1a>
   95c02:	6b83      	ldr	r3, [r0, #56]	; 0x38
   95c04:	2b00      	cmp	r3, #0
   95c06:	f000 80de 	beq.w	95dc6 <_vfiprintf_r+0x1d6>
   95c0a:	9800      	ldr	r0, [sp, #0]
   95c0c:	f9b0 100c 	ldrsh.w	r1, [r0, #12]
   95c10:	b28a      	uxth	r2, r1
   95c12:	0495      	lsls	r5, r2, #18
   95c14:	d407      	bmi.n	95c26 <_vfiprintf_r+0x36>
   95c16:	6e43      	ldr	r3, [r0, #100]	; 0x64
   95c18:	f441 5200 	orr.w	r2, r1, #8192	; 0x2000
   95c1c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
   95c20:	8182      	strh	r2, [r0, #12]
   95c22:	6643      	str	r3, [r0, #100]	; 0x64
   95c24:	b292      	uxth	r2, r2
   95c26:	0711      	lsls	r1, r2, #28
   95c28:	f140 80b1 	bpl.w	95d8e <_vfiprintf_r+0x19e>
   95c2c:	9b00      	ldr	r3, [sp, #0]
   95c2e:	691b      	ldr	r3, [r3, #16]
   95c30:	2b00      	cmp	r3, #0
   95c32:	f000 80ac 	beq.w	95d8e <_vfiprintf_r+0x19e>
   95c36:	f002 021a 	and.w	r2, r2, #26
   95c3a:	2a0a      	cmp	r2, #10
   95c3c:	f000 80b5 	beq.w	95daa <_vfiprintf_r+0x1ba>
   95c40:	f10d 0a68 	add.w	sl, sp, #104	; 0x68
   95c44:	46d3      	mov	fp, sl
   95c46:	2300      	movs	r3, #0
   95c48:	9302      	str	r3, [sp, #8]
   95c4a:	930f      	str	r3, [sp, #60]	; 0x3c
   95c4c:	930e      	str	r3, [sp, #56]	; 0x38
   95c4e:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
   95c52:	f898 3000 	ldrb.w	r3, [r8]
   95c56:	4644      	mov	r4, r8
   95c58:	b1fb      	cbz	r3, 95c9a <_vfiprintf_r+0xaa>
   95c5a:	2b25      	cmp	r3, #37	; 0x25
   95c5c:	d102      	bne.n	95c64 <_vfiprintf_r+0x74>
   95c5e:	e01c      	b.n	95c9a <_vfiprintf_r+0xaa>
   95c60:	2b25      	cmp	r3, #37	; 0x25
   95c62:	d003      	beq.n	95c6c <_vfiprintf_r+0x7c>
   95c64:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   95c68:	2b00      	cmp	r3, #0
   95c6a:	d1f9      	bne.n	95c60 <_vfiprintf_r+0x70>
   95c6c:	ebc8 0504 	rsb	r5, r8, r4
   95c70:	b19d      	cbz	r5, 95c9a <_vfiprintf_r+0xaa>
   95c72:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   95c74:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   95c76:	3301      	adds	r3, #1
   95c78:	442a      	add	r2, r5
   95c7a:	2b07      	cmp	r3, #7
   95c7c:	f8cb 8000 	str.w	r8, [fp]
   95c80:	f8cb 5004 	str.w	r5, [fp, #4]
   95c84:	920f      	str	r2, [sp, #60]	; 0x3c
   95c86:	930e      	str	r3, [sp, #56]	; 0x38
   95c88:	dd7b      	ble.n	95d82 <_vfiprintf_r+0x192>
   95c8a:	2a00      	cmp	r2, #0
   95c8c:	f040 851f 	bne.w	966ce <_vfiprintf_r+0xade>
   95c90:	46d3      	mov	fp, sl
   95c92:	9b02      	ldr	r3, [sp, #8]
   95c94:	920e      	str	r2, [sp, #56]	; 0x38
   95c96:	442b      	add	r3, r5
   95c98:	9302      	str	r3, [sp, #8]
   95c9a:	7823      	ldrb	r3, [r4, #0]
   95c9c:	2b00      	cmp	r3, #0
   95c9e:	f000 843b 	beq.w	96518 <_vfiprintf_r+0x928>
   95ca2:	f04f 0300 	mov.w	r3, #0
   95ca6:	2100      	movs	r1, #0
   95ca8:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
   95cac:	f104 0801 	add.w	r8, r4, #1
   95cb0:	7863      	ldrb	r3, [r4, #1]
   95cb2:	4608      	mov	r0, r1
   95cb4:	460e      	mov	r6, r1
   95cb6:	460c      	mov	r4, r1
   95cb8:	f04f 32ff 	mov.w	r2, #4294967295
   95cbc:	9201      	str	r2, [sp, #4]
   95cbe:	f108 0801 	add.w	r8, r8, #1
   95cc2:	f1a3 0220 	sub.w	r2, r3, #32
   95cc6:	2a58      	cmp	r2, #88	; 0x58
   95cc8:	f200 838b 	bhi.w	963e2 <_vfiprintf_r+0x7f2>
   95ccc:	e8df f012 	tbh	[pc, r2, lsl #1]
   95cd0:	0389033d 	.word	0x0389033d
   95cd4:	03450389 	.word	0x03450389
   95cd8:	03890389 	.word	0x03890389
   95cdc:	03890389 	.word	0x03890389
   95ce0:	03890389 	.word	0x03890389
   95ce4:	026b007e 	.word	0x026b007e
   95ce8:	00860389 	.word	0x00860389
   95cec:	03890270 	.word	0x03890270
   95cf0:	025d01cc 	.word	0x025d01cc
   95cf4:	025d025d 	.word	0x025d025d
   95cf8:	025d025d 	.word	0x025d025d
   95cfc:	025d025d 	.word	0x025d025d
   95d00:	025d025d 	.word	0x025d025d
   95d04:	03890389 	.word	0x03890389
   95d08:	03890389 	.word	0x03890389
   95d0c:	03890389 	.word	0x03890389
   95d10:	03890389 	.word	0x03890389
   95d14:	03890389 	.word	0x03890389
   95d18:	038901d1 	.word	0x038901d1
   95d1c:	03890389 	.word	0x03890389
   95d20:	03890389 	.word	0x03890389
   95d24:	03890389 	.word	0x03890389
   95d28:	03890389 	.word	0x03890389
   95d2c:	021a0389 	.word	0x021a0389
   95d30:	03890389 	.word	0x03890389
   95d34:	03890389 	.word	0x03890389
   95d38:	02e50389 	.word	0x02e50389
   95d3c:	03890389 	.word	0x03890389
   95d40:	03890308 	.word	0x03890308
   95d44:	03890389 	.word	0x03890389
   95d48:	03890389 	.word	0x03890389
   95d4c:	03890389 	.word	0x03890389
   95d50:	03890389 	.word	0x03890389
   95d54:	032b0389 	.word	0x032b0389
   95d58:	03890382 	.word	0x03890382
   95d5c:	03890389 	.word	0x03890389
   95d60:	0382035e 	.word	0x0382035e
   95d64:	03890389 	.word	0x03890389
   95d68:	03890363 	.word	0x03890363
   95d6c:	028d0370 	.word	0x028d0370
   95d70:	02e0008b 	.word	0x02e0008b
   95d74:	02930389 	.word	0x02930389
   95d78:	02b20389 	.word	0x02b20389
   95d7c:	03890389 	.word	0x03890389
   95d80:	034a      	.short	0x034a
   95d82:	f10b 0b08 	add.w	fp, fp, #8
   95d86:	9b02      	ldr	r3, [sp, #8]
   95d88:	442b      	add	r3, r5
   95d8a:	9302      	str	r3, [sp, #8]
   95d8c:	e785      	b.n	95c9a <_vfiprintf_r+0xaa>
   95d8e:	9900      	ldr	r1, [sp, #0]
   95d90:	9805      	ldr	r0, [sp, #20]
   95d92:	f000 fe57 	bl	96a44 <__swsetup_r>
   95d96:	2800      	cmp	r0, #0
   95d98:	f040 8545 	bne.w	96826 <_vfiprintf_r+0xc36>
   95d9c:	9b00      	ldr	r3, [sp, #0]
   95d9e:	899a      	ldrh	r2, [r3, #12]
   95da0:	f002 021a 	and.w	r2, r2, #26
   95da4:	2a0a      	cmp	r2, #10
   95da6:	f47f af4b 	bne.w	95c40 <_vfiprintf_r+0x50>
   95daa:	9900      	ldr	r1, [sp, #0]
   95dac:	f9b1 300e 	ldrsh.w	r3, [r1, #14]
   95db0:	2b00      	cmp	r3, #0
   95db2:	f6ff af45 	blt.w	95c40 <_vfiprintf_r+0x50>
   95db6:	4623      	mov	r3, r4
   95db8:	4642      	mov	r2, r8
   95dba:	9805      	ldr	r0, [sp, #20]
   95dbc:	f000 fe0c 	bl	969d8 <__sbprintf>
   95dc0:	b02b      	add	sp, #172	; 0xac
   95dc2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   95dc6:	f002 f801 	bl	97dcc <__sinit>
   95dca:	e71e      	b.n	95c0a <_vfiprintf_r+0x1a>
   95dcc:	9a04      	ldr	r2, [sp, #16]
   95dce:	4613      	mov	r3, r2
   95dd0:	6814      	ldr	r4, [r2, #0]
   95dd2:	3304      	adds	r3, #4
   95dd4:	2c00      	cmp	r4, #0
   95dd6:	9304      	str	r3, [sp, #16]
   95dd8:	da02      	bge.n	95de0 <_vfiprintf_r+0x1f0>
   95dda:	4264      	negs	r4, r4
   95ddc:	f046 0604 	orr.w	r6, r6, #4
   95de0:	f898 3000 	ldrb.w	r3, [r8]
   95de4:	e76b      	b.n	95cbe <_vfiprintf_r+0xce>
   95de6:	f04f 0300 	mov.w	r3, #0
   95dea:	9804      	ldr	r0, [sp, #16]
   95dec:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
   95df0:	4603      	mov	r3, r0
   95df2:	2130      	movs	r1, #48	; 0x30
   95df4:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   95df8:	9901      	ldr	r1, [sp, #4]
   95dfa:	2278      	movs	r2, #120	; 0x78
   95dfc:	2900      	cmp	r1, #0
   95dfe:	9406      	str	r4, [sp, #24]
   95e00:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   95e04:	6804      	ldr	r4, [r0, #0]
   95e06:	f103 0304 	add.w	r3, r3, #4
   95e0a:	f04f 0500 	mov.w	r5, #0
   95e0e:	f046 0202 	orr.w	r2, r6, #2
   95e12:	f2c0 850c 	blt.w	9682e <_vfiprintf_r+0xc3e>
   95e16:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   95e1a:	ea54 0205 	orrs.w	r2, r4, r5
   95e1e:	f046 0602 	orr.w	r6, r6, #2
   95e22:	9304      	str	r3, [sp, #16]
   95e24:	f040 84b5 	bne.w	96792 <_vfiprintf_r+0xba2>
   95e28:	48b3      	ldr	r0, [pc, #716]	; (960f8 <_vfiprintf_r+0x508>)
   95e2a:	9b01      	ldr	r3, [sp, #4]
   95e2c:	2b00      	cmp	r3, #0
   95e2e:	f040 8462 	bne.w	966f6 <_vfiprintf_r+0xb06>
   95e32:	4699      	mov	r9, r3
   95e34:	4657      	mov	r7, sl
   95e36:	2300      	movs	r3, #0
   95e38:	9301      	str	r3, [sp, #4]
   95e3a:	9303      	str	r3, [sp, #12]
   95e3c:	9b01      	ldr	r3, [sp, #4]
   95e3e:	9a03      	ldr	r2, [sp, #12]
   95e40:	4293      	cmp	r3, r2
   95e42:	bfb8      	it	lt
   95e44:	4613      	movlt	r3, r2
   95e46:	461d      	mov	r5, r3
   95e48:	f1b9 0f00 	cmp.w	r9, #0
   95e4c:	d000      	beq.n	95e50 <_vfiprintf_r+0x260>
   95e4e:	3501      	adds	r5, #1
   95e50:	f016 0302 	ands.w	r3, r6, #2
   95e54:	9307      	str	r3, [sp, #28]
   95e56:	bf18      	it	ne
   95e58:	3502      	addne	r5, #2
   95e5a:	f016 0384 	ands.w	r3, r6, #132	; 0x84
   95e5e:	9308      	str	r3, [sp, #32]
   95e60:	f040 82e8 	bne.w	96434 <_vfiprintf_r+0x844>
   95e64:	9b06      	ldr	r3, [sp, #24]
   95e66:	1b5c      	subs	r4, r3, r5
   95e68:	2c00      	cmp	r4, #0
   95e6a:	f340 82e3 	ble.w	96434 <_vfiprintf_r+0x844>
   95e6e:	2c10      	cmp	r4, #16
   95e70:	f340 853c 	ble.w	968ec <_vfiprintf_r+0xcfc>
   95e74:	f8df 9284 	ldr.w	r9, [pc, #644]	; 960fc <_vfiprintf_r+0x50c>
   95e78:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
   95e7c:	46dc      	mov	ip, fp
   95e7e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   95e80:	46c3      	mov	fp, r8
   95e82:	2310      	movs	r3, #16
   95e84:	46a8      	mov	r8, r5
   95e86:	4670      	mov	r0, lr
   95e88:	464d      	mov	r5, r9
   95e8a:	f8dd 9014 	ldr.w	r9, [sp, #20]
   95e8e:	e007      	b.n	95ea0 <_vfiprintf_r+0x2b0>
   95e90:	f100 0e02 	add.w	lr, r0, #2
   95e94:	4608      	mov	r0, r1
   95e96:	f10c 0c08 	add.w	ip, ip, #8
   95e9a:	3c10      	subs	r4, #16
   95e9c:	2c10      	cmp	r4, #16
   95e9e:	dd13      	ble.n	95ec8 <_vfiprintf_r+0x2d8>
   95ea0:	1c41      	adds	r1, r0, #1
   95ea2:	3210      	adds	r2, #16
   95ea4:	2907      	cmp	r1, #7
   95ea6:	920f      	str	r2, [sp, #60]	; 0x3c
   95ea8:	f8cc 5000 	str.w	r5, [ip]
   95eac:	f8cc 3004 	str.w	r3, [ip, #4]
   95eb0:	910e      	str	r1, [sp, #56]	; 0x38
   95eb2:	dded      	ble.n	95e90 <_vfiprintf_r+0x2a0>
   95eb4:	2a00      	cmp	r2, #0
   95eb6:	f040 82a5 	bne.w	96404 <_vfiprintf_r+0x814>
   95eba:	3c10      	subs	r4, #16
   95ebc:	2c10      	cmp	r4, #16
   95ebe:	4610      	mov	r0, r2
   95ec0:	f04f 0e01 	mov.w	lr, #1
   95ec4:	46d4      	mov	ip, sl
   95ec6:	dceb      	bgt.n	95ea0 <_vfiprintf_r+0x2b0>
   95ec8:	46a9      	mov	r9, r5
   95eca:	4670      	mov	r0, lr
   95ecc:	4645      	mov	r5, r8
   95ece:	46d8      	mov	r8, fp
   95ed0:	46e3      	mov	fp, ip
   95ed2:	4422      	add	r2, r4
   95ed4:	2807      	cmp	r0, #7
   95ed6:	920f      	str	r2, [sp, #60]	; 0x3c
   95ed8:	f8cb 9000 	str.w	r9, [fp]
   95edc:	f8cb 4004 	str.w	r4, [fp, #4]
   95ee0:	900e      	str	r0, [sp, #56]	; 0x38
   95ee2:	f300 836d 	bgt.w	965c0 <_vfiprintf_r+0x9d0>
   95ee6:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   95eea:	f10b 0b08 	add.w	fp, fp, #8
   95eee:	f100 0e01 	add.w	lr, r0, #1
   95ef2:	2b00      	cmp	r3, #0
   95ef4:	f040 82a7 	bne.w	96446 <_vfiprintf_r+0x856>
   95ef8:	9b07      	ldr	r3, [sp, #28]
   95efa:	2b00      	cmp	r3, #0
   95efc:	f000 82ba 	beq.w	96474 <_vfiprintf_r+0x884>
   95f00:	3202      	adds	r2, #2
   95f02:	a90c      	add	r1, sp, #48	; 0x30
   95f04:	2302      	movs	r3, #2
   95f06:	f1be 0f07 	cmp.w	lr, #7
   95f0a:	920f      	str	r2, [sp, #60]	; 0x3c
   95f0c:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
   95f10:	e88b 000a 	stmia.w	fp, {r1, r3}
   95f14:	f340 8370 	ble.w	965f8 <_vfiprintf_r+0xa08>
   95f18:	2a00      	cmp	r2, #0
   95f1a:	f040 8400 	bne.w	9671e <_vfiprintf_r+0xb2e>
   95f1e:	9b08      	ldr	r3, [sp, #32]
   95f20:	f04f 0e01 	mov.w	lr, #1
   95f24:	2b80      	cmp	r3, #128	; 0x80
   95f26:	4610      	mov	r0, r2
   95f28:	46d3      	mov	fp, sl
   95f2a:	f040 82a7 	bne.w	9647c <_vfiprintf_r+0x88c>
   95f2e:	9b06      	ldr	r3, [sp, #24]
   95f30:	1b5c      	subs	r4, r3, r5
   95f32:	2c00      	cmp	r4, #0
   95f34:	f340 82a2 	ble.w	9647c <_vfiprintf_r+0x88c>
   95f38:	2c10      	cmp	r4, #16
   95f3a:	f340 84f8 	ble.w	9692e <_vfiprintf_r+0xd3e>
   95f3e:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 96100 <_vfiprintf_r+0x510>
   95f42:	46de      	mov	lr, fp
   95f44:	2310      	movs	r3, #16
   95f46:	46c3      	mov	fp, r8
   95f48:	46a8      	mov	r8, r5
   95f4a:	464d      	mov	r5, r9
   95f4c:	f8dd 9014 	ldr.w	r9, [sp, #20]
   95f50:	e007      	b.n	95f62 <_vfiprintf_r+0x372>
   95f52:	f100 0c02 	add.w	ip, r0, #2
   95f56:	4608      	mov	r0, r1
   95f58:	f10e 0e08 	add.w	lr, lr, #8
   95f5c:	3c10      	subs	r4, #16
   95f5e:	2c10      	cmp	r4, #16
   95f60:	dd13      	ble.n	95f8a <_vfiprintf_r+0x39a>
   95f62:	1c41      	adds	r1, r0, #1
   95f64:	3210      	adds	r2, #16
   95f66:	2907      	cmp	r1, #7
   95f68:	920f      	str	r2, [sp, #60]	; 0x3c
   95f6a:	f8ce 5000 	str.w	r5, [lr]
   95f6e:	f8ce 3004 	str.w	r3, [lr, #4]
   95f72:	910e      	str	r1, [sp, #56]	; 0x38
   95f74:	dded      	ble.n	95f52 <_vfiprintf_r+0x362>
   95f76:	2a00      	cmp	r2, #0
   95f78:	f040 830c 	bne.w	96594 <_vfiprintf_r+0x9a4>
   95f7c:	3c10      	subs	r4, #16
   95f7e:	2c10      	cmp	r4, #16
   95f80:	f04f 0c01 	mov.w	ip, #1
   95f84:	4610      	mov	r0, r2
   95f86:	46d6      	mov	lr, sl
   95f88:	dceb      	bgt.n	95f62 <_vfiprintf_r+0x372>
   95f8a:	46a9      	mov	r9, r5
   95f8c:	4645      	mov	r5, r8
   95f8e:	46d8      	mov	r8, fp
   95f90:	46f3      	mov	fp, lr
   95f92:	4422      	add	r2, r4
   95f94:	f1bc 0f07 	cmp.w	ip, #7
   95f98:	920f      	str	r2, [sp, #60]	; 0x3c
   95f9a:	f8cb 9000 	str.w	r9, [fp]
   95f9e:	f8cb 4004 	str.w	r4, [fp, #4]
   95fa2:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
   95fa6:	f300 83c8 	bgt.w	9673a <_vfiprintf_r+0xb4a>
   95faa:	9b01      	ldr	r3, [sp, #4]
   95fac:	9903      	ldr	r1, [sp, #12]
   95fae:	f10b 0b08 	add.w	fp, fp, #8
   95fb2:	1a5c      	subs	r4, r3, r1
   95fb4:	2c00      	cmp	r4, #0
   95fb6:	f10c 0e01 	add.w	lr, ip, #1
   95fba:	4660      	mov	r0, ip
   95fbc:	f300 8264 	bgt.w	96488 <_vfiprintf_r+0x898>
   95fc0:	9903      	ldr	r1, [sp, #12]
   95fc2:	f1be 0f07 	cmp.w	lr, #7
   95fc6:	440a      	add	r2, r1
   95fc8:	920f      	str	r2, [sp, #60]	; 0x3c
   95fca:	f8cb 7000 	str.w	r7, [fp]
   95fce:	f8cb 1004 	str.w	r1, [fp, #4]
   95fd2:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
   95fd6:	f340 82c5 	ble.w	96564 <_vfiprintf_r+0x974>
   95fda:	2a00      	cmp	r2, #0
   95fdc:	f040 8332 	bne.w	96644 <_vfiprintf_r+0xa54>
   95fe0:	0770      	lsls	r0, r6, #29
   95fe2:	920e      	str	r2, [sp, #56]	; 0x38
   95fe4:	d538      	bpl.n	96058 <_vfiprintf_r+0x468>
   95fe6:	9b06      	ldr	r3, [sp, #24]
   95fe8:	1b5c      	subs	r4, r3, r5
   95fea:	2c00      	cmp	r4, #0
   95fec:	dd34      	ble.n	96058 <_vfiprintf_r+0x468>
   95fee:	46d3      	mov	fp, sl
   95ff0:	2c10      	cmp	r4, #16
   95ff2:	f340 8496 	ble.w	96922 <_vfiprintf_r+0xd32>
   95ff6:	f8df 9104 	ldr.w	r9, [pc, #260]	; 960fc <_vfiprintf_r+0x50c>
   95ffa:	990e      	ldr	r1, [sp, #56]	; 0x38
   95ffc:	464f      	mov	r7, r9
   95ffe:	2610      	movs	r6, #16
   96000:	f8dd 9014 	ldr.w	r9, [sp, #20]
   96004:	e006      	b.n	96014 <_vfiprintf_r+0x424>
   96006:	1c88      	adds	r0, r1, #2
   96008:	4619      	mov	r1, r3
   9600a:	f10b 0b08 	add.w	fp, fp, #8
   9600e:	3c10      	subs	r4, #16
   96010:	2c10      	cmp	r4, #16
   96012:	dd13      	ble.n	9603c <_vfiprintf_r+0x44c>
   96014:	1c4b      	adds	r3, r1, #1
   96016:	3210      	adds	r2, #16
   96018:	2b07      	cmp	r3, #7
   9601a:	920f      	str	r2, [sp, #60]	; 0x3c
   9601c:	f8cb 7000 	str.w	r7, [fp]
   96020:	f8cb 6004 	str.w	r6, [fp, #4]
   96024:	930e      	str	r3, [sp, #56]	; 0x38
   96026:	ddee      	ble.n	96006 <_vfiprintf_r+0x416>
   96028:	2a00      	cmp	r2, #0
   9602a:	f040 8285 	bne.w	96538 <_vfiprintf_r+0x948>
   9602e:	3c10      	subs	r4, #16
   96030:	2c10      	cmp	r4, #16
   96032:	f04f 0001 	mov.w	r0, #1
   96036:	4611      	mov	r1, r2
   96038:	46d3      	mov	fp, sl
   9603a:	dceb      	bgt.n	96014 <_vfiprintf_r+0x424>
   9603c:	46b9      	mov	r9, r7
   9603e:	4422      	add	r2, r4
   96040:	2807      	cmp	r0, #7
   96042:	920f      	str	r2, [sp, #60]	; 0x3c
   96044:	f8cb 9000 	str.w	r9, [fp]
   96048:	f8cb 4004 	str.w	r4, [fp, #4]
   9604c:	900e      	str	r0, [sp, #56]	; 0x38
   9604e:	f340 8292 	ble.w	96576 <_vfiprintf_r+0x986>
   96052:	2a00      	cmp	r2, #0
   96054:	f040 840c 	bne.w	96870 <_vfiprintf_r+0xc80>
   96058:	9b02      	ldr	r3, [sp, #8]
   9605a:	9a06      	ldr	r2, [sp, #24]
   9605c:	42aa      	cmp	r2, r5
   9605e:	bfac      	ite	ge
   96060:	189b      	addge	r3, r3, r2
   96062:	195b      	addlt	r3, r3, r5
   96064:	9302      	str	r3, [sp, #8]
   96066:	e290      	b.n	9658a <_vfiprintf_r+0x99a>
   96068:	f046 0680 	orr.w	r6, r6, #128	; 0x80
   9606c:	f898 3000 	ldrb.w	r3, [r8]
   96070:	e625      	b.n	95cbe <_vfiprintf_r+0xce>
   96072:	9406      	str	r4, [sp, #24]
   96074:	2900      	cmp	r1, #0
   96076:	f040 8485 	bne.w	96984 <_vfiprintf_r+0xd94>
   9607a:	f046 0610 	orr.w	r6, r6, #16
   9607e:	06b3      	lsls	r3, r6, #26
   96080:	f140 8304 	bpl.w	9668c <_vfiprintf_r+0xa9c>
   96084:	9904      	ldr	r1, [sp, #16]
   96086:	3107      	adds	r1, #7
   96088:	f021 0107 	bic.w	r1, r1, #7
   9608c:	e9d1 2300 	ldrd	r2, r3, [r1]
   96090:	4614      	mov	r4, r2
   96092:	461d      	mov	r5, r3
   96094:	3108      	adds	r1, #8
   96096:	9104      	str	r1, [sp, #16]
   96098:	2a00      	cmp	r2, #0
   9609a:	f173 0300 	sbcs.w	r3, r3, #0
   9609e:	f2c0 837c 	blt.w	9679a <_vfiprintf_r+0xbaa>
   960a2:	9b01      	ldr	r3, [sp, #4]
   960a4:	f89d 902f 	ldrb.w	r9, [sp, #47]	; 0x2f
   960a8:	2b00      	cmp	r3, #0
   960aa:	f2c0 830b 	blt.w	966c4 <_vfiprintf_r+0xad4>
   960ae:	ea54 0305 	orrs.w	r3, r4, r5
   960b2:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   960b6:	f000 80de 	beq.w	96276 <_vfiprintf_r+0x686>
   960ba:	2d00      	cmp	r5, #0
   960bc:	bf08      	it	eq
   960be:	2c0a      	cmpeq	r4, #10
   960c0:	f0c0 80de 	bcc.w	96280 <_vfiprintf_r+0x690>
   960c4:	4657      	mov	r7, sl
   960c6:	4620      	mov	r0, r4
   960c8:	4629      	mov	r1, r5
   960ca:	220a      	movs	r2, #10
   960cc:	2300      	movs	r3, #0
   960ce:	f003 f83f 	bl	99150 <__aeabi_uldivmod>
   960d2:	3230      	adds	r2, #48	; 0x30
   960d4:	f807 2d01 	strb.w	r2, [r7, #-1]!
   960d8:	4620      	mov	r0, r4
   960da:	4629      	mov	r1, r5
   960dc:	2300      	movs	r3, #0
   960de:	220a      	movs	r2, #10
   960e0:	f003 f836 	bl	99150 <__aeabi_uldivmod>
   960e4:	4604      	mov	r4, r0
   960e6:	460d      	mov	r5, r1
   960e8:	ea54 0305 	orrs.w	r3, r4, r5
   960ec:	d1eb      	bne.n	960c6 <_vfiprintf_r+0x4d6>
   960ee:	ebc7 030a 	rsb	r3, r7, sl
   960f2:	9303      	str	r3, [sp, #12]
   960f4:	e6a2      	b.n	95e3c <_vfiprintf_r+0x24c>
   960f6:	bf00      	nop
   960f8:	0009b1ac 	.word	0x0009b1ac
   960fc:	0009b1ec 	.word	0x0009b1ec
   96100:	0009b1dc 	.word	0x0009b1dc
   96104:	9406      	str	r4, [sp, #24]
   96106:	2900      	cmp	r1, #0
   96108:	f040 8438 	bne.w	9697c <_vfiprintf_r+0xd8c>
   9610c:	f046 0610 	orr.w	r6, r6, #16
   96110:	f016 0320 	ands.w	r3, r6, #32
   96114:	f000 82a1 	beq.w	9665a <_vfiprintf_r+0xa6a>
   96118:	f04f 0200 	mov.w	r2, #0
   9611c:	9b04      	ldr	r3, [sp, #16]
   9611e:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
   96122:	3307      	adds	r3, #7
   96124:	f023 0307 	bic.w	r3, r3, #7
   96128:	f103 0208 	add.w	r2, r3, #8
   9612c:	e9d3 4500 	ldrd	r4, r5, [r3]
   96130:	9b01      	ldr	r3, [sp, #4]
   96132:	9204      	str	r2, [sp, #16]
   96134:	2b00      	cmp	r3, #0
   96136:	db0a      	blt.n	9614e <_vfiprintf_r+0x55e>
   96138:	ea54 0305 	orrs.w	r3, r4, r5
   9613c:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   96140:	d105      	bne.n	9614e <_vfiprintf_r+0x55e>
   96142:	9b01      	ldr	r3, [sp, #4]
   96144:	2b00      	cmp	r3, #0
   96146:	f000 8427 	beq.w	96998 <_vfiprintf_r+0xda8>
   9614a:	2400      	movs	r4, #0
   9614c:	2500      	movs	r5, #0
   9614e:	f04f 0900 	mov.w	r9, #0
   96152:	4657      	mov	r7, sl
   96154:	08e2      	lsrs	r2, r4, #3
   96156:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
   9615a:	08e9      	lsrs	r1, r5, #3
   9615c:	f004 0307 	and.w	r3, r4, #7
   96160:	460d      	mov	r5, r1
   96162:	4614      	mov	r4, r2
   96164:	3330      	adds	r3, #48	; 0x30
   96166:	ea54 0205 	orrs.w	r2, r4, r5
   9616a:	f807 3d01 	strb.w	r3, [r7, #-1]!
   9616e:	d1f1      	bne.n	96154 <_vfiprintf_r+0x564>
   96170:	07f4      	lsls	r4, r6, #31
   96172:	d5bc      	bpl.n	960ee <_vfiprintf_r+0x4fe>
   96174:	2b30      	cmp	r3, #48	; 0x30
   96176:	d0ba      	beq.n	960ee <_vfiprintf_r+0x4fe>
   96178:	2230      	movs	r2, #48	; 0x30
   9617a:	1e7b      	subs	r3, r7, #1
   9617c:	f807 2c01 	strb.w	r2, [r7, #-1]
   96180:	ebc3 020a 	rsb	r2, r3, sl
   96184:	9203      	str	r2, [sp, #12]
   96186:	461f      	mov	r7, r3
   96188:	e658      	b.n	95e3c <_vfiprintf_r+0x24c>
   9618a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
   9618e:	2400      	movs	r4, #0
   96190:	f818 3b01 	ldrb.w	r3, [r8], #1
   96194:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   96198:	eb02 0444 	add.w	r4, r2, r4, lsl #1
   9619c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
   961a0:	2a09      	cmp	r2, #9
   961a2:	d9f5      	bls.n	96190 <_vfiprintf_r+0x5a0>
   961a4:	e58d      	b.n	95cc2 <_vfiprintf_r+0xd2>
   961a6:	f898 3000 	ldrb.w	r3, [r8]
   961aa:	2101      	movs	r1, #1
   961ac:	202b      	movs	r0, #43	; 0x2b
   961ae:	e586      	b.n	95cbe <_vfiprintf_r+0xce>
   961b0:	f898 3000 	ldrb.w	r3, [r8]
   961b4:	f108 0501 	add.w	r5, r8, #1
   961b8:	2b2a      	cmp	r3, #42	; 0x2a
   961ba:	f000 83cc 	beq.w	96956 <_vfiprintf_r+0xd66>
   961be:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
   961c2:	2a09      	cmp	r2, #9
   961c4:	46a8      	mov	r8, r5
   961c6:	bf98      	it	ls
   961c8:	2500      	movls	r5, #0
   961ca:	f200 83b5 	bhi.w	96938 <_vfiprintf_r+0xd48>
   961ce:	f818 3b01 	ldrb.w	r3, [r8], #1
   961d2:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   961d6:	eb02 0545 	add.w	r5, r2, r5, lsl #1
   961da:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
   961de:	2a09      	cmp	r2, #9
   961e0:	d9f5      	bls.n	961ce <_vfiprintf_r+0x5de>
   961e2:	ea45 72e5 	orr.w	r2, r5, r5, asr #31
   961e6:	9201      	str	r2, [sp, #4]
   961e8:	e56b      	b.n	95cc2 <_vfiprintf_r+0xd2>
   961ea:	9406      	str	r4, [sp, #24]
   961ec:	2900      	cmp	r1, #0
   961ee:	d08f      	beq.n	96110 <_vfiprintf_r+0x520>
   961f0:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
   961f4:	e78c      	b.n	96110 <_vfiprintf_r+0x520>
   961f6:	f04f 0300 	mov.w	r3, #0
   961fa:	9a04      	ldr	r2, [sp, #16]
   961fc:	9406      	str	r4, [sp, #24]
   961fe:	6817      	ldr	r7, [r2, #0]
   96200:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
   96204:	1d14      	adds	r4, r2, #4
   96206:	9b01      	ldr	r3, [sp, #4]
   96208:	2f00      	cmp	r7, #0
   9620a:	f000 837f 	beq.w	9690c <_vfiprintf_r+0xd1c>
   9620e:	2b00      	cmp	r3, #0
   96210:	f2c0 8353 	blt.w	968ba <_vfiprintf_r+0xcca>
   96214:	461a      	mov	r2, r3
   96216:	2100      	movs	r1, #0
   96218:	4638      	mov	r0, r7
   9621a:	f002 f9b5 	bl	98588 <memchr>
   9621e:	2800      	cmp	r0, #0
   96220:	f000 838e 	beq.w	96940 <_vfiprintf_r+0xd50>
   96224:	1bc3      	subs	r3, r0, r7
   96226:	9303      	str	r3, [sp, #12]
   96228:	2300      	movs	r3, #0
   9622a:	9404      	str	r4, [sp, #16]
   9622c:	f89d 902f 	ldrb.w	r9, [sp, #47]	; 0x2f
   96230:	9301      	str	r3, [sp, #4]
   96232:	e603      	b.n	95e3c <_vfiprintf_r+0x24c>
   96234:	9406      	str	r4, [sp, #24]
   96236:	2900      	cmp	r1, #0
   96238:	f040 839d 	bne.w	96976 <_vfiprintf_r+0xd86>
   9623c:	f016 0920 	ands.w	r9, r6, #32
   96240:	d134      	bne.n	962ac <_vfiprintf_r+0x6bc>
   96242:	f016 0310 	ands.w	r3, r6, #16
   96246:	d103      	bne.n	96250 <_vfiprintf_r+0x660>
   96248:	f016 0940 	ands.w	r9, r6, #64	; 0x40
   9624c:	f040 831f 	bne.w	9688e <_vfiprintf_r+0xc9e>
   96250:	9a04      	ldr	r2, [sp, #16]
   96252:	2500      	movs	r5, #0
   96254:	4613      	mov	r3, r2
   96256:	6814      	ldr	r4, [r2, #0]
   96258:	9a01      	ldr	r2, [sp, #4]
   9625a:	f88d 902f 	strb.w	r9, [sp, #47]	; 0x2f
   9625e:	2a00      	cmp	r2, #0
   96260:	f103 0304 	add.w	r3, r3, #4
   96264:	f2c0 8327 	blt.w	968b6 <_vfiprintf_r+0xcc6>
   96268:	ea54 0205 	orrs.w	r2, r4, r5
   9626c:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   96270:	9304      	str	r3, [sp, #16]
   96272:	f47f af22 	bne.w	960ba <_vfiprintf_r+0x4ca>
   96276:	9b01      	ldr	r3, [sp, #4]
   96278:	2b00      	cmp	r3, #0
   9627a:	f43f addb 	beq.w	95e34 <_vfiprintf_r+0x244>
   9627e:	2400      	movs	r4, #0
   96280:	af2a      	add	r7, sp, #168	; 0xa8
   96282:	3430      	adds	r4, #48	; 0x30
   96284:	f807 4d41 	strb.w	r4, [r7, #-65]!
   96288:	ebc7 030a 	rsb	r3, r7, sl
   9628c:	9303      	str	r3, [sp, #12]
   9628e:	e5d5      	b.n	95e3c <_vfiprintf_r+0x24c>
   96290:	f046 0620 	orr.w	r6, r6, #32
   96294:	f898 3000 	ldrb.w	r3, [r8]
   96298:	e511      	b.n	95cbe <_vfiprintf_r+0xce>
   9629a:	9406      	str	r4, [sp, #24]
   9629c:	2900      	cmp	r1, #0
   9629e:	f040 8375 	bne.w	9698c <_vfiprintf_r+0xd9c>
   962a2:	f046 0610 	orr.w	r6, r6, #16
   962a6:	f016 0920 	ands.w	r9, r6, #32
   962aa:	d0ca      	beq.n	96242 <_vfiprintf_r+0x652>
   962ac:	f04f 0200 	mov.w	r2, #0
   962b0:	9b04      	ldr	r3, [sp, #16]
   962b2:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
   962b6:	3307      	adds	r3, #7
   962b8:	f023 0307 	bic.w	r3, r3, #7
   962bc:	f103 0208 	add.w	r2, r3, #8
   962c0:	e9d3 4500 	ldrd	r4, r5, [r3]
   962c4:	9b01      	ldr	r3, [sp, #4]
   962c6:	9204      	str	r2, [sp, #16]
   962c8:	2b00      	cmp	r3, #0
   962ca:	f2c0 81f9 	blt.w	966c0 <_vfiprintf_r+0xad0>
   962ce:	ea54 0305 	orrs.w	r3, r4, r5
   962d2:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   962d6:	f04f 0900 	mov.w	r9, #0
   962da:	f47f aeee 	bne.w	960ba <_vfiprintf_r+0x4ca>
   962de:	e7ca      	b.n	96276 <_vfiprintf_r+0x686>
   962e0:	9406      	str	r4, [sp, #24]
   962e2:	2900      	cmp	r1, #0
   962e4:	f040 8355 	bne.w	96992 <_vfiprintf_r+0xda2>
   962e8:	06b2      	lsls	r2, r6, #26
   962ea:	48b2      	ldr	r0, [pc, #712]	; (965b4 <_vfiprintf_r+0x9c4>)
   962ec:	d541      	bpl.n	96372 <_vfiprintf_r+0x782>
   962ee:	9a04      	ldr	r2, [sp, #16]
   962f0:	3207      	adds	r2, #7
   962f2:	f022 0207 	bic.w	r2, r2, #7
   962f6:	f102 0108 	add.w	r1, r2, #8
   962fa:	9104      	str	r1, [sp, #16]
   962fc:	e9d2 4500 	ldrd	r4, r5, [r2]
   96300:	f016 0901 	ands.w	r9, r6, #1
   96304:	f000 817e 	beq.w	96604 <_vfiprintf_r+0xa14>
   96308:	ea54 0205 	orrs.w	r2, r4, r5
   9630c:	f040 822b 	bne.w	96766 <_vfiprintf_r+0xb76>
   96310:	f04f 0300 	mov.w	r3, #0
   96314:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
   96318:	9b01      	ldr	r3, [sp, #4]
   9631a:	2b00      	cmp	r3, #0
   9631c:	f2c0 82f3 	blt.w	96906 <_vfiprintf_r+0xd16>
   96320:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   96324:	e581      	b.n	95e2a <_vfiprintf_r+0x23a>
   96326:	9a04      	ldr	r2, [sp, #16]
   96328:	f04f 0100 	mov.w	r1, #0
   9632c:	6813      	ldr	r3, [r2, #0]
   9632e:	2501      	movs	r5, #1
   96330:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   96334:	4613      	mov	r3, r2
   96336:	3304      	adds	r3, #4
   96338:	9406      	str	r4, [sp, #24]
   9633a:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
   9633e:	9304      	str	r3, [sp, #16]
   96340:	9503      	str	r5, [sp, #12]
   96342:	af10      	add	r7, sp, #64	; 0x40
   96344:	2300      	movs	r3, #0
   96346:	9301      	str	r3, [sp, #4]
   96348:	e582      	b.n	95e50 <_vfiprintf_r+0x260>
   9634a:	f898 3000 	ldrb.w	r3, [r8]
   9634e:	2800      	cmp	r0, #0
   96350:	f47f acb5 	bne.w	95cbe <_vfiprintf_r+0xce>
   96354:	2101      	movs	r1, #1
   96356:	2020      	movs	r0, #32
   96358:	e4b1      	b.n	95cbe <_vfiprintf_r+0xce>
   9635a:	f046 0601 	orr.w	r6, r6, #1
   9635e:	f898 3000 	ldrb.w	r3, [r8]
   96362:	e4ac      	b.n	95cbe <_vfiprintf_r+0xce>
   96364:	9406      	str	r4, [sp, #24]
   96366:	2900      	cmp	r1, #0
   96368:	f040 832a 	bne.w	969c0 <_vfiprintf_r+0xdd0>
   9636c:	06b2      	lsls	r2, r6, #26
   9636e:	4892      	ldr	r0, [pc, #584]	; (965b8 <_vfiprintf_r+0x9c8>)
   96370:	d4bd      	bmi.n	962ee <_vfiprintf_r+0x6fe>
   96372:	9904      	ldr	r1, [sp, #16]
   96374:	06f7      	lsls	r7, r6, #27
   96376:	460a      	mov	r2, r1
   96378:	f100 819d 	bmi.w	966b6 <_vfiprintf_r+0xac6>
   9637c:	0675      	lsls	r5, r6, #25
   9637e:	f140 819a 	bpl.w	966b6 <_vfiprintf_r+0xac6>
   96382:	3204      	adds	r2, #4
   96384:	880c      	ldrh	r4, [r1, #0]
   96386:	9204      	str	r2, [sp, #16]
   96388:	2500      	movs	r5, #0
   9638a:	e7b9      	b.n	96300 <_vfiprintf_r+0x710>
   9638c:	f046 0640 	orr.w	r6, r6, #64	; 0x40
   96390:	f898 3000 	ldrb.w	r3, [r8]
   96394:	e493      	b.n	95cbe <_vfiprintf_r+0xce>
   96396:	f898 3000 	ldrb.w	r3, [r8]
   9639a:	2b6c      	cmp	r3, #108	; 0x6c
   9639c:	bf03      	ittte	eq
   9639e:	f898 3001 	ldrbeq.w	r3, [r8, #1]
   963a2:	f046 0620 	orreq.w	r6, r6, #32
   963a6:	f108 0801 	addeq.w	r8, r8, #1
   963aa:	f046 0610 	orrne.w	r6, r6, #16
   963ae:	e486      	b.n	95cbe <_vfiprintf_r+0xce>
   963b0:	2900      	cmp	r1, #0
   963b2:	f040 8302 	bne.w	969ba <_vfiprintf_r+0xdca>
   963b6:	06b4      	lsls	r4, r6, #26
   963b8:	f140 8220 	bpl.w	967fc <_vfiprintf_r+0xc0c>
   963bc:	9a04      	ldr	r2, [sp, #16]
   963be:	4613      	mov	r3, r2
   963c0:	3304      	adds	r3, #4
   963c2:	9304      	str	r3, [sp, #16]
   963c4:	9b02      	ldr	r3, [sp, #8]
   963c6:	6811      	ldr	r1, [r2, #0]
   963c8:	17dd      	asrs	r5, r3, #31
   963ca:	461a      	mov	r2, r3
   963cc:	462b      	mov	r3, r5
   963ce:	e9c1 2300 	strd	r2, r3, [r1]
   963d2:	e43e      	b.n	95c52 <_vfiprintf_r+0x62>
   963d4:	9406      	str	r4, [sp, #24]
   963d6:	2900      	cmp	r1, #0
   963d8:	f43f ae51 	beq.w	9607e <_vfiprintf_r+0x48e>
   963dc:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
   963e0:	e64d      	b.n	9607e <_vfiprintf_r+0x48e>
   963e2:	9406      	str	r4, [sp, #24]
   963e4:	2900      	cmp	r1, #0
   963e6:	f040 82e5 	bne.w	969b4 <_vfiprintf_r+0xdc4>
   963ea:	2b00      	cmp	r3, #0
   963ec:	f000 8094 	beq.w	96518 <_vfiprintf_r+0x928>
   963f0:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   963f4:	f04f 0300 	mov.w	r3, #0
   963f8:	2501      	movs	r5, #1
   963fa:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
   963fe:	9503      	str	r5, [sp, #12]
   96400:	af10      	add	r7, sp, #64	; 0x40
   96402:	e79f      	b.n	96344 <_vfiprintf_r+0x754>
   96404:	aa0d      	add	r2, sp, #52	; 0x34
   96406:	9900      	ldr	r1, [sp, #0]
   96408:	4648      	mov	r0, r9
   9640a:	9309      	str	r3, [sp, #36]	; 0x24
   9640c:	f7ff fbb4 	bl	95b78 <__sprint_r.part.0>
   96410:	2800      	cmp	r0, #0
   96412:	f040 8088 	bne.w	96526 <_vfiprintf_r+0x936>
   96416:	980e      	ldr	r0, [sp, #56]	; 0x38
   96418:	46d4      	mov	ip, sl
   9641a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   9641c:	f100 0e01 	add.w	lr, r0, #1
   96420:	9b09      	ldr	r3, [sp, #36]	; 0x24
   96422:	e53a      	b.n	95e9a <_vfiprintf_r+0x2aa>
   96424:	aa0d      	add	r2, sp, #52	; 0x34
   96426:	9900      	ldr	r1, [sp, #0]
   96428:	9805      	ldr	r0, [sp, #20]
   9642a:	f7ff fba5 	bl	95b78 <__sprint_r.part.0>
   9642e:	2800      	cmp	r0, #0
   96430:	d179      	bne.n	96526 <_vfiprintf_r+0x936>
   96432:	46d3      	mov	fp, sl
   96434:	980e      	ldr	r0, [sp, #56]	; 0x38
   96436:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   9643a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   9643c:	f100 0e01 	add.w	lr, r0, #1
   96440:	2b00      	cmp	r3, #0
   96442:	f43f ad59 	beq.w	95ef8 <_vfiprintf_r+0x308>
   96446:	3201      	adds	r2, #1
   96448:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
   9644c:	2301      	movs	r3, #1
   9644e:	f1be 0f07 	cmp.w	lr, #7
   96452:	920f      	str	r2, [sp, #60]	; 0x3c
   96454:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
   96458:	e88b 000a 	stmia.w	fp, {r1, r3}
   9645c:	f340 80c0 	ble.w	965e0 <_vfiprintf_r+0x9f0>
   96460:	2a00      	cmp	r2, #0
   96462:	f040 814d 	bne.w	96700 <_vfiprintf_r+0xb10>
   96466:	9907      	ldr	r1, [sp, #28]
   96468:	2900      	cmp	r1, #0
   9646a:	f040 80bf 	bne.w	965ec <_vfiprintf_r+0x9fc>
   9646e:	469e      	mov	lr, r3
   96470:	4610      	mov	r0, r2
   96472:	46d3      	mov	fp, sl
   96474:	9b08      	ldr	r3, [sp, #32]
   96476:	2b80      	cmp	r3, #128	; 0x80
   96478:	f43f ad59 	beq.w	95f2e <_vfiprintf_r+0x33e>
   9647c:	9b01      	ldr	r3, [sp, #4]
   9647e:	9903      	ldr	r1, [sp, #12]
   96480:	1a5c      	subs	r4, r3, r1
   96482:	2c00      	cmp	r4, #0
   96484:	f77f ad9c 	ble.w	95fc0 <_vfiprintf_r+0x3d0>
   96488:	2c10      	cmp	r4, #16
   9648a:	f8df 9130 	ldr.w	r9, [pc, #304]	; 965bc <_vfiprintf_r+0x9cc>
   9648e:	dd25      	ble.n	964dc <_vfiprintf_r+0x8ec>
   96490:	46dc      	mov	ip, fp
   96492:	2310      	movs	r3, #16
   96494:	46c3      	mov	fp, r8
   96496:	46a8      	mov	r8, r5
   96498:	464d      	mov	r5, r9
   9649a:	f8dd 9014 	ldr.w	r9, [sp, #20]
   9649e:	e007      	b.n	964b0 <_vfiprintf_r+0x8c0>
   964a0:	f100 0e02 	add.w	lr, r0, #2
   964a4:	4608      	mov	r0, r1
   964a6:	f10c 0c08 	add.w	ip, ip, #8
   964aa:	3c10      	subs	r4, #16
   964ac:	2c10      	cmp	r4, #16
   964ae:	dd11      	ble.n	964d4 <_vfiprintf_r+0x8e4>
   964b0:	1c41      	adds	r1, r0, #1
   964b2:	3210      	adds	r2, #16
   964b4:	2907      	cmp	r1, #7
   964b6:	920f      	str	r2, [sp, #60]	; 0x3c
   964b8:	f8cc 5000 	str.w	r5, [ip]
   964bc:	f8cc 3004 	str.w	r3, [ip, #4]
   964c0:	910e      	str	r1, [sp, #56]	; 0x38
   964c2:	dded      	ble.n	964a0 <_vfiprintf_r+0x8b0>
   964c4:	b9d2      	cbnz	r2, 964fc <_vfiprintf_r+0x90c>
   964c6:	3c10      	subs	r4, #16
   964c8:	2c10      	cmp	r4, #16
   964ca:	f04f 0e01 	mov.w	lr, #1
   964ce:	4610      	mov	r0, r2
   964d0:	46d4      	mov	ip, sl
   964d2:	dced      	bgt.n	964b0 <_vfiprintf_r+0x8c0>
   964d4:	46a9      	mov	r9, r5
   964d6:	4645      	mov	r5, r8
   964d8:	46d8      	mov	r8, fp
   964da:	46e3      	mov	fp, ip
   964dc:	4422      	add	r2, r4
   964de:	f1be 0f07 	cmp.w	lr, #7
   964e2:	920f      	str	r2, [sp, #60]	; 0x3c
   964e4:	f8cb 9000 	str.w	r9, [fp]
   964e8:	f8cb 4004 	str.w	r4, [fp, #4]
   964ec:	f8cd e038 	str.w	lr, [sp, #56]	; 0x38
   964f0:	dc2e      	bgt.n	96550 <_vfiprintf_r+0x960>
   964f2:	f10b 0b08 	add.w	fp, fp, #8
   964f6:	f10e 0e01 	add.w	lr, lr, #1
   964fa:	e561      	b.n	95fc0 <_vfiprintf_r+0x3d0>
   964fc:	aa0d      	add	r2, sp, #52	; 0x34
   964fe:	9900      	ldr	r1, [sp, #0]
   96500:	4648      	mov	r0, r9
   96502:	9301      	str	r3, [sp, #4]
   96504:	f7ff fb38 	bl	95b78 <__sprint_r.part.0>
   96508:	b968      	cbnz	r0, 96526 <_vfiprintf_r+0x936>
   9650a:	980e      	ldr	r0, [sp, #56]	; 0x38
   9650c:	46d4      	mov	ip, sl
   9650e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   96510:	f100 0e01 	add.w	lr, r0, #1
   96514:	9b01      	ldr	r3, [sp, #4]
   96516:	e7c8      	b.n	964aa <_vfiprintf_r+0x8ba>
   96518:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   9651a:	b123      	cbz	r3, 96526 <_vfiprintf_r+0x936>
   9651c:	9805      	ldr	r0, [sp, #20]
   9651e:	aa0d      	add	r2, sp, #52	; 0x34
   96520:	9900      	ldr	r1, [sp, #0]
   96522:	f7ff fb29 	bl	95b78 <__sprint_r.part.0>
   96526:	9b00      	ldr	r3, [sp, #0]
   96528:	899b      	ldrh	r3, [r3, #12]
   9652a:	065a      	lsls	r2, r3, #25
   9652c:	f100 817b 	bmi.w	96826 <_vfiprintf_r+0xc36>
   96530:	9802      	ldr	r0, [sp, #8]
   96532:	b02b      	add	sp, #172	; 0xac
   96534:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   96538:	aa0d      	add	r2, sp, #52	; 0x34
   9653a:	9900      	ldr	r1, [sp, #0]
   9653c:	4648      	mov	r0, r9
   9653e:	f7ff fb1b 	bl	95b78 <__sprint_r.part.0>
   96542:	2800      	cmp	r0, #0
   96544:	d1ef      	bne.n	96526 <_vfiprintf_r+0x936>
   96546:	990e      	ldr	r1, [sp, #56]	; 0x38
   96548:	46d3      	mov	fp, sl
   9654a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   9654c:	1c48      	adds	r0, r1, #1
   9654e:	e55e      	b.n	9600e <_vfiprintf_r+0x41e>
   96550:	2a00      	cmp	r2, #0
   96552:	f040 80fa 	bne.w	9674a <_vfiprintf_r+0xb5a>
   96556:	46d3      	mov	fp, sl
   96558:	9a03      	ldr	r2, [sp, #12]
   9655a:	2301      	movs	r3, #1
   9655c:	921b      	str	r2, [sp, #108]	; 0x6c
   9655e:	920f      	str	r2, [sp, #60]	; 0x3c
   96560:	971a      	str	r7, [sp, #104]	; 0x68
   96562:	930e      	str	r3, [sp, #56]	; 0x38
   96564:	f10b 0b08 	add.w	fp, fp, #8
   96568:	0771      	lsls	r1, r6, #29
   9656a:	d504      	bpl.n	96576 <_vfiprintf_r+0x986>
   9656c:	9b06      	ldr	r3, [sp, #24]
   9656e:	1b5c      	subs	r4, r3, r5
   96570:	2c00      	cmp	r4, #0
   96572:	f73f ad3d 	bgt.w	95ff0 <_vfiprintf_r+0x400>
   96576:	9b02      	ldr	r3, [sp, #8]
   96578:	9906      	ldr	r1, [sp, #24]
   9657a:	42a9      	cmp	r1, r5
   9657c:	bfac      	ite	ge
   9657e:	185b      	addge	r3, r3, r1
   96580:	195b      	addlt	r3, r3, r5
   96582:	9302      	str	r3, [sp, #8]
   96584:	2a00      	cmp	r2, #0
   96586:	f040 80ad 	bne.w	966e4 <_vfiprintf_r+0xaf4>
   9658a:	2300      	movs	r3, #0
   9658c:	930e      	str	r3, [sp, #56]	; 0x38
   9658e:	46d3      	mov	fp, sl
   96590:	f7ff bb5f 	b.w	95c52 <_vfiprintf_r+0x62>
   96594:	aa0d      	add	r2, sp, #52	; 0x34
   96596:	9900      	ldr	r1, [sp, #0]
   96598:	4648      	mov	r0, r9
   9659a:	9307      	str	r3, [sp, #28]
   9659c:	f7ff faec 	bl	95b78 <__sprint_r.part.0>
   965a0:	2800      	cmp	r0, #0
   965a2:	d1c0      	bne.n	96526 <_vfiprintf_r+0x936>
   965a4:	980e      	ldr	r0, [sp, #56]	; 0x38
   965a6:	46d6      	mov	lr, sl
   965a8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   965aa:	f100 0c01 	add.w	ip, r0, #1
   965ae:	9b07      	ldr	r3, [sp, #28]
   965b0:	e4d4      	b.n	95f5c <_vfiprintf_r+0x36c>
   965b2:	bf00      	nop
   965b4:	0009b198 	.word	0x0009b198
   965b8:	0009b1ac 	.word	0x0009b1ac
   965bc:	0009b1dc 	.word	0x0009b1dc
   965c0:	2a00      	cmp	r2, #0
   965c2:	f47f af2f 	bne.w	96424 <_vfiprintf_r+0x834>
   965c6:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   965ca:	2b00      	cmp	r3, #0
   965cc:	f000 80f3 	beq.w	967b6 <_vfiprintf_r+0xbc6>
   965d0:	2301      	movs	r3, #1
   965d2:	461a      	mov	r2, r3
   965d4:	469e      	mov	lr, r3
   965d6:	46d3      	mov	fp, sl
   965d8:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
   965dc:	931b      	str	r3, [sp, #108]	; 0x6c
   965de:	911a      	str	r1, [sp, #104]	; 0x68
   965e0:	4670      	mov	r0, lr
   965e2:	f10b 0b08 	add.w	fp, fp, #8
   965e6:	f10e 0e01 	add.w	lr, lr, #1
   965ea:	e485      	b.n	95ef8 <_vfiprintf_r+0x308>
   965ec:	469e      	mov	lr, r3
   965ee:	46d3      	mov	fp, sl
   965f0:	a90c      	add	r1, sp, #48	; 0x30
   965f2:	2202      	movs	r2, #2
   965f4:	911a      	str	r1, [sp, #104]	; 0x68
   965f6:	921b      	str	r2, [sp, #108]	; 0x6c
   965f8:	4670      	mov	r0, lr
   965fa:	f10b 0b08 	add.w	fp, fp, #8
   965fe:	f10e 0e01 	add.w	lr, lr, #1
   96602:	e737      	b.n	96474 <_vfiprintf_r+0x884>
   96604:	9b01      	ldr	r3, [sp, #4]
   96606:	f88d 902f 	strb.w	r9, [sp, #47]	; 0x2f
   9660a:	2b00      	cmp	r3, #0
   9660c:	f2c0 811b 	blt.w	96846 <_vfiprintf_r+0xc56>
   96610:	ea54 0305 	orrs.w	r3, r4, r5
   96614:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   96618:	f43f ac07 	beq.w	95e2a <_vfiprintf_r+0x23a>
   9661c:	4657      	mov	r7, sl
   9661e:	0923      	lsrs	r3, r4, #4
   96620:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
   96624:	0929      	lsrs	r1, r5, #4
   96626:	f004 020f 	and.w	r2, r4, #15
   9662a:	460d      	mov	r5, r1
   9662c:	461c      	mov	r4, r3
   9662e:	5c83      	ldrb	r3, [r0, r2]
   96630:	f807 3d01 	strb.w	r3, [r7, #-1]!
   96634:	ea54 0305 	orrs.w	r3, r4, r5
   96638:	d1f1      	bne.n	9661e <_vfiprintf_r+0xa2e>
   9663a:	ebc7 030a 	rsb	r3, r7, sl
   9663e:	9303      	str	r3, [sp, #12]
   96640:	f7ff bbfc 	b.w	95e3c <_vfiprintf_r+0x24c>
   96644:	aa0d      	add	r2, sp, #52	; 0x34
   96646:	9900      	ldr	r1, [sp, #0]
   96648:	9805      	ldr	r0, [sp, #20]
   9664a:	f7ff fa95 	bl	95b78 <__sprint_r.part.0>
   9664e:	2800      	cmp	r0, #0
   96650:	f47f af69 	bne.w	96526 <_vfiprintf_r+0x936>
   96654:	46d3      	mov	fp, sl
   96656:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   96658:	e786      	b.n	96568 <_vfiprintf_r+0x978>
   9665a:	f016 0210 	ands.w	r2, r6, #16
   9665e:	f000 80b5 	beq.w	967cc <_vfiprintf_r+0xbdc>
   96662:	9904      	ldr	r1, [sp, #16]
   96664:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
   96668:	460a      	mov	r2, r1
   9666a:	680c      	ldr	r4, [r1, #0]
   9666c:	9901      	ldr	r1, [sp, #4]
   9666e:	3204      	adds	r2, #4
   96670:	2900      	cmp	r1, #0
   96672:	f04f 0500 	mov.w	r5, #0
   96676:	f2c0 8152 	blt.w	9691e <_vfiprintf_r+0xd2e>
   9667a:	ea54 0105 	orrs.w	r1, r4, r5
   9667e:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   96682:	9204      	str	r2, [sp, #16]
   96684:	f43f ad5d 	beq.w	96142 <_vfiprintf_r+0x552>
   96688:	4699      	mov	r9, r3
   9668a:	e562      	b.n	96152 <_vfiprintf_r+0x562>
   9668c:	9a04      	ldr	r2, [sp, #16]
   9668e:	06f7      	lsls	r7, r6, #27
   96690:	4613      	mov	r3, r2
   96692:	d409      	bmi.n	966a8 <_vfiprintf_r+0xab8>
   96694:	0675      	lsls	r5, r6, #25
   96696:	d507      	bpl.n	966a8 <_vfiprintf_r+0xab8>
   96698:	f9b2 4000 	ldrsh.w	r4, [r2]
   9669c:	3304      	adds	r3, #4
   9669e:	17e5      	asrs	r5, r4, #31
   966a0:	9304      	str	r3, [sp, #16]
   966a2:	4622      	mov	r2, r4
   966a4:	462b      	mov	r3, r5
   966a6:	e4f7      	b.n	96098 <_vfiprintf_r+0x4a8>
   966a8:	681c      	ldr	r4, [r3, #0]
   966aa:	3304      	adds	r3, #4
   966ac:	17e5      	asrs	r5, r4, #31
   966ae:	9304      	str	r3, [sp, #16]
   966b0:	4622      	mov	r2, r4
   966b2:	462b      	mov	r3, r5
   966b4:	e4f0      	b.n	96098 <_vfiprintf_r+0x4a8>
   966b6:	6814      	ldr	r4, [r2, #0]
   966b8:	3204      	adds	r2, #4
   966ba:	9204      	str	r2, [sp, #16]
   966bc:	2500      	movs	r5, #0
   966be:	e61f      	b.n	96300 <_vfiprintf_r+0x710>
   966c0:	f04f 0900 	mov.w	r9, #0
   966c4:	ea54 0305 	orrs.w	r3, r4, r5
   966c8:	f47f acf7 	bne.w	960ba <_vfiprintf_r+0x4ca>
   966cc:	e5d8      	b.n	96280 <_vfiprintf_r+0x690>
   966ce:	aa0d      	add	r2, sp, #52	; 0x34
   966d0:	9900      	ldr	r1, [sp, #0]
   966d2:	9805      	ldr	r0, [sp, #20]
   966d4:	f7ff fa50 	bl	95b78 <__sprint_r.part.0>
   966d8:	2800      	cmp	r0, #0
   966da:	f47f af24 	bne.w	96526 <_vfiprintf_r+0x936>
   966de:	46d3      	mov	fp, sl
   966e0:	f7ff bb51 	b.w	95d86 <_vfiprintf_r+0x196>
   966e4:	aa0d      	add	r2, sp, #52	; 0x34
   966e6:	9900      	ldr	r1, [sp, #0]
   966e8:	9805      	ldr	r0, [sp, #20]
   966ea:	f7ff fa45 	bl	95b78 <__sprint_r.part.0>
   966ee:	2800      	cmp	r0, #0
   966f0:	f43f af4b 	beq.w	9658a <_vfiprintf_r+0x99a>
   966f4:	e717      	b.n	96526 <_vfiprintf_r+0x936>
   966f6:	2400      	movs	r4, #0
   966f8:	2500      	movs	r5, #0
   966fa:	f04f 0900 	mov.w	r9, #0
   966fe:	e78d      	b.n	9661c <_vfiprintf_r+0xa2c>
   96700:	aa0d      	add	r2, sp, #52	; 0x34
   96702:	9900      	ldr	r1, [sp, #0]
   96704:	9805      	ldr	r0, [sp, #20]
   96706:	f7ff fa37 	bl	95b78 <__sprint_r.part.0>
   9670a:	2800      	cmp	r0, #0
   9670c:	f47f af0b 	bne.w	96526 <_vfiprintf_r+0x936>
   96710:	980e      	ldr	r0, [sp, #56]	; 0x38
   96712:	46d3      	mov	fp, sl
   96714:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   96716:	f100 0e01 	add.w	lr, r0, #1
   9671a:	f7ff bbed 	b.w	95ef8 <_vfiprintf_r+0x308>
   9671e:	aa0d      	add	r2, sp, #52	; 0x34
   96720:	9900      	ldr	r1, [sp, #0]
   96722:	9805      	ldr	r0, [sp, #20]
   96724:	f7ff fa28 	bl	95b78 <__sprint_r.part.0>
   96728:	2800      	cmp	r0, #0
   9672a:	f47f aefc 	bne.w	96526 <_vfiprintf_r+0x936>
   9672e:	980e      	ldr	r0, [sp, #56]	; 0x38
   96730:	46d3      	mov	fp, sl
   96732:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   96734:	f100 0e01 	add.w	lr, r0, #1
   96738:	e69c      	b.n	96474 <_vfiprintf_r+0x884>
   9673a:	2a00      	cmp	r2, #0
   9673c:	f040 80c8 	bne.w	968d0 <_vfiprintf_r+0xce0>
   96740:	f04f 0e01 	mov.w	lr, #1
   96744:	4610      	mov	r0, r2
   96746:	46d3      	mov	fp, sl
   96748:	e698      	b.n	9647c <_vfiprintf_r+0x88c>
   9674a:	aa0d      	add	r2, sp, #52	; 0x34
   9674c:	9900      	ldr	r1, [sp, #0]
   9674e:	9805      	ldr	r0, [sp, #20]
   96750:	f7ff fa12 	bl	95b78 <__sprint_r.part.0>
   96754:	2800      	cmp	r0, #0
   96756:	f47f aee6 	bne.w	96526 <_vfiprintf_r+0x936>
   9675a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   9675c:	46d3      	mov	fp, sl
   9675e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   96760:	f103 0e01 	add.w	lr, r3, #1
   96764:	e42c      	b.n	95fc0 <_vfiprintf_r+0x3d0>
   96766:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
   9676a:	f04f 0300 	mov.w	r3, #0
   9676e:	2230      	movs	r2, #48	; 0x30
   96770:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
   96774:	9a01      	ldr	r2, [sp, #4]
   96776:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
   9677a:	2a00      	cmp	r2, #0
   9677c:	f046 0302 	orr.w	r3, r6, #2
   96780:	f2c0 80bb 	blt.w	968fa <_vfiprintf_r+0xd0a>
   96784:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   96788:	f046 0602 	orr.w	r6, r6, #2
   9678c:	f04f 0900 	mov.w	r9, #0
   96790:	e744      	b.n	9661c <_vfiprintf_r+0xa2c>
   96792:	f04f 0900 	mov.w	r9, #0
   96796:	488c      	ldr	r0, [pc, #560]	; (969c8 <_vfiprintf_r+0xdd8>)
   96798:	e740      	b.n	9661c <_vfiprintf_r+0xa2c>
   9679a:	9b01      	ldr	r3, [sp, #4]
   9679c:	4264      	negs	r4, r4
   9679e:	f04f 092d 	mov.w	r9, #45	; 0x2d
   967a2:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
   967a6:	2b00      	cmp	r3, #0
   967a8:	f88d 902f 	strb.w	r9, [sp, #47]	; 0x2f
   967ac:	f6ff ac85 	blt.w	960ba <_vfiprintf_r+0x4ca>
   967b0:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   967b4:	e481      	b.n	960ba <_vfiprintf_r+0x4ca>
   967b6:	9b07      	ldr	r3, [sp, #28]
   967b8:	2b00      	cmp	r3, #0
   967ba:	d063      	beq.n	96884 <_vfiprintf_r+0xc94>
   967bc:	ab0c      	add	r3, sp, #48	; 0x30
   967be:	2202      	movs	r2, #2
   967c0:	931a      	str	r3, [sp, #104]	; 0x68
   967c2:	921b      	str	r2, [sp, #108]	; 0x6c
   967c4:	f04f 0e01 	mov.w	lr, #1
   967c8:	46d3      	mov	fp, sl
   967ca:	e715      	b.n	965f8 <_vfiprintf_r+0xa08>
   967cc:	f016 0940 	ands.w	r9, r6, #64	; 0x40
   967d0:	d03b      	beq.n	9684a <_vfiprintf_r+0xc5a>
   967d2:	9904      	ldr	r1, [sp, #16]
   967d4:	f88d 202f 	strb.w	r2, [sp, #47]	; 0x2f
   967d8:	460b      	mov	r3, r1
   967da:	880c      	ldrh	r4, [r1, #0]
   967dc:	9901      	ldr	r1, [sp, #4]
   967de:	3304      	adds	r3, #4
   967e0:	2900      	cmp	r1, #0
   967e2:	f04f 0500 	mov.w	r5, #0
   967e6:	f2c0 808c 	blt.w	96902 <_vfiprintf_r+0xd12>
   967ea:	ea54 0105 	orrs.w	r1, r4, r5
   967ee:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   967f2:	9304      	str	r3, [sp, #16]
   967f4:	f43f aca5 	beq.w	96142 <_vfiprintf_r+0x552>
   967f8:	4691      	mov	r9, r2
   967fa:	e4aa      	b.n	96152 <_vfiprintf_r+0x562>
   967fc:	06f0      	lsls	r0, r6, #27
   967fe:	d40a      	bmi.n	96816 <_vfiprintf_r+0xc26>
   96800:	0671      	lsls	r1, r6, #25
   96802:	d508      	bpl.n	96816 <_vfiprintf_r+0xc26>
   96804:	9a04      	ldr	r2, [sp, #16]
   96806:	6813      	ldr	r3, [r2, #0]
   96808:	3204      	adds	r2, #4
   9680a:	9204      	str	r2, [sp, #16]
   9680c:	f8bd 2008 	ldrh.w	r2, [sp, #8]
   96810:	801a      	strh	r2, [r3, #0]
   96812:	f7ff ba1e 	b.w	95c52 <_vfiprintf_r+0x62>
   96816:	9a04      	ldr	r2, [sp, #16]
   96818:	6813      	ldr	r3, [r2, #0]
   9681a:	3204      	adds	r2, #4
   9681c:	9204      	str	r2, [sp, #16]
   9681e:	9a02      	ldr	r2, [sp, #8]
   96820:	601a      	str	r2, [r3, #0]
   96822:	f7ff ba16 	b.w	95c52 <_vfiprintf_r+0x62>
   96826:	f04f 30ff 	mov.w	r0, #4294967295
   9682a:	f7ff bac9 	b.w	95dc0 <_vfiprintf_r+0x1d0>
   9682e:	4616      	mov	r6, r2
   96830:	4865      	ldr	r0, [pc, #404]	; (969c8 <_vfiprintf_r+0xdd8>)
   96832:	ea54 0205 	orrs.w	r2, r4, r5
   96836:	9304      	str	r3, [sp, #16]
   96838:	f04f 0900 	mov.w	r9, #0
   9683c:	f47f aeee 	bne.w	9661c <_vfiprintf_r+0xa2c>
   96840:	2400      	movs	r4, #0
   96842:	2500      	movs	r5, #0
   96844:	e6ea      	b.n	9661c <_vfiprintf_r+0xa2c>
   96846:	9b04      	ldr	r3, [sp, #16]
   96848:	e7f3      	b.n	96832 <_vfiprintf_r+0xc42>
   9684a:	9a04      	ldr	r2, [sp, #16]
   9684c:	f88d 902f 	strb.w	r9, [sp, #47]	; 0x2f
   96850:	4613      	mov	r3, r2
   96852:	6814      	ldr	r4, [r2, #0]
   96854:	9a01      	ldr	r2, [sp, #4]
   96856:	3304      	adds	r3, #4
   96858:	2a00      	cmp	r2, #0
   9685a:	f04f 0500 	mov.w	r5, #0
   9685e:	db50      	blt.n	96902 <_vfiprintf_r+0xd12>
   96860:	ea54 0205 	orrs.w	r2, r4, r5
   96864:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   96868:	9304      	str	r3, [sp, #16]
   9686a:	f47f ac72 	bne.w	96152 <_vfiprintf_r+0x562>
   9686e:	e468      	b.n	96142 <_vfiprintf_r+0x552>
   96870:	aa0d      	add	r2, sp, #52	; 0x34
   96872:	9900      	ldr	r1, [sp, #0]
   96874:	9805      	ldr	r0, [sp, #20]
   96876:	f7ff f97f 	bl	95b78 <__sprint_r.part.0>
   9687a:	2800      	cmp	r0, #0
   9687c:	f47f ae53 	bne.w	96526 <_vfiprintf_r+0x936>
   96880:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   96882:	e678      	b.n	96576 <_vfiprintf_r+0x986>
   96884:	4610      	mov	r0, r2
   96886:	f04f 0e01 	mov.w	lr, #1
   9688a:	46d3      	mov	fp, sl
   9688c:	e5f6      	b.n	9647c <_vfiprintf_r+0x88c>
   9688e:	9904      	ldr	r1, [sp, #16]
   96890:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
   96894:	460a      	mov	r2, r1
   96896:	880c      	ldrh	r4, [r1, #0]
   96898:	9901      	ldr	r1, [sp, #4]
   9689a:	3204      	adds	r2, #4
   9689c:	2900      	cmp	r1, #0
   9689e:	f04f 0500 	mov.w	r5, #0
   968a2:	db55      	blt.n	96950 <_vfiprintf_r+0xd60>
   968a4:	ea54 0105 	orrs.w	r1, r4, r5
   968a8:	f026 0680 	bic.w	r6, r6, #128	; 0x80
   968ac:	9204      	str	r2, [sp, #16]
   968ae:	4699      	mov	r9, r3
   968b0:	f47f ac03 	bne.w	960ba <_vfiprintf_r+0x4ca>
   968b4:	e4df      	b.n	96276 <_vfiprintf_r+0x686>
   968b6:	9304      	str	r3, [sp, #16]
   968b8:	e704      	b.n	966c4 <_vfiprintf_r+0xad4>
   968ba:	4638      	mov	r0, r7
   968bc:	9404      	str	r4, [sp, #16]
   968be:	f7fd fd43 	bl	94348 <strlen>
   968c2:	2300      	movs	r3, #0
   968c4:	9003      	str	r0, [sp, #12]
   968c6:	f89d 902f 	ldrb.w	r9, [sp, #47]	; 0x2f
   968ca:	9301      	str	r3, [sp, #4]
   968cc:	f7ff bab6 	b.w	95e3c <_vfiprintf_r+0x24c>
   968d0:	aa0d      	add	r2, sp, #52	; 0x34
   968d2:	9900      	ldr	r1, [sp, #0]
   968d4:	9805      	ldr	r0, [sp, #20]
   968d6:	f7ff f94f 	bl	95b78 <__sprint_r.part.0>
   968da:	2800      	cmp	r0, #0
   968dc:	f47f ae23 	bne.w	96526 <_vfiprintf_r+0x936>
   968e0:	980e      	ldr	r0, [sp, #56]	; 0x38
   968e2:	46d3      	mov	fp, sl
   968e4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   968e6:	f100 0e01 	add.w	lr, r0, #1
   968ea:	e5c7      	b.n	9647c <_vfiprintf_r+0x88c>
   968ec:	980e      	ldr	r0, [sp, #56]	; 0x38
   968ee:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   968f0:	3001      	adds	r0, #1
   968f2:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 969d0 <_vfiprintf_r+0xde0>
   968f6:	f7ff baec 	b.w	95ed2 <_vfiprintf_r+0x2e2>
   968fa:	461e      	mov	r6, r3
   968fc:	f04f 0900 	mov.w	r9, #0
   96900:	e68c      	b.n	9661c <_vfiprintf_r+0xa2c>
   96902:	9304      	str	r3, [sp, #16]
   96904:	e423      	b.n	9614e <_vfiprintf_r+0x55e>
   96906:	f04f 0900 	mov.w	r9, #0
   9690a:	e799      	b.n	96840 <_vfiprintf_r+0xc50>
   9690c:	2b06      	cmp	r3, #6
   9690e:	bf28      	it	cs
   96910:	2306      	movcs	r3, #6
   96912:	9303      	str	r3, [sp, #12]
   96914:	9404      	str	r4, [sp, #16]
   96916:	ea23 75e3 	bic.w	r5, r3, r3, asr #31
   9691a:	4f2c      	ldr	r7, [pc, #176]	; (969cc <_vfiprintf_r+0xddc>)
   9691c:	e512      	b.n	96344 <_vfiprintf_r+0x754>
   9691e:	9204      	str	r2, [sp, #16]
   96920:	e415      	b.n	9614e <_vfiprintf_r+0x55e>
   96922:	980e      	ldr	r0, [sp, #56]	; 0x38
   96924:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 969d0 <_vfiprintf_r+0xde0>
   96928:	3001      	adds	r0, #1
   9692a:	f7ff bb88 	b.w	9603e <_vfiprintf_r+0x44e>
   9692e:	46f4      	mov	ip, lr
   96930:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 969d4 <_vfiprintf_r+0xde4>
   96934:	f7ff bb2d 	b.w	95f92 <_vfiprintf_r+0x3a2>
   96938:	2200      	movs	r2, #0
   9693a:	9201      	str	r2, [sp, #4]
   9693c:	f7ff b9c1 	b.w	95cc2 <_vfiprintf_r+0xd2>
   96940:	9b01      	ldr	r3, [sp, #4]
   96942:	9404      	str	r4, [sp, #16]
   96944:	9303      	str	r3, [sp, #12]
   96946:	9001      	str	r0, [sp, #4]
   96948:	f89d 902f 	ldrb.w	r9, [sp, #47]	; 0x2f
   9694c:	f7ff ba76 	b.w	95e3c <_vfiprintf_r+0x24c>
   96950:	9204      	str	r2, [sp, #16]
   96952:	4699      	mov	r9, r3
   96954:	e6b6      	b.n	966c4 <_vfiprintf_r+0xad4>
   96956:	9a04      	ldr	r2, [sp, #16]
   96958:	6813      	ldr	r3, [r2, #0]
   9695a:	3204      	adds	r2, #4
   9695c:	2b00      	cmp	r3, #0
   9695e:	9301      	str	r3, [sp, #4]
   96960:	9204      	str	r2, [sp, #16]
   96962:	f898 3001 	ldrb.w	r3, [r8, #1]
   96966:	46a8      	mov	r8, r5
   96968:	f6bf a9a9 	bge.w	95cbe <_vfiprintf_r+0xce>
   9696c:	f04f 32ff 	mov.w	r2, #4294967295
   96970:	9201      	str	r2, [sp, #4]
   96972:	f7ff b9a4 	b.w	95cbe <_vfiprintf_r+0xce>
   96976:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
   9697a:	e45f      	b.n	9623c <_vfiprintf_r+0x64c>
   9697c:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
   96980:	f7ff bbc4 	b.w	9610c <_vfiprintf_r+0x51c>
   96984:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
   96988:	f7ff bb77 	b.w	9607a <_vfiprintf_r+0x48a>
   9698c:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
   96990:	e487      	b.n	962a2 <_vfiprintf_r+0x6b2>
   96992:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
   96996:	e4a7      	b.n	962e8 <_vfiprintf_r+0x6f8>
   96998:	4699      	mov	r9, r3
   9699a:	07f3      	lsls	r3, r6, #31
   9699c:	d505      	bpl.n	969aa <_vfiprintf_r+0xdba>
   9699e:	af2a      	add	r7, sp, #168	; 0xa8
   969a0:	2330      	movs	r3, #48	; 0x30
   969a2:	f807 3d41 	strb.w	r3, [r7, #-65]!
   969a6:	f7ff bba2 	b.w	960ee <_vfiprintf_r+0x4fe>
   969aa:	9b01      	ldr	r3, [sp, #4]
   969ac:	4657      	mov	r7, sl
   969ae:	9303      	str	r3, [sp, #12]
   969b0:	f7ff ba44 	b.w	95e3c <_vfiprintf_r+0x24c>
   969b4:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
   969b8:	e517      	b.n	963ea <_vfiprintf_r+0x7fa>
   969ba:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
   969be:	e4fa      	b.n	963b6 <_vfiprintf_r+0x7c6>
   969c0:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
   969c4:	e4d2      	b.n	9636c <_vfiprintf_r+0x77c>
   969c6:	bf00      	nop
   969c8:	0009b1ac 	.word	0x0009b1ac
   969cc:	0009b1c0 	.word	0x0009b1c0
   969d0:	0009b1ec 	.word	0x0009b1ec
   969d4:	0009b1dc 	.word	0x0009b1dc

000969d8 <__sbprintf>:
   969d8:	b5f0      	push	{r4, r5, r6, r7, lr}
   969da:	460c      	mov	r4, r1
   969dc:	8989      	ldrh	r1, [r1, #12]
   969de:	f2ad 4d6c 	subw	sp, sp, #1132	; 0x46c
   969e2:	6e65      	ldr	r5, [r4, #100]	; 0x64
   969e4:	f021 0102 	bic.w	r1, r1, #2
   969e8:	6a66      	ldr	r6, [r4, #36]	; 0x24
   969ea:	f8ad 100c 	strh.w	r1, [sp, #12]
   969ee:	69e1      	ldr	r1, [r4, #28]
   969f0:	89e7      	ldrh	r7, [r4, #14]
   969f2:	9519      	str	r5, [sp, #100]	; 0x64
   969f4:	2500      	movs	r5, #0
   969f6:	9107      	str	r1, [sp, #28]
   969f8:	9609      	str	r6, [sp, #36]	; 0x24
   969fa:	9506      	str	r5, [sp, #24]
   969fc:	ae1a      	add	r6, sp, #104	; 0x68
   969fe:	f44f 6580 	mov.w	r5, #1024	; 0x400
   96a02:	4669      	mov	r1, sp
   96a04:	9600      	str	r6, [sp, #0]
   96a06:	9604      	str	r6, [sp, #16]
   96a08:	9502      	str	r5, [sp, #8]
   96a0a:	9505      	str	r5, [sp, #20]
   96a0c:	f8ad 700e 	strh.w	r7, [sp, #14]
   96a10:	4606      	mov	r6, r0
   96a12:	f7ff f8ed 	bl	95bf0 <_vfiprintf_r>
   96a16:	1e05      	subs	r5, r0, #0
   96a18:	db07      	blt.n	96a2a <__sbprintf+0x52>
   96a1a:	4630      	mov	r0, r6
   96a1c:	4669      	mov	r1, sp
   96a1e:	f001 f941 	bl	97ca4 <_fflush_r>
   96a22:	2800      	cmp	r0, #0
   96a24:	bf18      	it	ne
   96a26:	f04f 35ff 	movne.w	r5, #4294967295
   96a2a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   96a2e:	065b      	lsls	r3, r3, #25
   96a30:	d503      	bpl.n	96a3a <__sbprintf+0x62>
   96a32:	89a3      	ldrh	r3, [r4, #12]
   96a34:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   96a38:	81a3      	strh	r3, [r4, #12]
   96a3a:	4628      	mov	r0, r5
   96a3c:	f20d 4d6c 	addw	sp, sp, #1132	; 0x46c
   96a40:	bdf0      	pop	{r4, r5, r6, r7, pc}
   96a42:	bf00      	nop

00096a44 <__swsetup_r>:
   96a44:	b538      	push	{r3, r4, r5, lr}
   96a46:	4b30      	ldr	r3, [pc, #192]	; (96b08 <__swsetup_r+0xc4>)
   96a48:	4605      	mov	r5, r0
   96a4a:	6818      	ldr	r0, [r3, #0]
   96a4c:	460c      	mov	r4, r1
   96a4e:	b110      	cbz	r0, 96a56 <__swsetup_r+0x12>
   96a50:	6b83      	ldr	r3, [r0, #56]	; 0x38
   96a52:	2b00      	cmp	r3, #0
   96a54:	d038      	beq.n	96ac8 <__swsetup_r+0x84>
   96a56:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   96a5a:	b293      	uxth	r3, r2
   96a5c:	0718      	lsls	r0, r3, #28
   96a5e:	d50c      	bpl.n	96a7a <__swsetup_r+0x36>
   96a60:	6920      	ldr	r0, [r4, #16]
   96a62:	b1a8      	cbz	r0, 96a90 <__swsetup_r+0x4c>
   96a64:	f013 0201 	ands.w	r2, r3, #1
   96a68:	d01e      	beq.n	96aa8 <__swsetup_r+0x64>
   96a6a:	6963      	ldr	r3, [r4, #20]
   96a6c:	2200      	movs	r2, #0
   96a6e:	425b      	negs	r3, r3
   96a70:	61a3      	str	r3, [r4, #24]
   96a72:	60a2      	str	r2, [r4, #8]
   96a74:	b1f0      	cbz	r0, 96ab4 <__swsetup_r+0x70>
   96a76:	2000      	movs	r0, #0
   96a78:	bd38      	pop	{r3, r4, r5, pc}
   96a7a:	06d9      	lsls	r1, r3, #27
   96a7c:	d53b      	bpl.n	96af6 <__swsetup_r+0xb2>
   96a7e:	0758      	lsls	r0, r3, #29
   96a80:	d425      	bmi.n	96ace <__swsetup_r+0x8a>
   96a82:	6920      	ldr	r0, [r4, #16]
   96a84:	f042 0308 	orr.w	r3, r2, #8
   96a88:	81a3      	strh	r3, [r4, #12]
   96a8a:	b29b      	uxth	r3, r3
   96a8c:	2800      	cmp	r0, #0
   96a8e:	d1e9      	bne.n	96a64 <__swsetup_r+0x20>
   96a90:	f403 7220 	and.w	r2, r3, #640	; 0x280
   96a94:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   96a98:	d0e4      	beq.n	96a64 <__swsetup_r+0x20>
   96a9a:	4628      	mov	r0, r5
   96a9c:	4621      	mov	r1, r4
   96a9e:	f001 fd2f 	bl	98500 <__smakebuf_r>
   96aa2:	89a3      	ldrh	r3, [r4, #12]
   96aa4:	6920      	ldr	r0, [r4, #16]
   96aa6:	e7dd      	b.n	96a64 <__swsetup_r+0x20>
   96aa8:	0799      	lsls	r1, r3, #30
   96aaa:	bf58      	it	pl
   96aac:	6962      	ldrpl	r2, [r4, #20]
   96aae:	60a2      	str	r2, [r4, #8]
   96ab0:	2800      	cmp	r0, #0
   96ab2:	d1e0      	bne.n	96a76 <__swsetup_r+0x32>
   96ab4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   96ab8:	061a      	lsls	r2, r3, #24
   96aba:	d5dd      	bpl.n	96a78 <__swsetup_r+0x34>
   96abc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   96ac0:	81a3      	strh	r3, [r4, #12]
   96ac2:	f04f 30ff 	mov.w	r0, #4294967295
   96ac6:	bd38      	pop	{r3, r4, r5, pc}
   96ac8:	f001 f980 	bl	97dcc <__sinit>
   96acc:	e7c3      	b.n	96a56 <__swsetup_r+0x12>
   96ace:	6b21      	ldr	r1, [r4, #48]	; 0x30
   96ad0:	b151      	cbz	r1, 96ae8 <__swsetup_r+0xa4>
   96ad2:	f104 0340 	add.w	r3, r4, #64	; 0x40
   96ad6:	4299      	cmp	r1, r3
   96ad8:	d004      	beq.n	96ae4 <__swsetup_r+0xa0>
   96ada:	4628      	mov	r0, r5
   96adc:	f001 fa3e 	bl	97f5c <_free_r>
   96ae0:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   96ae4:	2300      	movs	r3, #0
   96ae6:	6323      	str	r3, [r4, #48]	; 0x30
   96ae8:	6920      	ldr	r0, [r4, #16]
   96aea:	2300      	movs	r3, #0
   96aec:	f022 0224 	bic.w	r2, r2, #36	; 0x24
   96af0:	e884 0009 	stmia.w	r4, {r0, r3}
   96af4:	e7c6      	b.n	96a84 <__swsetup_r+0x40>
   96af6:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   96afa:	2309      	movs	r3, #9
   96afc:	602b      	str	r3, [r5, #0]
   96afe:	f04f 30ff 	mov.w	r0, #4294967295
   96b02:	81a2      	strh	r2, [r4, #12]
   96b04:	bd38      	pop	{r3, r4, r5, pc}
   96b06:	bf00      	nop
   96b08:	20070548 	.word	0x20070548

00096b0c <__register_exitproc>:
   96b0c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   96b10:	4c25      	ldr	r4, [pc, #148]	; (96ba8 <__register_exitproc+0x9c>)
   96b12:	4606      	mov	r6, r0
   96b14:	6825      	ldr	r5, [r4, #0]
   96b16:	4688      	mov	r8, r1
   96b18:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
   96b1c:	4692      	mov	sl, r2
   96b1e:	4699      	mov	r9, r3
   96b20:	b3c4      	cbz	r4, 96b94 <__register_exitproc+0x88>
   96b22:	6860      	ldr	r0, [r4, #4]
   96b24:	281f      	cmp	r0, #31
   96b26:	dc17      	bgt.n	96b58 <__register_exitproc+0x4c>
   96b28:	1c41      	adds	r1, r0, #1
   96b2a:	b176      	cbz	r6, 96b4a <__register_exitproc+0x3e>
   96b2c:	eb04 0380 	add.w	r3, r4, r0, lsl #2
   96b30:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
   96b34:	f8d4 5188 	ldr.w	r5, [r4, #392]	; 0x188
   96b38:	2201      	movs	r2, #1
   96b3a:	4082      	lsls	r2, r0
   96b3c:	4315      	orrs	r5, r2
   96b3e:	2e02      	cmp	r6, #2
   96b40:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
   96b44:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
   96b48:	d01e      	beq.n	96b88 <__register_exitproc+0x7c>
   96b4a:	1c83      	adds	r3, r0, #2
   96b4c:	6061      	str	r1, [r4, #4]
   96b4e:	2000      	movs	r0, #0
   96b50:	f844 8023 	str.w	r8, [r4, r3, lsl #2]
   96b54:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   96b58:	4b14      	ldr	r3, [pc, #80]	; (96bac <__register_exitproc+0xa0>)
   96b5a:	b303      	cbz	r3, 96b9e <__register_exitproc+0x92>
   96b5c:	f44f 70c8 	mov.w	r0, #400	; 0x190
   96b60:	f7fc fce8 	bl	93534 <malloc>
   96b64:	4604      	mov	r4, r0
   96b66:	b1d0      	cbz	r0, 96b9e <__register_exitproc+0x92>
   96b68:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
   96b6c:	2700      	movs	r7, #0
   96b6e:	e884 0088 	stmia.w	r4, {r3, r7}
   96b72:	4638      	mov	r0, r7
   96b74:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
   96b78:	2101      	movs	r1, #1
   96b7a:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
   96b7e:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
   96b82:	2e00      	cmp	r6, #0
   96b84:	d0e1      	beq.n	96b4a <__register_exitproc+0x3e>
   96b86:	e7d1      	b.n	96b2c <__register_exitproc+0x20>
   96b88:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
   96b8c:	431a      	orrs	r2, r3
   96b8e:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
   96b92:	e7da      	b.n	96b4a <__register_exitproc+0x3e>
   96b94:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
   96b98:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
   96b9c:	e7c1      	b.n	96b22 <__register_exitproc+0x16>
   96b9e:	f04f 30ff 	mov.w	r0, #4294967295
   96ba2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   96ba6:	bf00      	nop
   96ba8:	0009b174 	.word	0x0009b174
   96bac:	00093535 	.word	0x00093535

00096bb0 <register_fini>:
   96bb0:	4b02      	ldr	r3, [pc, #8]	; (96bbc <register_fini+0xc>)
   96bb2:	b113      	cbz	r3, 96bba <register_fini+0xa>
   96bb4:	4802      	ldr	r0, [pc, #8]	; (96bc0 <register_fini+0x10>)
   96bb6:	f000 b80d 	b.w	96bd4 <atexit>
   96bba:	4770      	bx	lr
   96bbc:	00000000 	.word	0x00000000
   96bc0:	00097de1 	.word	0x00097de1

00096bc4 <abort>:
   96bc4:	b508      	push	{r3, lr}
   96bc6:	2006      	movs	r0, #6
   96bc8:	f002 f866 	bl	98c98 <raise>
   96bcc:	2001      	movs	r0, #1
   96bce:	f7e9 fc43 	bl	80458 <_exit>
   96bd2:	bf00      	nop

00096bd4 <atexit>:
   96bd4:	2300      	movs	r3, #0
   96bd6:	4601      	mov	r1, r0
   96bd8:	461a      	mov	r2, r3
   96bda:	4618      	mov	r0, r3
   96bdc:	f7ff bf96 	b.w	96b0c <__register_exitproc>

00096be0 <quorem>:
   96be0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   96be4:	6903      	ldr	r3, [r0, #16]
   96be6:	690f      	ldr	r7, [r1, #16]
   96be8:	b083      	sub	sp, #12
   96bea:	429f      	cmp	r7, r3
   96bec:	f300 8089 	bgt.w	96d02 <quorem+0x122>
   96bf0:	3f01      	subs	r7, #1
   96bf2:	f101 0614 	add.w	r6, r1, #20
   96bf6:	f100 0a14 	add.w	sl, r0, #20
   96bfa:	f856 3027 	ldr.w	r3, [r6, r7, lsl #2]
   96bfe:	f85a 2027 	ldr.w	r2, [sl, r7, lsl #2]
   96c02:	3301      	adds	r3, #1
   96c04:	fbb2 f8f3 	udiv	r8, r2, r3
   96c08:	00bb      	lsls	r3, r7, #2
   96c0a:	9300      	str	r3, [sp, #0]
   96c0c:	eb06 0903 	add.w	r9, r6, r3
   96c10:	4453      	add	r3, sl
   96c12:	9301      	str	r3, [sp, #4]
   96c14:	f1b8 0f00 	cmp.w	r8, #0
   96c18:	d03b      	beq.n	96c92 <quorem+0xb2>
   96c1a:	2300      	movs	r3, #0
   96c1c:	461c      	mov	r4, r3
   96c1e:	46b4      	mov	ip, r6
   96c20:	46d6      	mov	lr, sl
   96c22:	f85c bb04 	ldr.w	fp, [ip], #4
   96c26:	f8de 5000 	ldr.w	r5, [lr]
   96c2a:	fa1f f28b 	uxth.w	r2, fp
   96c2e:	fb08 3202 	mla	r2, r8, r2, r3
   96c32:	ea4f 4b1b 	mov.w	fp, fp, lsr #16
   96c36:	0c13      	lsrs	r3, r2, #16
   96c38:	fb08 330b 	mla	r3, r8, fp, r3
   96c3c:	b292      	uxth	r2, r2
   96c3e:	1aa4      	subs	r4, r4, r2
   96c40:	fa1f fb83 	uxth.w	fp, r3
   96c44:	b2aa      	uxth	r2, r5
   96c46:	4422      	add	r2, r4
   96c48:	ebcb 4415 	rsb	r4, fp, r5, lsr #16
   96c4c:	eb04 4422 	add.w	r4, r4, r2, asr #16
   96c50:	b292      	uxth	r2, r2
   96c52:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
   96c56:	45e1      	cmp	r9, ip
   96c58:	f84e 2b04 	str.w	r2, [lr], #4
   96c5c:	ea4f 4424 	mov.w	r4, r4, asr #16
   96c60:	ea4f 4313 	mov.w	r3, r3, lsr #16
   96c64:	d2dd      	bcs.n	96c22 <quorem+0x42>
   96c66:	9b00      	ldr	r3, [sp, #0]
   96c68:	f85a 3003 	ldr.w	r3, [sl, r3]
   96c6c:	b98b      	cbnz	r3, 96c92 <quorem+0xb2>
   96c6e:	9c01      	ldr	r4, [sp, #4]
   96c70:	1f23      	subs	r3, r4, #4
   96c72:	459a      	cmp	sl, r3
   96c74:	d20c      	bcs.n	96c90 <quorem+0xb0>
   96c76:	f854 3c04 	ldr.w	r3, [r4, #-4]
   96c7a:	b94b      	cbnz	r3, 96c90 <quorem+0xb0>
   96c7c:	f1a4 0308 	sub.w	r3, r4, #8
   96c80:	e002      	b.n	96c88 <quorem+0xa8>
   96c82:	681a      	ldr	r2, [r3, #0]
   96c84:	3b04      	subs	r3, #4
   96c86:	b91a      	cbnz	r2, 96c90 <quorem+0xb0>
   96c88:	459a      	cmp	sl, r3
   96c8a:	f107 37ff 	add.w	r7, r7, #4294967295
   96c8e:	d3f8      	bcc.n	96c82 <quorem+0xa2>
   96c90:	6107      	str	r7, [r0, #16]
   96c92:	4604      	mov	r4, r0
   96c94:	f001 fecc 	bl	98a30 <__mcmp>
   96c98:	2800      	cmp	r0, #0
   96c9a:	db2e      	blt.n	96cfa <quorem+0x11a>
   96c9c:	2300      	movs	r3, #0
   96c9e:	4655      	mov	r5, sl
   96ca0:	4619      	mov	r1, r3
   96ca2:	f108 0801 	add.w	r8, r8, #1
   96ca6:	f856 2b04 	ldr.w	r2, [r6], #4
   96caa:	682b      	ldr	r3, [r5, #0]
   96cac:	b290      	uxth	r0, r2
   96cae:	1a08      	subs	r0, r1, r0
   96cb0:	0c12      	lsrs	r2, r2, #16
   96cb2:	b299      	uxth	r1, r3
   96cb4:	ebc2 4313 	rsb	r3, r2, r3, lsr #16
   96cb8:	1842      	adds	r2, r0, r1
   96cba:	eb03 4322 	add.w	r3, r3, r2, asr #16
   96cbe:	b292      	uxth	r2, r2
   96cc0:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
   96cc4:	45b1      	cmp	r9, r6
   96cc6:	f845 2b04 	str.w	r2, [r5], #4
   96cca:	ea4f 4123 	mov.w	r1, r3, asr #16
   96cce:	d2ea      	bcs.n	96ca6 <quorem+0xc6>
   96cd0:	f85a 2027 	ldr.w	r2, [sl, r7, lsl #2]
   96cd4:	eb0a 0387 	add.w	r3, sl, r7, lsl #2
   96cd8:	b97a      	cbnz	r2, 96cfa <quorem+0x11a>
   96cda:	1f1a      	subs	r2, r3, #4
   96cdc:	4592      	cmp	sl, r2
   96cde:	d20b      	bcs.n	96cf8 <quorem+0x118>
   96ce0:	f853 2c04 	ldr.w	r2, [r3, #-4]
   96ce4:	b942      	cbnz	r2, 96cf8 <quorem+0x118>
   96ce6:	3b08      	subs	r3, #8
   96ce8:	e002      	b.n	96cf0 <quorem+0x110>
   96cea:	681a      	ldr	r2, [r3, #0]
   96cec:	3b04      	subs	r3, #4
   96cee:	b91a      	cbnz	r2, 96cf8 <quorem+0x118>
   96cf0:	459a      	cmp	sl, r3
   96cf2:	f107 37ff 	add.w	r7, r7, #4294967295
   96cf6:	d3f8      	bcc.n	96cea <quorem+0x10a>
   96cf8:	6127      	str	r7, [r4, #16]
   96cfa:	4640      	mov	r0, r8
   96cfc:	b003      	add	sp, #12
   96cfe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   96d02:	2000      	movs	r0, #0
   96d04:	b003      	add	sp, #12
   96d06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   96d0a:	bf00      	nop
   96d0c:	0000      	movs	r0, r0
	...

00096d10 <_dtoa_r>:
   96d10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   96d14:	6c01      	ldr	r1, [r0, #64]	; 0x40
   96d16:	b099      	sub	sp, #100	; 0x64
   96d18:	4681      	mov	r9, r0
   96d1a:	4692      	mov	sl, r2
   96d1c:	469b      	mov	fp, r3
   96d1e:	9c25      	ldr	r4, [sp, #148]	; 0x94
   96d20:	b149      	cbz	r1, 96d36 <_dtoa_r+0x26>
   96d22:	6c42      	ldr	r2, [r0, #68]	; 0x44
   96d24:	2301      	movs	r3, #1
   96d26:	4093      	lsls	r3, r2
   96d28:	608b      	str	r3, [r1, #8]
   96d2a:	604a      	str	r2, [r1, #4]
   96d2c:	f001 fc9a 	bl	98664 <_Bfree>
   96d30:	2300      	movs	r3, #0
   96d32:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
   96d36:	f1bb 0f00 	cmp.w	fp, #0
   96d3a:	46d8      	mov	r8, fp
   96d3c:	db33      	blt.n	96da6 <_dtoa_r+0x96>
   96d3e:	2300      	movs	r3, #0
   96d40:	6023      	str	r3, [r4, #0]
   96d42:	4ba3      	ldr	r3, [pc, #652]	; (96fd0 <_dtoa_r+0x2c0>)
   96d44:	461a      	mov	r2, r3
   96d46:	ea08 0303 	and.w	r3, r8, r3
   96d4a:	4293      	cmp	r3, r2
   96d4c:	d014      	beq.n	96d78 <_dtoa_r+0x68>
   96d4e:	2200      	movs	r2, #0
   96d50:	2300      	movs	r3, #0
   96d52:	4650      	mov	r0, sl
   96d54:	4659      	mov	r1, fp
   96d56:	f7fb ff79 	bl	92c4c <__aeabi_dcmpeq>
   96d5a:	4605      	mov	r5, r0
   96d5c:	b348      	cbz	r0, 96db2 <_dtoa_r+0xa2>
   96d5e:	9a24      	ldr	r2, [sp, #144]	; 0x90
   96d60:	2301      	movs	r3, #1
   96d62:	6013      	str	r3, [r2, #0]
   96d64:	9b26      	ldr	r3, [sp, #152]	; 0x98
   96d66:	2b00      	cmp	r3, #0
   96d68:	f000 80c5 	beq.w	96ef6 <_dtoa_r+0x1e6>
   96d6c:	4899      	ldr	r0, [pc, #612]	; (96fd4 <_dtoa_r+0x2c4>)
   96d6e:	6018      	str	r0, [r3, #0]
   96d70:	3801      	subs	r0, #1
   96d72:	b019      	add	sp, #100	; 0x64
   96d74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   96d78:	f242 730f 	movw	r3, #9999	; 0x270f
   96d7c:	9a24      	ldr	r2, [sp, #144]	; 0x90
   96d7e:	6013      	str	r3, [r2, #0]
   96d80:	f1ba 0f00 	cmp.w	sl, #0
   96d84:	f000 80a2 	beq.w	96ecc <_dtoa_r+0x1bc>
   96d88:	4893      	ldr	r0, [pc, #588]	; (96fd8 <_dtoa_r+0x2c8>)
   96d8a:	9b26      	ldr	r3, [sp, #152]	; 0x98
   96d8c:	2b00      	cmp	r3, #0
   96d8e:	d0f0      	beq.n	96d72 <_dtoa_r+0x62>
   96d90:	78c3      	ldrb	r3, [r0, #3]
   96d92:	2b00      	cmp	r3, #0
   96d94:	f000 80b1 	beq.w	96efa <_dtoa_r+0x1ea>
   96d98:	f100 0308 	add.w	r3, r0, #8
   96d9c:	9a26      	ldr	r2, [sp, #152]	; 0x98
   96d9e:	6013      	str	r3, [r2, #0]
   96da0:	b019      	add	sp, #100	; 0x64
   96da2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   96da6:	2301      	movs	r3, #1
   96da8:	f02b 4800 	bic.w	r8, fp, #2147483648	; 0x80000000
   96dac:	6023      	str	r3, [r4, #0]
   96dae:	46c3      	mov	fp, r8
   96db0:	e7c7      	b.n	96d42 <_dtoa_r+0x32>
   96db2:	aa16      	add	r2, sp, #88	; 0x58
   96db4:	ab17      	add	r3, sp, #92	; 0x5c
   96db6:	9201      	str	r2, [sp, #4]
   96db8:	9300      	str	r3, [sp, #0]
   96dba:	4652      	mov	r2, sl
   96dbc:	465b      	mov	r3, fp
   96dbe:	4648      	mov	r0, r9
   96dc0:	f001 feea 	bl	98b98 <__d2b>
   96dc4:	ea5f 5418 	movs.w	r4, r8, lsr #20
   96dc8:	9009      	str	r0, [sp, #36]	; 0x24
   96dca:	f040 8088 	bne.w	96ede <_dtoa_r+0x1ce>
   96dce:	9d16      	ldr	r5, [sp, #88]	; 0x58
   96dd0:	9c17      	ldr	r4, [sp, #92]	; 0x5c
   96dd2:	442c      	add	r4, r5
   96dd4:	f204 4332 	addw	r3, r4, #1074	; 0x432
   96dd8:	2b20      	cmp	r3, #32
   96dda:	f340 828a 	ble.w	972f2 <_dtoa_r+0x5e2>
   96dde:	f1c3 0340 	rsb	r3, r3, #64	; 0x40
   96de2:	f204 4012 	addw	r0, r4, #1042	; 0x412
   96de6:	fa08 f803 	lsl.w	r8, r8, r3
   96dea:	fa2a f000 	lsr.w	r0, sl, r0
   96dee:	ea40 0008 	orr.w	r0, r0, r8
   96df2:	f7fb fc4d 	bl	92690 <__aeabi_ui2d>
   96df6:	2301      	movs	r3, #1
   96df8:	3c01      	subs	r4, #1
   96dfa:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
   96dfe:	930f      	str	r3, [sp, #60]	; 0x3c
   96e00:	2200      	movs	r2, #0
   96e02:	4b76      	ldr	r3, [pc, #472]	; (96fdc <_dtoa_r+0x2cc>)
   96e04:	f7fb fb06 	bl	92414 <__aeabi_dsub>
   96e08:	a36b      	add	r3, pc, #428	; (adr r3, 96fb8 <_dtoa_r+0x2a8>)
   96e0a:	e9d3 2300 	ldrd	r2, r3, [r3]
   96e0e:	f7fb fcb5 	bl	9277c <__aeabi_dmul>
   96e12:	a36b      	add	r3, pc, #428	; (adr r3, 96fc0 <_dtoa_r+0x2b0>)
   96e14:	e9d3 2300 	ldrd	r2, r3, [r3]
   96e18:	f7fb fafe 	bl	92418 <__adddf3>
   96e1c:	4606      	mov	r6, r0
   96e1e:	4620      	mov	r0, r4
   96e20:	460f      	mov	r7, r1
   96e22:	f7fb fc45 	bl	926b0 <__aeabi_i2d>
   96e26:	a368      	add	r3, pc, #416	; (adr r3, 96fc8 <_dtoa_r+0x2b8>)
   96e28:	e9d3 2300 	ldrd	r2, r3, [r3]
   96e2c:	f7fb fca6 	bl	9277c <__aeabi_dmul>
   96e30:	4602      	mov	r2, r0
   96e32:	460b      	mov	r3, r1
   96e34:	4630      	mov	r0, r6
   96e36:	4639      	mov	r1, r7
   96e38:	f7fb faee 	bl	92418 <__adddf3>
   96e3c:	4606      	mov	r6, r0
   96e3e:	460f      	mov	r7, r1
   96e40:	f7fb ff4c 	bl	92cdc <__aeabi_d2iz>
   96e44:	2200      	movs	r2, #0
   96e46:	9003      	str	r0, [sp, #12]
   96e48:	2300      	movs	r3, #0
   96e4a:	4630      	mov	r0, r6
   96e4c:	4639      	mov	r1, r7
   96e4e:	f7fb ff07 	bl	92c60 <__aeabi_dcmplt>
   96e52:	2800      	cmp	r0, #0
   96e54:	f040 8229 	bne.w	972aa <_dtoa_r+0x59a>
   96e58:	9e03      	ldr	r6, [sp, #12]
   96e5a:	2e16      	cmp	r6, #22
   96e5c:	f200 8222 	bhi.w	972a4 <_dtoa_r+0x594>
   96e60:	495f      	ldr	r1, [pc, #380]	; (96fe0 <_dtoa_r+0x2d0>)
   96e62:	4652      	mov	r2, sl
   96e64:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
   96e68:	465b      	mov	r3, fp
   96e6a:	e9d1 0100 	ldrd	r0, r1, [r1]
   96e6e:	f7fb ff15 	bl	92c9c <__aeabi_dcmpgt>
   96e72:	2800      	cmp	r0, #0
   96e74:	f000 8242 	beq.w	972fc <_dtoa_r+0x5ec>
   96e78:	1e73      	subs	r3, r6, #1
   96e7a:	9303      	str	r3, [sp, #12]
   96e7c:	2300      	movs	r3, #0
   96e7e:	930d      	str	r3, [sp, #52]	; 0x34
   96e80:	1b2c      	subs	r4, r5, r4
   96e82:	1e63      	subs	r3, r4, #1
   96e84:	9304      	str	r3, [sp, #16]
   96e86:	f100 822b 	bmi.w	972e0 <_dtoa_r+0x5d0>
   96e8a:	2300      	movs	r3, #0
   96e8c:	9306      	str	r3, [sp, #24]
   96e8e:	9b03      	ldr	r3, [sp, #12]
   96e90:	2b00      	cmp	r3, #0
   96e92:	f2c0 821c 	blt.w	972ce <_dtoa_r+0x5be>
   96e96:	9a04      	ldr	r2, [sp, #16]
   96e98:	930c      	str	r3, [sp, #48]	; 0x30
   96e9a:	4611      	mov	r1, r2
   96e9c:	4419      	add	r1, r3
   96e9e:	2300      	movs	r3, #0
   96ea0:	9104      	str	r1, [sp, #16]
   96ea2:	930b      	str	r3, [sp, #44]	; 0x2c
   96ea4:	9b22      	ldr	r3, [sp, #136]	; 0x88
   96ea6:	2b09      	cmp	r3, #9
   96ea8:	d829      	bhi.n	96efe <_dtoa_r+0x1ee>
   96eaa:	2b05      	cmp	r3, #5
   96eac:	f340 8652 	ble.w	97b54 <_dtoa_r+0xe44>
   96eb0:	3b04      	subs	r3, #4
   96eb2:	9322      	str	r3, [sp, #136]	; 0x88
   96eb4:	2500      	movs	r5, #0
   96eb6:	9b22      	ldr	r3, [sp, #136]	; 0x88
   96eb8:	3b02      	subs	r3, #2
   96eba:	2b03      	cmp	r3, #3
   96ebc:	f200 862f 	bhi.w	97b1e <_dtoa_r+0xe0e>
   96ec0:	e8df f013 	tbh	[pc, r3, lsl #1]
   96ec4:	02200327 	.word	0x02200327
   96ec8:	04530332 	.word	0x04530332
   96ecc:	4b42      	ldr	r3, [pc, #264]	; (96fd8 <_dtoa_r+0x2c8>)
   96ece:	4a45      	ldr	r2, [pc, #276]	; (96fe4 <_dtoa_r+0x2d4>)
   96ed0:	f3c8 0013 	ubfx	r0, r8, #0, #20
   96ed4:	2800      	cmp	r0, #0
   96ed6:	bf14      	ite	ne
   96ed8:	4618      	movne	r0, r3
   96eda:	4610      	moveq	r0, r2
   96edc:	e755      	b.n	96d8a <_dtoa_r+0x7a>
   96ede:	f3cb 0313 	ubfx	r3, fp, #0, #20
   96ee2:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
   96ee6:	950f      	str	r5, [sp, #60]	; 0x3c
   96ee8:	4650      	mov	r0, sl
   96eea:	f2a4 34ff 	subw	r4, r4, #1023	; 0x3ff
   96eee:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
   96ef2:	9d16      	ldr	r5, [sp, #88]	; 0x58
   96ef4:	e784      	b.n	96e00 <_dtoa_r+0xf0>
   96ef6:	483c      	ldr	r0, [pc, #240]	; (96fe8 <_dtoa_r+0x2d8>)
   96ef8:	e73b      	b.n	96d72 <_dtoa_r+0x62>
   96efa:	1cc3      	adds	r3, r0, #3
   96efc:	e74e      	b.n	96d9c <_dtoa_r+0x8c>
   96efe:	2100      	movs	r1, #0
   96f00:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
   96f04:	4648      	mov	r0, r9
   96f06:	9122      	str	r1, [sp, #136]	; 0x88
   96f08:	f001 fb84 	bl	98614 <_Balloc>
   96f0c:	f04f 33ff 	mov.w	r3, #4294967295
   96f10:	9a22      	ldr	r2, [sp, #136]	; 0x88
   96f12:	9307      	str	r3, [sp, #28]
   96f14:	930e      	str	r3, [sp, #56]	; 0x38
   96f16:	2301      	movs	r3, #1
   96f18:	9008      	str	r0, [sp, #32]
   96f1a:	9223      	str	r2, [sp, #140]	; 0x8c
   96f1c:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
   96f20:	930a      	str	r3, [sp, #40]	; 0x28
   96f22:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   96f24:	2b00      	cmp	r3, #0
   96f26:	f2c0 80ca 	blt.w	970be <_dtoa_r+0x3ae>
   96f2a:	9a03      	ldr	r2, [sp, #12]
   96f2c:	2a0e      	cmp	r2, #14
   96f2e:	f300 80c6 	bgt.w	970be <_dtoa_r+0x3ae>
   96f32:	4b2b      	ldr	r3, [pc, #172]	; (96fe0 <_dtoa_r+0x2d0>)
   96f34:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   96f38:	cb18      	ldmia	r3, {r3, r4}
   96f3a:	e9cd 3404 	strd	r3, r4, [sp, #16]
   96f3e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   96f40:	2b00      	cmp	r3, #0
   96f42:	f2c0 82fc 	blt.w	9753e <_dtoa_r+0x82e>
   96f46:	4656      	mov	r6, sl
   96f48:	465f      	mov	r7, fp
   96f4a:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
   96f4e:	4630      	mov	r0, r6
   96f50:	4652      	mov	r2, sl
   96f52:	465b      	mov	r3, fp
   96f54:	4639      	mov	r1, r7
   96f56:	f7fb fd3b 	bl	929d0 <__aeabi_ddiv>
   96f5a:	f7fb febf 	bl	92cdc <__aeabi_d2iz>
   96f5e:	4604      	mov	r4, r0
   96f60:	f7fb fba6 	bl	926b0 <__aeabi_i2d>
   96f64:	4652      	mov	r2, sl
   96f66:	465b      	mov	r3, fp
   96f68:	f7fb fc08 	bl	9277c <__aeabi_dmul>
   96f6c:	4602      	mov	r2, r0
   96f6e:	460b      	mov	r3, r1
   96f70:	4630      	mov	r0, r6
   96f72:	4639      	mov	r1, r7
   96f74:	f7fb fa4e 	bl	92414 <__aeabi_dsub>
   96f78:	9e07      	ldr	r6, [sp, #28]
   96f7a:	9f08      	ldr	r7, [sp, #32]
   96f7c:	f104 0530 	add.w	r5, r4, #48	; 0x30
   96f80:	2e01      	cmp	r6, #1
   96f82:	703d      	strb	r5, [r7, #0]
   96f84:	4602      	mov	r2, r0
   96f86:	460b      	mov	r3, r1
   96f88:	f107 0501 	add.w	r5, r7, #1
   96f8c:	d05e      	beq.n	9704c <_dtoa_r+0x33c>
   96f8e:	2200      	movs	r2, #0
   96f90:	4b16      	ldr	r3, [pc, #88]	; (96fec <_dtoa_r+0x2dc>)
   96f92:	f7fb fbf3 	bl	9277c <__aeabi_dmul>
   96f96:	2200      	movs	r2, #0
   96f98:	2300      	movs	r3, #0
   96f9a:	4606      	mov	r6, r0
   96f9c:	460f      	mov	r7, r1
   96f9e:	f7fb fe55 	bl	92c4c <__aeabi_dcmpeq>
   96fa2:	2800      	cmp	r0, #0
   96fa4:	d178      	bne.n	97098 <_dtoa_r+0x388>
   96fa6:	f8cd 9018 	str.w	r9, [sp, #24]
   96faa:	f8dd a01c 	ldr.w	sl, [sp, #28]
   96fae:	f8dd b020 	ldr.w	fp, [sp, #32]
   96fb2:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
   96fb6:	e028      	b.n	9700a <_dtoa_r+0x2fa>
   96fb8:	636f4361 	.word	0x636f4361
   96fbc:	3fd287a7 	.word	0x3fd287a7
   96fc0:	8b60c8b3 	.word	0x8b60c8b3
   96fc4:	3fc68a28 	.word	0x3fc68a28
   96fc8:	509f79fb 	.word	0x509f79fb
   96fcc:	3fd34413 	.word	0x3fd34413
   96fd0:	7ff00000 	.word	0x7ff00000
   96fd4:	0009b1c9 	.word	0x0009b1c9
   96fd8:	0009b208 	.word	0x0009b208
   96fdc:	3ff80000 	.word	0x3ff80000
   96fe0:	0009b218 	.word	0x0009b218
   96fe4:	0009b1fc 	.word	0x0009b1fc
   96fe8:	0009b1c8 	.word	0x0009b1c8
   96fec:	40240000 	.word	0x40240000
   96ff0:	2200      	movs	r2, #0
   96ff2:	4bc3      	ldr	r3, [pc, #780]	; (97300 <_dtoa_r+0x5f0>)
   96ff4:	f7fb fbc2 	bl	9277c <__aeabi_dmul>
   96ff8:	2200      	movs	r2, #0
   96ffa:	2300      	movs	r3, #0
   96ffc:	4606      	mov	r6, r0
   96ffe:	460f      	mov	r7, r1
   97000:	f7fb fe24 	bl	92c4c <__aeabi_dcmpeq>
   97004:	2800      	cmp	r0, #0
   97006:	f040 83b3 	bne.w	97770 <_dtoa_r+0xa60>
   9700a:	4642      	mov	r2, r8
   9700c:	464b      	mov	r3, r9
   9700e:	4630      	mov	r0, r6
   97010:	4639      	mov	r1, r7
   97012:	f7fb fcdd 	bl	929d0 <__aeabi_ddiv>
   97016:	f7fb fe61 	bl	92cdc <__aeabi_d2iz>
   9701a:	4604      	mov	r4, r0
   9701c:	f7fb fb48 	bl	926b0 <__aeabi_i2d>
   97020:	4642      	mov	r2, r8
   97022:	464b      	mov	r3, r9
   97024:	f7fb fbaa 	bl	9277c <__aeabi_dmul>
   97028:	4602      	mov	r2, r0
   9702a:	460b      	mov	r3, r1
   9702c:	4630      	mov	r0, r6
   9702e:	4639      	mov	r1, r7
   97030:	f7fb f9f0 	bl	92414 <__aeabi_dsub>
   97034:	f104 0630 	add.w	r6, r4, #48	; 0x30
   97038:	f805 6b01 	strb.w	r6, [r5], #1
   9703c:	ebcb 0605 	rsb	r6, fp, r5
   97040:	4556      	cmp	r6, sl
   97042:	4602      	mov	r2, r0
   97044:	460b      	mov	r3, r1
   97046:	d1d3      	bne.n	96ff0 <_dtoa_r+0x2e0>
   97048:	f8dd 9018 	ldr.w	r9, [sp, #24]
   9704c:	4610      	mov	r0, r2
   9704e:	4619      	mov	r1, r3
   97050:	f7fb f9e2 	bl	92418 <__adddf3>
   97054:	4606      	mov	r6, r0
   97056:	460f      	mov	r7, r1
   97058:	4602      	mov	r2, r0
   9705a:	460b      	mov	r3, r1
   9705c:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   97060:	f7fb fdfe 	bl	92c60 <__aeabi_dcmplt>
   97064:	b940      	cbnz	r0, 97078 <_dtoa_r+0x368>
   97066:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   9706a:	4632      	mov	r2, r6
   9706c:	463b      	mov	r3, r7
   9706e:	f7fb fded 	bl	92c4c <__aeabi_dcmpeq>
   97072:	b188      	cbz	r0, 97098 <_dtoa_r+0x388>
   97074:	07e3      	lsls	r3, r4, #31
   97076:	d50f      	bpl.n	97098 <_dtoa_r+0x388>
   97078:	f815 4c01 	ldrb.w	r4, [r5, #-1]
   9707c:	1e6b      	subs	r3, r5, #1
   9707e:	9a08      	ldr	r2, [sp, #32]
   97080:	e004      	b.n	9708c <_dtoa_r+0x37c>
   97082:	429a      	cmp	r2, r3
   97084:	f000 842c 	beq.w	978e0 <_dtoa_r+0xbd0>
   97088:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   9708c:	2c39      	cmp	r4, #57	; 0x39
   9708e:	f103 0501 	add.w	r5, r3, #1
   97092:	d0f6      	beq.n	97082 <_dtoa_r+0x372>
   97094:	3401      	adds	r4, #1
   97096:	701c      	strb	r4, [r3, #0]
   97098:	9909      	ldr	r1, [sp, #36]	; 0x24
   9709a:	4648      	mov	r0, r9
   9709c:	f001 fae2 	bl	98664 <_Bfree>
   970a0:	2200      	movs	r2, #0
   970a2:	9b03      	ldr	r3, [sp, #12]
   970a4:	702a      	strb	r2, [r5, #0]
   970a6:	9a24      	ldr	r2, [sp, #144]	; 0x90
   970a8:	3301      	adds	r3, #1
   970aa:	6013      	str	r3, [r2, #0]
   970ac:	9b26      	ldr	r3, [sp, #152]	; 0x98
   970ae:	2b00      	cmp	r3, #0
   970b0:	f000 83a8 	beq.w	97804 <_dtoa_r+0xaf4>
   970b4:	9808      	ldr	r0, [sp, #32]
   970b6:	601d      	str	r5, [r3, #0]
   970b8:	b019      	add	sp, #100	; 0x64
   970ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   970be:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   970c0:	2a00      	cmp	r2, #0
   970c2:	f000 8112 	beq.w	972ea <_dtoa_r+0x5da>
   970c6:	9a22      	ldr	r2, [sp, #136]	; 0x88
   970c8:	2a01      	cmp	r2, #1
   970ca:	f340 825a 	ble.w	97582 <_dtoa_r+0x872>
   970ce:	9b07      	ldr	r3, [sp, #28]
   970d0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   970d2:	1e5f      	subs	r7, r3, #1
   970d4:	42ba      	cmp	r2, r7
   970d6:	f2c0 8398 	blt.w	9780a <_dtoa_r+0xafa>
   970da:	1bd7      	subs	r7, r2, r7
   970dc:	9b07      	ldr	r3, [sp, #28]
   970de:	2b00      	cmp	r3, #0
   970e0:	f2c0 848c 	blt.w	979fc <_dtoa_r+0xcec>
   970e4:	9d06      	ldr	r5, [sp, #24]
   970e6:	9b07      	ldr	r3, [sp, #28]
   970e8:	9a06      	ldr	r2, [sp, #24]
   970ea:	2101      	movs	r1, #1
   970ec:	441a      	add	r2, r3
   970ee:	9206      	str	r2, [sp, #24]
   970f0:	9a04      	ldr	r2, [sp, #16]
   970f2:	4648      	mov	r0, r9
   970f4:	441a      	add	r2, r3
   970f6:	9204      	str	r2, [sp, #16]
   970f8:	f001 fb4c 	bl	98794 <__i2b>
   970fc:	4606      	mov	r6, r0
   970fe:	b165      	cbz	r5, 9711a <_dtoa_r+0x40a>
   97100:	9904      	ldr	r1, [sp, #16]
   97102:	2900      	cmp	r1, #0
   97104:	460b      	mov	r3, r1
   97106:	dd08      	ble.n	9711a <_dtoa_r+0x40a>
   97108:	42a9      	cmp	r1, r5
   9710a:	bfa8      	it	ge
   9710c:	462b      	movge	r3, r5
   9710e:	9a06      	ldr	r2, [sp, #24]
   97110:	1aed      	subs	r5, r5, r3
   97112:	1ad2      	subs	r2, r2, r3
   97114:	1acb      	subs	r3, r1, r3
   97116:	9206      	str	r2, [sp, #24]
   97118:	9304      	str	r3, [sp, #16]
   9711a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   9711c:	2b00      	cmp	r3, #0
   9711e:	f340 82fd 	ble.w	9771c <_dtoa_r+0xa0c>
   97122:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   97124:	2a00      	cmp	r2, #0
   97126:	f000 8203 	beq.w	97530 <_dtoa_r+0x820>
   9712a:	2f00      	cmp	r7, #0
   9712c:	f000 8200 	beq.w	97530 <_dtoa_r+0x820>
   97130:	4631      	mov	r1, r6
   97132:	463a      	mov	r2, r7
   97134:	4648      	mov	r0, r9
   97136:	f001 fbd5 	bl	988e4 <__pow5mult>
   9713a:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
   9713e:	4601      	mov	r1, r0
   97140:	4642      	mov	r2, r8
   97142:	4606      	mov	r6, r0
   97144:	4648      	mov	r0, r9
   97146:	f001 fb2f 	bl	987a8 <__multiply>
   9714a:	4641      	mov	r1, r8
   9714c:	4604      	mov	r4, r0
   9714e:	4648      	mov	r0, r9
   97150:	f001 fa88 	bl	98664 <_Bfree>
   97154:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   97156:	1bdb      	subs	r3, r3, r7
   97158:	930b      	str	r3, [sp, #44]	; 0x2c
   9715a:	f040 81e8 	bne.w	9752e <_dtoa_r+0x81e>
   9715e:	2101      	movs	r1, #1
   97160:	4648      	mov	r0, r9
   97162:	f001 fb17 	bl	98794 <__i2b>
   97166:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   97168:	4680      	mov	r8, r0
   9716a:	2b00      	cmp	r3, #0
   9716c:	f000 821b 	beq.w	975a6 <_dtoa_r+0x896>
   97170:	4601      	mov	r1, r0
   97172:	461a      	mov	r2, r3
   97174:	4648      	mov	r0, r9
   97176:	f001 fbb5 	bl	988e4 <__pow5mult>
   9717a:	9b22      	ldr	r3, [sp, #136]	; 0x88
   9717c:	4680      	mov	r8, r0
   9717e:	2b01      	cmp	r3, #1
   97180:	f340 82f9 	ble.w	97776 <_dtoa_r+0xa66>
   97184:	2700      	movs	r7, #0
   97186:	f8d8 3010 	ldr.w	r3, [r8, #16]
   9718a:	eb08 0383 	add.w	r3, r8, r3, lsl #2
   9718e:	6918      	ldr	r0, [r3, #16]
   97190:	f001 fab2 	bl	986f8 <__hi0bits>
   97194:	f1c0 0020 	rsb	r0, r0, #32
   97198:	9a04      	ldr	r2, [sp, #16]
   9719a:	4410      	add	r0, r2
   9719c:	f010 001f 	ands.w	r0, r0, #31
   971a0:	f000 81f8 	beq.w	97594 <_dtoa_r+0x884>
   971a4:	f1c0 0320 	rsb	r3, r0, #32
   971a8:	2b04      	cmp	r3, #4
   971aa:	f340 84cb 	ble.w	97b44 <_dtoa_r+0xe34>
   971ae:	9b06      	ldr	r3, [sp, #24]
   971b0:	f1c0 001c 	rsb	r0, r0, #28
   971b4:	4403      	add	r3, r0
   971b6:	9306      	str	r3, [sp, #24]
   971b8:	4613      	mov	r3, r2
   971ba:	4403      	add	r3, r0
   971bc:	4405      	add	r5, r0
   971be:	9304      	str	r3, [sp, #16]
   971c0:	9b06      	ldr	r3, [sp, #24]
   971c2:	2b00      	cmp	r3, #0
   971c4:	dd05      	ble.n	971d2 <_dtoa_r+0x4c2>
   971c6:	4621      	mov	r1, r4
   971c8:	461a      	mov	r2, r3
   971ca:	4648      	mov	r0, r9
   971cc:	f001 fbda 	bl	98984 <__lshift>
   971d0:	4604      	mov	r4, r0
   971d2:	9b04      	ldr	r3, [sp, #16]
   971d4:	2b00      	cmp	r3, #0
   971d6:	dd05      	ble.n	971e4 <_dtoa_r+0x4d4>
   971d8:	4641      	mov	r1, r8
   971da:	461a      	mov	r2, r3
   971dc:	4648      	mov	r0, r9
   971de:	f001 fbd1 	bl	98984 <__lshift>
   971e2:	4680      	mov	r8, r0
   971e4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   971e6:	2b00      	cmp	r3, #0
   971e8:	f040 827d 	bne.w	976e6 <_dtoa_r+0x9d6>
   971ec:	9b07      	ldr	r3, [sp, #28]
   971ee:	2b00      	cmp	r3, #0
   971f0:	f340 8296 	ble.w	97720 <_dtoa_r+0xa10>
   971f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   971f6:	2b00      	cmp	r3, #0
   971f8:	f040 81f6 	bne.w	975e8 <_dtoa_r+0x8d8>
   971fc:	f8dd a020 	ldr.w	sl, [sp, #32]
   97200:	9f07      	ldr	r7, [sp, #28]
   97202:	4655      	mov	r5, sl
   97204:	e004      	b.n	97210 <_dtoa_r+0x500>
   97206:	4621      	mov	r1, r4
   97208:	4648      	mov	r0, r9
   9720a:	f001 fa35 	bl	98678 <__multadd>
   9720e:	4604      	mov	r4, r0
   97210:	4641      	mov	r1, r8
   97212:	4620      	mov	r0, r4
   97214:	f7ff fce4 	bl	96be0 <quorem>
   97218:	3030      	adds	r0, #48	; 0x30
   9721a:	f805 0b01 	strb.w	r0, [r5], #1
   9721e:	ebca 0305 	rsb	r3, sl, r5
   97222:	42bb      	cmp	r3, r7
   97224:	f04f 020a 	mov.w	r2, #10
   97228:	f04f 0300 	mov.w	r3, #0
   9722c:	dbeb      	blt.n	97206 <_dtoa_r+0x4f6>
   9722e:	9b08      	ldr	r3, [sp, #32]
   97230:	9a07      	ldr	r2, [sp, #28]
   97232:	4682      	mov	sl, r0
   97234:	2a01      	cmp	r2, #1
   97236:	bfac      	ite	ge
   97238:	189b      	addge	r3, r3, r2
   9723a:	3301      	addlt	r3, #1
   9723c:	461d      	mov	r5, r3
   9723e:	f04f 0b00 	mov.w	fp, #0
   97242:	4621      	mov	r1, r4
   97244:	2201      	movs	r2, #1
   97246:	4648      	mov	r0, r9
   97248:	f001 fb9c 	bl	98984 <__lshift>
   9724c:	4641      	mov	r1, r8
   9724e:	9009      	str	r0, [sp, #36]	; 0x24
   97250:	f001 fbee 	bl	98a30 <__mcmp>
   97254:	2800      	cmp	r0, #0
   97256:	f340 830e 	ble.w	97876 <_dtoa_r+0xb66>
   9725a:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   9725e:	1e6b      	subs	r3, r5, #1
   97260:	9908      	ldr	r1, [sp, #32]
   97262:	e004      	b.n	9726e <_dtoa_r+0x55e>
   97264:	428b      	cmp	r3, r1
   97266:	f000 8279 	beq.w	9775c <_dtoa_r+0xa4c>
   9726a:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
   9726e:	2a39      	cmp	r2, #57	; 0x39
   97270:	f103 0501 	add.w	r5, r3, #1
   97274:	d0f6      	beq.n	97264 <_dtoa_r+0x554>
   97276:	3201      	adds	r2, #1
   97278:	701a      	strb	r2, [r3, #0]
   9727a:	4641      	mov	r1, r8
   9727c:	4648      	mov	r0, r9
   9727e:	f001 f9f1 	bl	98664 <_Bfree>
   97282:	2e00      	cmp	r6, #0
   97284:	f43f af08 	beq.w	97098 <_dtoa_r+0x388>
   97288:	f1bb 0f00 	cmp.w	fp, #0
   9728c:	d005      	beq.n	9729a <_dtoa_r+0x58a>
   9728e:	45b3      	cmp	fp, r6
   97290:	d003      	beq.n	9729a <_dtoa_r+0x58a>
   97292:	4659      	mov	r1, fp
   97294:	4648      	mov	r0, r9
   97296:	f001 f9e5 	bl	98664 <_Bfree>
   9729a:	4631      	mov	r1, r6
   9729c:	4648      	mov	r0, r9
   9729e:	f001 f9e1 	bl	98664 <_Bfree>
   972a2:	e6f9      	b.n	97098 <_dtoa_r+0x388>
   972a4:	2301      	movs	r3, #1
   972a6:	930d      	str	r3, [sp, #52]	; 0x34
   972a8:	e5ea      	b.n	96e80 <_dtoa_r+0x170>
   972aa:	f8dd 800c 	ldr.w	r8, [sp, #12]
   972ae:	4640      	mov	r0, r8
   972b0:	f7fb f9fe 	bl	926b0 <__aeabi_i2d>
   972b4:	4602      	mov	r2, r0
   972b6:	460b      	mov	r3, r1
   972b8:	4630      	mov	r0, r6
   972ba:	4639      	mov	r1, r7
   972bc:	f7fb fcc6 	bl	92c4c <__aeabi_dcmpeq>
   972c0:	2800      	cmp	r0, #0
   972c2:	f47f adc9 	bne.w	96e58 <_dtoa_r+0x148>
   972c6:	f108 33ff 	add.w	r3, r8, #4294967295
   972ca:	9303      	str	r3, [sp, #12]
   972cc:	e5c4      	b.n	96e58 <_dtoa_r+0x148>
   972ce:	9a06      	ldr	r2, [sp, #24]
   972d0:	9b03      	ldr	r3, [sp, #12]
   972d2:	1ad2      	subs	r2, r2, r3
   972d4:	425b      	negs	r3, r3
   972d6:	930b      	str	r3, [sp, #44]	; 0x2c
   972d8:	2300      	movs	r3, #0
   972da:	9206      	str	r2, [sp, #24]
   972dc:	930c      	str	r3, [sp, #48]	; 0x30
   972de:	e5e1      	b.n	96ea4 <_dtoa_r+0x194>
   972e0:	425b      	negs	r3, r3
   972e2:	9306      	str	r3, [sp, #24]
   972e4:	2300      	movs	r3, #0
   972e6:	9304      	str	r3, [sp, #16]
   972e8:	e5d1      	b.n	96e8e <_dtoa_r+0x17e>
   972ea:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   972ec:	9d06      	ldr	r5, [sp, #24]
   972ee:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   972f0:	e705      	b.n	970fe <_dtoa_r+0x3ee>
   972f2:	f1c3 0820 	rsb	r8, r3, #32
   972f6:	fa0a f008 	lsl.w	r0, sl, r8
   972fa:	e57a      	b.n	96df2 <_dtoa_r+0xe2>
   972fc:	900d      	str	r0, [sp, #52]	; 0x34
   972fe:	e5bf      	b.n	96e80 <_dtoa_r+0x170>
   97300:	40240000 	.word	0x40240000
   97304:	2300      	movs	r3, #0
   97306:	930a      	str	r3, [sp, #40]	; 0x28
   97308:	9b03      	ldr	r3, [sp, #12]
   9730a:	9a23      	ldr	r2, [sp, #140]	; 0x8c
   9730c:	4413      	add	r3, r2
   9730e:	930e      	str	r3, [sp, #56]	; 0x38
   97310:	3301      	adds	r3, #1
   97312:	2b00      	cmp	r3, #0
   97314:	9307      	str	r3, [sp, #28]
   97316:	f340 8285 	ble.w	97824 <_dtoa_r+0xb14>
   9731a:	9c07      	ldr	r4, [sp, #28]
   9731c:	4626      	mov	r6, r4
   9731e:	2100      	movs	r1, #0
   97320:	2e17      	cmp	r6, #23
   97322:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
   97326:	d90b      	bls.n	97340 <_dtoa_r+0x630>
   97328:	2201      	movs	r2, #1
   9732a:	2304      	movs	r3, #4
   9732c:	005b      	lsls	r3, r3, #1
   9732e:	f103 0014 	add.w	r0, r3, #20
   97332:	42b0      	cmp	r0, r6
   97334:	4611      	mov	r1, r2
   97336:	f102 0201 	add.w	r2, r2, #1
   9733a:	d9f7      	bls.n	9732c <_dtoa_r+0x61c>
   9733c:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
   97340:	4648      	mov	r0, r9
   97342:	f001 f967 	bl	98614 <_Balloc>
   97346:	2c0e      	cmp	r4, #14
   97348:	9008      	str	r0, [sp, #32]
   9734a:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
   9734e:	f63f ade8 	bhi.w	96f22 <_dtoa_r+0x212>
   97352:	2d00      	cmp	r5, #0
   97354:	f43f ade5 	beq.w	96f22 <_dtoa_r+0x212>
   97358:	4657      	mov	r7, sl
   9735a:	46d8      	mov	r8, fp
   9735c:	9903      	ldr	r1, [sp, #12]
   9735e:	e9cd 7810 	strd	r7, r8, [sp, #64]	; 0x40
   97362:	2900      	cmp	r1, #0
   97364:	f340 8293 	ble.w	9788e <_dtoa_r+0xb7e>
   97368:	4b92      	ldr	r3, [pc, #584]	; (975b4 <_dtoa_r+0x8a4>)
   9736a:	f001 020f 	and.w	r2, r1, #15
   9736e:	110e      	asrs	r6, r1, #4
   97370:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   97374:	06f0      	lsls	r0, r6, #27
   97376:	e9d3 4500 	ldrd	r4, r5, [r3]
   9737a:	f140 824e 	bpl.w	9781a <_dtoa_r+0xb0a>
   9737e:	4b8e      	ldr	r3, [pc, #568]	; (975b8 <_dtoa_r+0x8a8>)
   97380:	4650      	mov	r0, sl
   97382:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
   97386:	4659      	mov	r1, fp
   97388:	f7fb fb22 	bl	929d0 <__aeabi_ddiv>
   9738c:	4682      	mov	sl, r0
   9738e:	468b      	mov	fp, r1
   97390:	f006 060f 	and.w	r6, r6, #15
   97394:	f04f 0803 	mov.w	r8, #3
   97398:	b186      	cbz	r6, 973bc <_dtoa_r+0x6ac>
   9739a:	4f87      	ldr	r7, [pc, #540]	; (975b8 <_dtoa_r+0x8a8>)
   9739c:	07f1      	lsls	r1, r6, #31
   9739e:	d509      	bpl.n	973b4 <_dtoa_r+0x6a4>
   973a0:	e9d7 2300 	ldrd	r2, r3, [r7]
   973a4:	4620      	mov	r0, r4
   973a6:	4629      	mov	r1, r5
   973a8:	f7fb f9e8 	bl	9277c <__aeabi_dmul>
   973ac:	4604      	mov	r4, r0
   973ae:	460d      	mov	r5, r1
   973b0:	f108 0801 	add.w	r8, r8, #1
   973b4:	1076      	asrs	r6, r6, #1
   973b6:	f107 0708 	add.w	r7, r7, #8
   973ba:	d1ef      	bne.n	9739c <_dtoa_r+0x68c>
   973bc:	4622      	mov	r2, r4
   973be:	462b      	mov	r3, r5
   973c0:	4650      	mov	r0, sl
   973c2:	4659      	mov	r1, fp
   973c4:	f7fb fb04 	bl	929d0 <__aeabi_ddiv>
   973c8:	4606      	mov	r6, r0
   973ca:	460f      	mov	r7, r1
   973cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   973ce:	b143      	cbz	r3, 973e2 <_dtoa_r+0x6d2>
   973d0:	2200      	movs	r2, #0
   973d2:	4b7a      	ldr	r3, [pc, #488]	; (975bc <_dtoa_r+0x8ac>)
   973d4:	4630      	mov	r0, r6
   973d6:	4639      	mov	r1, r7
   973d8:	f7fb fc42 	bl	92c60 <__aeabi_dcmplt>
   973dc:	2800      	cmp	r0, #0
   973de:	f040 8323 	bne.w	97a28 <_dtoa_r+0xd18>
   973e2:	4640      	mov	r0, r8
   973e4:	f7fb f964 	bl	926b0 <__aeabi_i2d>
   973e8:	4632      	mov	r2, r6
   973ea:	463b      	mov	r3, r7
   973ec:	f7fb f9c6 	bl	9277c <__aeabi_dmul>
   973f0:	4b73      	ldr	r3, [pc, #460]	; (975c0 <_dtoa_r+0x8b0>)
   973f2:	2200      	movs	r2, #0
   973f4:	f7fb f810 	bl	92418 <__adddf3>
   973f8:	9b07      	ldr	r3, [sp, #28]
   973fa:	4604      	mov	r4, r0
   973fc:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
   97400:	2b00      	cmp	r3, #0
   97402:	f000 81e1 	beq.w	977c8 <_dtoa_r+0xab8>
   97406:	9b03      	ldr	r3, [sp, #12]
   97408:	9313      	str	r3, [sp, #76]	; 0x4c
   9740a:	9b07      	ldr	r3, [sp, #28]
   9740c:	9312      	str	r3, [sp, #72]	; 0x48
   9740e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   97410:	2b00      	cmp	r3, #0
   97412:	f000 8298 	beq.w	97946 <_dtoa_r+0xc36>
   97416:	9a12      	ldr	r2, [sp, #72]	; 0x48
   97418:	4b66      	ldr	r3, [pc, #408]	; (975b4 <_dtoa_r+0x8a4>)
   9741a:	2000      	movs	r0, #0
   9741c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   97420:	e953 2302 	ldrd	r2, r3, [r3, #-8]
   97424:	4967      	ldr	r1, [pc, #412]	; (975c4 <_dtoa_r+0x8b4>)
   97426:	f7fb fad3 	bl	929d0 <__aeabi_ddiv>
   9742a:	4622      	mov	r2, r4
   9742c:	462b      	mov	r3, r5
   9742e:	f7fa fff1 	bl	92414 <__aeabi_dsub>
   97432:	4682      	mov	sl, r0
   97434:	468b      	mov	fp, r1
   97436:	4630      	mov	r0, r6
   97438:	4639      	mov	r1, r7
   9743a:	f7fb fc4f 	bl	92cdc <__aeabi_d2iz>
   9743e:	4604      	mov	r4, r0
   97440:	f7fb f936 	bl	926b0 <__aeabi_i2d>
   97444:	4602      	mov	r2, r0
   97446:	460b      	mov	r3, r1
   97448:	4630      	mov	r0, r6
   9744a:	4639      	mov	r1, r7
   9744c:	f7fa ffe2 	bl	92414 <__aeabi_dsub>
   97450:	3430      	adds	r4, #48	; 0x30
   97452:	9d08      	ldr	r5, [sp, #32]
   97454:	b2e4      	uxtb	r4, r4
   97456:	4606      	mov	r6, r0
   97458:	460f      	mov	r7, r1
   9745a:	702c      	strb	r4, [r5, #0]
   9745c:	4602      	mov	r2, r0
   9745e:	460b      	mov	r3, r1
   97460:	4650      	mov	r0, sl
   97462:	4659      	mov	r1, fp
   97464:	3501      	adds	r5, #1
   97466:	f7fb fc19 	bl	92c9c <__aeabi_dcmpgt>
   9746a:	2800      	cmp	r0, #0
   9746c:	d14e      	bne.n	9750c <_dtoa_r+0x7fc>
   9746e:	4632      	mov	r2, r6
   97470:	463b      	mov	r3, r7
   97472:	2000      	movs	r0, #0
   97474:	4951      	ldr	r1, [pc, #324]	; (975bc <_dtoa_r+0x8ac>)
   97476:	f7fa ffcd 	bl	92414 <__aeabi_dsub>
   9747a:	4602      	mov	r2, r0
   9747c:	460b      	mov	r3, r1
   9747e:	4650      	mov	r0, sl
   97480:	4659      	mov	r1, fp
   97482:	f7fb fc0b 	bl	92c9c <__aeabi_dcmpgt>
   97486:	2800      	cmp	r0, #0
   97488:	f040 830e 	bne.w	97aa8 <_dtoa_r+0xd98>
   9748c:	9a12      	ldr	r2, [sp, #72]	; 0x48
   9748e:	2a01      	cmp	r2, #1
   97490:	f340 81b4 	ble.w	977fc <_dtoa_r+0xaec>
   97494:	9b12      	ldr	r3, [sp, #72]	; 0x48
   97496:	9a08      	ldr	r2, [sp, #32]
   97498:	4413      	add	r3, r2
   9749a:	4698      	mov	r8, r3
   9749c:	e00f      	b.n	974be <_dtoa_r+0x7ae>
   9749e:	4632      	mov	r2, r6
   974a0:	463b      	mov	r3, r7
   974a2:	2000      	movs	r0, #0
   974a4:	4945      	ldr	r1, [pc, #276]	; (975bc <_dtoa_r+0x8ac>)
   974a6:	f7fa ffb5 	bl	92414 <__aeabi_dsub>
   974aa:	4652      	mov	r2, sl
   974ac:	465b      	mov	r3, fp
   974ae:	f7fb fbd7 	bl	92c60 <__aeabi_dcmplt>
   974b2:	2800      	cmp	r0, #0
   974b4:	f040 82f8 	bne.w	97aa8 <_dtoa_r+0xd98>
   974b8:	4545      	cmp	r5, r8
   974ba:	f000 819f 	beq.w	977fc <_dtoa_r+0xaec>
   974be:	4650      	mov	r0, sl
   974c0:	4659      	mov	r1, fp
   974c2:	2200      	movs	r2, #0
   974c4:	4b40      	ldr	r3, [pc, #256]	; (975c8 <_dtoa_r+0x8b8>)
   974c6:	f7fb f959 	bl	9277c <__aeabi_dmul>
   974ca:	2200      	movs	r2, #0
   974cc:	4b3e      	ldr	r3, [pc, #248]	; (975c8 <_dtoa_r+0x8b8>)
   974ce:	4682      	mov	sl, r0
   974d0:	468b      	mov	fp, r1
   974d2:	4630      	mov	r0, r6
   974d4:	4639      	mov	r1, r7
   974d6:	f7fb f951 	bl	9277c <__aeabi_dmul>
   974da:	460f      	mov	r7, r1
   974dc:	4606      	mov	r6, r0
   974de:	f7fb fbfd 	bl	92cdc <__aeabi_d2iz>
   974e2:	4604      	mov	r4, r0
   974e4:	f7fb f8e4 	bl	926b0 <__aeabi_i2d>
   974e8:	4602      	mov	r2, r0
   974ea:	460b      	mov	r3, r1
   974ec:	4630      	mov	r0, r6
   974ee:	4639      	mov	r1, r7
   974f0:	f7fa ff90 	bl	92414 <__aeabi_dsub>
   974f4:	3430      	adds	r4, #48	; 0x30
   974f6:	b2e4      	uxtb	r4, r4
   974f8:	f805 4b01 	strb.w	r4, [r5], #1
   974fc:	4652      	mov	r2, sl
   974fe:	465b      	mov	r3, fp
   97500:	4606      	mov	r6, r0
   97502:	460f      	mov	r7, r1
   97504:	f7fb fbac 	bl	92c60 <__aeabi_dcmplt>
   97508:	2800      	cmp	r0, #0
   9750a:	d0c8      	beq.n	9749e <_dtoa_r+0x78e>
   9750c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   9750e:	9303      	str	r3, [sp, #12]
   97510:	e5c2      	b.n	97098 <_dtoa_r+0x388>
   97512:	2300      	movs	r3, #0
   97514:	930a      	str	r3, [sp, #40]	; 0x28
   97516:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   97518:	2b00      	cmp	r3, #0
   9751a:	f340 8188 	ble.w	9782e <_dtoa_r+0xb1e>
   9751e:	461e      	mov	r6, r3
   97520:	461c      	mov	r4, r3
   97522:	930e      	str	r3, [sp, #56]	; 0x38
   97524:	9307      	str	r3, [sp, #28]
   97526:	e6fa      	b.n	9731e <_dtoa_r+0x60e>
   97528:	2301      	movs	r3, #1
   9752a:	930a      	str	r3, [sp, #40]	; 0x28
   9752c:	e7f3      	b.n	97516 <_dtoa_r+0x806>
   9752e:	9409      	str	r4, [sp, #36]	; 0x24
   97530:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   97532:	9909      	ldr	r1, [sp, #36]	; 0x24
   97534:	4648      	mov	r0, r9
   97536:	f001 f9d5 	bl	988e4 <__pow5mult>
   9753a:	4604      	mov	r4, r0
   9753c:	e60f      	b.n	9715e <_dtoa_r+0x44e>
   9753e:	9b07      	ldr	r3, [sp, #28]
   97540:	2b00      	cmp	r3, #0
   97542:	f73f ad00 	bgt.w	96f46 <_dtoa_r+0x236>
   97546:	f040 82d9 	bne.w	97afc <_dtoa_r+0xdec>
   9754a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   9754e:	2200      	movs	r2, #0
   97550:	4b1e      	ldr	r3, [pc, #120]	; (975cc <_dtoa_r+0x8bc>)
   97552:	f7fb f913 	bl	9277c <__aeabi_dmul>
   97556:	4652      	mov	r2, sl
   97558:	465b      	mov	r3, fp
   9755a:	f7fb fb95 	bl	92c88 <__aeabi_dcmpge>
   9755e:	f8dd 801c 	ldr.w	r8, [sp, #28]
   97562:	4646      	mov	r6, r8
   97564:	2800      	cmp	r0, #0
   97566:	f000 80f1 	beq.w	9774c <_dtoa_r+0xa3c>
   9756a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   9756c:	9d08      	ldr	r5, [sp, #32]
   9756e:	43db      	mvns	r3, r3
   97570:	9303      	str	r3, [sp, #12]
   97572:	4641      	mov	r1, r8
   97574:	4648      	mov	r0, r9
   97576:	f001 f875 	bl	98664 <_Bfree>
   9757a:	2e00      	cmp	r6, #0
   9757c:	f43f ad8c 	beq.w	97098 <_dtoa_r+0x388>
   97580:	e68b      	b.n	9729a <_dtoa_r+0x58a>
   97582:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   97584:	2a00      	cmp	r2, #0
   97586:	f000 8241 	beq.w	97a0c <_dtoa_r+0xcfc>
   9758a:	f203 4333 	addw	r3, r3, #1075	; 0x433
   9758e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   97590:	9d06      	ldr	r5, [sp, #24]
   97592:	e5a9      	b.n	970e8 <_dtoa_r+0x3d8>
   97594:	201c      	movs	r0, #28
   97596:	9b06      	ldr	r3, [sp, #24]
   97598:	4405      	add	r5, r0
   9759a:	4403      	add	r3, r0
   9759c:	9306      	str	r3, [sp, #24]
   9759e:	9b04      	ldr	r3, [sp, #16]
   975a0:	4403      	add	r3, r0
   975a2:	9304      	str	r3, [sp, #16]
   975a4:	e60c      	b.n	971c0 <_dtoa_r+0x4b0>
   975a6:	9b22      	ldr	r3, [sp, #136]	; 0x88
   975a8:	2b01      	cmp	r3, #1
   975aa:	f340 8281 	ble.w	97ab0 <_dtoa_r+0xda0>
   975ae:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   975b0:	2001      	movs	r0, #1
   975b2:	e5f1      	b.n	97198 <_dtoa_r+0x488>
   975b4:	0009b218 	.word	0x0009b218
   975b8:	0009b2e0 	.word	0x0009b2e0
   975bc:	3ff00000 	.word	0x3ff00000
   975c0:	401c0000 	.word	0x401c0000
   975c4:	3fe00000 	.word	0x3fe00000
   975c8:	40240000 	.word	0x40240000
   975cc:	40140000 	.word	0x40140000
   975d0:	4631      	mov	r1, r6
   975d2:	2300      	movs	r3, #0
   975d4:	220a      	movs	r2, #10
   975d6:	4648      	mov	r0, r9
   975d8:	f001 f84e 	bl	98678 <__multadd>
   975dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   975de:	4606      	mov	r6, r0
   975e0:	2b00      	cmp	r3, #0
   975e2:	f340 8297 	ble.w	97b14 <_dtoa_r+0xe04>
   975e6:	9307      	str	r3, [sp, #28]
   975e8:	2d00      	cmp	r5, #0
   975ea:	dd05      	ble.n	975f8 <_dtoa_r+0x8e8>
   975ec:	4631      	mov	r1, r6
   975ee:	462a      	mov	r2, r5
   975f0:	4648      	mov	r0, r9
   975f2:	f001 f9c7 	bl	98984 <__lshift>
   975f6:	4606      	mov	r6, r0
   975f8:	2f00      	cmp	r7, #0
   975fa:	f040 817b 	bne.w	978f4 <_dtoa_r+0xbe4>
   975fe:	9606      	str	r6, [sp, #24]
   97600:	9b07      	ldr	r3, [sp, #28]
   97602:	9a08      	ldr	r2, [sp, #32]
   97604:	3b01      	subs	r3, #1
   97606:	18d3      	adds	r3, r2, r3
   97608:	9309      	str	r3, [sp, #36]	; 0x24
   9760a:	4617      	mov	r7, r2
   9760c:	f00a 0301 	and.w	r3, sl, #1
   97610:	46c2      	mov	sl, r8
   97612:	f8dd b018 	ldr.w	fp, [sp, #24]
   97616:	930a      	str	r3, [sp, #40]	; 0x28
   97618:	4651      	mov	r1, sl
   9761a:	4620      	mov	r0, r4
   9761c:	f7ff fae0 	bl	96be0 <quorem>
   97620:	4631      	mov	r1, r6
   97622:	4605      	mov	r5, r0
   97624:	4620      	mov	r0, r4
   97626:	f001 fa03 	bl	98a30 <__mcmp>
   9762a:	465a      	mov	r2, fp
   9762c:	9004      	str	r0, [sp, #16]
   9762e:	4651      	mov	r1, sl
   97630:	4648      	mov	r0, r9
   97632:	f001 fa1d 	bl	98a70 <__mdiff>
   97636:	68c2      	ldr	r2, [r0, #12]
   97638:	4680      	mov	r8, r0
   9763a:	f105 0330 	add.w	r3, r5, #48	; 0x30
   9763e:	2a00      	cmp	r2, #0
   97640:	d149      	bne.n	976d6 <_dtoa_r+0x9c6>
   97642:	4601      	mov	r1, r0
   97644:	4620      	mov	r0, r4
   97646:	9307      	str	r3, [sp, #28]
   97648:	f001 f9f2 	bl	98a30 <__mcmp>
   9764c:	4641      	mov	r1, r8
   9764e:	9006      	str	r0, [sp, #24]
   97650:	4648      	mov	r0, r9
   97652:	f001 f807 	bl	98664 <_Bfree>
   97656:	9a06      	ldr	r2, [sp, #24]
   97658:	9b07      	ldr	r3, [sp, #28]
   9765a:	b92a      	cbnz	r2, 97668 <_dtoa_r+0x958>
   9765c:	9922      	ldr	r1, [sp, #136]	; 0x88
   9765e:	b919      	cbnz	r1, 97668 <_dtoa_r+0x958>
   97660:	990a      	ldr	r1, [sp, #40]	; 0x28
   97662:	2900      	cmp	r1, #0
   97664:	f000 8236 	beq.w	97ad4 <_dtoa_r+0xdc4>
   97668:	9904      	ldr	r1, [sp, #16]
   9766a:	2900      	cmp	r1, #0
   9766c:	f2c0 80e4 	blt.w	97838 <_dtoa_r+0xb28>
   97670:	d105      	bne.n	9767e <_dtoa_r+0x96e>
   97672:	9922      	ldr	r1, [sp, #136]	; 0x88
   97674:	b919      	cbnz	r1, 9767e <_dtoa_r+0x96e>
   97676:	990a      	ldr	r1, [sp, #40]	; 0x28
   97678:	2900      	cmp	r1, #0
   9767a:	f000 80dd 	beq.w	97838 <_dtoa_r+0xb28>
   9767e:	2a00      	cmp	r2, #0
   97680:	f300 814c 	bgt.w	9791c <_dtoa_r+0xc0c>
   97684:	9a09      	ldr	r2, [sp, #36]	; 0x24
   97686:	f107 0801 	add.w	r8, r7, #1
   9768a:	4297      	cmp	r7, r2
   9768c:	703b      	strb	r3, [r7, #0]
   9768e:	4645      	mov	r5, r8
   97690:	f000 8153 	beq.w	9793a <_dtoa_r+0xc2a>
   97694:	4621      	mov	r1, r4
   97696:	2300      	movs	r3, #0
   97698:	220a      	movs	r2, #10
   9769a:	4648      	mov	r0, r9
   9769c:	f000 ffec 	bl	98678 <__multadd>
   976a0:	455e      	cmp	r6, fp
   976a2:	4604      	mov	r4, r0
   976a4:	4631      	mov	r1, r6
   976a6:	f04f 0300 	mov.w	r3, #0
   976aa:	f04f 020a 	mov.w	r2, #10
   976ae:	4648      	mov	r0, r9
   976b0:	d00b      	beq.n	976ca <_dtoa_r+0x9ba>
   976b2:	f000 ffe1 	bl	98678 <__multadd>
   976b6:	4659      	mov	r1, fp
   976b8:	4606      	mov	r6, r0
   976ba:	2300      	movs	r3, #0
   976bc:	220a      	movs	r2, #10
   976be:	4648      	mov	r0, r9
   976c0:	f000 ffda 	bl	98678 <__multadd>
   976c4:	4647      	mov	r7, r8
   976c6:	4683      	mov	fp, r0
   976c8:	e7a6      	b.n	97618 <_dtoa_r+0x908>
   976ca:	f000 ffd5 	bl	98678 <__multadd>
   976ce:	4647      	mov	r7, r8
   976d0:	4606      	mov	r6, r0
   976d2:	4683      	mov	fp, r0
   976d4:	e7a0      	b.n	97618 <_dtoa_r+0x908>
   976d6:	4601      	mov	r1, r0
   976d8:	4648      	mov	r0, r9
   976da:	9306      	str	r3, [sp, #24]
   976dc:	f000 ffc2 	bl	98664 <_Bfree>
   976e0:	2201      	movs	r2, #1
   976e2:	9b06      	ldr	r3, [sp, #24]
   976e4:	e7c0      	b.n	97668 <_dtoa_r+0x958>
   976e6:	4641      	mov	r1, r8
   976e8:	4620      	mov	r0, r4
   976ea:	f001 f9a1 	bl	98a30 <__mcmp>
   976ee:	2800      	cmp	r0, #0
   976f0:	f6bf ad7c 	bge.w	971ec <_dtoa_r+0x4dc>
   976f4:	4621      	mov	r1, r4
   976f6:	9c03      	ldr	r4, [sp, #12]
   976f8:	2300      	movs	r3, #0
   976fa:	3c01      	subs	r4, #1
   976fc:	220a      	movs	r2, #10
   976fe:	4648      	mov	r0, r9
   97700:	9403      	str	r4, [sp, #12]
   97702:	f000 ffb9 	bl	98678 <__multadd>
   97706:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   97708:	4604      	mov	r4, r0
   9770a:	2b00      	cmp	r3, #0
   9770c:	f47f af60 	bne.w	975d0 <_dtoa_r+0x8c0>
   97710:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   97712:	2b00      	cmp	r3, #0
   97714:	f340 81f6 	ble.w	97b04 <_dtoa_r+0xdf4>
   97718:	9307      	str	r3, [sp, #28]
   9771a:	e56f      	b.n	971fc <_dtoa_r+0x4ec>
   9771c:	9c09      	ldr	r4, [sp, #36]	; 0x24
   9771e:	e51e      	b.n	9715e <_dtoa_r+0x44e>
   97720:	9b22      	ldr	r3, [sp, #136]	; 0x88
   97722:	2b02      	cmp	r3, #2
   97724:	f77f ad66 	ble.w	971f4 <_dtoa_r+0x4e4>
   97728:	9b07      	ldr	r3, [sp, #28]
   9772a:	2b00      	cmp	r3, #0
   9772c:	f040 817a 	bne.w	97a24 <_dtoa_r+0xd14>
   97730:	4641      	mov	r1, r8
   97732:	2205      	movs	r2, #5
   97734:	4648      	mov	r0, r9
   97736:	f000 ff9f 	bl	98678 <__multadd>
   9773a:	4601      	mov	r1, r0
   9773c:	4680      	mov	r8, r0
   9773e:	4620      	mov	r0, r4
   97740:	f001 f976 	bl	98a30 <__mcmp>
   97744:	2800      	cmp	r0, #0
   97746:	9409      	str	r4, [sp, #36]	; 0x24
   97748:	f77f af0f 	ble.w	9756a <_dtoa_r+0x85a>
   9774c:	9a03      	ldr	r2, [sp, #12]
   9774e:	9908      	ldr	r1, [sp, #32]
   97750:	2331      	movs	r3, #49	; 0x31
   97752:	3201      	adds	r2, #1
   97754:	9203      	str	r2, [sp, #12]
   97756:	700b      	strb	r3, [r1, #0]
   97758:	1c4d      	adds	r5, r1, #1
   9775a:	e70a      	b.n	97572 <_dtoa_r+0x862>
   9775c:	9a03      	ldr	r2, [sp, #12]
   9775e:	2331      	movs	r3, #49	; 0x31
   97760:	3201      	adds	r2, #1
   97762:	9203      	str	r2, [sp, #12]
   97764:	9a08      	ldr	r2, [sp, #32]
   97766:	7013      	strb	r3, [r2, #0]
   97768:	e587      	b.n	9727a <_dtoa_r+0x56a>
   9776a:	2301      	movs	r3, #1
   9776c:	930a      	str	r3, [sp, #40]	; 0x28
   9776e:	e5cb      	b.n	97308 <_dtoa_r+0x5f8>
   97770:	f8dd 9018 	ldr.w	r9, [sp, #24]
   97774:	e490      	b.n	97098 <_dtoa_r+0x388>
   97776:	f1ba 0f00 	cmp.w	sl, #0
   9777a:	f47f ad03 	bne.w	97184 <_dtoa_r+0x474>
   9777e:	f3cb 0313 	ubfx	r3, fp, #0, #20
   97782:	2b00      	cmp	r3, #0
   97784:	f040 8140 	bne.w	97a08 <_dtoa_r+0xcf8>
   97788:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
   9778c:	0d3f      	lsrs	r7, r7, #20
   9778e:	053f      	lsls	r7, r7, #20
   97790:	b137      	cbz	r7, 977a0 <_dtoa_r+0xa90>
   97792:	9b06      	ldr	r3, [sp, #24]
   97794:	2701      	movs	r7, #1
   97796:	3301      	adds	r3, #1
   97798:	9306      	str	r3, [sp, #24]
   9779a:	9b04      	ldr	r3, [sp, #16]
   9779c:	3301      	adds	r3, #1
   9779e:	9304      	str	r3, [sp, #16]
   977a0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   977a2:	2001      	movs	r0, #1
   977a4:	2b00      	cmp	r3, #0
   977a6:	f43f acf7 	beq.w	97198 <_dtoa_r+0x488>
   977aa:	e4ec      	b.n	97186 <_dtoa_r+0x476>
   977ac:	4640      	mov	r0, r8
   977ae:	f7fa ff7f 	bl	926b0 <__aeabi_i2d>
   977b2:	4632      	mov	r2, r6
   977b4:	463b      	mov	r3, r7
   977b6:	f7fa ffe1 	bl	9277c <__aeabi_dmul>
   977ba:	2200      	movs	r2, #0
   977bc:	4bbf      	ldr	r3, [pc, #764]	; (97abc <_dtoa_r+0xdac>)
   977be:	f7fa fe2b 	bl	92418 <__adddf3>
   977c2:	4604      	mov	r4, r0
   977c4:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
   977c8:	4630      	mov	r0, r6
   977ca:	4639      	mov	r1, r7
   977cc:	2200      	movs	r2, #0
   977ce:	4bbc      	ldr	r3, [pc, #752]	; (97ac0 <_dtoa_r+0xdb0>)
   977d0:	f7fa fe20 	bl	92414 <__aeabi_dsub>
   977d4:	4622      	mov	r2, r4
   977d6:	462b      	mov	r3, r5
   977d8:	4606      	mov	r6, r0
   977da:	460f      	mov	r7, r1
   977dc:	f7fb fa5e 	bl	92c9c <__aeabi_dcmpgt>
   977e0:	4680      	mov	r8, r0
   977e2:	2800      	cmp	r0, #0
   977e4:	f040 8106 	bne.w	979f4 <_dtoa_r+0xce4>
   977e8:	4622      	mov	r2, r4
   977ea:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
   977ee:	4630      	mov	r0, r6
   977f0:	4639      	mov	r1, r7
   977f2:	f7fb fa35 	bl	92c60 <__aeabi_dcmplt>
   977f6:	b108      	cbz	r0, 977fc <_dtoa_r+0xaec>
   977f8:	4646      	mov	r6, r8
   977fa:	e6b6      	b.n	9756a <_dtoa_r+0x85a>
   977fc:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
   97800:	f7ff bb8f 	b.w	96f22 <_dtoa_r+0x212>
   97804:	9808      	ldr	r0, [sp, #32]
   97806:	f7ff bab4 	b.w	96d72 <_dtoa_r+0x62>
   9780a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   9780c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   9780e:	1afb      	subs	r3, r7, r3
   97810:	441a      	add	r2, r3
   97812:	970b      	str	r7, [sp, #44]	; 0x2c
   97814:	920c      	str	r2, [sp, #48]	; 0x30
   97816:	2700      	movs	r7, #0
   97818:	e460      	b.n	970dc <_dtoa_r+0x3cc>
   9781a:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
   9781e:	f04f 0802 	mov.w	r8, #2
   97822:	e5b9      	b.n	97398 <_dtoa_r+0x688>
   97824:	461c      	mov	r4, r3
   97826:	2100      	movs	r1, #0
   97828:	f8c9 1044 	str.w	r1, [r9, #68]	; 0x44
   9782c:	e588      	b.n	97340 <_dtoa_r+0x630>
   9782e:	2401      	movs	r4, #1
   97830:	9423      	str	r4, [sp, #140]	; 0x8c
   97832:	940e      	str	r4, [sp, #56]	; 0x38
   97834:	9407      	str	r4, [sp, #28]
   97836:	e7f6      	b.n	97826 <_dtoa_r+0xb16>
   97838:	2a00      	cmp	r2, #0
   9783a:	46d0      	mov	r8, sl
   9783c:	f8cd b018 	str.w	fp, [sp, #24]
   97840:	469a      	mov	sl, r3
   97842:	dd11      	ble.n	97868 <_dtoa_r+0xb58>
   97844:	4621      	mov	r1, r4
   97846:	2201      	movs	r2, #1
   97848:	4648      	mov	r0, r9
   9784a:	f001 f89b 	bl	98984 <__lshift>
   9784e:	4641      	mov	r1, r8
   97850:	4604      	mov	r4, r0
   97852:	f001 f8ed 	bl	98a30 <__mcmp>
   97856:	2800      	cmp	r0, #0
   97858:	f340 8149 	ble.w	97aee <_dtoa_r+0xdde>
   9785c:	f1ba 0f39 	cmp.w	sl, #57	; 0x39
   97860:	f000 8107 	beq.w	97a72 <_dtoa_r+0xd62>
   97864:	f105 0a31 	add.w	sl, r5, #49	; 0x31
   97868:	46b3      	mov	fp, r6
   9786a:	f887 a000 	strb.w	sl, [r7]
   9786e:	1c7d      	adds	r5, r7, #1
   97870:	9e06      	ldr	r6, [sp, #24]
   97872:	9409      	str	r4, [sp, #36]	; 0x24
   97874:	e501      	b.n	9727a <_dtoa_r+0x56a>
   97876:	d104      	bne.n	97882 <_dtoa_r+0xb72>
   97878:	f01a 0f01 	tst.w	sl, #1
   9787c:	d001      	beq.n	97882 <_dtoa_r+0xb72>
   9787e:	e4ec      	b.n	9725a <_dtoa_r+0x54a>
   97880:	4615      	mov	r5, r2
   97882:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   97886:	1e6a      	subs	r2, r5, #1
   97888:	2b30      	cmp	r3, #48	; 0x30
   9788a:	d0f9      	beq.n	97880 <_dtoa_r+0xb70>
   9788c:	e4f5      	b.n	9727a <_dtoa_r+0x56a>
   9788e:	9b03      	ldr	r3, [sp, #12]
   97890:	425c      	negs	r4, r3
   97892:	2c00      	cmp	r4, #0
   97894:	f000 80c1 	beq.w	97a1a <_dtoa_r+0xd0a>
   97898:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
   9789c:	4b89      	ldr	r3, [pc, #548]	; (97ac4 <_dtoa_r+0xdb4>)
   9789e:	f004 020f 	and.w	r2, r4, #15
   978a2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   978a6:	e9d3 2300 	ldrd	r2, r3, [r3]
   978aa:	f7fa ff67 	bl	9277c <__aeabi_dmul>
   978ae:	1124      	asrs	r4, r4, #4
   978b0:	4606      	mov	r6, r0
   978b2:	460f      	mov	r7, r1
   978b4:	f000 812b 	beq.w	97b0e <_dtoa_r+0xdfe>
   978b8:	4d83      	ldr	r5, [pc, #524]	; (97ac8 <_dtoa_r+0xdb8>)
   978ba:	f04f 0802 	mov.w	r8, #2
   978be:	07e2      	lsls	r2, r4, #31
   978c0:	d509      	bpl.n	978d6 <_dtoa_r+0xbc6>
   978c2:	e9d5 2300 	ldrd	r2, r3, [r5]
   978c6:	4630      	mov	r0, r6
   978c8:	4639      	mov	r1, r7
   978ca:	f7fa ff57 	bl	9277c <__aeabi_dmul>
   978ce:	4606      	mov	r6, r0
   978d0:	460f      	mov	r7, r1
   978d2:	f108 0801 	add.w	r8, r8, #1
   978d6:	1064      	asrs	r4, r4, #1
   978d8:	f105 0508 	add.w	r5, r5, #8
   978dc:	d1ef      	bne.n	978be <_dtoa_r+0xbae>
   978de:	e575      	b.n	973cc <_dtoa_r+0x6bc>
   978e0:	9908      	ldr	r1, [sp, #32]
   978e2:	2230      	movs	r2, #48	; 0x30
   978e4:	700a      	strb	r2, [r1, #0]
   978e6:	9a03      	ldr	r2, [sp, #12]
   978e8:	f815 4c01 	ldrb.w	r4, [r5, #-1]
   978ec:	3201      	adds	r2, #1
   978ee:	9203      	str	r2, [sp, #12]
   978f0:	f7ff bbd0 	b.w	97094 <_dtoa_r+0x384>
   978f4:	6871      	ldr	r1, [r6, #4]
   978f6:	4648      	mov	r0, r9
   978f8:	f000 fe8c 	bl	98614 <_Balloc>
   978fc:	4605      	mov	r5, r0
   978fe:	6933      	ldr	r3, [r6, #16]
   97900:	f106 010c 	add.w	r1, r6, #12
   97904:	1c9a      	adds	r2, r3, #2
   97906:	0092      	lsls	r2, r2, #2
   97908:	300c      	adds	r0, #12
   9790a:	f7fc f901 	bl	93b10 <memcpy>
   9790e:	4629      	mov	r1, r5
   97910:	2201      	movs	r2, #1
   97912:	4648      	mov	r0, r9
   97914:	f001 f836 	bl	98984 <__lshift>
   97918:	9006      	str	r0, [sp, #24]
   9791a:	e671      	b.n	97600 <_dtoa_r+0x8f0>
   9791c:	2b39      	cmp	r3, #57	; 0x39
   9791e:	f8cd b018 	str.w	fp, [sp, #24]
   97922:	46d0      	mov	r8, sl
   97924:	f000 80a5 	beq.w	97a72 <_dtoa_r+0xd62>
   97928:	f103 0a01 	add.w	sl, r3, #1
   9792c:	46b3      	mov	fp, r6
   9792e:	f887 a000 	strb.w	sl, [r7]
   97932:	1c7d      	adds	r5, r7, #1
   97934:	9e06      	ldr	r6, [sp, #24]
   97936:	9409      	str	r4, [sp, #36]	; 0x24
   97938:	e49f      	b.n	9727a <_dtoa_r+0x56a>
   9793a:	465a      	mov	r2, fp
   9793c:	46d0      	mov	r8, sl
   9793e:	46b3      	mov	fp, r6
   97940:	469a      	mov	sl, r3
   97942:	4616      	mov	r6, r2
   97944:	e47d      	b.n	97242 <_dtoa_r+0x532>
   97946:	9b12      	ldr	r3, [sp, #72]	; 0x48
   97948:	495e      	ldr	r1, [pc, #376]	; (97ac4 <_dtoa_r+0xdb4>)
   9794a:	f103 3aff 	add.w	sl, r3, #4294967295
   9794e:	eb01 01ca 	add.w	r1, r1, sl, lsl #3
   97952:	4622      	mov	r2, r4
   97954:	e9d1 0100 	ldrd	r0, r1, [r1]
   97958:	462b      	mov	r3, r5
   9795a:	f7fa ff0f 	bl	9277c <__aeabi_dmul>
   9795e:	e9cd 0114 	strd	r0, r1, [sp, #80]	; 0x50
   97962:	4639      	mov	r1, r7
   97964:	4630      	mov	r0, r6
   97966:	f7fb f9b9 	bl	92cdc <__aeabi_d2iz>
   9796a:	4604      	mov	r4, r0
   9796c:	f7fa fea0 	bl	926b0 <__aeabi_i2d>
   97970:	460b      	mov	r3, r1
   97972:	4602      	mov	r2, r0
   97974:	4639      	mov	r1, r7
   97976:	4630      	mov	r0, r6
   97978:	f7fa fd4c 	bl	92414 <__aeabi_dsub>
   9797c:	9b12      	ldr	r3, [sp, #72]	; 0x48
   9797e:	460f      	mov	r7, r1
   97980:	9908      	ldr	r1, [sp, #32]
   97982:	3430      	adds	r4, #48	; 0x30
   97984:	2b01      	cmp	r3, #1
   97986:	4606      	mov	r6, r0
   97988:	700c      	strb	r4, [r1, #0]
   9798a:	f101 0501 	add.w	r5, r1, #1
   9798e:	d01f      	beq.n	979d0 <_dtoa_r+0xcc0>
   97990:	9b12      	ldr	r3, [sp, #72]	; 0x48
   97992:	9a08      	ldr	r2, [sp, #32]
   97994:	46a8      	mov	r8, r5
   97996:	4413      	add	r3, r2
   97998:	469b      	mov	fp, r3
   9799a:	2200      	movs	r2, #0
   9799c:	4b4b      	ldr	r3, [pc, #300]	; (97acc <_dtoa_r+0xdbc>)
   9799e:	4630      	mov	r0, r6
   979a0:	4639      	mov	r1, r7
   979a2:	f7fa feeb 	bl	9277c <__aeabi_dmul>
   979a6:	460f      	mov	r7, r1
   979a8:	4606      	mov	r6, r0
   979aa:	f7fb f997 	bl	92cdc <__aeabi_d2iz>
   979ae:	4604      	mov	r4, r0
   979b0:	f7fa fe7e 	bl	926b0 <__aeabi_i2d>
   979b4:	4602      	mov	r2, r0
   979b6:	460b      	mov	r3, r1
   979b8:	4630      	mov	r0, r6
   979ba:	4639      	mov	r1, r7
   979bc:	f7fa fd2a 	bl	92414 <__aeabi_dsub>
   979c0:	3430      	adds	r4, #48	; 0x30
   979c2:	f808 4b01 	strb.w	r4, [r8], #1
   979c6:	45c3      	cmp	fp, r8
   979c8:	4606      	mov	r6, r0
   979ca:	460f      	mov	r7, r1
   979cc:	d1e5      	bne.n	9799a <_dtoa_r+0xc8a>
   979ce:	4455      	add	r5, sl
   979d0:	2200      	movs	r2, #0
   979d2:	4b3f      	ldr	r3, [pc, #252]	; (97ad0 <_dtoa_r+0xdc0>)
   979d4:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
   979d8:	f7fa fd1e 	bl	92418 <__adddf3>
   979dc:	4632      	mov	r2, r6
   979de:	463b      	mov	r3, r7
   979e0:	f7fb f93e 	bl	92c60 <__aeabi_dcmplt>
   979e4:	2800      	cmp	r0, #0
   979e6:	d04c      	beq.n	97a82 <_dtoa_r+0xd72>
   979e8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   979ea:	9303      	str	r3, [sp, #12]
   979ec:	f815 4c01 	ldrb.w	r4, [r5, #-1]
   979f0:	f7ff bb44 	b.w	9707c <_dtoa_r+0x36c>
   979f4:	f04f 0800 	mov.w	r8, #0
   979f8:	4646      	mov	r6, r8
   979fa:	e6a7      	b.n	9774c <_dtoa_r+0xa3c>
   979fc:	9b06      	ldr	r3, [sp, #24]
   979fe:	9a07      	ldr	r2, [sp, #28]
   97a00:	1a9d      	subs	r5, r3, r2
   97a02:	2300      	movs	r3, #0
   97a04:	f7ff bb70 	b.w	970e8 <_dtoa_r+0x3d8>
   97a08:	2700      	movs	r7, #0
   97a0a:	e6c9      	b.n	977a0 <_dtoa_r+0xa90>
   97a0c:	9b16      	ldr	r3, [sp, #88]	; 0x58
   97a0e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
   97a10:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
   97a14:	9d06      	ldr	r5, [sp, #24]
   97a16:	f7ff bb67 	b.w	970e8 <_dtoa_r+0x3d8>
   97a1a:	e9dd 6710 	ldrd	r6, r7, [sp, #64]	; 0x40
   97a1e:	f04f 0802 	mov.w	r8, #2
   97a22:	e4d3      	b.n	973cc <_dtoa_r+0x6bc>
   97a24:	9409      	str	r4, [sp, #36]	; 0x24
   97a26:	e5a0      	b.n	9756a <_dtoa_r+0x85a>
   97a28:	9b07      	ldr	r3, [sp, #28]
   97a2a:	2b00      	cmp	r3, #0
   97a2c:	f43f aebe 	beq.w	977ac <_dtoa_r+0xa9c>
   97a30:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   97a32:	2b00      	cmp	r3, #0
   97a34:	f77f aee2 	ble.w	977fc <_dtoa_r+0xaec>
   97a38:	2200      	movs	r2, #0
   97a3a:	4b24      	ldr	r3, [pc, #144]	; (97acc <_dtoa_r+0xdbc>)
   97a3c:	4630      	mov	r0, r6
   97a3e:	4639      	mov	r1, r7
   97a40:	f7fa fe9c 	bl	9277c <__aeabi_dmul>
   97a44:	4606      	mov	r6, r0
   97a46:	460f      	mov	r7, r1
   97a48:	f108 0001 	add.w	r0, r8, #1
   97a4c:	f7fa fe30 	bl	926b0 <__aeabi_i2d>
   97a50:	4632      	mov	r2, r6
   97a52:	463b      	mov	r3, r7
   97a54:	f7fa fe92 	bl	9277c <__aeabi_dmul>
   97a58:	2200      	movs	r2, #0
   97a5a:	4b18      	ldr	r3, [pc, #96]	; (97abc <_dtoa_r+0xdac>)
   97a5c:	f7fa fcdc 	bl	92418 <__adddf3>
   97a60:	9a03      	ldr	r2, [sp, #12]
   97a62:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   97a64:	3a01      	subs	r2, #1
   97a66:	4604      	mov	r4, r0
   97a68:	9213      	str	r2, [sp, #76]	; 0x4c
   97a6a:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
   97a6e:	9312      	str	r3, [sp, #72]	; 0x48
   97a70:	e4cd      	b.n	9740e <_dtoa_r+0x6fe>
   97a72:	2239      	movs	r2, #57	; 0x39
   97a74:	46b3      	mov	fp, r6
   97a76:	9409      	str	r4, [sp, #36]	; 0x24
   97a78:	9e06      	ldr	r6, [sp, #24]
   97a7a:	703a      	strb	r2, [r7, #0]
   97a7c:	1c7d      	adds	r5, r7, #1
   97a7e:	f7ff bbee 	b.w	9725e <_dtoa_r+0x54e>
   97a82:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
   97a86:	2000      	movs	r0, #0
   97a88:	4911      	ldr	r1, [pc, #68]	; (97ad0 <_dtoa_r+0xdc0>)
   97a8a:	f7fa fcc3 	bl	92414 <__aeabi_dsub>
   97a8e:	4632      	mov	r2, r6
   97a90:	463b      	mov	r3, r7
   97a92:	f7fb f903 	bl	92c9c <__aeabi_dcmpgt>
   97a96:	b908      	cbnz	r0, 97a9c <_dtoa_r+0xd8c>
   97a98:	e6b0      	b.n	977fc <_dtoa_r+0xaec>
   97a9a:	4615      	mov	r5, r2
   97a9c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   97aa0:	1e6a      	subs	r2, r5, #1
   97aa2:	2b30      	cmp	r3, #48	; 0x30
   97aa4:	d0f9      	beq.n	97a9a <_dtoa_r+0xd8a>
   97aa6:	e531      	b.n	9750c <_dtoa_r+0x7fc>
   97aa8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   97aaa:	9303      	str	r3, [sp, #12]
   97aac:	f7ff bae6 	b.w	9707c <_dtoa_r+0x36c>
   97ab0:	f1ba 0f00 	cmp.w	sl, #0
   97ab4:	f47f ad7b 	bne.w	975ae <_dtoa_r+0x89e>
   97ab8:	e661      	b.n	9777e <_dtoa_r+0xa6e>
   97aba:	bf00      	nop
   97abc:	401c0000 	.word	0x401c0000
   97ac0:	40140000 	.word	0x40140000
   97ac4:	0009b218 	.word	0x0009b218
   97ac8:	0009b2e0 	.word	0x0009b2e0
   97acc:	40240000 	.word	0x40240000
   97ad0:	3fe00000 	.word	0x3fe00000
   97ad4:	2b39      	cmp	r3, #57	; 0x39
   97ad6:	f8cd b018 	str.w	fp, [sp, #24]
   97ada:	46d0      	mov	r8, sl
   97adc:	f8dd b010 	ldr.w	fp, [sp, #16]
   97ae0:	469a      	mov	sl, r3
   97ae2:	d0c6      	beq.n	97a72 <_dtoa_r+0xd62>
   97ae4:	f1bb 0f00 	cmp.w	fp, #0
   97ae8:	f73f aebc 	bgt.w	97864 <_dtoa_r+0xb54>
   97aec:	e6bc      	b.n	97868 <_dtoa_r+0xb58>
   97aee:	f47f aebb 	bne.w	97868 <_dtoa_r+0xb58>
   97af2:	f01a 0f01 	tst.w	sl, #1
   97af6:	f43f aeb7 	beq.w	97868 <_dtoa_r+0xb58>
   97afa:	e6af      	b.n	9785c <_dtoa_r+0xb4c>
   97afc:	f04f 0800 	mov.w	r8, #0
   97b00:	4646      	mov	r6, r8
   97b02:	e532      	b.n	9756a <_dtoa_r+0x85a>
   97b04:	9b22      	ldr	r3, [sp, #136]	; 0x88
   97b06:	2b02      	cmp	r3, #2
   97b08:	dc21      	bgt.n	97b4e <_dtoa_r+0xe3e>
   97b0a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   97b0c:	e604      	b.n	97718 <_dtoa_r+0xa08>
   97b0e:	f04f 0802 	mov.w	r8, #2
   97b12:	e45b      	b.n	973cc <_dtoa_r+0x6bc>
   97b14:	9b22      	ldr	r3, [sp, #136]	; 0x88
   97b16:	2b02      	cmp	r3, #2
   97b18:	dc19      	bgt.n	97b4e <_dtoa_r+0xe3e>
   97b1a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   97b1c:	e563      	b.n	975e6 <_dtoa_r+0x8d6>
   97b1e:	2400      	movs	r4, #0
   97b20:	f8c9 4044 	str.w	r4, [r9, #68]	; 0x44
   97b24:	4621      	mov	r1, r4
   97b26:	4648      	mov	r0, r9
   97b28:	f000 fd74 	bl	98614 <_Balloc>
   97b2c:	f04f 33ff 	mov.w	r3, #4294967295
   97b30:	9307      	str	r3, [sp, #28]
   97b32:	930e      	str	r3, [sp, #56]	; 0x38
   97b34:	2301      	movs	r3, #1
   97b36:	9008      	str	r0, [sp, #32]
   97b38:	9423      	str	r4, [sp, #140]	; 0x8c
   97b3a:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
   97b3e:	930a      	str	r3, [sp, #40]	; 0x28
   97b40:	f7ff b9ef 	b.w	96f22 <_dtoa_r+0x212>
   97b44:	f43f ab3c 	beq.w	971c0 <_dtoa_r+0x4b0>
   97b48:	f1c0 003c 	rsb	r0, r0, #60	; 0x3c
   97b4c:	e523      	b.n	97596 <_dtoa_r+0x886>
   97b4e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   97b50:	9307      	str	r3, [sp, #28]
   97b52:	e5e9      	b.n	97728 <_dtoa_r+0xa18>
   97b54:	2501      	movs	r5, #1
   97b56:	f7ff b9ae 	b.w	96eb6 <_dtoa_r+0x1a6>
   97b5a:	bf00      	nop

00097b5c <__sflush_r>:
   97b5c:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
   97b60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   97b64:	b29a      	uxth	r2, r3
   97b66:	460d      	mov	r5, r1
   97b68:	0711      	lsls	r1, r2, #28
   97b6a:	4680      	mov	r8, r0
   97b6c:	d43c      	bmi.n	97be8 <__sflush_r+0x8c>
   97b6e:	686a      	ldr	r2, [r5, #4]
   97b70:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   97b74:	2a00      	cmp	r2, #0
   97b76:	81ab      	strh	r3, [r5, #12]
   97b78:	dd73      	ble.n	97c62 <__sflush_r+0x106>
   97b7a:	6aac      	ldr	r4, [r5, #40]	; 0x28
   97b7c:	2c00      	cmp	r4, #0
   97b7e:	d04b      	beq.n	97c18 <__sflush_r+0xbc>
   97b80:	b29b      	uxth	r3, r3
   97b82:	f403 5280 	and.w	r2, r3, #4096	; 0x1000
   97b86:	2100      	movs	r1, #0
   97b88:	b292      	uxth	r2, r2
   97b8a:	f8d8 6000 	ldr.w	r6, [r8]
   97b8e:	f8c8 1000 	str.w	r1, [r8]
   97b92:	2a00      	cmp	r2, #0
   97b94:	d069      	beq.n	97c6a <__sflush_r+0x10e>
   97b96:	6d2a      	ldr	r2, [r5, #80]	; 0x50
   97b98:	075f      	lsls	r7, r3, #29
   97b9a:	d505      	bpl.n	97ba8 <__sflush_r+0x4c>
   97b9c:	6869      	ldr	r1, [r5, #4]
   97b9e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   97ba0:	1a52      	subs	r2, r2, r1
   97ba2:	b10b      	cbz	r3, 97ba8 <__sflush_r+0x4c>
   97ba4:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   97ba6:	1ad2      	subs	r2, r2, r3
   97ba8:	2300      	movs	r3, #0
   97baa:	69e9      	ldr	r1, [r5, #28]
   97bac:	4640      	mov	r0, r8
   97bae:	47a0      	blx	r4
   97bb0:	1c44      	adds	r4, r0, #1
   97bb2:	d03c      	beq.n	97c2e <__sflush_r+0xd2>
   97bb4:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
   97bb8:	6929      	ldr	r1, [r5, #16]
   97bba:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
   97bbe:	2200      	movs	r2, #0
   97bc0:	81ab      	strh	r3, [r5, #12]
   97bc2:	04db      	lsls	r3, r3, #19
   97bc4:	e885 0006 	stmia.w	r5, {r1, r2}
   97bc8:	d449      	bmi.n	97c5e <__sflush_r+0x102>
   97bca:	6b29      	ldr	r1, [r5, #48]	; 0x30
   97bcc:	f8c8 6000 	str.w	r6, [r8]
   97bd0:	b311      	cbz	r1, 97c18 <__sflush_r+0xbc>
   97bd2:	f105 0340 	add.w	r3, r5, #64	; 0x40
   97bd6:	4299      	cmp	r1, r3
   97bd8:	d002      	beq.n	97be0 <__sflush_r+0x84>
   97bda:	4640      	mov	r0, r8
   97bdc:	f000 f9be 	bl	97f5c <_free_r>
   97be0:	2000      	movs	r0, #0
   97be2:	6328      	str	r0, [r5, #48]	; 0x30
   97be4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   97be8:	692e      	ldr	r6, [r5, #16]
   97bea:	b1ae      	cbz	r6, 97c18 <__sflush_r+0xbc>
   97bec:	0790      	lsls	r0, r2, #30
   97bee:	682c      	ldr	r4, [r5, #0]
   97bf0:	bf0c      	ite	eq
   97bf2:	696b      	ldreq	r3, [r5, #20]
   97bf4:	2300      	movne	r3, #0
   97bf6:	602e      	str	r6, [r5, #0]
   97bf8:	1ba4      	subs	r4, r4, r6
   97bfa:	60ab      	str	r3, [r5, #8]
   97bfc:	e00a      	b.n	97c14 <__sflush_r+0xb8>
   97bfe:	4623      	mov	r3, r4
   97c00:	4632      	mov	r2, r6
   97c02:	6a6f      	ldr	r7, [r5, #36]	; 0x24
   97c04:	69e9      	ldr	r1, [r5, #28]
   97c06:	4640      	mov	r0, r8
   97c08:	47b8      	blx	r7
   97c0a:	2800      	cmp	r0, #0
   97c0c:	eba4 0400 	sub.w	r4, r4, r0
   97c10:	4406      	add	r6, r0
   97c12:	dd04      	ble.n	97c1e <__sflush_r+0xc2>
   97c14:	2c00      	cmp	r4, #0
   97c16:	dcf2      	bgt.n	97bfe <__sflush_r+0xa2>
   97c18:	2000      	movs	r0, #0
   97c1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   97c1e:	89ab      	ldrh	r3, [r5, #12]
   97c20:	f04f 30ff 	mov.w	r0, #4294967295
   97c24:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   97c28:	81ab      	strh	r3, [r5, #12]
   97c2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   97c2e:	f8d8 2000 	ldr.w	r2, [r8]
   97c32:	2a1d      	cmp	r2, #29
   97c34:	d8f3      	bhi.n	97c1e <__sflush_r+0xc2>
   97c36:	4b1a      	ldr	r3, [pc, #104]	; (97ca0 <__sflush_r+0x144>)
   97c38:	40d3      	lsrs	r3, r2
   97c3a:	f003 0301 	and.w	r3, r3, #1
   97c3e:	f083 0401 	eor.w	r4, r3, #1
   97c42:	2b00      	cmp	r3, #0
   97c44:	d0eb      	beq.n	97c1e <__sflush_r+0xc2>
   97c46:	f9b5 300c 	ldrsh.w	r3, [r5, #12]
   97c4a:	6929      	ldr	r1, [r5, #16]
   97c4c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
   97c50:	6029      	str	r1, [r5, #0]
   97c52:	04d9      	lsls	r1, r3, #19
   97c54:	606c      	str	r4, [r5, #4]
   97c56:	81ab      	strh	r3, [r5, #12]
   97c58:	d5b7      	bpl.n	97bca <__sflush_r+0x6e>
   97c5a:	2a00      	cmp	r2, #0
   97c5c:	d1b5      	bne.n	97bca <__sflush_r+0x6e>
   97c5e:	6528      	str	r0, [r5, #80]	; 0x50
   97c60:	e7b3      	b.n	97bca <__sflush_r+0x6e>
   97c62:	6bea      	ldr	r2, [r5, #60]	; 0x3c
   97c64:	2a00      	cmp	r2, #0
   97c66:	dc88      	bgt.n	97b7a <__sflush_r+0x1e>
   97c68:	e7d6      	b.n	97c18 <__sflush_r+0xbc>
   97c6a:	2301      	movs	r3, #1
   97c6c:	69e9      	ldr	r1, [r5, #28]
   97c6e:	4640      	mov	r0, r8
   97c70:	47a0      	blx	r4
   97c72:	1c43      	adds	r3, r0, #1
   97c74:	4602      	mov	r2, r0
   97c76:	d002      	beq.n	97c7e <__sflush_r+0x122>
   97c78:	89ab      	ldrh	r3, [r5, #12]
   97c7a:	6aac      	ldr	r4, [r5, #40]	; 0x28
   97c7c:	e78c      	b.n	97b98 <__sflush_r+0x3c>
   97c7e:	f8d8 3000 	ldr.w	r3, [r8]
   97c82:	2b00      	cmp	r3, #0
   97c84:	d0f8      	beq.n	97c78 <__sflush_r+0x11c>
   97c86:	2b1d      	cmp	r3, #29
   97c88:	d001      	beq.n	97c8e <__sflush_r+0x132>
   97c8a:	2b16      	cmp	r3, #22
   97c8c:	d102      	bne.n	97c94 <__sflush_r+0x138>
   97c8e:	f8c8 6000 	str.w	r6, [r8]
   97c92:	e7c1      	b.n	97c18 <__sflush_r+0xbc>
   97c94:	89ab      	ldrh	r3, [r5, #12]
   97c96:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   97c9a:	81ab      	strh	r3, [r5, #12]
   97c9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   97ca0:	20400001 	.word	0x20400001

00097ca4 <_fflush_r>:
   97ca4:	b510      	push	{r4, lr}
   97ca6:	4604      	mov	r4, r0
   97ca8:	b082      	sub	sp, #8
   97caa:	b108      	cbz	r0, 97cb0 <_fflush_r+0xc>
   97cac:	6b83      	ldr	r3, [r0, #56]	; 0x38
   97cae:	b153      	cbz	r3, 97cc6 <_fflush_r+0x22>
   97cb0:	f9b1 000c 	ldrsh.w	r0, [r1, #12]
   97cb4:	b908      	cbnz	r0, 97cba <_fflush_r+0x16>
   97cb6:	b002      	add	sp, #8
   97cb8:	bd10      	pop	{r4, pc}
   97cba:	4620      	mov	r0, r4
   97cbc:	b002      	add	sp, #8
   97cbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   97cc2:	f7ff bf4b 	b.w	97b5c <__sflush_r>
   97cc6:	9101      	str	r1, [sp, #4]
   97cc8:	f000 f880 	bl	97dcc <__sinit>
   97ccc:	9901      	ldr	r1, [sp, #4]
   97cce:	e7ef      	b.n	97cb0 <_fflush_r+0xc>

00097cd0 <_cleanup_r>:
   97cd0:	4901      	ldr	r1, [pc, #4]	; (97cd8 <_cleanup_r+0x8>)
   97cd2:	f000 bbaf 	b.w	98434 <_fwalk_reent>
   97cd6:	bf00      	nop
   97cd8:	00099029 	.word	0x00099029

00097cdc <__sinit.part.1>:
   97cdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   97ce0:	4607      	mov	r7, r0
   97ce2:	4835      	ldr	r0, [pc, #212]	; (97db8 <__sinit.part.1+0xdc>)
   97ce4:	687d      	ldr	r5, [r7, #4]
   97ce6:	2400      	movs	r4, #0
   97ce8:	f507 723b 	add.w	r2, r7, #748	; 0x2ec
   97cec:	2304      	movs	r3, #4
   97cee:	2103      	movs	r1, #3
   97cf0:	63f8      	str	r0, [r7, #60]	; 0x3c
   97cf2:	f8c7 12e4 	str.w	r1, [r7, #740]	; 0x2e4
   97cf6:	f8c7 22e8 	str.w	r2, [r7, #744]	; 0x2e8
   97cfa:	f8c7 42e0 	str.w	r4, [r7, #736]	; 0x2e0
   97cfe:	b083      	sub	sp, #12
   97d00:	602c      	str	r4, [r5, #0]
   97d02:	606c      	str	r4, [r5, #4]
   97d04:	60ac      	str	r4, [r5, #8]
   97d06:	666c      	str	r4, [r5, #100]	; 0x64
   97d08:	81ec      	strh	r4, [r5, #14]
   97d0a:	612c      	str	r4, [r5, #16]
   97d0c:	616c      	str	r4, [r5, #20]
   97d0e:	61ac      	str	r4, [r5, #24]
   97d10:	81ab      	strh	r3, [r5, #12]
   97d12:	4621      	mov	r1, r4
   97d14:	f105 005c 	add.w	r0, r5, #92	; 0x5c
   97d18:	2208      	movs	r2, #8
   97d1a:	f7fb ffd3 	bl	93cc4 <memset>
   97d1e:	f8df b09c 	ldr.w	fp, [pc, #156]	; 97dbc <__sinit.part.1+0xe0>
   97d22:	68be      	ldr	r6, [r7, #8]
   97d24:	f8df a098 	ldr.w	sl, [pc, #152]	; 97dc0 <__sinit.part.1+0xe4>
   97d28:	f8df 9098 	ldr.w	r9, [pc, #152]	; 97dc4 <__sinit.part.1+0xe8>
   97d2c:	f8df 8098 	ldr.w	r8, [pc, #152]	; 97dc8 <__sinit.part.1+0xec>
   97d30:	2301      	movs	r3, #1
   97d32:	2209      	movs	r2, #9
   97d34:	f8c5 b020 	str.w	fp, [r5, #32]
   97d38:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
   97d3c:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
   97d40:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
   97d44:	61ed      	str	r5, [r5, #28]
   97d46:	4621      	mov	r1, r4
   97d48:	81f3      	strh	r3, [r6, #14]
   97d4a:	81b2      	strh	r2, [r6, #12]
   97d4c:	f106 005c 	add.w	r0, r6, #92	; 0x5c
   97d50:	6034      	str	r4, [r6, #0]
   97d52:	6074      	str	r4, [r6, #4]
   97d54:	60b4      	str	r4, [r6, #8]
   97d56:	6674      	str	r4, [r6, #100]	; 0x64
   97d58:	6134      	str	r4, [r6, #16]
   97d5a:	6174      	str	r4, [r6, #20]
   97d5c:	61b4      	str	r4, [r6, #24]
   97d5e:	2208      	movs	r2, #8
   97d60:	9301      	str	r3, [sp, #4]
   97d62:	f7fb ffaf 	bl	93cc4 <memset>
   97d66:	68fd      	ldr	r5, [r7, #12]
   97d68:	2012      	movs	r0, #18
   97d6a:	2202      	movs	r2, #2
   97d6c:	61f6      	str	r6, [r6, #28]
   97d6e:	f8c6 b020 	str.w	fp, [r6, #32]
   97d72:	f8c6 a024 	str.w	sl, [r6, #36]	; 0x24
   97d76:	f8c6 9028 	str.w	r9, [r6, #40]	; 0x28
   97d7a:	f8c6 802c 	str.w	r8, [r6, #44]	; 0x2c
   97d7e:	4621      	mov	r1, r4
   97d80:	81a8      	strh	r0, [r5, #12]
   97d82:	81ea      	strh	r2, [r5, #14]
   97d84:	602c      	str	r4, [r5, #0]
   97d86:	606c      	str	r4, [r5, #4]
   97d88:	60ac      	str	r4, [r5, #8]
   97d8a:	666c      	str	r4, [r5, #100]	; 0x64
   97d8c:	612c      	str	r4, [r5, #16]
   97d8e:	616c      	str	r4, [r5, #20]
   97d90:	61ac      	str	r4, [r5, #24]
   97d92:	f105 005c 	add.w	r0, r5, #92	; 0x5c
   97d96:	2208      	movs	r2, #8
   97d98:	f7fb ff94 	bl	93cc4 <memset>
   97d9c:	9b01      	ldr	r3, [sp, #4]
   97d9e:	61ed      	str	r5, [r5, #28]
   97da0:	f8c5 b020 	str.w	fp, [r5, #32]
   97da4:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
   97da8:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
   97dac:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
   97db0:	63bb      	str	r3, [r7, #56]	; 0x38
   97db2:	b003      	add	sp, #12
   97db4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   97db8:	00097cd1 	.word	0x00097cd1
   97dbc:	00098cd5 	.word	0x00098cd5
   97dc0:	00098cf9 	.word	0x00098cf9
   97dc4:	00098d35 	.word	0x00098d35
   97dc8:	00098d55 	.word	0x00098d55

00097dcc <__sinit>:
   97dcc:	6b83      	ldr	r3, [r0, #56]	; 0x38
   97dce:	b103      	cbz	r3, 97dd2 <__sinit+0x6>
   97dd0:	4770      	bx	lr
   97dd2:	f7ff bf83 	b.w	97cdc <__sinit.part.1>
   97dd6:	bf00      	nop

00097dd8 <__sfp_lock_acquire>:
   97dd8:	4770      	bx	lr
   97dda:	bf00      	nop

00097ddc <__sfp_lock_release>:
   97ddc:	4770      	bx	lr
   97dde:	bf00      	nop

00097de0 <__libc_fini_array>:
   97de0:	b538      	push	{r3, r4, r5, lr}
   97de2:	4d07      	ldr	r5, [pc, #28]	; (97e00 <__libc_fini_array+0x20>)
   97de4:	4c07      	ldr	r4, [pc, #28]	; (97e04 <__libc_fini_array+0x24>)
   97de6:	1b2c      	subs	r4, r5, r4
   97de8:	10a4      	asrs	r4, r4, #2
   97dea:	d005      	beq.n	97df8 <__libc_fini_array+0x18>
   97dec:	3c01      	subs	r4, #1
   97dee:	f855 3d04 	ldr.w	r3, [r5, #-4]!
   97df2:	4798      	blx	r3
   97df4:	2c00      	cmp	r4, #0
   97df6:	d1f9      	bne.n	97dec <__libc_fini_array+0xc>
   97df8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   97dfc:	f003 baa8 	b.w	9b350 <_fini>
   97e00:	0009b360 	.word	0x0009b360
   97e04:	0009b35c 	.word	0x0009b35c

00097e08 <__fputwc>:
   97e08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   97e0c:	b082      	sub	sp, #8
   97e0e:	4606      	mov	r6, r0
   97e10:	460f      	mov	r7, r1
   97e12:	4614      	mov	r4, r2
   97e14:	f000 fb3a 	bl	9848c <__locale_mb_cur_max>
   97e18:	2801      	cmp	r0, #1
   97e1a:	d032      	beq.n	97e82 <__fputwc+0x7a>
   97e1c:	f104 035c 	add.w	r3, r4, #92	; 0x5c
   97e20:	463a      	mov	r2, r7
   97e22:	a901      	add	r1, sp, #4
   97e24:	4630      	mov	r0, r6
   97e26:	f001 f86f 	bl	98f08 <_wcrtomb_r>
   97e2a:	f1b0 3fff 	cmp.w	r0, #4294967295
   97e2e:	4680      	mov	r8, r0
   97e30:	d020      	beq.n	97e74 <__fputwc+0x6c>
   97e32:	b370      	cbz	r0, 97e92 <__fputwc+0x8a>
   97e34:	f89d 1004 	ldrb.w	r1, [sp, #4]
   97e38:	2500      	movs	r5, #0
   97e3a:	e008      	b.n	97e4e <__fputwc+0x46>
   97e3c:	6823      	ldr	r3, [r4, #0]
   97e3e:	1c5a      	adds	r2, r3, #1
   97e40:	6022      	str	r2, [r4, #0]
   97e42:	7019      	strb	r1, [r3, #0]
   97e44:	3501      	adds	r5, #1
   97e46:	4545      	cmp	r5, r8
   97e48:	d223      	bcs.n	97e92 <__fputwc+0x8a>
   97e4a:	ab01      	add	r3, sp, #4
   97e4c:	5d59      	ldrb	r1, [r3, r5]
   97e4e:	68a3      	ldr	r3, [r4, #8]
   97e50:	3b01      	subs	r3, #1
   97e52:	2b00      	cmp	r3, #0
   97e54:	60a3      	str	r3, [r4, #8]
   97e56:	daf1      	bge.n	97e3c <__fputwc+0x34>
   97e58:	69a2      	ldr	r2, [r4, #24]
   97e5a:	4293      	cmp	r3, r2
   97e5c:	db01      	blt.n	97e62 <__fputwc+0x5a>
   97e5e:	290a      	cmp	r1, #10
   97e60:	d1ec      	bne.n	97e3c <__fputwc+0x34>
   97e62:	4622      	mov	r2, r4
   97e64:	4630      	mov	r0, r6
   97e66:	f000 fff9 	bl	98e5c <__swbuf_r>
   97e6a:	1c43      	adds	r3, r0, #1
   97e6c:	d1ea      	bne.n	97e44 <__fputwc+0x3c>
   97e6e:	b002      	add	sp, #8
   97e70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   97e74:	89a3      	ldrh	r3, [r4, #12]
   97e76:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   97e7a:	81a3      	strh	r3, [r4, #12]
   97e7c:	b002      	add	sp, #8
   97e7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   97e82:	1e7b      	subs	r3, r7, #1
   97e84:	2bfe      	cmp	r3, #254	; 0xfe
   97e86:	d8c9      	bhi.n	97e1c <__fputwc+0x14>
   97e88:	b2f9      	uxtb	r1, r7
   97e8a:	4680      	mov	r8, r0
   97e8c:	f88d 1004 	strb.w	r1, [sp, #4]
   97e90:	e7d2      	b.n	97e38 <__fputwc+0x30>
   97e92:	4638      	mov	r0, r7
   97e94:	b002      	add	sp, #8
   97e96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   97e9a:	bf00      	nop

00097e9c <_fputwc_r>:
   97e9c:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
   97ea0:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   97ea4:	d10a      	bne.n	97ebc <_fputwc_r+0x20>
   97ea6:	b410      	push	{r4}
   97ea8:	6e54      	ldr	r4, [r2, #100]	; 0x64
   97eaa:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   97eae:	f444 5400 	orr.w	r4, r4, #8192	; 0x2000
   97eb2:	6654      	str	r4, [r2, #100]	; 0x64
   97eb4:	8193      	strh	r3, [r2, #12]
   97eb6:	bc10      	pop	{r4}
   97eb8:	f7ff bfa6 	b.w	97e08 <__fputwc>
   97ebc:	f7ff bfa4 	b.w	97e08 <__fputwc>

00097ec0 <_malloc_trim_r>:
   97ec0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   97ec2:	460c      	mov	r4, r1
   97ec4:	4f22      	ldr	r7, [pc, #136]	; (97f50 <_malloc_trim_r+0x90>)
   97ec6:	4606      	mov	r6, r0
   97ec8:	f7fb ff4a 	bl	93d60 <__malloc_lock>
   97ecc:	68bb      	ldr	r3, [r7, #8]
   97ece:	685d      	ldr	r5, [r3, #4]
   97ed0:	f025 0503 	bic.w	r5, r5, #3
   97ed4:	1b29      	subs	r1, r5, r4
   97ed6:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
   97eda:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
   97ede:	f021 010f 	bic.w	r1, r1, #15
   97ee2:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
   97ee6:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
   97eea:	db07      	blt.n	97efc <_malloc_trim_r+0x3c>
   97eec:	2100      	movs	r1, #0
   97eee:	4630      	mov	r0, r6
   97ef0:	f7fc f92c 	bl	9414c <_sbrk_r>
   97ef4:	68bb      	ldr	r3, [r7, #8]
   97ef6:	442b      	add	r3, r5
   97ef8:	4298      	cmp	r0, r3
   97efa:	d004      	beq.n	97f06 <_malloc_trim_r+0x46>
   97efc:	4630      	mov	r0, r6
   97efe:	f7fb ff31 	bl	93d64 <__malloc_unlock>
   97f02:	2000      	movs	r0, #0
   97f04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   97f06:	4261      	negs	r1, r4
   97f08:	4630      	mov	r0, r6
   97f0a:	f7fc f91f 	bl	9414c <_sbrk_r>
   97f0e:	3001      	adds	r0, #1
   97f10:	d00d      	beq.n	97f2e <_malloc_trim_r+0x6e>
   97f12:	4b10      	ldr	r3, [pc, #64]	; (97f54 <_malloc_trim_r+0x94>)
   97f14:	68ba      	ldr	r2, [r7, #8]
   97f16:	6819      	ldr	r1, [r3, #0]
   97f18:	1b2d      	subs	r5, r5, r4
   97f1a:	f045 0501 	orr.w	r5, r5, #1
   97f1e:	4630      	mov	r0, r6
   97f20:	1b09      	subs	r1, r1, r4
   97f22:	6055      	str	r5, [r2, #4]
   97f24:	6019      	str	r1, [r3, #0]
   97f26:	f7fb ff1d 	bl	93d64 <__malloc_unlock>
   97f2a:	2001      	movs	r0, #1
   97f2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   97f2e:	2100      	movs	r1, #0
   97f30:	4630      	mov	r0, r6
   97f32:	f7fc f90b 	bl	9414c <_sbrk_r>
   97f36:	68ba      	ldr	r2, [r7, #8]
   97f38:	1a83      	subs	r3, r0, r2
   97f3a:	2b0f      	cmp	r3, #15
   97f3c:	ddde      	ble.n	97efc <_malloc_trim_r+0x3c>
   97f3e:	4c06      	ldr	r4, [pc, #24]	; (97f58 <_malloc_trim_r+0x98>)
   97f40:	4904      	ldr	r1, [pc, #16]	; (97f54 <_malloc_trim_r+0x94>)
   97f42:	6824      	ldr	r4, [r4, #0]
   97f44:	f043 0301 	orr.w	r3, r3, #1
   97f48:	1b00      	subs	r0, r0, r4
   97f4a:	6053      	str	r3, [r2, #4]
   97f4c:	6008      	str	r0, [r1, #0]
   97f4e:	e7d5      	b.n	97efc <_malloc_trim_r+0x3c>
   97f50:	2007054c 	.word	0x2007054c
   97f54:	20071cd8 	.word	0x20071cd8
   97f58:	20070958 	.word	0x20070958

00097f5c <_free_r>:
   97f5c:	2900      	cmp	r1, #0
   97f5e:	d045      	beq.n	97fec <_free_r+0x90>
   97f60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   97f64:	460d      	mov	r5, r1
   97f66:	4680      	mov	r8, r0
   97f68:	f7fb fefa 	bl	93d60 <__malloc_lock>
   97f6c:	f855 7c04 	ldr.w	r7, [r5, #-4]
   97f70:	496a      	ldr	r1, [pc, #424]	; (9811c <_free_r+0x1c0>)
   97f72:	f1a5 0408 	sub.w	r4, r5, #8
   97f76:	f027 0301 	bic.w	r3, r7, #1
   97f7a:	18e2      	adds	r2, r4, r3
   97f7c:	688e      	ldr	r6, [r1, #8]
   97f7e:	6850      	ldr	r0, [r2, #4]
   97f80:	42b2      	cmp	r2, r6
   97f82:	f020 0003 	bic.w	r0, r0, #3
   97f86:	d062      	beq.n	9804e <_free_r+0xf2>
   97f88:	07fe      	lsls	r6, r7, #31
   97f8a:	6050      	str	r0, [r2, #4]
   97f8c:	d40b      	bmi.n	97fa6 <_free_r+0x4a>
   97f8e:	f855 7c08 	ldr.w	r7, [r5, #-8]
   97f92:	f101 0e08 	add.w	lr, r1, #8
   97f96:	1be4      	subs	r4, r4, r7
   97f98:	68a5      	ldr	r5, [r4, #8]
   97f9a:	443b      	add	r3, r7
   97f9c:	4575      	cmp	r5, lr
   97f9e:	d06f      	beq.n	98080 <_free_r+0x124>
   97fa0:	68e7      	ldr	r7, [r4, #12]
   97fa2:	60ef      	str	r7, [r5, #12]
   97fa4:	60bd      	str	r5, [r7, #8]
   97fa6:	1815      	adds	r5, r2, r0
   97fa8:	686d      	ldr	r5, [r5, #4]
   97faa:	07ed      	lsls	r5, r5, #31
   97fac:	d542      	bpl.n	98034 <_free_r+0xd8>
   97fae:	f043 0201 	orr.w	r2, r3, #1
   97fb2:	6062      	str	r2, [r4, #4]
   97fb4:	50e3      	str	r3, [r4, r3]
   97fb6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   97fba:	d218      	bcs.n	97fee <_free_r+0x92>
   97fbc:	08db      	lsrs	r3, r3, #3
   97fbe:	6848      	ldr	r0, [r1, #4]
   97fc0:	109d      	asrs	r5, r3, #2
   97fc2:	2201      	movs	r2, #1
   97fc4:	3301      	adds	r3, #1
   97fc6:	f851 7033 	ldr.w	r7, [r1, r3, lsl #3]
   97fca:	fa02 f505 	lsl.w	r5, r2, r5
   97fce:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
   97fd2:	4328      	orrs	r0, r5
   97fd4:	3a08      	subs	r2, #8
   97fd6:	60e2      	str	r2, [r4, #12]
   97fd8:	60a7      	str	r7, [r4, #8]
   97fda:	6048      	str	r0, [r1, #4]
   97fdc:	f841 4033 	str.w	r4, [r1, r3, lsl #3]
   97fe0:	60fc      	str	r4, [r7, #12]
   97fe2:	4640      	mov	r0, r8
   97fe4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   97fe8:	f7fb bebc 	b.w	93d64 <__malloc_unlock>
   97fec:	4770      	bx	lr
   97fee:	0a5a      	lsrs	r2, r3, #9
   97ff0:	2a04      	cmp	r2, #4
   97ff2:	d853      	bhi.n	9809c <_free_r+0x140>
   97ff4:	099a      	lsrs	r2, r3, #6
   97ff6:	f102 0739 	add.w	r7, r2, #57	; 0x39
   97ffa:	007f      	lsls	r7, r7, #1
   97ffc:	f102 0538 	add.w	r5, r2, #56	; 0x38
   98000:	eb01 0087 	add.w	r0, r1, r7, lsl #2
   98004:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
   98008:	3808      	subs	r0, #8
   9800a:	4290      	cmp	r0, r2
   9800c:	4943      	ldr	r1, [pc, #268]	; (9811c <_free_r+0x1c0>)
   9800e:	d04d      	beq.n	980ac <_free_r+0x150>
   98010:	6851      	ldr	r1, [r2, #4]
   98012:	f021 0103 	bic.w	r1, r1, #3
   98016:	428b      	cmp	r3, r1
   98018:	d202      	bcs.n	98020 <_free_r+0xc4>
   9801a:	6892      	ldr	r2, [r2, #8]
   9801c:	4290      	cmp	r0, r2
   9801e:	d1f7      	bne.n	98010 <_free_r+0xb4>
   98020:	68d0      	ldr	r0, [r2, #12]
   98022:	60e0      	str	r0, [r4, #12]
   98024:	60a2      	str	r2, [r4, #8]
   98026:	6084      	str	r4, [r0, #8]
   98028:	60d4      	str	r4, [r2, #12]
   9802a:	4640      	mov	r0, r8
   9802c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   98030:	f7fb be98 	b.w	93d64 <__malloc_unlock>
   98034:	6895      	ldr	r5, [r2, #8]
   98036:	4f3a      	ldr	r7, [pc, #232]	; (98120 <_free_r+0x1c4>)
   98038:	4403      	add	r3, r0
   9803a:	42bd      	cmp	r5, r7
   9803c:	d03f      	beq.n	980be <_free_r+0x162>
   9803e:	68d0      	ldr	r0, [r2, #12]
   98040:	f043 0201 	orr.w	r2, r3, #1
   98044:	60e8      	str	r0, [r5, #12]
   98046:	6085      	str	r5, [r0, #8]
   98048:	6062      	str	r2, [r4, #4]
   9804a:	50e3      	str	r3, [r4, r3]
   9804c:	e7b3      	b.n	97fb6 <_free_r+0x5a>
   9804e:	07ff      	lsls	r7, r7, #31
   98050:	4403      	add	r3, r0
   98052:	d407      	bmi.n	98064 <_free_r+0x108>
   98054:	f855 5c08 	ldr.w	r5, [r5, #-8]
   98058:	1b64      	subs	r4, r4, r5
   9805a:	68e2      	ldr	r2, [r4, #12]
   9805c:	68a0      	ldr	r0, [r4, #8]
   9805e:	442b      	add	r3, r5
   98060:	60c2      	str	r2, [r0, #12]
   98062:	6090      	str	r0, [r2, #8]
   98064:	4a2f      	ldr	r2, [pc, #188]	; (98124 <_free_r+0x1c8>)
   98066:	f043 0001 	orr.w	r0, r3, #1
   9806a:	6812      	ldr	r2, [r2, #0]
   9806c:	6060      	str	r0, [r4, #4]
   9806e:	4293      	cmp	r3, r2
   98070:	608c      	str	r4, [r1, #8]
   98072:	d3b6      	bcc.n	97fe2 <_free_r+0x86>
   98074:	4b2c      	ldr	r3, [pc, #176]	; (98128 <_free_r+0x1cc>)
   98076:	4640      	mov	r0, r8
   98078:	6819      	ldr	r1, [r3, #0]
   9807a:	f7ff ff21 	bl	97ec0 <_malloc_trim_r>
   9807e:	e7b0      	b.n	97fe2 <_free_r+0x86>
   98080:	1811      	adds	r1, r2, r0
   98082:	6849      	ldr	r1, [r1, #4]
   98084:	07c9      	lsls	r1, r1, #31
   98086:	d444      	bmi.n	98112 <_free_r+0x1b6>
   98088:	6891      	ldr	r1, [r2, #8]
   9808a:	4403      	add	r3, r0
   9808c:	68d2      	ldr	r2, [r2, #12]
   9808e:	f043 0001 	orr.w	r0, r3, #1
   98092:	60ca      	str	r2, [r1, #12]
   98094:	6091      	str	r1, [r2, #8]
   98096:	6060      	str	r0, [r4, #4]
   98098:	50e3      	str	r3, [r4, r3]
   9809a:	e7a2      	b.n	97fe2 <_free_r+0x86>
   9809c:	2a14      	cmp	r2, #20
   9809e:	d817      	bhi.n	980d0 <_free_r+0x174>
   980a0:	f102 075c 	add.w	r7, r2, #92	; 0x5c
   980a4:	007f      	lsls	r7, r7, #1
   980a6:	f102 055b 	add.w	r5, r2, #91	; 0x5b
   980aa:	e7a9      	b.n	98000 <_free_r+0xa4>
   980ac:	10aa      	asrs	r2, r5, #2
   980ae:	684b      	ldr	r3, [r1, #4]
   980b0:	2501      	movs	r5, #1
   980b2:	fa05 f202 	lsl.w	r2, r5, r2
   980b6:	4313      	orrs	r3, r2
   980b8:	604b      	str	r3, [r1, #4]
   980ba:	4602      	mov	r2, r0
   980bc:	e7b1      	b.n	98022 <_free_r+0xc6>
   980be:	f043 0201 	orr.w	r2, r3, #1
   980c2:	614c      	str	r4, [r1, #20]
   980c4:	610c      	str	r4, [r1, #16]
   980c6:	60e5      	str	r5, [r4, #12]
   980c8:	60a5      	str	r5, [r4, #8]
   980ca:	6062      	str	r2, [r4, #4]
   980cc:	50e3      	str	r3, [r4, r3]
   980ce:	e788      	b.n	97fe2 <_free_r+0x86>
   980d0:	2a54      	cmp	r2, #84	; 0x54
   980d2:	d806      	bhi.n	980e2 <_free_r+0x186>
   980d4:	0b1a      	lsrs	r2, r3, #12
   980d6:	f102 076f 	add.w	r7, r2, #111	; 0x6f
   980da:	007f      	lsls	r7, r7, #1
   980dc:	f102 056e 	add.w	r5, r2, #110	; 0x6e
   980e0:	e78e      	b.n	98000 <_free_r+0xa4>
   980e2:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
   980e6:	d806      	bhi.n	980f6 <_free_r+0x19a>
   980e8:	0bda      	lsrs	r2, r3, #15
   980ea:	f102 0778 	add.w	r7, r2, #120	; 0x78
   980ee:	007f      	lsls	r7, r7, #1
   980f0:	f102 0577 	add.w	r5, r2, #119	; 0x77
   980f4:	e784      	b.n	98000 <_free_r+0xa4>
   980f6:	f240 5054 	movw	r0, #1364	; 0x554
   980fa:	4282      	cmp	r2, r0
   980fc:	d806      	bhi.n	9810c <_free_r+0x1b0>
   980fe:	0c9a      	lsrs	r2, r3, #18
   98100:	f102 077d 	add.w	r7, r2, #125	; 0x7d
   98104:	007f      	lsls	r7, r7, #1
   98106:	f102 057c 	add.w	r5, r2, #124	; 0x7c
   9810a:	e779      	b.n	98000 <_free_r+0xa4>
   9810c:	27fe      	movs	r7, #254	; 0xfe
   9810e:	257e      	movs	r5, #126	; 0x7e
   98110:	e776      	b.n	98000 <_free_r+0xa4>
   98112:	f043 0201 	orr.w	r2, r3, #1
   98116:	6062      	str	r2, [r4, #4]
   98118:	50e3      	str	r3, [r4, r3]
   9811a:	e762      	b.n	97fe2 <_free_r+0x86>
   9811c:	2007054c 	.word	0x2007054c
   98120:	20070554 	.word	0x20070554
   98124:	20070954 	.word	0x20070954
   98128:	20071cd4 	.word	0x20071cd4

0009812c <__sfvwrite_r>:
   9812c:	6893      	ldr	r3, [r2, #8]
   9812e:	2b00      	cmp	r3, #0
   98130:	f000 80ab 	beq.w	9828a <__sfvwrite_r+0x15e>
   98134:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   98138:	898b      	ldrh	r3, [r1, #12]
   9813a:	b085      	sub	sp, #20
   9813c:	460c      	mov	r4, r1
   9813e:	0719      	lsls	r1, r3, #28
   98140:	9002      	str	r0, [sp, #8]
   98142:	4616      	mov	r6, r2
   98144:	d528      	bpl.n	98198 <__sfvwrite_r+0x6c>
   98146:	6922      	ldr	r2, [r4, #16]
   98148:	b332      	cbz	r2, 98198 <__sfvwrite_r+0x6c>
   9814a:	f003 0802 	and.w	r8, r3, #2
   9814e:	fa1f f088 	uxth.w	r0, r8
   98152:	6835      	ldr	r5, [r6, #0]
   98154:	b378      	cbz	r0, 981b6 <__sfvwrite_r+0x8a>
   98156:	f04f 0900 	mov.w	r9, #0
   9815a:	46c8      	mov	r8, r9
   9815c:	f8df a2d0 	ldr.w	sl, [pc, #720]	; 98430 <__sfvwrite_r+0x304>
   98160:	f1b8 0f00 	cmp.w	r8, #0
   98164:	f000 808b 	beq.w	9827e <__sfvwrite_r+0x152>
   98168:	45d0      	cmp	r8, sl
   9816a:	4643      	mov	r3, r8
   9816c:	464a      	mov	r2, r9
   9816e:	bf28      	it	cs
   98170:	4653      	movcs	r3, sl
   98172:	69e1      	ldr	r1, [r4, #28]
   98174:	9802      	ldr	r0, [sp, #8]
   98176:	6a67      	ldr	r7, [r4, #36]	; 0x24
   98178:	47b8      	blx	r7
   9817a:	2800      	cmp	r0, #0
   9817c:	f340 80a5 	ble.w	982ca <__sfvwrite_r+0x19e>
   98180:	68b3      	ldr	r3, [r6, #8]
   98182:	4481      	add	r9, r0
   98184:	1a1b      	subs	r3, r3, r0
   98186:	ebc0 0808 	rsb	r8, r0, r8
   9818a:	60b3      	str	r3, [r6, #8]
   9818c:	2b00      	cmp	r3, #0
   9818e:	d1e7      	bne.n	98160 <__sfvwrite_r+0x34>
   98190:	2000      	movs	r0, #0
   98192:	b005      	add	sp, #20
   98194:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   98198:	4621      	mov	r1, r4
   9819a:	9802      	ldr	r0, [sp, #8]
   9819c:	f7fe fc52 	bl	96a44 <__swsetup_r>
   981a0:	2800      	cmp	r0, #0
   981a2:	f040 813c 	bne.w	9841e <__sfvwrite_r+0x2f2>
   981a6:	89a3      	ldrh	r3, [r4, #12]
   981a8:	6835      	ldr	r5, [r6, #0]
   981aa:	f003 0802 	and.w	r8, r3, #2
   981ae:	fa1f f088 	uxth.w	r0, r8
   981b2:	2800      	cmp	r0, #0
   981b4:	d1cf      	bne.n	98156 <__sfvwrite_r+0x2a>
   981b6:	f013 0901 	ands.w	r9, r3, #1
   981ba:	f040 8090 	bne.w	982de <__sfvwrite_r+0x1b2>
   981be:	464f      	mov	r7, r9
   981c0:	9601      	str	r6, [sp, #4]
   981c2:	2f00      	cmp	r7, #0
   981c4:	d056      	beq.n	98274 <__sfvwrite_r+0x148>
   981c6:	059a      	lsls	r2, r3, #22
   981c8:	f8d4 8008 	ldr.w	r8, [r4, #8]
   981cc:	d55f      	bpl.n	9828e <__sfvwrite_r+0x162>
   981ce:	4547      	cmp	r7, r8
   981d0:	46c2      	mov	sl, r8
   981d2:	f0c0 80bf 	bcc.w	98354 <__sfvwrite_r+0x228>
   981d6:	f413 6f90 	tst.w	r3, #1152	; 0x480
   981da:	f000 80bd 	beq.w	98358 <__sfvwrite_r+0x22c>
   981de:	6962      	ldr	r2, [r4, #20]
   981e0:	6820      	ldr	r0, [r4, #0]
   981e2:	6921      	ldr	r1, [r4, #16]
   981e4:	eb02 0842 	add.w	r8, r2, r2, lsl #1
   981e8:	ebc1 0a00 	rsb	sl, r1, r0
   981ec:	eb08 78d8 	add.w	r8, r8, r8, lsr #31
   981f0:	f10a 0001 	add.w	r0, sl, #1
   981f4:	ea4f 0868 	mov.w	r8, r8, asr #1
   981f8:	4438      	add	r0, r7
   981fa:	4540      	cmp	r0, r8
   981fc:	4642      	mov	r2, r8
   981fe:	bf84      	itt	hi
   98200:	4680      	movhi	r8, r0
   98202:	4642      	movhi	r2, r8
   98204:	055b      	lsls	r3, r3, #21
   98206:	f140 80f2 	bpl.w	983ee <__sfvwrite_r+0x2c2>
   9820a:	4611      	mov	r1, r2
   9820c:	9802      	ldr	r0, [sp, #8]
   9820e:	f7fb f9a1 	bl	93554 <_malloc_r>
   98212:	4683      	mov	fp, r0
   98214:	2800      	cmp	r0, #0
   98216:	f000 8105 	beq.w	98424 <__sfvwrite_r+0x2f8>
   9821a:	4652      	mov	r2, sl
   9821c:	6921      	ldr	r1, [r4, #16]
   9821e:	f7fb fc77 	bl	93b10 <memcpy>
   98222:	89a3      	ldrh	r3, [r4, #12]
   98224:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   98228:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   9822c:	81a3      	strh	r3, [r4, #12]
   9822e:	ebca 0308 	rsb	r3, sl, r8
   98232:	eb0b 000a 	add.w	r0, fp, sl
   98236:	f8c4 8014 	str.w	r8, [r4, #20]
   9823a:	46ba      	mov	sl, r7
   9823c:	46b8      	mov	r8, r7
   9823e:	f8c4 b010 	str.w	fp, [r4, #16]
   98242:	6020      	str	r0, [r4, #0]
   98244:	60a3      	str	r3, [r4, #8]
   98246:	4652      	mov	r2, sl
   98248:	4649      	mov	r1, r9
   9824a:	f7fb fcd7 	bl	93bfc <memmove>
   9824e:	68a0      	ldr	r0, [r4, #8]
   98250:	6823      	ldr	r3, [r4, #0]
   98252:	ebc8 0000 	rsb	r0, r8, r0
   98256:	60a0      	str	r0, [r4, #8]
   98258:	4638      	mov	r0, r7
   9825a:	4453      	add	r3, sl
   9825c:	6023      	str	r3, [r4, #0]
   9825e:	9a01      	ldr	r2, [sp, #4]
   98260:	4481      	add	r9, r0
   98262:	6893      	ldr	r3, [r2, #8]
   98264:	1a3f      	subs	r7, r7, r0
   98266:	1a1b      	subs	r3, r3, r0
   98268:	6093      	str	r3, [r2, #8]
   9826a:	2b00      	cmp	r3, #0
   9826c:	d090      	beq.n	98190 <__sfvwrite_r+0x64>
   9826e:	89a3      	ldrh	r3, [r4, #12]
   98270:	2f00      	cmp	r7, #0
   98272:	d1a8      	bne.n	981c6 <__sfvwrite_r+0x9a>
   98274:	f8d5 9000 	ldr.w	r9, [r5]
   98278:	686f      	ldr	r7, [r5, #4]
   9827a:	3508      	adds	r5, #8
   9827c:	e7a1      	b.n	981c2 <__sfvwrite_r+0x96>
   9827e:	f8d5 9000 	ldr.w	r9, [r5]
   98282:	f8d5 8004 	ldr.w	r8, [r5, #4]
   98286:	3508      	adds	r5, #8
   98288:	e76a      	b.n	98160 <__sfvwrite_r+0x34>
   9828a:	2000      	movs	r0, #0
   9828c:	4770      	bx	lr
   9828e:	6820      	ldr	r0, [r4, #0]
   98290:	6923      	ldr	r3, [r4, #16]
   98292:	4298      	cmp	r0, r3
   98294:	d803      	bhi.n	9829e <__sfvwrite_r+0x172>
   98296:	6962      	ldr	r2, [r4, #20]
   98298:	4297      	cmp	r7, r2
   9829a:	f080 8083 	bcs.w	983a4 <__sfvwrite_r+0x278>
   9829e:	45b8      	cmp	r8, r7
   982a0:	bf28      	it	cs
   982a2:	46b8      	movcs	r8, r7
   982a4:	4649      	mov	r1, r9
   982a6:	4642      	mov	r2, r8
   982a8:	f7fb fca8 	bl	93bfc <memmove>
   982ac:	68a3      	ldr	r3, [r4, #8]
   982ae:	6822      	ldr	r2, [r4, #0]
   982b0:	ebc8 0303 	rsb	r3, r8, r3
   982b4:	4442      	add	r2, r8
   982b6:	60a3      	str	r3, [r4, #8]
   982b8:	6022      	str	r2, [r4, #0]
   982ba:	2b00      	cmp	r3, #0
   982bc:	d148      	bne.n	98350 <__sfvwrite_r+0x224>
   982be:	4621      	mov	r1, r4
   982c0:	9802      	ldr	r0, [sp, #8]
   982c2:	f7ff fcef 	bl	97ca4 <_fflush_r>
   982c6:	2800      	cmp	r0, #0
   982c8:	d042      	beq.n	98350 <__sfvwrite_r+0x224>
   982ca:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   982ce:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   982d2:	f04f 30ff 	mov.w	r0, #4294967295
   982d6:	81a3      	strh	r3, [r4, #12]
   982d8:	b005      	add	sp, #20
   982da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   982de:	4680      	mov	r8, r0
   982e0:	4682      	mov	sl, r0
   982e2:	4681      	mov	r9, r0
   982e4:	9001      	str	r0, [sp, #4]
   982e6:	f1b9 0f00 	cmp.w	r9, #0
   982ea:	d029      	beq.n	98340 <__sfvwrite_r+0x214>
   982ec:	9b01      	ldr	r3, [sp, #4]
   982ee:	2b00      	cmp	r3, #0
   982f0:	d04b      	beq.n	9838a <__sfvwrite_r+0x25e>
   982f2:	45c8      	cmp	r8, r9
   982f4:	46c3      	mov	fp, r8
   982f6:	bf28      	it	cs
   982f8:	46cb      	movcs	fp, r9
   982fa:	6820      	ldr	r0, [r4, #0]
   982fc:	6923      	ldr	r3, [r4, #16]
   982fe:	465f      	mov	r7, fp
   98300:	4298      	cmp	r0, r3
   98302:	6962      	ldr	r2, [r4, #20]
   98304:	d903      	bls.n	9830e <__sfvwrite_r+0x1e2>
   98306:	68a3      	ldr	r3, [r4, #8]
   98308:	4413      	add	r3, r2
   9830a:	459b      	cmp	fp, r3
   9830c:	dc5c      	bgt.n	983c8 <__sfvwrite_r+0x29c>
   9830e:	4593      	cmp	fp, r2
   98310:	db24      	blt.n	9835c <__sfvwrite_r+0x230>
   98312:	4613      	mov	r3, r2
   98314:	6a67      	ldr	r7, [r4, #36]	; 0x24
   98316:	4652      	mov	r2, sl
   98318:	69e1      	ldr	r1, [r4, #28]
   9831a:	9802      	ldr	r0, [sp, #8]
   9831c:	47b8      	blx	r7
   9831e:	1e07      	subs	r7, r0, #0
   98320:	ddd3      	ble.n	982ca <__sfvwrite_r+0x19e>
   98322:	ebb8 0807 	subs.w	r8, r8, r7
   98326:	d027      	beq.n	98378 <__sfvwrite_r+0x24c>
   98328:	68b3      	ldr	r3, [r6, #8]
   9832a:	44ba      	add	sl, r7
   9832c:	1bdb      	subs	r3, r3, r7
   9832e:	ebc7 0909 	rsb	r9, r7, r9
   98332:	60b3      	str	r3, [r6, #8]
   98334:	2b00      	cmp	r3, #0
   98336:	f43f af2b 	beq.w	98190 <__sfvwrite_r+0x64>
   9833a:	f1b9 0f00 	cmp.w	r9, #0
   9833e:	d1d5      	bne.n	982ec <__sfvwrite_r+0x1c0>
   98340:	2300      	movs	r3, #0
   98342:	f8d5 a000 	ldr.w	sl, [r5]
   98346:	f8d5 9004 	ldr.w	r9, [r5, #4]
   9834a:	9301      	str	r3, [sp, #4]
   9834c:	3508      	adds	r5, #8
   9834e:	e7ca      	b.n	982e6 <__sfvwrite_r+0x1ba>
   98350:	4640      	mov	r0, r8
   98352:	e784      	b.n	9825e <__sfvwrite_r+0x132>
   98354:	46b8      	mov	r8, r7
   98356:	46ba      	mov	sl, r7
   98358:	6820      	ldr	r0, [r4, #0]
   9835a:	e774      	b.n	98246 <__sfvwrite_r+0x11a>
   9835c:	465a      	mov	r2, fp
   9835e:	4651      	mov	r1, sl
   98360:	f7fb fc4c 	bl	93bfc <memmove>
   98364:	68a2      	ldr	r2, [r4, #8]
   98366:	6823      	ldr	r3, [r4, #0]
   98368:	ebcb 0202 	rsb	r2, fp, r2
   9836c:	445b      	add	r3, fp
   9836e:	ebb8 0807 	subs.w	r8, r8, r7
   98372:	60a2      	str	r2, [r4, #8]
   98374:	6023      	str	r3, [r4, #0]
   98376:	d1d7      	bne.n	98328 <__sfvwrite_r+0x1fc>
   98378:	4621      	mov	r1, r4
   9837a:	9802      	ldr	r0, [sp, #8]
   9837c:	f7ff fc92 	bl	97ca4 <_fflush_r>
   98380:	2800      	cmp	r0, #0
   98382:	d1a2      	bne.n	982ca <__sfvwrite_r+0x19e>
   98384:	f8cd 8004 	str.w	r8, [sp, #4]
   98388:	e7ce      	b.n	98328 <__sfvwrite_r+0x1fc>
   9838a:	464a      	mov	r2, r9
   9838c:	210a      	movs	r1, #10
   9838e:	4650      	mov	r0, sl
   98390:	f000 f8fa 	bl	98588 <memchr>
   98394:	2800      	cmp	r0, #0
   98396:	d03d      	beq.n	98414 <__sfvwrite_r+0x2e8>
   98398:	3001      	adds	r0, #1
   9839a:	2301      	movs	r3, #1
   9839c:	ebca 0800 	rsb	r8, sl, r0
   983a0:	9301      	str	r3, [sp, #4]
   983a2:	e7a6      	b.n	982f2 <__sfvwrite_r+0x1c6>
   983a4:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   983a8:	42bb      	cmp	r3, r7
   983aa:	bf28      	it	cs
   983ac:	463b      	movcs	r3, r7
   983ae:	fb93 f3f2 	sdiv	r3, r3, r2
   983b2:	69e1      	ldr	r1, [r4, #28]
   983b4:	fb02 f303 	mul.w	r3, r2, r3
   983b8:	9802      	ldr	r0, [sp, #8]
   983ba:	464a      	mov	r2, r9
   983bc:	6a66      	ldr	r6, [r4, #36]	; 0x24
   983be:	47b0      	blx	r6
   983c0:	2800      	cmp	r0, #0
   983c2:	f73f af4c 	bgt.w	9825e <__sfvwrite_r+0x132>
   983c6:	e780      	b.n	982ca <__sfvwrite_r+0x19e>
   983c8:	461a      	mov	r2, r3
   983ca:	4651      	mov	r1, sl
   983cc:	9303      	str	r3, [sp, #12]
   983ce:	f7fb fc15 	bl	93bfc <memmove>
   983d2:	6822      	ldr	r2, [r4, #0]
   983d4:	9b03      	ldr	r3, [sp, #12]
   983d6:	4621      	mov	r1, r4
   983d8:	441a      	add	r2, r3
   983da:	6022      	str	r2, [r4, #0]
   983dc:	9802      	ldr	r0, [sp, #8]
   983de:	f7ff fc61 	bl	97ca4 <_fflush_r>
   983e2:	9b03      	ldr	r3, [sp, #12]
   983e4:	2800      	cmp	r0, #0
   983e6:	f47f af70 	bne.w	982ca <__sfvwrite_r+0x19e>
   983ea:	461f      	mov	r7, r3
   983ec:	e799      	b.n	98322 <__sfvwrite_r+0x1f6>
   983ee:	9802      	ldr	r0, [sp, #8]
   983f0:	f7fb fcc2 	bl	93d78 <_realloc_r>
   983f4:	4683      	mov	fp, r0
   983f6:	2800      	cmp	r0, #0
   983f8:	f47f af19 	bne.w	9822e <__sfvwrite_r+0x102>
   983fc:	9d02      	ldr	r5, [sp, #8]
   983fe:	6921      	ldr	r1, [r4, #16]
   98400:	4628      	mov	r0, r5
   98402:	f7ff fdab 	bl	97f5c <_free_r>
   98406:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   9840a:	220c      	movs	r2, #12
   9840c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   98410:	602a      	str	r2, [r5, #0]
   98412:	e75c      	b.n	982ce <__sfvwrite_r+0x1a2>
   98414:	2301      	movs	r3, #1
   98416:	f109 0801 	add.w	r8, r9, #1
   9841a:	9301      	str	r3, [sp, #4]
   9841c:	e769      	b.n	982f2 <__sfvwrite_r+0x1c6>
   9841e:	f04f 30ff 	mov.w	r0, #4294967295
   98422:	e6b6      	b.n	98192 <__sfvwrite_r+0x66>
   98424:	9a02      	ldr	r2, [sp, #8]
   98426:	230c      	movs	r3, #12
   98428:	6013      	str	r3, [r2, #0]
   9842a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   9842e:	e74e      	b.n	982ce <__sfvwrite_r+0x1a2>
   98430:	7ffffc00 	.word	0x7ffffc00

00098434 <_fwalk_reent>:
   98434:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   98438:	f510 7638 	adds.w	r6, r0, #736	; 0x2e0
   9843c:	d01e      	beq.n	9847c <_fwalk_reent+0x48>
   9843e:	4688      	mov	r8, r1
   98440:	4607      	mov	r7, r0
   98442:	f04f 0900 	mov.w	r9, #0
   98446:	6875      	ldr	r5, [r6, #4]
   98448:	68b4      	ldr	r4, [r6, #8]
   9844a:	3d01      	subs	r5, #1
   9844c:	d410      	bmi.n	98470 <_fwalk_reent+0x3c>
   9844e:	89a3      	ldrh	r3, [r4, #12]
   98450:	3d01      	subs	r5, #1
   98452:	2b01      	cmp	r3, #1
   98454:	d908      	bls.n	98468 <_fwalk_reent+0x34>
   98456:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
   9845a:	3301      	adds	r3, #1
   9845c:	d004      	beq.n	98468 <_fwalk_reent+0x34>
   9845e:	4621      	mov	r1, r4
   98460:	4638      	mov	r0, r7
   98462:	47c0      	blx	r8
   98464:	ea49 0900 	orr.w	r9, r9, r0
   98468:	1c6b      	adds	r3, r5, #1
   9846a:	f104 0468 	add.w	r4, r4, #104	; 0x68
   9846e:	d1ee      	bne.n	9844e <_fwalk_reent+0x1a>
   98470:	6836      	ldr	r6, [r6, #0]
   98472:	2e00      	cmp	r6, #0
   98474:	d1e7      	bne.n	98446 <_fwalk_reent+0x12>
   98476:	4648      	mov	r0, r9
   98478:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   9847c:	46b1      	mov	r9, r6
   9847e:	4648      	mov	r0, r9
   98480:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00098484 <__locale_charset>:
   98484:	4800      	ldr	r0, [pc, #0]	; (98488 <__locale_charset+0x4>)
   98486:	4770      	bx	lr
   98488:	20070994 	.word	0x20070994

0009848c <__locale_mb_cur_max>:
   9848c:	4b01      	ldr	r3, [pc, #4]	; (98494 <__locale_mb_cur_max+0x8>)
   9848e:	6818      	ldr	r0, [r3, #0]
   98490:	4770      	bx	lr
   98492:	bf00      	nop
   98494:	200709b4 	.word	0x200709b4

00098498 <_localeconv_r>:
   98498:	4800      	ldr	r0, [pc, #0]	; (9849c <_localeconv_r+0x4>)
   9849a:	4770      	bx	lr
   9849c:	2007095c 	.word	0x2007095c

000984a0 <__swhatbuf_r>:
   984a0:	b570      	push	{r4, r5, r6, lr}
   984a2:	460e      	mov	r6, r1
   984a4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   984a8:	b090      	sub	sp, #64	; 0x40
   984aa:	2900      	cmp	r1, #0
   984ac:	4614      	mov	r4, r2
   984ae:	461d      	mov	r5, r3
   984b0:	db14      	blt.n	984dc <__swhatbuf_r+0x3c>
   984b2:	aa01      	add	r2, sp, #4
   984b4:	f000 fdfa 	bl	990ac <_fstat_r>
   984b8:	2800      	cmp	r0, #0
   984ba:	db0f      	blt.n	984dc <__swhatbuf_r+0x3c>
   984bc:	9a02      	ldr	r2, [sp, #8]
   984be:	f44f 6380 	mov.w	r3, #1024	; 0x400
   984c2:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   984c6:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
   984ca:	fab2 f282 	clz	r2, r2
   984ce:	f44f 6000 	mov.w	r0, #2048	; 0x800
   984d2:	0952      	lsrs	r2, r2, #5
   984d4:	602a      	str	r2, [r5, #0]
   984d6:	6023      	str	r3, [r4, #0]
   984d8:	b010      	add	sp, #64	; 0x40
   984da:	bd70      	pop	{r4, r5, r6, pc}
   984dc:	89b2      	ldrh	r2, [r6, #12]
   984de:	2000      	movs	r0, #0
   984e0:	f002 0280 	and.w	r2, r2, #128	; 0x80
   984e4:	b292      	uxth	r2, r2
   984e6:	6028      	str	r0, [r5, #0]
   984e8:	b11a      	cbz	r2, 984f2 <__swhatbuf_r+0x52>
   984ea:	2340      	movs	r3, #64	; 0x40
   984ec:	6023      	str	r3, [r4, #0]
   984ee:	b010      	add	sp, #64	; 0x40
   984f0:	bd70      	pop	{r4, r5, r6, pc}
   984f2:	4610      	mov	r0, r2
   984f4:	f44f 6380 	mov.w	r3, #1024	; 0x400
   984f8:	6023      	str	r3, [r4, #0]
   984fa:	b010      	add	sp, #64	; 0x40
   984fc:	bd70      	pop	{r4, r5, r6, pc}
   984fe:	bf00      	nop

00098500 <__smakebuf_r>:
   98500:	898a      	ldrh	r2, [r1, #12]
   98502:	460b      	mov	r3, r1
   98504:	0792      	lsls	r2, r2, #30
   98506:	d506      	bpl.n	98516 <__smakebuf_r+0x16>
   98508:	f101 0243 	add.w	r2, r1, #67	; 0x43
   9850c:	2101      	movs	r1, #1
   9850e:	601a      	str	r2, [r3, #0]
   98510:	611a      	str	r2, [r3, #16]
   98512:	6159      	str	r1, [r3, #20]
   98514:	4770      	bx	lr
   98516:	b5f0      	push	{r4, r5, r6, r7, lr}
   98518:	b083      	sub	sp, #12
   9851a:	ab01      	add	r3, sp, #4
   9851c:	466a      	mov	r2, sp
   9851e:	460c      	mov	r4, r1
   98520:	4605      	mov	r5, r0
   98522:	f7ff ffbd 	bl	984a0 <__swhatbuf_r>
   98526:	9900      	ldr	r1, [sp, #0]
   98528:	4606      	mov	r6, r0
   9852a:	4628      	mov	r0, r5
   9852c:	f7fb f812 	bl	93554 <_malloc_r>
   98530:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   98534:	b1d0      	cbz	r0, 9856c <__smakebuf_r+0x6c>
   98536:	e89d 0006 	ldmia.w	sp, {r1, r2}
   9853a:	4f12      	ldr	r7, [pc, #72]	; (98584 <__smakebuf_r+0x84>)
   9853c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   98540:	63ef      	str	r7, [r5, #60]	; 0x3c
   98542:	81a3      	strh	r3, [r4, #12]
   98544:	6020      	str	r0, [r4, #0]
   98546:	6120      	str	r0, [r4, #16]
   98548:	6161      	str	r1, [r4, #20]
   9854a:	b91a      	cbnz	r2, 98554 <__smakebuf_r+0x54>
   9854c:	4333      	orrs	r3, r6
   9854e:	81a3      	strh	r3, [r4, #12]
   98550:	b003      	add	sp, #12
   98552:	bdf0      	pop	{r4, r5, r6, r7, pc}
   98554:	4628      	mov	r0, r5
   98556:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   9855a:	f000 fdbb 	bl	990d4 <_isatty_r>
   9855e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   98562:	2800      	cmp	r0, #0
   98564:	d0f2      	beq.n	9854c <__smakebuf_r+0x4c>
   98566:	f043 0301 	orr.w	r3, r3, #1
   9856a:	e7ef      	b.n	9854c <__smakebuf_r+0x4c>
   9856c:	059a      	lsls	r2, r3, #22
   9856e:	d4ef      	bmi.n	98550 <__smakebuf_r+0x50>
   98570:	f104 0243 	add.w	r2, r4, #67	; 0x43
   98574:	f043 0302 	orr.w	r3, r3, #2
   98578:	2101      	movs	r1, #1
   9857a:	81a3      	strh	r3, [r4, #12]
   9857c:	6022      	str	r2, [r4, #0]
   9857e:	6122      	str	r2, [r4, #16]
   98580:	6161      	str	r1, [r4, #20]
   98582:	e7e5      	b.n	98550 <__smakebuf_r+0x50>
   98584:	00097cd1 	.word	0x00097cd1

00098588 <memchr>:
   98588:	0783      	lsls	r3, r0, #30
   9858a:	b470      	push	{r4, r5, r6}
   9858c:	b2cd      	uxtb	r5, r1
   9858e:	d03d      	beq.n	9860c <memchr+0x84>
   98590:	1e53      	subs	r3, r2, #1
   98592:	b302      	cbz	r2, 985d6 <memchr+0x4e>
   98594:	7802      	ldrb	r2, [r0, #0]
   98596:	42aa      	cmp	r2, r5
   98598:	d01e      	beq.n	985d8 <memchr+0x50>
   9859a:	1c42      	adds	r2, r0, #1
   9859c:	e004      	b.n	985a8 <memchr+0x20>
   9859e:	b1d3      	cbz	r3, 985d6 <memchr+0x4e>
   985a0:	7804      	ldrb	r4, [r0, #0]
   985a2:	3b01      	subs	r3, #1
   985a4:	42ac      	cmp	r4, r5
   985a6:	d017      	beq.n	985d8 <memchr+0x50>
   985a8:	f012 0f03 	tst.w	r2, #3
   985ac:	4610      	mov	r0, r2
   985ae:	f102 0201 	add.w	r2, r2, #1
   985b2:	d1f4      	bne.n	9859e <memchr+0x16>
   985b4:	2b03      	cmp	r3, #3
   985b6:	d811      	bhi.n	985dc <memchr+0x54>
   985b8:	b353      	cbz	r3, 98610 <memchr+0x88>
   985ba:	7802      	ldrb	r2, [r0, #0]
   985bc:	42aa      	cmp	r2, r5
   985be:	d00b      	beq.n	985d8 <memchr+0x50>
   985c0:	4403      	add	r3, r0
   985c2:	1c42      	adds	r2, r0, #1
   985c4:	e002      	b.n	985cc <memchr+0x44>
   985c6:	7801      	ldrb	r1, [r0, #0]
   985c8:	42a9      	cmp	r1, r5
   985ca:	d005      	beq.n	985d8 <memchr+0x50>
   985cc:	4293      	cmp	r3, r2
   985ce:	4610      	mov	r0, r2
   985d0:	f102 0201 	add.w	r2, r2, #1
   985d4:	d1f7      	bne.n	985c6 <memchr+0x3e>
   985d6:	2000      	movs	r0, #0
   985d8:	bc70      	pop	{r4, r5, r6}
   985da:	4770      	bx	lr
   985dc:	4604      	mov	r4, r0
   985de:	020e      	lsls	r6, r1, #8
   985e0:	f406 467f 	and.w	r6, r6, #65280	; 0xff00
   985e4:	432e      	orrs	r6, r5
   985e6:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
   985ea:	6822      	ldr	r2, [r4, #0]
   985ec:	4620      	mov	r0, r4
   985ee:	4072      	eors	r2, r6
   985f0:	f1a2 3101 	sub.w	r1, r2, #16843009	; 0x1010101
   985f4:	ea21 0202 	bic.w	r2, r1, r2
   985f8:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   985fc:	f104 0404 	add.w	r4, r4, #4
   98600:	d1db      	bne.n	985ba <memchr+0x32>
   98602:	3b04      	subs	r3, #4
   98604:	2b03      	cmp	r3, #3
   98606:	4620      	mov	r0, r4
   98608:	d8ef      	bhi.n	985ea <memchr+0x62>
   9860a:	e7d5      	b.n	985b8 <memchr+0x30>
   9860c:	4613      	mov	r3, r2
   9860e:	e7d1      	b.n	985b4 <memchr+0x2c>
   98610:	4618      	mov	r0, r3
   98612:	e7e1      	b.n	985d8 <memchr+0x50>

00098614 <_Balloc>:
   98614:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
   98616:	b570      	push	{r4, r5, r6, lr}
   98618:	4605      	mov	r5, r0
   9861a:	460c      	mov	r4, r1
   9861c:	b152      	cbz	r2, 98634 <_Balloc+0x20>
   9861e:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
   98622:	b18b      	cbz	r3, 98648 <_Balloc+0x34>
   98624:	6819      	ldr	r1, [r3, #0]
   98626:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
   9862a:	2200      	movs	r2, #0
   9862c:	4618      	mov	r0, r3
   9862e:	611a      	str	r2, [r3, #16]
   98630:	60da      	str	r2, [r3, #12]
   98632:	bd70      	pop	{r4, r5, r6, pc}
   98634:	2221      	movs	r2, #33	; 0x21
   98636:	2104      	movs	r1, #4
   98638:	f000 fcb4 	bl	98fa4 <_calloc_r>
   9863c:	64e8      	str	r0, [r5, #76]	; 0x4c
   9863e:	4602      	mov	r2, r0
   98640:	2800      	cmp	r0, #0
   98642:	d1ec      	bne.n	9861e <_Balloc+0xa>
   98644:	2000      	movs	r0, #0
   98646:	bd70      	pop	{r4, r5, r6, pc}
   98648:	2101      	movs	r1, #1
   9864a:	fa01 f604 	lsl.w	r6, r1, r4
   9864e:	1d72      	adds	r2, r6, #5
   98650:	4628      	mov	r0, r5
   98652:	0092      	lsls	r2, r2, #2
   98654:	f000 fca6 	bl	98fa4 <_calloc_r>
   98658:	4603      	mov	r3, r0
   9865a:	2800      	cmp	r0, #0
   9865c:	d0f2      	beq.n	98644 <_Balloc+0x30>
   9865e:	6044      	str	r4, [r0, #4]
   98660:	6086      	str	r6, [r0, #8]
   98662:	e7e2      	b.n	9862a <_Balloc+0x16>

00098664 <_Bfree>:
   98664:	b131      	cbz	r1, 98674 <_Bfree+0x10>
   98666:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   98668:	684a      	ldr	r2, [r1, #4]
   9866a:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
   9866e:	6008      	str	r0, [r1, #0]
   98670:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   98674:	4770      	bx	lr
   98676:	bf00      	nop

00098678 <__multadd>:
   98678:	b5f0      	push	{r4, r5, r6, r7, lr}
   9867a:	460c      	mov	r4, r1
   9867c:	4605      	mov	r5, r0
   9867e:	690e      	ldr	r6, [r1, #16]
   98680:	b083      	sub	sp, #12
   98682:	f101 0e14 	add.w	lr, r1, #20
   98686:	2700      	movs	r7, #0
   98688:	f8de 0000 	ldr.w	r0, [lr]
   9868c:	3701      	adds	r7, #1
   9868e:	b281      	uxth	r1, r0
   98690:	fb02 3101 	mla	r1, r2, r1, r3
   98694:	0c00      	lsrs	r0, r0, #16
   98696:	0c0b      	lsrs	r3, r1, #16
   98698:	fb02 3300 	mla	r3, r2, r0, r3
   9869c:	b289      	uxth	r1, r1
   9869e:	eb01 4103 	add.w	r1, r1, r3, lsl #16
   986a2:	42be      	cmp	r6, r7
   986a4:	f84e 1b04 	str.w	r1, [lr], #4
   986a8:	ea4f 4313 	mov.w	r3, r3, lsr #16
   986ac:	dcec      	bgt.n	98688 <__multadd+0x10>
   986ae:	b13b      	cbz	r3, 986c0 <__multadd+0x48>
   986b0:	68a2      	ldr	r2, [r4, #8]
   986b2:	4296      	cmp	r6, r2
   986b4:	da07      	bge.n	986c6 <__multadd+0x4e>
   986b6:	eb04 0286 	add.w	r2, r4, r6, lsl #2
   986ba:	3601      	adds	r6, #1
   986bc:	6153      	str	r3, [r2, #20]
   986be:	6126      	str	r6, [r4, #16]
   986c0:	4620      	mov	r0, r4
   986c2:	b003      	add	sp, #12
   986c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   986c6:	6861      	ldr	r1, [r4, #4]
   986c8:	4628      	mov	r0, r5
   986ca:	3101      	adds	r1, #1
   986cc:	9301      	str	r3, [sp, #4]
   986ce:	f7ff ffa1 	bl	98614 <_Balloc>
   986d2:	4607      	mov	r7, r0
   986d4:	6922      	ldr	r2, [r4, #16]
   986d6:	f104 010c 	add.w	r1, r4, #12
   986da:	3202      	adds	r2, #2
   986dc:	0092      	lsls	r2, r2, #2
   986de:	300c      	adds	r0, #12
   986e0:	f7fb fa16 	bl	93b10 <memcpy>
   986e4:	6cea      	ldr	r2, [r5, #76]	; 0x4c
   986e6:	6861      	ldr	r1, [r4, #4]
   986e8:	9b01      	ldr	r3, [sp, #4]
   986ea:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   986ee:	6020      	str	r0, [r4, #0]
   986f0:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
   986f4:	463c      	mov	r4, r7
   986f6:	e7de      	b.n	986b6 <__multadd+0x3e>

000986f8 <__hi0bits>:
   986f8:	0c03      	lsrs	r3, r0, #16
   986fa:	041b      	lsls	r3, r3, #16
   986fc:	b9b3      	cbnz	r3, 9872c <__hi0bits+0x34>
   986fe:	0400      	lsls	r0, r0, #16
   98700:	2310      	movs	r3, #16
   98702:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
   98706:	bf04      	itt	eq
   98708:	0200      	lsleq	r0, r0, #8
   9870a:	3308      	addeq	r3, #8
   9870c:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
   98710:	bf04      	itt	eq
   98712:	0100      	lsleq	r0, r0, #4
   98714:	3304      	addeq	r3, #4
   98716:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
   9871a:	bf04      	itt	eq
   9871c:	0080      	lsleq	r0, r0, #2
   9871e:	3302      	addeq	r3, #2
   98720:	2800      	cmp	r0, #0
   98722:	db07      	blt.n	98734 <__hi0bits+0x3c>
   98724:	0042      	lsls	r2, r0, #1
   98726:	d403      	bmi.n	98730 <__hi0bits+0x38>
   98728:	2020      	movs	r0, #32
   9872a:	4770      	bx	lr
   9872c:	2300      	movs	r3, #0
   9872e:	e7e8      	b.n	98702 <__hi0bits+0xa>
   98730:	1c58      	adds	r0, r3, #1
   98732:	4770      	bx	lr
   98734:	4618      	mov	r0, r3
   98736:	4770      	bx	lr

00098738 <__lo0bits>:
   98738:	6803      	ldr	r3, [r0, #0]
   9873a:	f013 0207 	ands.w	r2, r3, #7
   9873e:	d007      	beq.n	98750 <__lo0bits+0x18>
   98740:	07d9      	lsls	r1, r3, #31
   98742:	d420      	bmi.n	98786 <__lo0bits+0x4e>
   98744:	079a      	lsls	r2, r3, #30
   98746:	d420      	bmi.n	9878a <__lo0bits+0x52>
   98748:	089b      	lsrs	r3, r3, #2
   9874a:	6003      	str	r3, [r0, #0]
   9874c:	2002      	movs	r0, #2
   9874e:	4770      	bx	lr
   98750:	b299      	uxth	r1, r3
   98752:	b909      	cbnz	r1, 98758 <__lo0bits+0x20>
   98754:	0c1b      	lsrs	r3, r3, #16
   98756:	2210      	movs	r2, #16
   98758:	f013 0fff 	tst.w	r3, #255	; 0xff
   9875c:	bf04      	itt	eq
   9875e:	0a1b      	lsreq	r3, r3, #8
   98760:	3208      	addeq	r2, #8
   98762:	0719      	lsls	r1, r3, #28
   98764:	bf04      	itt	eq
   98766:	091b      	lsreq	r3, r3, #4
   98768:	3204      	addeq	r2, #4
   9876a:	0799      	lsls	r1, r3, #30
   9876c:	bf04      	itt	eq
   9876e:	089b      	lsreq	r3, r3, #2
   98770:	3202      	addeq	r2, #2
   98772:	07d9      	lsls	r1, r3, #31
   98774:	d404      	bmi.n	98780 <__lo0bits+0x48>
   98776:	085b      	lsrs	r3, r3, #1
   98778:	d101      	bne.n	9877e <__lo0bits+0x46>
   9877a:	2020      	movs	r0, #32
   9877c:	4770      	bx	lr
   9877e:	3201      	adds	r2, #1
   98780:	6003      	str	r3, [r0, #0]
   98782:	4610      	mov	r0, r2
   98784:	4770      	bx	lr
   98786:	2000      	movs	r0, #0
   98788:	4770      	bx	lr
   9878a:	085b      	lsrs	r3, r3, #1
   9878c:	6003      	str	r3, [r0, #0]
   9878e:	2001      	movs	r0, #1
   98790:	4770      	bx	lr
   98792:	bf00      	nop

00098794 <__i2b>:
   98794:	b510      	push	{r4, lr}
   98796:	460c      	mov	r4, r1
   98798:	2101      	movs	r1, #1
   9879a:	f7ff ff3b 	bl	98614 <_Balloc>
   9879e:	2201      	movs	r2, #1
   987a0:	6144      	str	r4, [r0, #20]
   987a2:	6102      	str	r2, [r0, #16]
   987a4:	bd10      	pop	{r4, pc}
   987a6:	bf00      	nop

000987a8 <__multiply>:
   987a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   987ac:	690d      	ldr	r5, [r1, #16]
   987ae:	6916      	ldr	r6, [r2, #16]
   987b0:	b085      	sub	sp, #20
   987b2:	42b5      	cmp	r5, r6
   987b4:	460c      	mov	r4, r1
   987b6:	4691      	mov	r9, r2
   987b8:	da04      	bge.n	987c4 <__multiply+0x1c>
   987ba:	462a      	mov	r2, r5
   987bc:	464c      	mov	r4, r9
   987be:	4635      	mov	r5, r6
   987c0:	4689      	mov	r9, r1
   987c2:	4616      	mov	r6, r2
   987c4:	68a3      	ldr	r3, [r4, #8]
   987c6:	eb05 0806 	add.w	r8, r5, r6
   987ca:	6861      	ldr	r1, [r4, #4]
   987cc:	4598      	cmp	r8, r3
   987ce:	bfc8      	it	gt
   987d0:	3101      	addgt	r1, #1
   987d2:	f7ff ff1f 	bl	98614 <_Balloc>
   987d6:	f100 0a14 	add.w	sl, r0, #20
   987da:	eb0a 0b88 	add.w	fp, sl, r8, lsl #2
   987de:	45da      	cmp	sl, fp
   987e0:	9001      	str	r0, [sp, #4]
   987e2:	d205      	bcs.n	987f0 <__multiply+0x48>
   987e4:	4653      	mov	r3, sl
   987e6:	2100      	movs	r1, #0
   987e8:	f843 1b04 	str.w	r1, [r3], #4
   987ec:	459b      	cmp	fp, r3
   987ee:	d8fb      	bhi.n	987e8 <__multiply+0x40>
   987f0:	f109 0914 	add.w	r9, r9, #20
   987f4:	eb09 0386 	add.w	r3, r9, r6, lsl #2
   987f8:	f104 0214 	add.w	r2, r4, #20
   987fc:	4599      	cmp	r9, r3
   987fe:	eb02 0c85 	add.w	ip, r2, r5, lsl #2
   98802:	d259      	bcs.n	988b8 <__multiply+0x110>
   98804:	f8cd b008 	str.w	fp, [sp, #8]
   98808:	f8cd 800c 	str.w	r8, [sp, #12]
   9880c:	469b      	mov	fp, r3
   9880e:	4690      	mov	r8, r2
   98810:	f859 7b04 	ldr.w	r7, [r9], #4
   98814:	fa1f fe87 	uxth.w	lr, r7
   98818:	f1be 0f00 	cmp.w	lr, #0
   9881c:	d01f      	beq.n	9885e <__multiply+0xb6>
   9881e:	4647      	mov	r7, r8
   98820:	4656      	mov	r6, sl
   98822:	2100      	movs	r1, #0
   98824:	e000      	b.n	98828 <__multiply+0x80>
   98826:	4606      	mov	r6, r0
   98828:	4630      	mov	r0, r6
   9882a:	f857 5b04 	ldr.w	r5, [r7], #4
   9882e:	6834      	ldr	r4, [r6, #0]
   98830:	b2ab      	uxth	r3, r5
   98832:	b2a2      	uxth	r2, r4
   98834:	fb0e 2203 	mla	r2, lr, r3, r2
   98838:	0c2d      	lsrs	r5, r5, #16
   9883a:	0c24      	lsrs	r4, r4, #16
   9883c:	fb0e 4405 	mla	r4, lr, r5, r4
   98840:	1853      	adds	r3, r2, r1
   98842:	eb04 4113 	add.w	r1, r4, r3, lsr #16
   98846:	b29a      	uxth	r2, r3
   98848:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
   9884c:	45bc      	cmp	ip, r7
   9884e:	ea4f 4111 	mov.w	r1, r1, lsr #16
   98852:	f840 2b04 	str.w	r2, [r0], #4
   98856:	d8e6      	bhi.n	98826 <__multiply+0x7e>
   98858:	6071      	str	r1, [r6, #4]
   9885a:	f859 7c04 	ldr.w	r7, [r9, #-4]
   9885e:	0c3f      	lsrs	r7, r7, #16
   98860:	d022      	beq.n	988a8 <__multiply+0x100>
   98862:	f8da 3000 	ldr.w	r3, [sl]
   98866:	2200      	movs	r2, #0
   98868:	4655      	mov	r5, sl
   9886a:	461e      	mov	r6, r3
   9886c:	4640      	mov	r0, r8
   9886e:	4696      	mov	lr, r2
   98870:	e000      	b.n	98874 <__multiply+0xcc>
   98872:	4625      	mov	r5, r4
   98874:	462c      	mov	r4, r5
   98876:	8802      	ldrh	r2, [r0, #0]
   98878:	0c36      	lsrs	r6, r6, #16
   9887a:	fb07 6602 	mla	r6, r7, r2, r6
   9887e:	b299      	uxth	r1, r3
   98880:	eb06 020e 	add.w	r2, r6, lr
   98884:	ea41 4302 	orr.w	r3, r1, r2, lsl #16
   98888:	f844 3b04 	str.w	r3, [r4], #4
   9888c:	f850 1b04 	ldr.w	r1, [r0], #4
   98890:	686e      	ldr	r6, [r5, #4]
   98892:	0c09      	lsrs	r1, r1, #16
   98894:	b2b3      	uxth	r3, r6
   98896:	fb07 3101 	mla	r1, r7, r1, r3
   9889a:	4584      	cmp	ip, r0
   9889c:	eb01 4312 	add.w	r3, r1, r2, lsr #16
   988a0:	ea4f 4e13 	mov.w	lr, r3, lsr #16
   988a4:	d8e5      	bhi.n	98872 <__multiply+0xca>
   988a6:	606b      	str	r3, [r5, #4]
   988a8:	45cb      	cmp	fp, r9
   988aa:	f10a 0a04 	add.w	sl, sl, #4
   988ae:	d8af      	bhi.n	98810 <__multiply+0x68>
   988b0:	f8dd b008 	ldr.w	fp, [sp, #8]
   988b4:	f8dd 800c 	ldr.w	r8, [sp, #12]
   988b8:	f1b8 0f00 	cmp.w	r8, #0
   988bc:	dd0b      	ble.n	988d6 <__multiply+0x12e>
   988be:	f85b 3c04 	ldr.w	r3, [fp, #-4]
   988c2:	f1ab 0b04 	sub.w	fp, fp, #4
   988c6:	b11b      	cbz	r3, 988d0 <__multiply+0x128>
   988c8:	e005      	b.n	988d6 <__multiply+0x12e>
   988ca:	f85b 3d04 	ldr.w	r3, [fp, #-4]!
   988ce:	b913      	cbnz	r3, 988d6 <__multiply+0x12e>
   988d0:	f1b8 0801 	subs.w	r8, r8, #1
   988d4:	d1f9      	bne.n	988ca <__multiply+0x122>
   988d6:	9801      	ldr	r0, [sp, #4]
   988d8:	f8c0 8010 	str.w	r8, [r0, #16]
   988dc:	b005      	add	sp, #20
   988de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   988e2:	bf00      	nop

000988e4 <__pow5mult>:
   988e4:	f012 0303 	ands.w	r3, r2, #3
   988e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   988ec:	4614      	mov	r4, r2
   988ee:	4607      	mov	r7, r0
   988f0:	d12e      	bne.n	98950 <__pow5mult+0x6c>
   988f2:	460e      	mov	r6, r1
   988f4:	10a4      	asrs	r4, r4, #2
   988f6:	d01c      	beq.n	98932 <__pow5mult+0x4e>
   988f8:	6cbd      	ldr	r5, [r7, #72]	; 0x48
   988fa:	b395      	cbz	r5, 98962 <__pow5mult+0x7e>
   988fc:	07e3      	lsls	r3, r4, #31
   988fe:	f04f 0800 	mov.w	r8, #0
   98902:	d406      	bmi.n	98912 <__pow5mult+0x2e>
   98904:	1064      	asrs	r4, r4, #1
   98906:	d014      	beq.n	98932 <__pow5mult+0x4e>
   98908:	6828      	ldr	r0, [r5, #0]
   9890a:	b1a8      	cbz	r0, 98938 <__pow5mult+0x54>
   9890c:	4605      	mov	r5, r0
   9890e:	07e3      	lsls	r3, r4, #31
   98910:	d5f8      	bpl.n	98904 <__pow5mult+0x20>
   98912:	462a      	mov	r2, r5
   98914:	4631      	mov	r1, r6
   98916:	4638      	mov	r0, r7
   98918:	f7ff ff46 	bl	987a8 <__multiply>
   9891c:	b1b6      	cbz	r6, 9894c <__pow5mult+0x68>
   9891e:	6872      	ldr	r2, [r6, #4]
   98920:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   98922:	1064      	asrs	r4, r4, #1
   98924:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   98928:	6031      	str	r1, [r6, #0]
   9892a:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
   9892e:	4606      	mov	r6, r0
   98930:	d1ea      	bne.n	98908 <__pow5mult+0x24>
   98932:	4630      	mov	r0, r6
   98934:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   98938:	462a      	mov	r2, r5
   9893a:	4629      	mov	r1, r5
   9893c:	4638      	mov	r0, r7
   9893e:	f7ff ff33 	bl	987a8 <__multiply>
   98942:	6028      	str	r0, [r5, #0]
   98944:	f8c0 8000 	str.w	r8, [r0]
   98948:	4605      	mov	r5, r0
   9894a:	e7e0      	b.n	9890e <__pow5mult+0x2a>
   9894c:	4606      	mov	r6, r0
   9894e:	e7d9      	b.n	98904 <__pow5mult+0x20>
   98950:	4a0b      	ldr	r2, [pc, #44]	; (98980 <__pow5mult+0x9c>)
   98952:	3b01      	subs	r3, #1
   98954:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   98958:	2300      	movs	r3, #0
   9895a:	f7ff fe8d 	bl	98678 <__multadd>
   9895e:	4606      	mov	r6, r0
   98960:	e7c8      	b.n	988f4 <__pow5mult+0x10>
   98962:	2101      	movs	r1, #1
   98964:	4638      	mov	r0, r7
   98966:	f7ff fe55 	bl	98614 <_Balloc>
   9896a:	f240 2171 	movw	r1, #625	; 0x271
   9896e:	2201      	movs	r2, #1
   98970:	2300      	movs	r3, #0
   98972:	6141      	str	r1, [r0, #20]
   98974:	6102      	str	r2, [r0, #16]
   98976:	4605      	mov	r5, r0
   98978:	64b8      	str	r0, [r7, #72]	; 0x48
   9897a:	6003      	str	r3, [r0, #0]
   9897c:	e7be      	b.n	988fc <__pow5mult+0x18>
   9897e:	bf00      	nop
   98980:	0009b308 	.word	0x0009b308

00098984 <__lshift>:
   98984:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   98988:	690b      	ldr	r3, [r1, #16]
   9898a:	1154      	asrs	r4, r2, #5
   9898c:	eb04 0803 	add.w	r8, r4, r3
   98990:	688b      	ldr	r3, [r1, #8]
   98992:	f108 0501 	add.w	r5, r8, #1
   98996:	429d      	cmp	r5, r3
   98998:	460e      	mov	r6, r1
   9899a:	4691      	mov	r9, r2
   9899c:	4683      	mov	fp, r0
   9899e:	6849      	ldr	r1, [r1, #4]
   989a0:	dd04      	ble.n	989ac <__lshift+0x28>
   989a2:	005b      	lsls	r3, r3, #1
   989a4:	429d      	cmp	r5, r3
   989a6:	f101 0101 	add.w	r1, r1, #1
   989aa:	dcfa      	bgt.n	989a2 <__lshift+0x1e>
   989ac:	4658      	mov	r0, fp
   989ae:	f7ff fe31 	bl	98614 <_Balloc>
   989b2:	2c00      	cmp	r4, #0
   989b4:	f100 0214 	add.w	r2, r0, #20
   989b8:	dd37      	ble.n	98a2a <__lshift+0xa6>
   989ba:	eb02 0384 	add.w	r3, r2, r4, lsl #2
   989be:	2100      	movs	r1, #0
   989c0:	f842 1b04 	str.w	r1, [r2], #4
   989c4:	4293      	cmp	r3, r2
   989c6:	d1fb      	bne.n	989c0 <__lshift+0x3c>
   989c8:	6934      	ldr	r4, [r6, #16]
   989ca:	f106 0114 	add.w	r1, r6, #20
   989ce:	f019 091f 	ands.w	r9, r9, #31
   989d2:	eb01 0e84 	add.w	lr, r1, r4, lsl #2
   989d6:	d020      	beq.n	98a1a <__lshift+0x96>
   989d8:	f1c9 0c20 	rsb	ip, r9, #32
   989dc:	2400      	movs	r4, #0
   989de:	680f      	ldr	r7, [r1, #0]
   989e0:	461a      	mov	r2, r3
   989e2:	fa07 fa09 	lsl.w	sl, r7, r9
   989e6:	ea4a 0404 	orr.w	r4, sl, r4
   989ea:	f843 4b04 	str.w	r4, [r3], #4
   989ee:	f851 4b04 	ldr.w	r4, [r1], #4
   989f2:	458e      	cmp	lr, r1
   989f4:	fa24 f40c 	lsr.w	r4, r4, ip
   989f8:	d8f1      	bhi.n	989de <__lshift+0x5a>
   989fa:	6054      	str	r4, [r2, #4]
   989fc:	b10c      	cbz	r4, 98a02 <__lshift+0x7e>
   989fe:	f108 0502 	add.w	r5, r8, #2
   98a02:	f8db 304c 	ldr.w	r3, [fp, #76]	; 0x4c
   98a06:	6872      	ldr	r2, [r6, #4]
   98a08:	3d01      	subs	r5, #1
   98a0a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   98a0e:	6105      	str	r5, [r0, #16]
   98a10:	6031      	str	r1, [r6, #0]
   98a12:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
   98a16:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   98a1a:	3b04      	subs	r3, #4
   98a1c:	f851 2b04 	ldr.w	r2, [r1], #4
   98a20:	458e      	cmp	lr, r1
   98a22:	f843 2f04 	str.w	r2, [r3, #4]!
   98a26:	d8f9      	bhi.n	98a1c <__lshift+0x98>
   98a28:	e7eb      	b.n	98a02 <__lshift+0x7e>
   98a2a:	4613      	mov	r3, r2
   98a2c:	e7cc      	b.n	989c8 <__lshift+0x44>
   98a2e:	bf00      	nop

00098a30 <__mcmp>:
   98a30:	6902      	ldr	r2, [r0, #16]
   98a32:	690b      	ldr	r3, [r1, #16]
   98a34:	1ad2      	subs	r2, r2, r3
   98a36:	d112      	bne.n	98a5e <__mcmp+0x2e>
   98a38:	009b      	lsls	r3, r3, #2
   98a3a:	3014      	adds	r0, #20
   98a3c:	3114      	adds	r1, #20
   98a3e:	4419      	add	r1, r3
   98a40:	b410      	push	{r4}
   98a42:	4403      	add	r3, r0
   98a44:	e001      	b.n	98a4a <__mcmp+0x1a>
   98a46:	4298      	cmp	r0, r3
   98a48:	d20b      	bcs.n	98a62 <__mcmp+0x32>
   98a4a:	f853 4d04 	ldr.w	r4, [r3, #-4]!
   98a4e:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   98a52:	4294      	cmp	r4, r2
   98a54:	d0f7      	beq.n	98a46 <__mcmp+0x16>
   98a56:	d307      	bcc.n	98a68 <__mcmp+0x38>
   98a58:	2001      	movs	r0, #1
   98a5a:	bc10      	pop	{r4}
   98a5c:	4770      	bx	lr
   98a5e:	4610      	mov	r0, r2
   98a60:	4770      	bx	lr
   98a62:	2000      	movs	r0, #0
   98a64:	bc10      	pop	{r4}
   98a66:	4770      	bx	lr
   98a68:	f04f 30ff 	mov.w	r0, #4294967295
   98a6c:	e7f5      	b.n	98a5a <__mcmp+0x2a>
   98a6e:	bf00      	nop

00098a70 <__mdiff>:
   98a70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   98a74:	690b      	ldr	r3, [r1, #16]
   98a76:	460c      	mov	r4, r1
   98a78:	6911      	ldr	r1, [r2, #16]
   98a7a:	4690      	mov	r8, r2
   98a7c:	1a5b      	subs	r3, r3, r1
   98a7e:	2b00      	cmp	r3, #0
   98a80:	d118      	bne.n	98ab4 <__mdiff+0x44>
   98a82:	0089      	lsls	r1, r1, #2
   98a84:	f104 0614 	add.w	r6, r4, #20
   98a88:	f102 0714 	add.w	r7, r2, #20
   98a8c:	1873      	adds	r3, r6, r1
   98a8e:	4439      	add	r1, r7
   98a90:	e001      	b.n	98a96 <__mdiff+0x26>
   98a92:	429e      	cmp	r6, r3
   98a94:	d269      	bcs.n	98b6a <__mdiff+0xfa>
   98a96:	f853 5d04 	ldr.w	r5, [r3, #-4]!
   98a9a:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   98a9e:	4295      	cmp	r5, r2
   98aa0:	d0f7      	beq.n	98a92 <__mdiff+0x22>
   98aa2:	d26b      	bcs.n	98b7c <__mdiff+0x10c>
   98aa4:	4623      	mov	r3, r4
   98aa6:	46b2      	mov	sl, r6
   98aa8:	4644      	mov	r4, r8
   98aaa:	463e      	mov	r6, r7
   98aac:	4698      	mov	r8, r3
   98aae:	f04f 0901 	mov.w	r9, #1
   98ab2:	e006      	b.n	98ac2 <__mdiff+0x52>
   98ab4:	db66      	blt.n	98b84 <__mdiff+0x114>
   98ab6:	f104 0614 	add.w	r6, r4, #20
   98aba:	f102 0a14 	add.w	sl, r2, #20
   98abe:	f04f 0900 	mov.w	r9, #0
   98ac2:	6861      	ldr	r1, [r4, #4]
   98ac4:	f7ff fda6 	bl	98614 <_Balloc>
   98ac8:	4655      	mov	r5, sl
   98aca:	f8d4 e010 	ldr.w	lr, [r4, #16]
   98ace:	f8d8 3010 	ldr.w	r3, [r8, #16]
   98ad2:	4637      	mov	r7, r6
   98ad4:	f8c0 900c 	str.w	r9, [r0, #12]
   98ad8:	eb0a 0c83 	add.w	ip, sl, r3, lsl #2
   98adc:	eb06 068e 	add.w	r6, r6, lr, lsl #2
   98ae0:	f100 0414 	add.w	r4, r0, #20
   98ae4:	f04f 0900 	mov.w	r9, #0
   98ae8:	f857 2b04 	ldr.w	r2, [r7], #4
   98aec:	f855 1b04 	ldr.w	r1, [r5], #4
   98af0:	fa1f f882 	uxth.w	r8, r2
   98af4:	eb08 0309 	add.w	r3, r8, r9
   98af8:	fa1f f881 	uxth.w	r8, r1
   98afc:	0c09      	lsrs	r1, r1, #16
   98afe:	ebc8 0303 	rsb	r3, r8, r3
   98b02:	ebc1 4212 	rsb	r2, r1, r2, lsr #16
   98b06:	eb02 4223 	add.w	r2, r2, r3, asr #16
   98b0a:	b29b      	uxth	r3, r3
   98b0c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   98b10:	45ac      	cmp	ip, r5
   98b12:	f844 3b04 	str.w	r3, [r4], #4
   98b16:	ea4f 4922 	mov.w	r9, r2, asr #16
   98b1a:	d8e5      	bhi.n	98ae8 <__mdiff+0x78>
   98b1c:	42be      	cmp	r6, r7
   98b1e:	d918      	bls.n	98b52 <__mdiff+0xe2>
   98b20:	46a0      	mov	r8, r4
   98b22:	46bc      	mov	ip, r7
   98b24:	f85c 2b04 	ldr.w	r2, [ip], #4
   98b28:	b295      	uxth	r5, r2
   98b2a:	eb05 0109 	add.w	r1, r5, r9
   98b2e:	140b      	asrs	r3, r1, #16
   98b30:	eb03 4212 	add.w	r2, r3, r2, lsr #16
   98b34:	b28b      	uxth	r3, r1
   98b36:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   98b3a:	4566      	cmp	r6, ip
   98b3c:	f848 3b04 	str.w	r3, [r8], #4
   98b40:	ea4f 4922 	mov.w	r9, r2, asr #16
   98b44:	d8ee      	bhi.n	98b24 <__mdiff+0xb4>
   98b46:	43ff      	mvns	r7, r7
   98b48:	4437      	add	r7, r6
   98b4a:	f027 0703 	bic.w	r7, r7, #3
   98b4e:	3704      	adds	r7, #4
   98b50:	443c      	add	r4, r7
   98b52:	3c04      	subs	r4, #4
   98b54:	b92b      	cbnz	r3, 98b62 <__mdiff+0xf2>
   98b56:	f854 3d04 	ldr.w	r3, [r4, #-4]!
   98b5a:	f10e 3eff 	add.w	lr, lr, #4294967295
   98b5e:	2b00      	cmp	r3, #0
   98b60:	d0f9      	beq.n	98b56 <__mdiff+0xe6>
   98b62:	f8c0 e010 	str.w	lr, [r0, #16]
   98b66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   98b6a:	2100      	movs	r1, #0
   98b6c:	f7ff fd52 	bl	98614 <_Balloc>
   98b70:	2201      	movs	r2, #1
   98b72:	2300      	movs	r3, #0
   98b74:	6102      	str	r2, [r0, #16]
   98b76:	6143      	str	r3, [r0, #20]
   98b78:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   98b7c:	46ba      	mov	sl, r7
   98b7e:	f04f 0900 	mov.w	r9, #0
   98b82:	e79e      	b.n	98ac2 <__mdiff+0x52>
   98b84:	4623      	mov	r3, r4
   98b86:	f104 0a14 	add.w	sl, r4, #20
   98b8a:	f108 0614 	add.w	r6, r8, #20
   98b8e:	4644      	mov	r4, r8
   98b90:	f04f 0901 	mov.w	r9, #1
   98b94:	4698      	mov	r8, r3
   98b96:	e794      	b.n	98ac2 <__mdiff+0x52>

00098b98 <__d2b>:
   98b98:	b5f0      	push	{r4, r5, r6, r7, lr}
   98b9a:	2101      	movs	r1, #1
   98b9c:	b083      	sub	sp, #12
   98b9e:	461c      	mov	r4, r3
   98ba0:	f3c3 550a 	ubfx	r5, r3, #20, #11
   98ba4:	4616      	mov	r6, r2
   98ba6:	f7ff fd35 	bl	98614 <_Balloc>
   98baa:	f3c4 0413 	ubfx	r4, r4, #0, #20
   98bae:	4607      	mov	r7, r0
   98bb0:	b10d      	cbz	r5, 98bb6 <__d2b+0x1e>
   98bb2:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
   98bb6:	9401      	str	r4, [sp, #4]
   98bb8:	b306      	cbz	r6, 98bfc <__d2b+0x64>
   98bba:	a802      	add	r0, sp, #8
   98bbc:	f840 6d08 	str.w	r6, [r0, #-8]!
   98bc0:	f7ff fdba 	bl	98738 <__lo0bits>
   98bc4:	2800      	cmp	r0, #0
   98bc6:	d130      	bne.n	98c2a <__d2b+0x92>
   98bc8:	e89d 000c 	ldmia.w	sp, {r2, r3}
   98bcc:	617a      	str	r2, [r7, #20]
   98bce:	2b00      	cmp	r3, #0
   98bd0:	bf0c      	ite	eq
   98bd2:	2101      	moveq	r1, #1
   98bd4:	2102      	movne	r1, #2
   98bd6:	61bb      	str	r3, [r7, #24]
   98bd8:	6139      	str	r1, [r7, #16]
   98bda:	b9d5      	cbnz	r5, 98c12 <__d2b+0x7a>
   98bdc:	9a08      	ldr	r2, [sp, #32]
   98bde:	eb07 0381 	add.w	r3, r7, r1, lsl #2
   98be2:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   98be6:	6010      	str	r0, [r2, #0]
   98be8:	6918      	ldr	r0, [r3, #16]
   98bea:	f7ff fd85 	bl	986f8 <__hi0bits>
   98bee:	9b09      	ldr	r3, [sp, #36]	; 0x24
   98bf0:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
   98bf4:	6018      	str	r0, [r3, #0]
   98bf6:	4638      	mov	r0, r7
   98bf8:	b003      	add	sp, #12
   98bfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
   98bfc:	a801      	add	r0, sp, #4
   98bfe:	f7ff fd9b 	bl	98738 <__lo0bits>
   98c02:	9b01      	ldr	r3, [sp, #4]
   98c04:	2201      	movs	r2, #1
   98c06:	4611      	mov	r1, r2
   98c08:	3020      	adds	r0, #32
   98c0a:	613a      	str	r2, [r7, #16]
   98c0c:	617b      	str	r3, [r7, #20]
   98c0e:	2d00      	cmp	r5, #0
   98c10:	d0e4      	beq.n	98bdc <__d2b+0x44>
   98c12:	f2a5 4333 	subw	r3, r5, #1075	; 0x433
   98c16:	9a08      	ldr	r2, [sp, #32]
   98c18:	4403      	add	r3, r0
   98c1a:	6013      	str	r3, [r2, #0]
   98c1c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   98c1e:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   98c22:	6018      	str	r0, [r3, #0]
   98c24:	4638      	mov	r0, r7
   98c26:	b003      	add	sp, #12
   98c28:	bdf0      	pop	{r4, r5, r6, r7, pc}
   98c2a:	9b01      	ldr	r3, [sp, #4]
   98c2c:	f1c0 0120 	rsb	r1, r0, #32
   98c30:	9a00      	ldr	r2, [sp, #0]
   98c32:	fa03 f101 	lsl.w	r1, r3, r1
   98c36:	430a      	orrs	r2, r1
   98c38:	40c3      	lsrs	r3, r0
   98c3a:	9301      	str	r3, [sp, #4]
   98c3c:	617a      	str	r2, [r7, #20]
   98c3e:	e7c6      	b.n	98bce <__d2b+0x36>

00098c40 <_raise_r>:
   98c40:	291f      	cmp	r1, #31
   98c42:	b538      	push	{r3, r4, r5, lr}
   98c44:	d822      	bhi.n	98c8c <_raise_r+0x4c>
   98c46:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
   98c4a:	4605      	mov	r5, r0
   98c4c:	460c      	mov	r4, r1
   98c4e:	b19a      	cbz	r2, 98c78 <_raise_r+0x38>
   98c50:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   98c54:	b183      	cbz	r3, 98c78 <_raise_r+0x38>
   98c56:	2b01      	cmp	r3, #1
   98c58:	d00c      	beq.n	98c74 <_raise_r+0x34>
   98c5a:	1c59      	adds	r1, r3, #1
   98c5c:	d006      	beq.n	98c6c <_raise_r+0x2c>
   98c5e:	2500      	movs	r5, #0
   98c60:	4620      	mov	r0, r4
   98c62:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
   98c66:	4798      	blx	r3
   98c68:	4628      	mov	r0, r5
   98c6a:	bd38      	pop	{r3, r4, r5, pc}
   98c6c:	2316      	movs	r3, #22
   98c6e:	6003      	str	r3, [r0, #0]
   98c70:	2001      	movs	r0, #1
   98c72:	bd38      	pop	{r3, r4, r5, pc}
   98c74:	2000      	movs	r0, #0
   98c76:	bd38      	pop	{r3, r4, r5, pc}
   98c78:	4628      	mov	r0, r5
   98c7a:	f000 f829 	bl	98cd0 <_getpid_r>
   98c7e:	4622      	mov	r2, r4
   98c80:	4601      	mov	r1, r0
   98c82:	4628      	mov	r0, r5
   98c84:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   98c88:	f000 b80e 	b.w	98ca8 <_kill_r>
   98c8c:	2316      	movs	r3, #22
   98c8e:	6003      	str	r3, [r0, #0]
   98c90:	f04f 30ff 	mov.w	r0, #4294967295
   98c94:	bd38      	pop	{r3, r4, r5, pc}
   98c96:	bf00      	nop

00098c98 <raise>:
   98c98:	4b02      	ldr	r3, [pc, #8]	; (98ca4 <raise+0xc>)
   98c9a:	4601      	mov	r1, r0
   98c9c:	6818      	ldr	r0, [r3, #0]
   98c9e:	f7ff bfcf 	b.w	98c40 <_raise_r>
   98ca2:	bf00      	nop
   98ca4:	20070548 	.word	0x20070548

00098ca8 <_kill_r>:
   98ca8:	b538      	push	{r3, r4, r5, lr}
   98caa:	460b      	mov	r3, r1
   98cac:	4c07      	ldr	r4, [pc, #28]	; (98ccc <_kill_r+0x24>)
   98cae:	4605      	mov	r5, r0
   98cb0:	4611      	mov	r1, r2
   98cb2:	4618      	mov	r0, r3
   98cb4:	2300      	movs	r3, #0
   98cb6:	6023      	str	r3, [r4, #0]
   98cb8:	f7e7 fbdc 	bl	80474 <_kill>
   98cbc:	1c43      	adds	r3, r0, #1
   98cbe:	d000      	beq.n	98cc2 <_kill_r+0x1a>
   98cc0:	bd38      	pop	{r3, r4, r5, pc}
   98cc2:	6823      	ldr	r3, [r4, #0]
   98cc4:	2b00      	cmp	r3, #0
   98cc6:	d0fb      	beq.n	98cc0 <_kill_r+0x18>
   98cc8:	602b      	str	r3, [r5, #0]
   98cca:	bd38      	pop	{r3, r4, r5, pc}
   98ccc:	20071d00 	.word	0x20071d00

00098cd0 <_getpid_r>:
   98cd0:	f7e7 bbda 	b.w	80488 <_getpid>

00098cd4 <__sread>:
   98cd4:	b510      	push	{r4, lr}
   98cd6:	460c      	mov	r4, r1
   98cd8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   98cdc:	f000 fa22 	bl	99124 <_read_r>
   98ce0:	2800      	cmp	r0, #0
   98ce2:	db03      	blt.n	98cec <__sread+0x18>
   98ce4:	6d23      	ldr	r3, [r4, #80]	; 0x50
   98ce6:	4403      	add	r3, r0
   98ce8:	6523      	str	r3, [r4, #80]	; 0x50
   98cea:	bd10      	pop	{r4, pc}
   98cec:	89a3      	ldrh	r3, [r4, #12]
   98cee:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   98cf2:	81a3      	strh	r3, [r4, #12]
   98cf4:	bd10      	pop	{r4, pc}
   98cf6:	bf00      	nop

00098cf8 <__swrite>:
   98cf8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   98cfc:	460c      	mov	r4, r1
   98cfe:	f9b1 100c 	ldrsh.w	r1, [r1, #12]
   98d02:	461f      	mov	r7, r3
   98d04:	05cb      	lsls	r3, r1, #23
   98d06:	4616      	mov	r6, r2
   98d08:	4605      	mov	r5, r0
   98d0a:	d507      	bpl.n	98d1c <__swrite+0x24>
   98d0c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   98d10:	2302      	movs	r3, #2
   98d12:	2200      	movs	r2, #0
   98d14:	f000 f9f0 	bl	990f8 <_lseek_r>
   98d18:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
   98d1c:	f421 5180 	bic.w	r1, r1, #4096	; 0x1000
   98d20:	81a1      	strh	r1, [r4, #12]
   98d22:	463b      	mov	r3, r7
   98d24:	4632      	mov	r2, r6
   98d26:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   98d2a:	4628      	mov	r0, r5
   98d2c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   98d30:	f000 b922 	b.w	98f78 <_write_r>

00098d34 <__sseek>:
   98d34:	b510      	push	{r4, lr}
   98d36:	460c      	mov	r4, r1
   98d38:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   98d3c:	f000 f9dc 	bl	990f8 <_lseek_r>
   98d40:	89a3      	ldrh	r3, [r4, #12]
   98d42:	1c42      	adds	r2, r0, #1
   98d44:	bf0e      	itee	eq
   98d46:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   98d4a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   98d4e:	6520      	strne	r0, [r4, #80]	; 0x50
   98d50:	81a3      	strh	r3, [r4, #12]
   98d52:	bd10      	pop	{r4, pc}

00098d54 <__sclose>:
   98d54:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   98d58:	f000 b954 	b.w	99004 <_close_r>

00098d5c <__ssprint_r>:
   98d5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   98d60:	6893      	ldr	r3, [r2, #8]
   98d62:	b083      	sub	sp, #12
   98d64:	4690      	mov	r8, r2
   98d66:	2b00      	cmp	r3, #0
   98d68:	d072      	beq.n	98e50 <__ssprint_r+0xf4>
   98d6a:	f04f 0900 	mov.w	r9, #0
   98d6e:	460d      	mov	r5, r1
   98d70:	464c      	mov	r4, r9
   98d72:	4683      	mov	fp, r0
   98d74:	6816      	ldr	r6, [r2, #0]
   98d76:	6808      	ldr	r0, [r1, #0]
   98d78:	688b      	ldr	r3, [r1, #8]
   98d7a:	2c00      	cmp	r4, #0
   98d7c:	d045      	beq.n	98e0a <__ssprint_r+0xae>
   98d7e:	429c      	cmp	r4, r3
   98d80:	461f      	mov	r7, r3
   98d82:	469a      	mov	sl, r3
   98d84:	d346      	bcc.n	98e14 <__ssprint_r+0xb8>
   98d86:	89ab      	ldrh	r3, [r5, #12]
   98d88:	f413 6f90 	tst.w	r3, #1152	; 0x480
   98d8c:	d02d      	beq.n	98dea <__ssprint_r+0x8e>
   98d8e:	696f      	ldr	r7, [r5, #20]
   98d90:	6929      	ldr	r1, [r5, #16]
   98d92:	eb07 0747 	add.w	r7, r7, r7, lsl #1
   98d96:	ebc1 0a00 	rsb	sl, r1, r0
   98d9a:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
   98d9e:	1c60      	adds	r0, r4, #1
   98da0:	107f      	asrs	r7, r7, #1
   98da2:	4450      	add	r0, sl
   98da4:	42b8      	cmp	r0, r7
   98da6:	463a      	mov	r2, r7
   98da8:	bf84      	itt	hi
   98daa:	4607      	movhi	r7, r0
   98dac:	463a      	movhi	r2, r7
   98dae:	055b      	lsls	r3, r3, #21
   98db0:	d533      	bpl.n	98e1a <__ssprint_r+0xbe>
   98db2:	4611      	mov	r1, r2
   98db4:	4658      	mov	r0, fp
   98db6:	f7fa fbcd 	bl	93554 <_malloc_r>
   98dba:	2800      	cmp	r0, #0
   98dbc:	d037      	beq.n	98e2e <__ssprint_r+0xd2>
   98dbe:	4652      	mov	r2, sl
   98dc0:	6929      	ldr	r1, [r5, #16]
   98dc2:	9001      	str	r0, [sp, #4]
   98dc4:	f7fa fea4 	bl	93b10 <memcpy>
   98dc8:	89aa      	ldrh	r2, [r5, #12]
   98dca:	9b01      	ldr	r3, [sp, #4]
   98dcc:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   98dd0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   98dd4:	81aa      	strh	r2, [r5, #12]
   98dd6:	ebca 0207 	rsb	r2, sl, r7
   98dda:	eb03 000a 	add.w	r0, r3, sl
   98dde:	616f      	str	r7, [r5, #20]
   98de0:	46a2      	mov	sl, r4
   98de2:	4627      	mov	r7, r4
   98de4:	612b      	str	r3, [r5, #16]
   98de6:	6028      	str	r0, [r5, #0]
   98de8:	60aa      	str	r2, [r5, #8]
   98dea:	4652      	mov	r2, sl
   98dec:	4649      	mov	r1, r9
   98dee:	f7fa ff05 	bl	93bfc <memmove>
   98df2:	f8d8 2008 	ldr.w	r2, [r8, #8]
   98df6:	68ab      	ldr	r3, [r5, #8]
   98df8:	6828      	ldr	r0, [r5, #0]
   98dfa:	1bdb      	subs	r3, r3, r7
   98dfc:	4450      	add	r0, sl
   98dfe:	1b14      	subs	r4, r2, r4
   98e00:	60ab      	str	r3, [r5, #8]
   98e02:	6028      	str	r0, [r5, #0]
   98e04:	f8c8 4008 	str.w	r4, [r8, #8]
   98e08:	b314      	cbz	r4, 98e50 <__ssprint_r+0xf4>
   98e0a:	f8d6 9000 	ldr.w	r9, [r6]
   98e0e:	6874      	ldr	r4, [r6, #4]
   98e10:	3608      	adds	r6, #8
   98e12:	e7b2      	b.n	98d7a <__ssprint_r+0x1e>
   98e14:	4627      	mov	r7, r4
   98e16:	46a2      	mov	sl, r4
   98e18:	e7e7      	b.n	98dea <__ssprint_r+0x8e>
   98e1a:	4658      	mov	r0, fp
   98e1c:	f7fa ffac 	bl	93d78 <_realloc_r>
   98e20:	4603      	mov	r3, r0
   98e22:	2800      	cmp	r0, #0
   98e24:	d1d7      	bne.n	98dd6 <__ssprint_r+0x7a>
   98e26:	6929      	ldr	r1, [r5, #16]
   98e28:	4658      	mov	r0, fp
   98e2a:	f7ff f897 	bl	97f5c <_free_r>
   98e2e:	230c      	movs	r3, #12
   98e30:	f8cb 3000 	str.w	r3, [fp]
   98e34:	89ab      	ldrh	r3, [r5, #12]
   98e36:	2200      	movs	r2, #0
   98e38:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   98e3c:	f04f 30ff 	mov.w	r0, #4294967295
   98e40:	81ab      	strh	r3, [r5, #12]
   98e42:	f8c8 2008 	str.w	r2, [r8, #8]
   98e46:	f8c8 2004 	str.w	r2, [r8, #4]
   98e4a:	b003      	add	sp, #12
   98e4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   98e50:	2000      	movs	r0, #0
   98e52:	f8c8 0004 	str.w	r0, [r8, #4]
   98e56:	b003      	add	sp, #12
   98e58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00098e5c <__swbuf_r>:
   98e5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   98e5e:	460e      	mov	r6, r1
   98e60:	4614      	mov	r4, r2
   98e62:	4607      	mov	r7, r0
   98e64:	b110      	cbz	r0, 98e6c <__swbuf_r+0x10>
   98e66:	6b83      	ldr	r3, [r0, #56]	; 0x38
   98e68:	2b00      	cmp	r3, #0
   98e6a:	d04a      	beq.n	98f02 <__swbuf_r+0xa6>
   98e6c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   98e70:	69a3      	ldr	r3, [r4, #24]
   98e72:	b291      	uxth	r1, r2
   98e74:	0708      	lsls	r0, r1, #28
   98e76:	60a3      	str	r3, [r4, #8]
   98e78:	d538      	bpl.n	98eec <__swbuf_r+0x90>
   98e7a:	6923      	ldr	r3, [r4, #16]
   98e7c:	2b00      	cmp	r3, #0
   98e7e:	d035      	beq.n	98eec <__swbuf_r+0x90>
   98e80:	0489      	lsls	r1, r1, #18
   98e82:	b2f5      	uxtb	r5, r6
   98e84:	d515      	bpl.n	98eb2 <__swbuf_r+0x56>
   98e86:	6822      	ldr	r2, [r4, #0]
   98e88:	6961      	ldr	r1, [r4, #20]
   98e8a:	1ad3      	subs	r3, r2, r3
   98e8c:	428b      	cmp	r3, r1
   98e8e:	da1c      	bge.n	98eca <__swbuf_r+0x6e>
   98e90:	3301      	adds	r3, #1
   98e92:	68a1      	ldr	r1, [r4, #8]
   98e94:	1c50      	adds	r0, r2, #1
   98e96:	3901      	subs	r1, #1
   98e98:	60a1      	str	r1, [r4, #8]
   98e9a:	6020      	str	r0, [r4, #0]
   98e9c:	7016      	strb	r6, [r2, #0]
   98e9e:	6962      	ldr	r2, [r4, #20]
   98ea0:	429a      	cmp	r2, r3
   98ea2:	d01a      	beq.n	98eda <__swbuf_r+0x7e>
   98ea4:	89a3      	ldrh	r3, [r4, #12]
   98ea6:	07db      	lsls	r3, r3, #31
   98ea8:	d501      	bpl.n	98eae <__swbuf_r+0x52>
   98eaa:	2d0a      	cmp	r5, #10
   98eac:	d015      	beq.n	98eda <__swbuf_r+0x7e>
   98eae:	4628      	mov	r0, r5
   98eb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   98eb2:	6e61      	ldr	r1, [r4, #100]	; 0x64
   98eb4:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   98eb8:	f421 5100 	bic.w	r1, r1, #8192	; 0x2000
   98ebc:	81a2      	strh	r2, [r4, #12]
   98ebe:	6822      	ldr	r2, [r4, #0]
   98ec0:	6661      	str	r1, [r4, #100]	; 0x64
   98ec2:	6961      	ldr	r1, [r4, #20]
   98ec4:	1ad3      	subs	r3, r2, r3
   98ec6:	428b      	cmp	r3, r1
   98ec8:	dbe2      	blt.n	98e90 <__swbuf_r+0x34>
   98eca:	4621      	mov	r1, r4
   98ecc:	4638      	mov	r0, r7
   98ece:	f7fe fee9 	bl	97ca4 <_fflush_r>
   98ed2:	b940      	cbnz	r0, 98ee6 <__swbuf_r+0x8a>
   98ed4:	6822      	ldr	r2, [r4, #0]
   98ed6:	2301      	movs	r3, #1
   98ed8:	e7db      	b.n	98e92 <__swbuf_r+0x36>
   98eda:	4621      	mov	r1, r4
   98edc:	4638      	mov	r0, r7
   98ede:	f7fe fee1 	bl	97ca4 <_fflush_r>
   98ee2:	2800      	cmp	r0, #0
   98ee4:	d0e3      	beq.n	98eae <__swbuf_r+0x52>
   98ee6:	f04f 30ff 	mov.w	r0, #4294967295
   98eea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   98eec:	4621      	mov	r1, r4
   98eee:	4638      	mov	r0, r7
   98ef0:	f7fd fda8 	bl	96a44 <__swsetup_r>
   98ef4:	2800      	cmp	r0, #0
   98ef6:	d1f6      	bne.n	98ee6 <__swbuf_r+0x8a>
   98ef8:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   98efc:	6923      	ldr	r3, [r4, #16]
   98efe:	b291      	uxth	r1, r2
   98f00:	e7be      	b.n	98e80 <__swbuf_r+0x24>
   98f02:	f7fe ff63 	bl	97dcc <__sinit>
   98f06:	e7b1      	b.n	98e6c <__swbuf_r+0x10>

00098f08 <_wcrtomb_r>:
   98f08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   98f0c:	4605      	mov	r5, r0
   98f0e:	b086      	sub	sp, #24
   98f10:	461e      	mov	r6, r3
   98f12:	460c      	mov	r4, r1
   98f14:	b1a1      	cbz	r1, 98f40 <_wcrtomb_r+0x38>
   98f16:	4b10      	ldr	r3, [pc, #64]	; (98f58 <_wcrtomb_r+0x50>)
   98f18:	4617      	mov	r7, r2
   98f1a:	f8d3 8000 	ldr.w	r8, [r3]
   98f1e:	f7ff fab1 	bl	98484 <__locale_charset>
   98f22:	9600      	str	r6, [sp, #0]
   98f24:	4603      	mov	r3, r0
   98f26:	463a      	mov	r2, r7
   98f28:	4621      	mov	r1, r4
   98f2a:	4628      	mov	r0, r5
   98f2c:	47c0      	blx	r8
   98f2e:	1c43      	adds	r3, r0, #1
   98f30:	d103      	bne.n	98f3a <_wcrtomb_r+0x32>
   98f32:	2200      	movs	r2, #0
   98f34:	238a      	movs	r3, #138	; 0x8a
   98f36:	6032      	str	r2, [r6, #0]
   98f38:	602b      	str	r3, [r5, #0]
   98f3a:	b006      	add	sp, #24
   98f3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   98f40:	4b05      	ldr	r3, [pc, #20]	; (98f58 <_wcrtomb_r+0x50>)
   98f42:	681f      	ldr	r7, [r3, #0]
   98f44:	f7ff fa9e 	bl	98484 <__locale_charset>
   98f48:	9600      	str	r6, [sp, #0]
   98f4a:	4603      	mov	r3, r0
   98f4c:	4622      	mov	r2, r4
   98f4e:	a903      	add	r1, sp, #12
   98f50:	4628      	mov	r0, r5
   98f52:	47b8      	blx	r7
   98f54:	e7eb      	b.n	98f2e <_wcrtomb_r+0x26>
   98f56:	bf00      	nop
   98f58:	200709b8 	.word	0x200709b8

00098f5c <__ascii_wctomb>:
   98f5c:	b121      	cbz	r1, 98f68 <__ascii_wctomb+0xc>
   98f5e:	2aff      	cmp	r2, #255	; 0xff
   98f60:	d804      	bhi.n	98f6c <__ascii_wctomb+0x10>
   98f62:	700a      	strb	r2, [r1, #0]
   98f64:	2001      	movs	r0, #1
   98f66:	4770      	bx	lr
   98f68:	4608      	mov	r0, r1
   98f6a:	4770      	bx	lr
   98f6c:	238a      	movs	r3, #138	; 0x8a
   98f6e:	6003      	str	r3, [r0, #0]
   98f70:	f04f 30ff 	mov.w	r0, #4294967295
   98f74:	4770      	bx	lr
   98f76:	bf00      	nop

00098f78 <_write_r>:
   98f78:	b570      	push	{r4, r5, r6, lr}
   98f7a:	460d      	mov	r5, r1
   98f7c:	4c08      	ldr	r4, [pc, #32]	; (98fa0 <_write_r+0x28>)
   98f7e:	4611      	mov	r1, r2
   98f80:	4606      	mov	r6, r0
   98f82:	461a      	mov	r2, r3
   98f84:	4628      	mov	r0, r5
   98f86:	2300      	movs	r3, #0
   98f88:	6023      	str	r3, [r4, #0]
   98f8a:	f7e7 fa3f 	bl	8040c <_write>
   98f8e:	1c43      	adds	r3, r0, #1
   98f90:	d000      	beq.n	98f94 <_write_r+0x1c>
   98f92:	bd70      	pop	{r4, r5, r6, pc}
   98f94:	6823      	ldr	r3, [r4, #0]
   98f96:	2b00      	cmp	r3, #0
   98f98:	d0fb      	beq.n	98f92 <_write_r+0x1a>
   98f9a:	6033      	str	r3, [r6, #0]
   98f9c:	bd70      	pop	{r4, r5, r6, pc}
   98f9e:	bf00      	nop
   98fa0:	20071d00 	.word	0x20071d00

00098fa4 <_calloc_r>:
   98fa4:	b510      	push	{r4, lr}
   98fa6:	fb02 f101 	mul.w	r1, r2, r1
   98faa:	f7fa fad3 	bl	93554 <_malloc_r>
   98fae:	4604      	mov	r4, r0
   98fb0:	b1d8      	cbz	r0, 98fea <_calloc_r+0x46>
   98fb2:	f850 2c04 	ldr.w	r2, [r0, #-4]
   98fb6:	f022 0203 	bic.w	r2, r2, #3
   98fba:	3a04      	subs	r2, #4
   98fbc:	2a24      	cmp	r2, #36	; 0x24
   98fbe:	d818      	bhi.n	98ff2 <_calloc_r+0x4e>
   98fc0:	2a13      	cmp	r2, #19
   98fc2:	d914      	bls.n	98fee <_calloc_r+0x4a>
   98fc4:	2300      	movs	r3, #0
   98fc6:	2a1b      	cmp	r2, #27
   98fc8:	6003      	str	r3, [r0, #0]
   98fca:	6043      	str	r3, [r0, #4]
   98fcc:	d916      	bls.n	98ffc <_calloc_r+0x58>
   98fce:	2a24      	cmp	r2, #36	; 0x24
   98fd0:	6083      	str	r3, [r0, #8]
   98fd2:	60c3      	str	r3, [r0, #12]
   98fd4:	bf11      	iteee	ne
   98fd6:	f100 0210 	addne.w	r2, r0, #16
   98fda:	6103      	streq	r3, [r0, #16]
   98fdc:	6143      	streq	r3, [r0, #20]
   98fde:	f100 0218 	addeq.w	r2, r0, #24
   98fe2:	2300      	movs	r3, #0
   98fe4:	6013      	str	r3, [r2, #0]
   98fe6:	6053      	str	r3, [r2, #4]
   98fe8:	6093      	str	r3, [r2, #8]
   98fea:	4620      	mov	r0, r4
   98fec:	bd10      	pop	{r4, pc}
   98fee:	4602      	mov	r2, r0
   98ff0:	e7f7      	b.n	98fe2 <_calloc_r+0x3e>
   98ff2:	2100      	movs	r1, #0
   98ff4:	f7fa fe66 	bl	93cc4 <memset>
   98ff8:	4620      	mov	r0, r4
   98ffa:	bd10      	pop	{r4, pc}
   98ffc:	f100 0208 	add.w	r2, r0, #8
   99000:	e7ef      	b.n	98fe2 <_calloc_r+0x3e>
   99002:	bf00      	nop

00099004 <_close_r>:
   99004:	b538      	push	{r3, r4, r5, lr}
   99006:	4c07      	ldr	r4, [pc, #28]	; (99024 <_close_r+0x20>)
   99008:	2300      	movs	r3, #0
   9900a:	4605      	mov	r5, r0
   9900c:	4608      	mov	r0, r1
   9900e:	6023      	str	r3, [r4, #0]
   99010:	f7e7 f9be 	bl	80390 <_close>
   99014:	1c43      	adds	r3, r0, #1
   99016:	d000      	beq.n	9901a <_close_r+0x16>
   99018:	bd38      	pop	{r3, r4, r5, pc}
   9901a:	6823      	ldr	r3, [r4, #0]
   9901c:	2b00      	cmp	r3, #0
   9901e:	d0fb      	beq.n	99018 <_close_r+0x14>
   99020:	602b      	str	r3, [r5, #0]
   99022:	bd38      	pop	{r3, r4, r5, pc}
   99024:	20071d00 	.word	0x20071d00

00099028 <_fclose_r>:
   99028:	2900      	cmp	r1, #0
   9902a:	d03d      	beq.n	990a8 <_fclose_r+0x80>
   9902c:	b570      	push	{r4, r5, r6, lr}
   9902e:	4605      	mov	r5, r0
   99030:	460c      	mov	r4, r1
   99032:	b108      	cbz	r0, 99038 <_fclose_r+0x10>
   99034:	6b83      	ldr	r3, [r0, #56]	; 0x38
   99036:	b37b      	cbz	r3, 99098 <_fclose_r+0x70>
   99038:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   9903c:	b90b      	cbnz	r3, 99042 <_fclose_r+0x1a>
   9903e:	2000      	movs	r0, #0
   99040:	bd70      	pop	{r4, r5, r6, pc}
   99042:	4621      	mov	r1, r4
   99044:	4628      	mov	r0, r5
   99046:	f7fe fd89 	bl	97b5c <__sflush_r>
   9904a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   9904c:	4606      	mov	r6, r0
   9904e:	b133      	cbz	r3, 9905e <_fclose_r+0x36>
   99050:	69e1      	ldr	r1, [r4, #28]
   99052:	4628      	mov	r0, r5
   99054:	4798      	blx	r3
   99056:	2800      	cmp	r0, #0
   99058:	bfb8      	it	lt
   9905a:	f04f 36ff 	movlt.w	r6, #4294967295
   9905e:	89a3      	ldrh	r3, [r4, #12]
   99060:	061b      	lsls	r3, r3, #24
   99062:	d41c      	bmi.n	9909e <_fclose_r+0x76>
   99064:	6b21      	ldr	r1, [r4, #48]	; 0x30
   99066:	b141      	cbz	r1, 9907a <_fclose_r+0x52>
   99068:	f104 0340 	add.w	r3, r4, #64	; 0x40
   9906c:	4299      	cmp	r1, r3
   9906e:	d002      	beq.n	99076 <_fclose_r+0x4e>
   99070:	4628      	mov	r0, r5
   99072:	f7fe ff73 	bl	97f5c <_free_r>
   99076:	2300      	movs	r3, #0
   99078:	6323      	str	r3, [r4, #48]	; 0x30
   9907a:	6c61      	ldr	r1, [r4, #68]	; 0x44
   9907c:	b121      	cbz	r1, 99088 <_fclose_r+0x60>
   9907e:	4628      	mov	r0, r5
   99080:	f7fe ff6c 	bl	97f5c <_free_r>
   99084:	2300      	movs	r3, #0
   99086:	6463      	str	r3, [r4, #68]	; 0x44
   99088:	f7fe fea6 	bl	97dd8 <__sfp_lock_acquire>
   9908c:	2300      	movs	r3, #0
   9908e:	81a3      	strh	r3, [r4, #12]
   99090:	f7fe fea4 	bl	97ddc <__sfp_lock_release>
   99094:	4630      	mov	r0, r6
   99096:	bd70      	pop	{r4, r5, r6, pc}
   99098:	f7fe fe98 	bl	97dcc <__sinit>
   9909c:	e7cc      	b.n	99038 <_fclose_r+0x10>
   9909e:	6921      	ldr	r1, [r4, #16]
   990a0:	4628      	mov	r0, r5
   990a2:	f7fe ff5b 	bl	97f5c <_free_r>
   990a6:	e7dd      	b.n	99064 <_fclose_r+0x3c>
   990a8:	2000      	movs	r0, #0
   990aa:	4770      	bx	lr

000990ac <_fstat_r>:
   990ac:	b538      	push	{r3, r4, r5, lr}
   990ae:	460b      	mov	r3, r1
   990b0:	4c07      	ldr	r4, [pc, #28]	; (990d0 <_fstat_r+0x24>)
   990b2:	4605      	mov	r5, r0
   990b4:	4611      	mov	r1, r2
   990b6:	4618      	mov	r0, r3
   990b8:	2300      	movs	r3, #0
   990ba:	6023      	str	r3, [r4, #0]
   990bc:	f7e7 f974 	bl	803a8 <_fstat>
   990c0:	1c43      	adds	r3, r0, #1
   990c2:	d000      	beq.n	990c6 <_fstat_r+0x1a>
   990c4:	bd38      	pop	{r3, r4, r5, pc}
   990c6:	6823      	ldr	r3, [r4, #0]
   990c8:	2b00      	cmp	r3, #0
   990ca:	d0fb      	beq.n	990c4 <_fstat_r+0x18>
   990cc:	602b      	str	r3, [r5, #0]
   990ce:	bd38      	pop	{r3, r4, r5, pc}
   990d0:	20071d00 	.word	0x20071d00

000990d4 <_isatty_r>:
   990d4:	b538      	push	{r3, r4, r5, lr}
   990d6:	4c07      	ldr	r4, [pc, #28]	; (990f4 <_isatty_r+0x20>)
   990d8:	2300      	movs	r3, #0
   990da:	4605      	mov	r5, r0
   990dc:	4608      	mov	r0, r1
   990de:	6023      	str	r3, [r4, #0]
   990e0:	f7e7 f972 	bl	803c8 <_isatty>
   990e4:	1c43      	adds	r3, r0, #1
   990e6:	d000      	beq.n	990ea <_isatty_r+0x16>
   990e8:	bd38      	pop	{r3, r4, r5, pc}
   990ea:	6823      	ldr	r3, [r4, #0]
   990ec:	2b00      	cmp	r3, #0
   990ee:	d0fb      	beq.n	990e8 <_isatty_r+0x14>
   990f0:	602b      	str	r3, [r5, #0]
   990f2:	bd38      	pop	{r3, r4, r5, pc}
   990f4:	20071d00 	.word	0x20071d00

000990f8 <_lseek_r>:
   990f8:	b570      	push	{r4, r5, r6, lr}
   990fa:	460d      	mov	r5, r1
   990fc:	4c08      	ldr	r4, [pc, #32]	; (99120 <_lseek_r+0x28>)
   990fe:	4611      	mov	r1, r2
   99100:	4606      	mov	r6, r0
   99102:	461a      	mov	r2, r3
   99104:	4628      	mov	r0, r5
   99106:	2300      	movs	r3, #0
   99108:	6023      	str	r3, [r4, #0]
   9910a:	f7e7 f967 	bl	803dc <_lseek>
   9910e:	1c43      	adds	r3, r0, #1
   99110:	d000      	beq.n	99114 <_lseek_r+0x1c>
   99112:	bd70      	pop	{r4, r5, r6, pc}
   99114:	6823      	ldr	r3, [r4, #0]
   99116:	2b00      	cmp	r3, #0
   99118:	d0fb      	beq.n	99112 <_lseek_r+0x1a>
   9911a:	6033      	str	r3, [r6, #0]
   9911c:	bd70      	pop	{r4, r5, r6, pc}
   9911e:	bf00      	nop
   99120:	20071d00 	.word	0x20071d00

00099124 <_read_r>:
   99124:	b570      	push	{r4, r5, r6, lr}
   99126:	460d      	mov	r5, r1
   99128:	4c08      	ldr	r4, [pc, #32]	; (9914c <_read_r+0x28>)
   9912a:	4611      	mov	r1, r2
   9912c:	4606      	mov	r6, r0
   9912e:	461a      	mov	r2, r3
   99130:	4628      	mov	r0, r5
   99132:	2300      	movs	r3, #0
   99134:	6023      	str	r3, [r4, #0]
   99136:	f7e7 f95d 	bl	803f4 <_read>
   9913a:	1c43      	adds	r3, r0, #1
   9913c:	d000      	beq.n	99140 <_read_r+0x1c>
   9913e:	bd70      	pop	{r4, r5, r6, pc}
   99140:	6823      	ldr	r3, [r4, #0]
   99142:	2b00      	cmp	r3, #0
   99144:	d0fb      	beq.n	9913e <_read_r+0x1a>
   99146:	6033      	str	r3, [r6, #0]
   99148:	bd70      	pop	{r4, r5, r6, pc}
   9914a:	bf00      	nop
   9914c:	20071d00 	.word	0x20071d00

00099150 <__aeabi_uldivmod>:
   99150:	b953      	cbnz	r3, 99168 <__aeabi_uldivmod+0x18>
   99152:	b94a      	cbnz	r2, 99168 <__aeabi_uldivmod+0x18>
   99154:	2900      	cmp	r1, #0
   99156:	bf08      	it	eq
   99158:	2800      	cmpeq	r0, #0
   9915a:	bf1c      	itt	ne
   9915c:	f04f 31ff 	movne.w	r1, #4294967295
   99160:	f04f 30ff 	movne.w	r0, #4294967295
   99164:	f000 b982 	b.w	9946c <__aeabi_idiv0>
   99168:	f1ad 0c08 	sub.w	ip, sp, #8
   9916c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   99170:	f000 f806 	bl	99180 <__udivmoddi4>
   99174:	f8dd e004 	ldr.w	lr, [sp, #4]
   99178:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   9917c:	b004      	add	sp, #16
   9917e:	4770      	bx	lr

00099180 <__udivmoddi4>:
   99180:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   99184:	468c      	mov	ip, r1
   99186:	460c      	mov	r4, r1
   99188:	4605      	mov	r5, r0
   9918a:	9e09      	ldr	r6, [sp, #36]	; 0x24
   9918c:	2b00      	cmp	r3, #0
   9918e:	d14f      	bne.n	99230 <__udivmoddi4+0xb0>
   99190:	428a      	cmp	r2, r1
   99192:	4617      	mov	r7, r2
   99194:	d96b      	bls.n	9926e <__udivmoddi4+0xee>
   99196:	fab2 fe82 	clz	lr, r2
   9919a:	f1be 0f00 	cmp.w	lr, #0
   9919e:	d00b      	beq.n	991b8 <__udivmoddi4+0x38>
   991a0:	f1ce 0520 	rsb	r5, lr, #32
   991a4:	fa20 f505 	lsr.w	r5, r0, r5
   991a8:	fa01 f30e 	lsl.w	r3, r1, lr
   991ac:	ea45 0c03 	orr.w	ip, r5, r3
   991b0:	fa02 f70e 	lsl.w	r7, r2, lr
   991b4:	fa00 f50e 	lsl.w	r5, r0, lr
   991b8:	0c39      	lsrs	r1, r7, #16
   991ba:	fbbc f0f1 	udiv	r0, ip, r1
   991be:	b2ba      	uxth	r2, r7
   991c0:	fb01 c310 	mls	r3, r1, r0, ip
   991c4:	fb00 f802 	mul.w	r8, r0, r2
   991c8:	ea4f 4c15 	mov.w	ip, r5, lsr #16
   991cc:	ea4c 4403 	orr.w	r4, ip, r3, lsl #16
   991d0:	45a0      	cmp	r8, r4
   991d2:	d909      	bls.n	991e8 <__udivmoddi4+0x68>
   991d4:	19e4      	adds	r4, r4, r7
   991d6:	f100 33ff 	add.w	r3, r0, #4294967295
   991da:	f080 8128 	bcs.w	9942e <__udivmoddi4+0x2ae>
   991de:	45a0      	cmp	r8, r4
   991e0:	f240 8125 	bls.w	9942e <__udivmoddi4+0x2ae>
   991e4:	3802      	subs	r0, #2
   991e6:	443c      	add	r4, r7
   991e8:	ebc8 0404 	rsb	r4, r8, r4
   991ec:	fbb4 f3f1 	udiv	r3, r4, r1
   991f0:	fb01 4c13 	mls	ip, r1, r3, r4
   991f4:	fb03 f202 	mul.w	r2, r3, r2
   991f8:	b2ac      	uxth	r4, r5
   991fa:	ea44 410c 	orr.w	r1, r4, ip, lsl #16
   991fe:	428a      	cmp	r2, r1
   99200:	d909      	bls.n	99216 <__udivmoddi4+0x96>
   99202:	19c9      	adds	r1, r1, r7
   99204:	f103 34ff 	add.w	r4, r3, #4294967295
   99208:	f080 810f 	bcs.w	9942a <__udivmoddi4+0x2aa>
   9920c:	428a      	cmp	r2, r1
   9920e:	f240 810c 	bls.w	9942a <__udivmoddi4+0x2aa>
   99212:	3b02      	subs	r3, #2
   99214:	4439      	add	r1, r7
   99216:	1a8a      	subs	r2, r1, r2
   99218:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   9921c:	2100      	movs	r1, #0
   9921e:	2e00      	cmp	r6, #0
   99220:	d063      	beq.n	992ea <__udivmoddi4+0x16a>
   99222:	fa22 f20e 	lsr.w	r2, r2, lr
   99226:	2300      	movs	r3, #0
   99228:	e886 000c 	stmia.w	r6, {r2, r3}
   9922c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   99230:	428b      	cmp	r3, r1
   99232:	d907      	bls.n	99244 <__udivmoddi4+0xc4>
   99234:	2e00      	cmp	r6, #0
   99236:	d056      	beq.n	992e6 <__udivmoddi4+0x166>
   99238:	2100      	movs	r1, #0
   9923a:	e886 0011 	stmia.w	r6, {r0, r4}
   9923e:	4608      	mov	r0, r1
   99240:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   99244:	fab3 f183 	clz	r1, r3
   99248:	2900      	cmp	r1, #0
   9924a:	f040 8093 	bne.w	99374 <__udivmoddi4+0x1f4>
   9924e:	42a3      	cmp	r3, r4
   99250:	d302      	bcc.n	99258 <__udivmoddi4+0xd8>
   99252:	4282      	cmp	r2, r0
   99254:	f200 80fe 	bhi.w	99454 <__udivmoddi4+0x2d4>
   99258:	1a85      	subs	r5, r0, r2
   9925a:	eb64 0303 	sbc.w	r3, r4, r3
   9925e:	469c      	mov	ip, r3
   99260:	2001      	movs	r0, #1
   99262:	2e00      	cmp	r6, #0
   99264:	d041      	beq.n	992ea <__udivmoddi4+0x16a>
   99266:	e886 1020 	stmia.w	r6, {r5, ip}
   9926a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   9926e:	b912      	cbnz	r2, 99276 <__udivmoddi4+0xf6>
   99270:	2701      	movs	r7, #1
   99272:	fbb7 f7f2 	udiv	r7, r7, r2
   99276:	fab7 fe87 	clz	lr, r7
   9927a:	f1be 0f00 	cmp.w	lr, #0
   9927e:	d136      	bne.n	992ee <__udivmoddi4+0x16e>
   99280:	1be4      	subs	r4, r4, r7
   99282:	ea4f 4817 	mov.w	r8, r7, lsr #16
   99286:	fa1f f987 	uxth.w	r9, r7
   9928a:	2101      	movs	r1, #1
   9928c:	fbb4 f3f8 	udiv	r3, r4, r8
   99290:	fb08 4413 	mls	r4, r8, r3, r4
   99294:	fb09 f203 	mul.w	r2, r9, r3
   99298:	ea4f 4c15 	mov.w	ip, r5, lsr #16
   9929c:	ea4c 4404 	orr.w	r4, ip, r4, lsl #16
   992a0:	42a2      	cmp	r2, r4
   992a2:	d907      	bls.n	992b4 <__udivmoddi4+0x134>
   992a4:	19e4      	adds	r4, r4, r7
   992a6:	f103 30ff 	add.w	r0, r3, #4294967295
   992aa:	d202      	bcs.n	992b2 <__udivmoddi4+0x132>
   992ac:	42a2      	cmp	r2, r4
   992ae:	f200 80d3 	bhi.w	99458 <__udivmoddi4+0x2d8>
   992b2:	4603      	mov	r3, r0
   992b4:	1aa4      	subs	r4, r4, r2
   992b6:	fbb4 f0f8 	udiv	r0, r4, r8
   992ba:	fb08 4810 	mls	r8, r8, r0, r4
   992be:	fb09 f900 	mul.w	r9, r9, r0
   992c2:	b2ac      	uxth	r4, r5
   992c4:	ea44 4208 	orr.w	r2, r4, r8, lsl #16
   992c8:	4591      	cmp	r9, r2
   992ca:	d907      	bls.n	992dc <__udivmoddi4+0x15c>
   992cc:	19d2      	adds	r2, r2, r7
   992ce:	f100 34ff 	add.w	r4, r0, #4294967295
   992d2:	d202      	bcs.n	992da <__udivmoddi4+0x15a>
   992d4:	4591      	cmp	r9, r2
   992d6:	f200 80ba 	bhi.w	9944e <__udivmoddi4+0x2ce>
   992da:	4620      	mov	r0, r4
   992dc:	ebc9 0202 	rsb	r2, r9, r2
   992e0:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
   992e4:	e79b      	b.n	9921e <__udivmoddi4+0x9e>
   992e6:	4631      	mov	r1, r6
   992e8:	4630      	mov	r0, r6
   992ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   992ee:	fa07 f70e 	lsl.w	r7, r7, lr
   992f2:	f1ce 0c20 	rsb	ip, lr, #32
   992f6:	fa24 f30c 	lsr.w	r3, r4, ip
   992fa:	ea4f 4817 	mov.w	r8, r7, lsr #16
   992fe:	fbb3 faf8 	udiv	sl, r3, r8
   99302:	fa1f f987 	uxth.w	r9, r7
   99306:	fb08 351a 	mls	r5, r8, sl, r3
   9930a:	fa20 fc0c 	lsr.w	ip, r0, ip
   9930e:	fa04 f40e 	lsl.w	r4, r4, lr
   99312:	fb0a fb09 	mul.w	fp, sl, r9
   99316:	ea4c 0c04 	orr.w	ip, ip, r4
   9931a:	ea4f 421c 	mov.w	r2, ip, lsr #16
   9931e:	ea42 4305 	orr.w	r3, r2, r5, lsl #16
   99322:	459b      	cmp	fp, r3
   99324:	fa00 f50e 	lsl.w	r5, r0, lr
   99328:	d90a      	bls.n	99340 <__udivmoddi4+0x1c0>
   9932a:	19db      	adds	r3, r3, r7
   9932c:	f10a 32ff 	add.w	r2, sl, #4294967295
   99330:	f080 808b 	bcs.w	9944a <__udivmoddi4+0x2ca>
   99334:	459b      	cmp	fp, r3
   99336:	f240 8088 	bls.w	9944a <__udivmoddi4+0x2ca>
   9933a:	f1aa 0a02 	sub.w	sl, sl, #2
   9933e:	443b      	add	r3, r7
   99340:	ebcb 0303 	rsb	r3, fp, r3
   99344:	fbb3 f0f8 	udiv	r0, r3, r8
   99348:	fb08 3310 	mls	r3, r8, r0, r3
   9934c:	fb00 f409 	mul.w	r4, r0, r9
   99350:	fa1f fc8c 	uxth.w	ip, ip
   99354:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
   99358:	429c      	cmp	r4, r3
   9935a:	d907      	bls.n	9936c <__udivmoddi4+0x1ec>
   9935c:	19db      	adds	r3, r3, r7
   9935e:	f100 32ff 	add.w	r2, r0, #4294967295
   99362:	d26e      	bcs.n	99442 <__udivmoddi4+0x2c2>
   99364:	429c      	cmp	r4, r3
   99366:	d96c      	bls.n	99442 <__udivmoddi4+0x2c2>
   99368:	3802      	subs	r0, #2
   9936a:	443b      	add	r3, r7
   9936c:	1b1c      	subs	r4, r3, r4
   9936e:	ea40 410a 	orr.w	r1, r0, sl, lsl #16
   99372:	e78b      	b.n	9928c <__udivmoddi4+0x10c>
   99374:	f1c1 0e20 	rsb	lr, r1, #32
   99378:	408b      	lsls	r3, r1
   9937a:	fa22 fc0e 	lsr.w	ip, r2, lr
   9937e:	ea4c 0c03 	orr.w	ip, ip, r3
   99382:	fa24 f70e 	lsr.w	r7, r4, lr
   99386:	ea4f 491c 	mov.w	r9, ip, lsr #16
   9938a:	fbb7 faf9 	udiv	sl, r7, r9
   9938e:	fa1f f38c 	uxth.w	r3, ip
   99392:	fb09 771a 	mls	r7, r9, sl, r7
   99396:	fa20 f80e 	lsr.w	r8, r0, lr
   9939a:	408c      	lsls	r4, r1
   9939c:	fb0a f503 	mul.w	r5, sl, r3
   993a0:	ea48 0404 	orr.w	r4, r8, r4
   993a4:	ea4f 4814 	mov.w	r8, r4, lsr #16
   993a8:	ea48 4707 	orr.w	r7, r8, r7, lsl #16
   993ac:	42bd      	cmp	r5, r7
   993ae:	fa02 f201 	lsl.w	r2, r2, r1
   993b2:	fa00 fb01 	lsl.w	fp, r0, r1
   993b6:	d909      	bls.n	993cc <__udivmoddi4+0x24c>
   993b8:	eb17 070c 	adds.w	r7, r7, ip
   993bc:	f10a 30ff 	add.w	r0, sl, #4294967295
   993c0:	d241      	bcs.n	99446 <__udivmoddi4+0x2c6>
   993c2:	42bd      	cmp	r5, r7
   993c4:	d93f      	bls.n	99446 <__udivmoddi4+0x2c6>
   993c6:	f1aa 0a02 	sub.w	sl, sl, #2
   993ca:	4467      	add	r7, ip
   993cc:	1b7f      	subs	r7, r7, r5
   993ce:	fbb7 f5f9 	udiv	r5, r7, r9
   993d2:	fb09 7715 	mls	r7, r9, r5, r7
   993d6:	fb05 f303 	mul.w	r3, r5, r3
   993da:	b2a4      	uxth	r4, r4
   993dc:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
   993e0:	42bb      	cmp	r3, r7
   993e2:	d908      	bls.n	993f6 <__udivmoddi4+0x276>
   993e4:	eb17 070c 	adds.w	r7, r7, ip
   993e8:	f105 30ff 	add.w	r0, r5, #4294967295
   993ec:	d227      	bcs.n	9943e <__udivmoddi4+0x2be>
   993ee:	42bb      	cmp	r3, r7
   993f0:	d925      	bls.n	9943e <__udivmoddi4+0x2be>
   993f2:	3d02      	subs	r5, #2
   993f4:	4467      	add	r7, ip
   993f6:	ea45 400a 	orr.w	r0, r5, sl, lsl #16
   993fa:	fba0 8902 	umull	r8, r9, r0, r2
   993fe:	1aff      	subs	r7, r7, r3
   99400:	454f      	cmp	r7, r9
   99402:	4645      	mov	r5, r8
   99404:	464c      	mov	r4, r9
   99406:	d314      	bcc.n	99432 <__udivmoddi4+0x2b2>
   99408:	d029      	beq.n	9945e <__udivmoddi4+0x2de>
   9940a:	b366      	cbz	r6, 99466 <__udivmoddi4+0x2e6>
   9940c:	ebbb 0305 	subs.w	r3, fp, r5
   99410:	eb67 0704 	sbc.w	r7, r7, r4
   99414:	fa07 fe0e 	lsl.w	lr, r7, lr
   99418:	40cb      	lsrs	r3, r1
   9941a:	40cf      	lsrs	r7, r1
   9941c:	ea4e 0303 	orr.w	r3, lr, r3
   99420:	e886 0088 	stmia.w	r6, {r3, r7}
   99424:	2100      	movs	r1, #0
   99426:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   9942a:	4623      	mov	r3, r4
   9942c:	e6f3      	b.n	99216 <__udivmoddi4+0x96>
   9942e:	4618      	mov	r0, r3
   99430:	e6da      	b.n	991e8 <__udivmoddi4+0x68>
   99432:	ebb8 0502 	subs.w	r5, r8, r2
   99436:	eb69 040c 	sbc.w	r4, r9, ip
   9943a:	3801      	subs	r0, #1
   9943c:	e7e5      	b.n	9940a <__udivmoddi4+0x28a>
   9943e:	4605      	mov	r5, r0
   99440:	e7d9      	b.n	993f6 <__udivmoddi4+0x276>
   99442:	4610      	mov	r0, r2
   99444:	e792      	b.n	9936c <__udivmoddi4+0x1ec>
   99446:	4682      	mov	sl, r0
   99448:	e7c0      	b.n	993cc <__udivmoddi4+0x24c>
   9944a:	4692      	mov	sl, r2
   9944c:	e778      	b.n	99340 <__udivmoddi4+0x1c0>
   9944e:	3802      	subs	r0, #2
   99450:	443a      	add	r2, r7
   99452:	e743      	b.n	992dc <__udivmoddi4+0x15c>
   99454:	4608      	mov	r0, r1
   99456:	e704      	b.n	99262 <__udivmoddi4+0xe2>
   99458:	3b02      	subs	r3, #2
   9945a:	443c      	add	r4, r7
   9945c:	e72a      	b.n	992b4 <__udivmoddi4+0x134>
   9945e:	45c3      	cmp	fp, r8
   99460:	d3e7      	bcc.n	99432 <__udivmoddi4+0x2b2>
   99462:	463c      	mov	r4, r7
   99464:	e7d1      	b.n	9940a <__udivmoddi4+0x28a>
   99466:	4631      	mov	r1, r6
   99468:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0009946c <__aeabi_idiv0>:
   9946c:	4770      	bx	lr
   9946e:	bf00      	nop
   99470:	74697845 	.word	0x74697845
   99474:	20676e69 	.word	0x20676e69
   99478:	68746977 	.word	0x68746977
   9947c:	61747320 	.word	0x61747320
   99480:	20737574 	.word	0x20737574
   99484:	0a2e6425 	.word	0x0a2e6425
   99488:	00000000 	.word	0x00000000

0009948c <_ZTV9UARTClass>:
	...
   99494:	0008083d 0008793d 0008071d 00080791     =...=y..........
   994a4:	00080749 000807f1 000805dd 000806d1     I...............
   994b4:	00080551                                Q...

000994b8 <_ZTV14HardwareSerial>:
	...
   994c0:	00087829 0008793d 00087829 00087829     )x..=y..)x..)x..
   994d0:	00087829 00087829 00087829 00087829     )x..)x..)x..)x..
   994e0:	00087829                                )x..

000994e4 <_ZTV6Stream>:
	...
   994ec:	00087829 0008793d 00087829 00087829     )x..=y..)x..)x..
   994fc:	00087829 00087829                       )x..)x..

00099504 <STRING_LANGUAGE>:
   99504:	04090304                                ....

00099508 <STRING_PRODUCT>:
   99508:	75647241 206f6e69 00657544              Arduino Due.

00099514 <STRING_MANUFACTURER>:
   99514:	75647241 206f6e69 00434c4c              Arduino LLC.

00099520 <USB_DeviceDescriptor>:
   99520:	02000112 40000000 003e2341 02010100     .......@A#>.....
   99530:	00000103                                ....

00099534 <USB_DeviceDescriptorA>:
   99534:	02000112 400102ef 003e2341 02010100     .......@A#>.....
   99544:	00000103                                ....

00099548 <_ZL19USB_DeviceQualifier>:
   99548:	0200060a 40000000 00000001              .......@....

00099554 <_ZL18test_packet_buffer>:
	...
   9955c:	aaaaaa00 aaaaaaaa eeeeeeaa eeeeeeee     ................
   9956c:	fffffeee ffffffff ffffffff dfbf7fff     ................
   9957c:	fdfbf7ef dfbf7efc fdfbf7ef 0000007e     .....~......~...

0009958c <g_APinDescription>:
   9958c:	400e0e00 00000100 0000000b 00000001     ...@............
   9959c:	00000000 00000004 ffffffff 400e0e00     ...............@
   995ac:	00000200 0000000b 00000001 00000000     ................
   995bc:	00000004 ffffffff 400e1000 02000000     ...........@....
   995cc:	0000000c 00000002 00000000 00000014     ................
   995dc:	00ffffff 400e1200 10000000 0000000d     .......@........
   995ec:	00000002 00000000 00000014 0effffff     ................
   995fc:	400e1200 04000000 0000000d 00000002     ...@............
   9960c:	00000000 00000014 0dffffff 400e1200     ...............@
   9961c:	02000000 0000000d 00000002 00000000     ................
   9962c:	00000014 0cffffff 400e1200 01000000     ...........@....
   9963c:	0000000d 00000002 00000000 0000000c     ................
   9964c:	ff07ffff 400e1200 00800000 0000000d     .......@........
   9965c:	00000002 00000000 0000000c ff06ffff     ................
   9966c:	400e1200 00400000 0000000d 00000002     ...@..@.........
   9967c:	00000000 0000000c ff05ffff 400e1200     ...............@
   9968c:	00200000 0000000d 00000002 00000000     .. .............
   9969c:	0000000c ff04ffff 400e1200 20000000     ...........@... 
   996ac:	0000000d 00000002 00000000 00000014     ................
   996bc:	0fffffff 400e1400 00000080 0000000e     .......@........
   996cc:	00000002 00000000 00000014 10ffffff     ................
   996dc:	400e1400 00000100 0000000e 00000002     ...@............
   996ec:	00000000 00000014 11ffffff 400e1000     ...............@
   996fc:	08000000 0000000c 00000002 00000000     ................
   9970c:	00000014 01ffffff 400e1400 00000010     ...........@....
   9971c:	0000000e 00000002 00000000 00000004     ................
   9972c:	ffffffff 400e1400 00000020 0000000e     .......@ .......
   9973c:	00000002 00000000 00000004 ffffffff     ................
   9974c:	400e0e00 00002000 0000000b 00000001     ...@. ..........
   9975c:	00000000 00000004 ffffffff 400e0e00     ...............@
   9976c:	00001000 0000000b 00000001 00000000     ................
   9977c:	00000004 ffffffff 400e0e00 00000800     ...........@....
   9978c:	0000000b 00000001 00000000 00000004     ................
   9979c:	ffffffff 400e0e00 00000400 0000000b     .......@........
   997ac:	00000001 00000000 00000004 ffffffff     ................
   997bc:	400e1000 00001000 0000000c 00000001     ...@............
   997cc:	00000000 00000004 ffffffff 400e1000     ...............@
   997dc:	00002000 0000000c 00000001 00000000     . ..............
   997ec:	00000004 ffffffff 400e1000 04000000     ...........@....
   997fc:	0000000c 00000004 00000000 00000004     ................
   9980c:	ffffffff 400e0e00 00004000 0000000b     .......@.@......
   9981c:	00000004 00000000 00000004 ffffffff     ................
   9982c:	400e0e00 00008000 0000000b 00000004     ...@............
   9983c:	00000000 00000004 ffffffff 400e1400     ...............@
   9984c:	00000001 0000000e 00000004 00000000     ................
   9985c:	00000004 ffffffff 400e1400 00000002     ...........@....
   9986c:	0000000e 00000004 00000000 00000004     ................
   9987c:	ffffffff 400e1400 00000004 0000000e     .......@........
   9988c:	00000004 00000000 00000004 ffffffff     ................
   9989c:	400e1400 00000008 0000000e 00000004     ...@............
   998ac:	00000000 00000004 ffffffff 400e1400     ...............@
   998bc:	00000040 0000000e 00000004 00000000     @...............
   998cc:	00000004 ffffffff 400e1400 00000200     ...........@....
   998dc:	0000000e 00000004 00000000 00000004     ................
   998ec:	ffffffff 400e0e00 00000080 0000000b     .......@........
   998fc:	00000004 00000000 00000004 ffffffff     ................
   9990c:	400e1400 00000400 0000000e 00000004     ...@............
   9991c:	00000000 00000004 ffffffff 400e1200     ...............@
   9992c:	00000002 0000000d 00000004 00000000     ................
   9993c:	00000004 ffffffff 400e1200 00000004     ...........@....
   9994c:	0000000d 00000004 00000000 00000004     ................
   9995c:	ffffffff 400e1200 00000008 0000000d     .......@........
   9996c:	00000004 00000000 00000004 ffffffff     ................
   9997c:	400e1200 00000010 0000000d 00000004     ...@............
   9998c:	00000000 00000004 ffffffff 400e1200     ...............@
   9999c:	00000020 0000000d 00000004 00000000      ...............
   999ac:	00000004 ffffffff 400e1200 00000040     ...........@@...
   999bc:	0000000d 00000004 00000000 00000004     ................
   999cc:	ffffffff 400e1200 00000080 0000000d     .......@........
   999dc:	00000004 00000000 00000004 ffffffff     ................
   999ec:	400e1200 00000100 0000000d 00000004     ...@............
   999fc:	00000000 00000004 ffffffff 400e1200     ...............@
   99a0c:	00000200 0000000d 00000004 00000000     ................
   99a1c:	00000004 ffffffff 400e0e00 00080000     ...........@....
   99a2c:	0000000b 00000004 00000000 00000004     ................
   99a3c:	ffffffff 400e0e00 00100000 0000000b     .......@........
   99a4c:	00000004 00000000 00000004 ffffffff     ................
   99a5c:	400e1200 00080000 0000000d 00000004     ...@............
   99a6c:	00000000 00000004 ffffffff 400e1200     ...............@
   99a7c:	00040000 0000000d 00000004 00000000     ................
   99a8c:	00000004 ffffffff 400e1200 00020000     ...........@....
   99a9c:	0000000d 00000004 00000000 00000004     ................
   99aac:	ffffffff 400e1200 00010000 0000000d     .......@........
   99abc:	00000004 00000000 00000004 ffffffff     ................
   99acc:	400e1200 00008000 0000000d 00000004     ...@............
   99adc:	00000000 00000004 ffffffff 400e1200     ...............@
   99aec:	00004000 0000000d 00000004 00000000     .@..............
   99afc:	00000004 ffffffff 400e1200 00002000     ...........@. ..
   99b0c:	0000000d 00000004 00000000 00000004     ................
   99b1c:	ffffffff 400e1200 00001000 0000000d     .......@........
   99b2c:	00000004 00000000 00000004 ffffffff     ................
   99b3c:	400e1000 00200000 0000000c 00000004     ...@.. .........
   99b4c:	00000000 00000004 ffffffff 400e1000     ...............@
   99b5c:	00004000 0000000c 00000004 00000000     .@..............
   99b6c:	00000004 ffffffff 400e0e00 00010000     ...........@....
   99b7c:	0000000b 00000003 00000000 00000002     ................
   99b8c:	ffff0700 400e0e00 01000000 0000000b     .......@........
   99b9c:	00000003 00000000 00000002 ffff0601     ................
   99bac:	400e0e00 00800000 0000000b 00000003     ...@............
   99bbc:	00000000 00000002 ffff0502 400e0e00     ...............@
   99bcc:	00400000 0000000b 00000003 00000000     ..@.............
   99bdc:	00000002 ffff0403 400e0e00 00000040     ...........@@...
   99bec:	0000000b 00000003 00000000 00000002     ................
   99bfc:	05ff0304 400e0e00 00000010 0000000b     .......@........
   99c0c:	00000003 00000000 00000002 ffff0205     ................
   99c1c:	400e0e00 00000008 0000000b 00000003     ...@............
   99c2c:	00000000 00000002 03ff0106 400e0e00     ...............@
   99c3c:	00000004 0000000b 00000003 00000000     ................
   99c4c:	00000002 02ff0007 400e1000 00020000     ...........@....
   99c5c:	0000000c 00000003 00000000 00000002     ................
   99c6c:	ffff0a08 400e1000 00040000 0000000c     .......@........
   99c7c:	00000003 00000000 00000002 ffff0b09     ................
   99c8c:	400e1000 00080000 0000000c 00000003     ...@............
   99c9c:	00000000 00000002 ffff0c0a 400e1000     ...............@
   99cac:	00100000 0000000c 00000003 00000000     ................
   99cbc:	00000002 ffff0d0b 400e1000 00008000     ...........@....
   99ccc:	0000000c 00000003 00000000 00000002     ................
   99cdc:	ffff100c 400e1000 00010000 0000000c     .......@........
   99cec:	00000003 00000000 00000002 ffff110d     ................
   99cfc:	400e0e00 00000002 0000000b 00000001     ...@............
   99d0c:	00000000 00000004 ffffff0e 400e0e00     ...............@
   99d1c:	00000001 0000000b 00000001 00000000     ................
   99d2c:	00000004 ffffff0f 400e0e00 00020000     ...........@....
   99d3c:	0000000b 00000001 00000000 00000004     ................
   99d4c:	ffffffff 400e0e00 00040000 0000000b     .......@........
   99d5c:	00000001 00000000 00000004 ffffffff     ................
   99d6c:	400e1200 40000000 0000000d 00000004     ...@...@........
   99d7c:	00000000 00000004 ffffffff 400e0e00     ...............@
   99d8c:	00200000 0000000b 00000004 00000000     .. .............
   99d9c:	00000004 ffffffff 400e0e00 02000000     ...........@....
   99dac:	0000000b 00000001 00000000 00000004     ................
   99dbc:	ffffffff 400e0e00 04000000 0000000b     .......@........
   99dcc:	00000001 00000000 00000004 ffffffff     ................
   99ddc:	400e0e00 08000000 0000000b 00000001     ...@............
   99dec:	00000000 00000004 ffffffff 400e0e00     ...............@
   99dfc:	10000000 0000000b 00000001 00000000     ................
   99e0c:	00000004 ffffffff 400e1000 00800000     ...........@....
   99e1c:	0000000c 00000002 00000000 00000004     ................
   99e2c:	ffffffff 400e0e00 00060000 0000000b     .......@........
   99e3c:	00000001 00000000 00000005 ffffffff     ................
   99e4c:	400e1000 00003000 0000000c 00000001     ...@.0..........
   99e5c:	00000000 00000005 ffffffff 400e0e00     ...............@
   99e6c:	00000300 0000000b 00000001 00000000     ................
   99e7c:	00000005 ffffffff 400e0e00 00000c00     ...........@....
   99e8c:	0000000b 00000001 00000000 00000005     ................
   99e9c:	ffffffff 400e0e00 00003000 0000000b     .......@.0......
   99eac:	00000001 00000000 00000005 ffffffff     ................
   99ebc:	400e1400 00000030 0000000e 00000002     ...@0...........
   99ecc:	00000000 00000005 ffffffff 400e1000     ...............@
   99edc:	00000c00 0000000c 00000001 00000000     ................
   99eec:	00000004 ffffffff 400e1000 00200000     ...........@.. .
   99efc:	0000000c 00000002 00000000 00000004     ................
   99f0c:	ffffffff 400e0e00 20000000 0000000b     .......@... ....
   99f1c:	00000001 00000000 00000004 ffffffff     ................
   99f2c:	400e1000 00008000 0000000c 00000001     ...@............
   99f3c:	00000000 00000004 ffffffff 400e1000     ...............@
   99f4c:	00004000 0000000c 00000001 00000000     .@..............
   99f5c:	00000004 ffffffff 400e0e00 00000003     ...........@....
   99f6c:	0000000b 00000001 00000000 00000005     ................
   99f7c:	ffffffff 400e1000 0000c000 0000000c     .......@........
   99f8c:	00000001 00000000 00000005 ffffffff     ................
	...
   99fb4:	ffffffff                                ....

00099fb8 <_ZN8DueTimer6TimersE>:
   99fb8:	40080000 00000000 0000001b 40080000     ...@...........@
   99fc8:	00000001 0000001c 40080000 00000002     ...........@....
   99fd8:	0000001d 40084000 00000000 0000001e     .....@.@........
   99fe8:	40084000 00000001 0000001f 40084000     .@.@.........@.@
   99ff8:	00000002 00000020 40088000 00000000     .... ......@....
   9a008:	00000021 40088000 00000001 00000022     !......@...."...
   9a018:	40088000 00000002 00000023 08010200     ...@....#.......
   9a028:	80032002 412a2020 52455353 3a202a54     . ..  *ASSERT* :
   9a038:	00000020 616c6544 68732079 206c6c61      ...Delay shall 
   9a048:	6e206562 6e206e6f 2e6c6c75 00000000     be non null.....
   9a058:	656e6547 20636972 61726170 6320736d     Generic params c
   9a068:	20747361 6c696166 002e6465 6472415b     ast failed..[Ard
   9a078:	205d734f 00000000 20736920 6e6e7572     Os] .... is runn
   9a088:	2e676e69 00000000 20736920 696e6966     ing..... is fini
   9a098:	64656873 0000002e 4f647241 73692073     shed....ArdOs is
   9a0a8:	746f6e20 206e6920 20656874 68676972      not in the righ
   9a0b8:	74732074 20657461 64206f74 6e61206f     t state to do an
   9a0c8:	696e6920 00000074 6f626f52 73692074      init...Robot is
   9a0d8:	6f6f6220 20646574 63637573 66737365      booted successf
   9a0e8:	796c6c75 7469202c 6f6f7420 0000206b     ully, it took ..
   9a0f8:	2e736d20 00000000 4f525245 203a2052      ms.....ERROR : 
   9a108:	65686353 656c7564 78652072 64657469     Scheduler exited
   9a118:	00002120 2d2d2d2d 2d2d2d2d 2d2d2d2d      !..------------
   9a128:	202d2d2d 4f647241 74532073 20737461     --- ArdOs Stats 
   9a138:	2d2d2d20 2d2d2d2d 2d2d2d2d 2d2d2d2d      ---------------
   9a148:	002d2d2d 2020207c 65726854 20206461     ---.|   Thread  
   9a158:	53207c20 65746174 50207c20 206f6972      | State | Prio 
   9a168:	7246207c 73206565 6b636174 49207c20     | Free stack | I
   9a178:	007c2044 2d2d2d2d 2d2d2d2d 2d2d2d2d     D |.------------
   9a188:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
   9a198:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
   9a1a8:	002d2d2d 53202a20 65746174 203a2073     ---. * States : 
   9a1b8:	636f6c62 2064656b 27422728 72202c29     blocked ('B'), r
   9a1c8:	79646165 52272820 202c2927 656c6564     eady ('R'), dele
   9a1d8:	20646574 27442728 726f2029 73757320     ted ('D') or sus
   9a1e8:	646e6570 28206465 29275327 0000002e     pended ('S')....
   9a1f8:	50202a20 726f6972 20797469 6968203a      * Priority : hi
   9a208:	72656867 6d756e20 2c726562 67696820     gher number, hig
   9a218:	20726568 6f697270 79746972 00000000     her priority....
   9a228:	5420624e 61657268 3a207364 00000020     Nb Threads : ...
   9a238:	00202f20 4d20624e 78657475 3a207365      / .Nb Mutexes :
   9a248:	00000020 5320624e 616e6769 3a20736c      ...Nb Signals :
   9a258:	00000020 746f6f42 69206465 0000206e      ...Booted in ..
   9a268:	4f647241 73692073 746f6e20 206e6920     ArdOs is not in 
   9a278:	20656874 68676972 74732074 20657461     the right state 
   9a288:	64206f74 2061206f 65726874 63206461     to do a thread c
   9a298:	74616572 006e6f69 206f6f54 796e616d     reation.Too many
   9a2a8:	72687420 73646165 0000002e 69727020      threads.... pri
   9a2b8:	7469726f 00282079 73692029 6f6f7420     ority (.) is too
   9a2c8:	67696820 6d282068 69207861 00002073      high (max is ..
   9a2d8:	63202c29 6b636568 726f6620 61747320     ), check for sta
   9a2e8:	702f6b63 726f6972 20797469 6564726f     ck/priority orde
   9a2f8:	726f2072 636e6920 73616572 616d2065     r or increase ma
   9a308:	61762078 2065756c 46206e69 52656572     x value in FreeR
   9a318:	43736f74 69666e6f 2e682e67 00000000     tosConfig.h.....
   9a328:	6b736154 65726320 6f697461 6166206e     Task creation fa
   9a338:	64656c69 0000002e 4f647241 73692073     iled....ArdOs is
   9a348:	746f6e20 206e6920 20656874 68676972      not in the righ
   9a358:	74732074 20657461 64206f74 2061206f     t state to do a 
   9a368:	6e676973 63206c61 74616572 006e6f69     signal creation.
   9a378:	6d206f4e 2065726f 70616568 00000000     No more heap....
   9a388:	4f647241 73692073 746f6e20 206e6920     ArdOs is not in 
   9a398:	20656874 68676972 74732074 20657461     the right state 
   9a3a8:	73206f74 61207465 67697320 2e6c616e     to set a signal.
   9a3b8:	00000000 4f647241 73692073 746f6e20     ....ArdOs is not
   9a3c8:	206e6920 20656874 68676972 74732074      in the right st
   9a3d8:	20657461 77206f74 20746961 20726f66     ate to wait for 
   9a3e8:	69732061 6c616e67 0000002e 4f647241     a signal....ArdO
   9a3f8:	73692073 746f6e20 206e6920 20656874     s is not in the 
   9a408:	68676972 74732074 20657461 64206f74     right state to d
   9a418:	2061206f 6574756d 72632078 69746165     o a mutex creati
   9a428:	00006e6f 4f647241 73692073 746f6e20     on..ArdOs is not
   9a438:	206e6920 20656874 68676972 74732074      in the right st
   9a448:	20657461 6c206f74 206b636f 756d2061     ate to lock a mu
   9a458:	00786574 4f647241 73692073 746f6e20     tex.ArdOs is not
   9a468:	206e6920 20656874 68676972 74732074      in the right st
   9a478:	20657461 75206f74 636f6c6e 2061206b     ate to unlock a 
   9a488:	6574756d 00000078 4f647241 73692073     mutex...ArdOs is
   9a498:	746f6e20 206e6920 20656874 68676972      not in the righ
   9a4a8:	74732074 20657461 64206f74 2061206f     t state to do a 
   9a4b8:	616d6573 726f6870 72632065 69746165     semaphore creati
   9a4c8:	00006e6f 4f647241 73692073 746f6e20     on..ArdOs is not
   9a4d8:	206e6920 20656874 68676972 74732074      in the right st
   9a4e8:	20657461 67206f74 20657669 65732061     ate to give a se
   9a4f8:	6870616d 0065726f 4f647241 73692073     maphore.ArdOs is
   9a508:	746f6e20 206e6920 20656874 68676972      not in the righ
   9a518:	74732074 20657461 74206f74 20656b61     t state to take 
   9a528:	65732061 6870616d 0065726f 412a2020     a semaphore.  *A
   9a538:	52455353 3a202a54 00000020 5f6f6966     SSERT* : ...fio_
   9a548:	616e616d 5f726567 69676572 72657473     manager_register
   9a558:	72206e49 69656365 20646576 756e2061     In received a nu
   9a568:	70206c6c 746e696f 00007265 5f6f6966     ll pointer..fio_
   9a578:	616e616d 20726567 66207369 2c6c6c75     manager is full,
   9a588:	6e616320 61207427 61206464 77656e20      can't add a new
   9a598:	6e697020 00000000 00494d48               pin....HMI.

0009a5a4 <_ZTVN3ard9HmiThreadE>:
	...
   9a5ac:	00084e9d 00084ed1 00084f39 00084f71     .N...N..9O..qO..

0009a5bc <_ZTVN3ard7IThreadE>:
	...
   9a5c4:	00087829 00087829 00000000 00000000     )x..)x..........
   9a5d4:	00000000 00676f4c 676f4c5b 65726854     ....Log.[LogThre
   9a5e4:	205d6461 74696e49 696c6169 676e697a     ad] Initializing
   9a5f4:	20445320 64726163 002e2e2e 676f4c5b      SD card....[Log
   9a604:	65726854 205d6461 63204453 20647261     Thread] SD card 
   9a614:	74696e69 49414620 2c44454c 20726f20     init FAILED, or 
   9a624:	20746f6e 73657270 2c746e65 676f6c20     not present, log
   9a634:	72657020 74736973 79636e65 73696420      persistency dis
   9a644:	656c6261 00002e64 676f4c5b 65726854     abled...[LogThre
   9a654:	205d6461 63204453 20647261 74696e69     ad] SD card init
   9a664:	43555320 53534543 0000002e 2d2d2d20      SUCCESS.... ---
   9a674:	42454420 2d204755 28202d2d 20656573      DEBUG --- (see 
   9a684:	5f445241 55424544 6e692047 64724120     ARD_DEBUG in Ard
   9a694:	682e734f 00002029 5441465b 205d4c41     Os.h) ..[FATAL] 
   9a6a4:	65726f4d 61687420 3532206e 6f6c2035     More than 255 lo
   9a6b4:	68207367 20657661 6e656562 736f6c20     gs have been los
   9a6c4:	00002e74 5441465b 205d4c41 00000000     t...[FATAL] ....
   9a6d4:	676f6c20 61682073 62206576 206e6565      logs have been 
   9a6e4:	74736f6c 0000002e 2e676f6c 00747874     lost....log.txt.
   9a6f4:	5441465b 205d4c41 6c696146 74206465     [FATAL] Failed t
   9a704:	706f206f 6c206e65 6620676f 2c656c69     o open log file,
   9a714:	63445320 20647261 67676f6c 20676e69      SDcard logging 
   9a724:	74616566 20657275 61736964 64656c62     feature disabled
   9a734:	0000002e 55424544 00000047 4f464e49     ....DEBUG...INFO
   9a744:	00000000 4f525245 00000052 00005b20     ....ERROR... [..
   9a754:	0000205d                                ] ..

0009a758 <_ZTVN3ard9LogThreadE>:
	...
   9a760:	000851c9 00085309 0008500d 0008508d     .Q...S...P...P..
   9a770:	00085385 fffffffc 00000000 00085085     .S...........P..
   9a780:	000850b5 00085499                       .P...T..

0009a788 <_ZTVN3ard7ILoggerE>:
	...
   9a798:	00087829 2056414e 7473203a 20657461     )x..NAV : state 
   9a7a8:	6e616863 20646567 6d6f7266 00002020     changed from  ..
   9a7b8:	206f7420 00000000 2056414e 656e203a      to ....NAV : ne
   9a7c8:	726f2077 20726564 00000000 00000028     w order ....(...
   9a7d8:	0000202c 00002029 0000002e 2056414e     , ..) ......NAV 
   9a7e8:	6166203a 676e6963 73656420 616e6974     : facing destina
   9a7f8:	6e6f6974 6562202c 6e6e6967 20676e69     tion, beginning 
   9a808:	656e696c 0000002e 2056414e 726f203a     line....NAV : or
   9a818:	20726564 696e6966 64656873 0000002e     der finished....
   9a828:	2056414e 726f203a 20726564 65746e69     NAV : order inte
   9a838:	70757272 2e646574 00000000 2056414e     rrupted.....NAV 
   9a848:	6f70203a 69746973 73206e6f 74207465     : position set t
   9a858:	003a206f 2056414e 656e203a 726f2077     o :.NAV : new or
   9a868:	20726564 646e6570 20676e69 69746e75     der pending unti
   9a878:	7563206c 6e657272 726f2074 20726564     l current order 
   9a888:	66207369 73696e69 00646568 412a2020     is finished.  *A
   9a898:	52455353 3a202a54 00000020 20746f6e     SSERT* : ...not 
   9a8a8:	6c706d69 6e656d65 00646574 2056414e     implemented.NAV 
   9a8b8:	6f63203a 20726f6c 756f6873 6e20646c     : color should n
   9a8c8:	6220746f 65732065 6f742074 646e7520     ot be set to und
   9a8d8:	6e696665 002e6465 2056414e 6f43203a     efined..NAV : Co
   9a8e8:	20726f6c 20746573 3a206f74 45525020     lor set to : PRE
   9a8f8:	00000046 2056414e 6f43203a 20726f6c     F...NAV : Color 
   9a908:	20746573 3a206f74 4d595320 00000000     set to : SYM....
   9a918:	2056414e 7563203a 6e657272 726f2074     NAV : current or
   9a928:	20726564 69207369 7265746e 74707572     der is interrupt
   9a938:	002e6465 534e4553 444e555f 4e494645     ed..SENS_UNDEFIN
   9a948:	00004445 534e4553 0056415f 534e4553     ED..SENS_AV.SENS
   9a958:	0052415f 76614e65 6564724f 4e3a3a72     _AR.eNavOrder::N
   9a968:	4948544f 0000474e 76614e65 6564724f     OTHING..eNavOrde
   9a978:	473a3a72 004f544f 76614e65 6564724f     r::GOTO.eNavOrde
   9a988:	473a3a72 5f4f544f 00504143 76614e65     r::GOTO_CAP.eNav
   9a998:	74617453 493a3a65 00454c44 76614e65     State::IDLE.eNav
   9a9a8:	74617453 463a3a65 4e494341 45445f47     State::FACING_DE
   9a9b8:	00005453 76614e65 74617453 473a3a65     ST..eNavState::G
   9a9c8:	474e494f 5f4f545f 47524154 00005445     OING_TO_TARGET..
   9a9d8:	76614e65 74617453 543a3a65 494e5255     eNavState::TURNI
   9a9e8:	415f474e 41545f54 54454752 00000000     NG_AT_TARGET....
   9a9f8:	76614e65 74617453 493a3a65 5245544e     eNavState::INTER
   9aa08:	54505552 5f474e49 4544524f 00000052     RUPTING_ORDER...

0009aa18 <_ZTVN3ard10NavigationE>:
	...
   9aa20:	00085bb5 00085c19 00086a99 00086ae9     .[...\...j...j..

0009aa30 <_ZTVN3ard19IMiniPeriodicThreadE>:
	...
   9aa38:	00087829 00087829 00000000 00000000     )x..)x..........
   9aa48:	656c6554 0000706f                       Teleop..

0009aa50 <_ZTVN3ard12TeleopThreadE>:
	...
   9aa58:	00086bf9 00086c29 00086b71 00086ba9     .k..)l..qk...k..
   9aa68:	75746341 726f7461 00000073 412a2020     Actuators...  *A
   9aa78:	52455353 3a202a54 00000020 75746341     SSERT* : ...Actu
   9aa88:	726f7461 203a2073 206f6f74 796e616d     ators : too many
   9aa98:	6e696d20 68742069 64616572 00000073      mini threads...

0009aaa8 <_ZTVN3ard14ActuatorThreadE>:
	...
   9aab0:	00086c99 00086d01 00086e1d 00086e55     .l...m...n..Un..
   9aac0:	61727453 79676574 00000000 41525453     Strategy....STRA
   9aad0:	203a2054 74696157 20676e69 72617473     T : Waiting star
   9aae0:	69772074 72646874 002e7761 41525453     t withdraw..STRA
   9aaf0:	203a2054 61727453 79676574 706c415f     T : Strategy_Alp
   9ab00:	002e6168 41525453 203a2054 65766f4d     ha..STRAT : Move
   9ab10:	64726f20 73207265 2c746e65 69617720      order sent, wai
   9ab20:	676e6974 002e2e2e 41525453 203a2054     ting....STRAT : 
   9ab30:	75746552 74206e72 7473206f 20747261     Return to start 
   9ab40:	2c736f70 69617720 676e6974 002e2e2e     pos, waiting....
   9ab50:	41525453 203a2054 696e6946 64656873     STRAT : Finished
   9ab60:	0000002e 41525453 203a2054 61727453     ....STRAT : Stra
   9ab70:	79676574 64654c5f 74736554 0000002e     tegy_LedTest....
   9ab80:	41525453 203a2054 61727453 79676574     STRAT : Strategy
   9ab90:	7475425f 546e6f74 2e747365 00000000     _ButtonTest.....
   9aba0:	41525453 203a2054 61727453 79676574     STRAT : Strategy
   9abb0:	726d4f5f 65546e6f 002e7473 72657355     _OmronTest..User
   9abc0:	73616820 6c657320 65746365 52502064      has selected PR
   9abd0:	28204645 6c6c6559 2029776f 6f6c6f63     EF (Yellow) colo
   9abe0:	00000072 72657355 73616820 6c657320     r...User has sel
   9abf0:	65746365 59532064 4228204d 2965756c     ected SYM (Blue)
   9ac00:	6c6f6320 0000726f 72657355 73616820      color..User has
   9ac10:	6c657320 65746365 74732064 65746172      selected strate
   9ac20:	00207967                                gy .

0009ac24 <_ZTVN3ard14StrategyThreadE>:
	...
   9ac2c:	00086ff5 00087025 000877c9 00087801     .o..%p...w...x..
   9ac3c:	00000a0d 006e616e 00666e69 0066766f     ....nan.inf.ovf.
   9ac4c:	0000002e                                ....

0009ac50 <_ZTV5Print>:
	...
   9ac58:	00087829 0008793d 00000000 00000008     )x..=y..........
   9ac68:	00000010 00000018 00000040 00000050     ........@...P...
   9ac78:	00000060 00000070 00000200 00000240     `...p.......@...
   9ac88:	00000280 000002c0 00000300 00000340     ............@...
   9ac98:	00000380 000003c0 68437764 656e6e61     ........dwChanne
   9aca8:	203c206c 7a697328 28666f65 63547020     l < (sizeof( pTc
   9acb8:	43543e2d 4148435f 4c454e4e 732f2920     ->TC_CHANNEL )/s
   9acc8:	6f657a69 70202866 3e2d6354 435f4354     izeof( pTc->TC_C
   9acd8:	4e4e4148 305b4c45 2929205d 00000000     HANNEL[0] ))....
   9ace8:	302f2e2e 5053425f 6472412f 6f6e6975     ../0_BSP/Arduino
   9acf8:	65726f43 756f732f 2f656372 632e6374     Core/source/tc.c
   9ad08:	00000000                                ....

0009ad0c <__func__.7028>:
   9ad0c:	435f4354 69666e6f 65727567 00000000     TC_Configure....

0009ad1c <__func__.7034>:
   9ad1c:	535f4354 74726174 00000000              TC_Start....

0009ad28 <_ZTV10USARTClass>:
	...
   9ad30:	0008083d 0008793d 0008071d 00080791     =...=y..........
   9ad40:	00080749 000807f1 00088a01 000806d1     I...............
   9ad50:	00080551                                Q...

0009ad54 <_ZL13_cdcInterface>:
   9ad54:	02000b08 00010202 00000409 00020201     ................
   9ad64:	00240500 24050110 04010101 05060224     ..$....$....$...
   9ad74:	01000624 03810507 09100010 02000104     $...............
   9ad84:	0000000a 02020507 07000200 00028305     ................
   9ad94:	00000002                                ....

0009ad98 <_ZL18_cdcOtherInterface>:
   9ad98:	02000b08 00010202 00000409 00020201     ................
   9ada8:	00240500 24050110 04010101 05060224     ..$....$....$...
   9adb8:	01000624 03810507 09100010 02000104     $...............
   9adc8:	0000000a 02020507 07000040 40028305     ........@......@
   9add8:	00000000                                ....

0009addc <_ZTV7Serial_>:
	...
   9ade4:	00088e05 00088d9d 00088c79 00088d01     ........y.......
   9adf4:	00088cbd 00088d81 00088ca5 00088b99     ................

0009ae04 <_ZTV12AccelStepper>:
	...
   9ae0c:	0008a21d 0008a269 00089e01 00089d4d     ....i.......M...
   9ae1c:	00089e95 00089ecd 00089f59 00089fcd     ........Y.......
   9ae2c:	0008a035 0008a0a9 0008a159              5.......Y...

0009ae38 <_ZTVN5SDLib4FileE>:
	...
   9ae40:	0008a4c1 0008a4e9 0008a5e5 0008a5b5     ................
   9ae50:	0008a569 0008a629 0000002f 5e3e3c7c     i...).../...|<>^
   9ae60:	2f3f3d2b 2c3b5d5b 005c222a              +=?/[];,*"\.

0009ae6c <_ZTV6SdFile>:
	...
   9ae74:	0008ca79 0008793d 454c4449 00000000     y...=y..IDLE....
   9ae84:	09632509 25097525 75250975 00000a0d     .%c.%u.%u.%u....
   9ae94:	20726d54 00637653 412a2020 52455353     Tmr Svc.  *ASSER
   9aea4:	3a202a54 00000020 6f6c6f43 68732072     T* : ...Color sh
   9aeb4:	646c756f 746f6e20 20656220 65646e75     ould not be unde
   9aec4:	656e6966 00000064 00000028 0000202c     fined...(..., ..
   9aed4:	00000029                                )...

0009aed8 <_ZTVN3ard8PointCapE>:
	...
   9aee0:	00086b11 00086b49 0008fbf1              .k..Ik......

0009aeec <_ZTVN3ard5PointE>:
	...
   9aef4:	000859fd 00085a29 0008fa09 64252525     .Y..)Z......%%%d
   9af04:	6664252e 00000000 74727173 00000000     .%df....sqrt....

0009af14 <npio2_hw>:
   9af14:	3ff921fb 400921fb 4012d97c 401921fb     .!.?.!.@|..@.!.@
   9af24:	401f6a7a 4022d97c 4025fdbb 402921fb     zj.@|."@..%@.!)@
   9af34:	402c463a 402f6a7a 4031475c 4032d97c     :F,@zj/@\G1@|.2@
   9af44:	40346b9c 4035fdbb 40378fdb 403921fb     .k4@..5@..7@.!9@
   9af54:	403ab41b 403c463a 403dd85a 403f6a7a     ..:@:F<@Z.=@zj?@
   9af64:	40407e4c 4041475c 4042106c 4042d97c     L~@@\GA@l.B@|.B@
   9af74:	4043a28c 40446b9c 404534ac 4045fdbb     ..C@.kD@.4E@..E@
   9af84:	4046c6cb 40478fdb 404858eb 404921fb     ..F@..G@.XH@.!I@

0009af94 <two_over_pi>:
   9af94:	00a2f983 006e4e44 001529fc 002757d1     ....DNn..)...W'.
   9afa4:	00f534dd 00c0db62 0095993c 00439041     .4..b...<...A.C.
   9afb4:	00fe5163 00abdebb 00c561b7 00246e3a     cQ.......a..:n$.
   9afc4:	00424dd2 00e00649 002eea09 00d1921c     .MB.I...........
   9afd4:	00fe1deb 001cb129 00a73ee8 008235f5     ....)....>...5..
   9afe4:	002ebb44 0084e99c 007026b4 005f7e41     D........&p.A~_.
   9aff4:	003991d6 00398353 0039f49c 00845f8b     ..9.S.9...9.._..
   9b004:	00bdf928 003b1ff8 0097ffde 0005980f     (.....;.........
   9b014:	00ef2f11 008b5a0a 006d1f6d 00367ecf     ./...Z..m.m..~6.
   9b024:	0027cb09 00b74f46 003f669e 005fea2d     ..'.FO...f?.-._.
   9b034:	007527ba 00c7ebe5 00f17b3d 000739f7     .'u.....={...9..
   9b044:	008a5292 00ea6bfb 005fb11f 008d5d08     .R...k...._..]..
   9b054:	00560330 0046fc7b 006babf0 00cfbc20     0.V.{.F...k. ...
   9b064:	009af436 001da9e3 0091615e 00e61b08     6.......^a......
   9b074:	00659985 005f14a0 0068408d 00ffd880     ..e..._..@h.....
   9b084:	004d7327 00310606 001556ca 0073a8c9     'sM...1..V....s.
   9b094:	0060e27b 00c08c6b                       {.`.k...

0009b09c <init_jk>:
   9b09c:	00000002 00000003 00000004 00000006     ................
   9b0ac:	00000000                                ....

0009b0b0 <PIo2>:
   9b0b0:	40000000 3ff921fb 00000000 3e74442d     ...@.!.?....-Dt>
   9b0c0:	80000000 3cf84698 60000000 3b78cc51     .....F.<...`Q.x;
   9b0d0:	80000000 39f01b83 40000000 387a2520     .......9...@ %z8
   9b0e0:	80000000 36e38222 00000000 3569f31d     ...."..6......i5

0009b0f0 <atanlo>:
   9b0f0:	222f65e2 3c7a2b7f 33145c07 3c81a626     .e/".+z<.\.3&..<
   9b100:	7af0cbbd 3c700788 33145c07 3c91a626     ...z..p<.\.3&..<

0009b110 <atanhi>:
   9b110:	0561bb4f 3fddac67 54442d18 3fe921fb     O.a.g..?.-DT.!.?
   9b120:	d281f69b 3fef730b 54442d18 3ff921fb     .....s.?.-DT.!.?
   9b130:	7566202c 6974636e 203a6e6f 00000000     , function: ....
   9b140:	65737361 6f697472 2522206e 66202273     assertion "%s" f
   9b150:	656c6961 66203a64 20656c69 22732522     ailed: file "%s"
   9b160:	696c202c 2520656e 25732564 00000a73     , line %d%s%s...
   9b170:	00000043                                C...

0009b174 <_global_impure_ptr>:
   9b174:	20070120                                 .. 

0009b178 <zeroes.7035>:
   9b178:	30303030 30303030 30303030 30303030     0000000000000000
   9b188:	00464e49 00666e69 004e414e 006e616e     INF.inf.NAN.nan.
   9b198:	33323130 37363534 42413938 46454443     0123456789ABCDEF
   9b1a8:	00000000 33323130 37363534 62613938     ....0123456789ab
   9b1b8:	66656463 00000000 6c756e28 0000296c     cdef....(null)..
   9b1c8:	00000030                                0...

0009b1cc <blanks.7034>:
   9b1cc:	20202020 20202020 20202020 20202020                     

0009b1dc <zeroes.6993>:
   9b1dc:	30303030 30303030 30303030 30303030     0000000000000000

0009b1ec <blanks.6992>:
   9b1ec:	20202020 20202020 20202020 20202020                     
   9b1fc:	69666e49 7974696e 00000000 004e614e     Infinity....NaN.
   9b20c:	49534f50 00000058 0000002e              POSIX.......

0009b218 <__mprec_tens>:
   9b218:	00000000 3ff00000 00000000 40240000     .......?......$@
   9b228:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
   9b238:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
   9b248:	00000000 412e8480 00000000 416312d0     .......A......cA
   9b258:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
   9b268:	20000000 4202a05f e8000000 42374876     ... _..B....vH7B
   9b278:	a2000000 426d1a94 e5400000 42a2309c     ......mB..@..0.B
   9b288:	1e900000 42d6bcc4 26340000 430c6bf5     .......B..4&.k.C
   9b298:	37e08000 4341c379 85d8a000 43763457     ...7y.AC....W4vC
   9b2a8:	674ec800 43abc16d 60913d00 43e158e4     ..Ngm..C.=.`.X.C
   9b2b8:	78b58c40 4415af1d d6e2ef50 444b1ae4     @..x...DP.....KD
   9b2c8:	064dd592 4480f0cf c7e14af6 44b52d02     ..M....D.J...-.D
   9b2d8:	79d99db4 44ea7843                       ...yCx.D

0009b2e0 <__mprec_bigtens>:
   9b2e0:	37e08000 4341c379 b5056e17 4693b8b5     ...7y.AC.n.....F
   9b2f0:	e93ff9f5 4d384f03 f9301d32 5a827748     ..?..O8M2.0.Hw.Z
   9b300:	7f73bf3c 75154fdd                       <.s..O.u

0009b308 <p05.5373>:
   9b308:	00000005 00000019 0000007d              ........}...

0009b314 <_init>:
   9b314:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   9b316:	bf00      	nop
   9b318:	bcf8      	pop	{r3, r4, r5, r6, r7}
   9b31a:	bc08      	pop	{r3}
   9b31c:	469e      	mov	lr, r3
   9b31e:	4770      	bx	lr

0009b320 <__init_array_start>:
   9b320:	00096bb1 	.word	0x00096bb1

0009b324 <__frame_dummy_init_array_entry>:
   9b324:	00080119 000801f9 0008174d 00081b85     ........M.......
   9b334:	00082b91 00084509 0008595d 00088e85     .+...E..]Y......
   9b344:	0008aca1 0008b8b9 00090445              ........E...

0009b350 <_fini>:
   9b350:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   9b352:	bf00      	nop
   9b354:	bcf8      	pop	{r3, r4, r5, r6, r7}
   9b356:	bc08      	pop	{r3}
   9b358:	469e      	mov	lr, r3
   9b35a:	4770      	bx	lr

0009b35c <__fini_array_start>:
   9b35c:	000800f5 	.word	0x000800f5

Disassembly of section .relocate:

20070000 <banzai>:
#ifdef __cplusplus
extern "C" {
#endif

__attribute__ ((long_call, section (".ramfunc")))
void banzai() {
20070000:	b480      	push	{r7}
20070002:	b085      	sub	sp, #20
20070004:	af00      	add	r7, sp, #0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
20070006:	b672      	cpsid	i
	// Disable all interrupts
	__disable_irq();

	// Set bootflag to run SAM-BA bootloader at restart
	const int EEFC_FCMD_CGPB = 0x0C;
20070008:	230c      	movs	r3, #12
2007000a:	60fb      	str	r3, [r7, #12]
	const int EEFC_KEY = 0x5A;
2007000c:	235a      	movs	r3, #90	; 0x5a
2007000e:	60bb      	str	r3, [r7, #8]
	while ((EFC0->EEFC_FSR & EEFC_FSR_FRDY) == 0);
20070010:	4b10      	ldr	r3, [pc, #64]	; (20070054 <banzai+0x54>)
20070012:	689b      	ldr	r3, [r3, #8]
20070014:	f003 0301 	and.w	r3, r3, #1
20070018:	2b00      	cmp	r3, #0
2007001a:	bf0c      	ite	eq
2007001c:	2301      	moveq	r3, #1
2007001e:	2300      	movne	r3, #0
20070020:	b2db      	uxtb	r3, r3
20070022:	2b00      	cmp	r3, #0
20070024:	d000      	beq.n	20070028 <banzai+0x28>
20070026:	e7f3      	b.n	20070010 <banzai+0x10>
	EFC0->EEFC_FCR =
20070028:	4b0a      	ldr	r3, [pc, #40]	; (20070054 <banzai+0x54>)
		EEFC_FCR_FCMD(EEFC_FCMD_CGPB) |
		EEFC_FCR_FARG(1) |
		EEFC_FCR_FKEY(EEFC_KEY);
2007002a:	4a0b      	ldr	r2, [pc, #44]	; (20070058 <banzai+0x58>)
2007002c:	605a      	str	r2, [r3, #4]
	while ((EFC0->EEFC_FSR & EEFC_FSR_FRDY) == 0);
2007002e:	4b09      	ldr	r3, [pc, #36]	; (20070054 <banzai+0x54>)
20070030:	689b      	ldr	r3, [r3, #8]
20070032:	f003 0301 	and.w	r3, r3, #1
20070036:	2b00      	cmp	r3, #0
20070038:	bf0c      	ite	eq
2007003a:	2301      	moveq	r3, #1
2007003c:	2300      	movne	r3, #0
2007003e:	b2db      	uxtb	r3, r3
20070040:	2b00      	cmp	r3, #0
20070042:	d000      	beq.n	20070046 <banzai+0x46>
20070044:	e7f3      	b.n	2007002e <banzai+0x2e>

	// From here flash memory is no more available.

	// BANZAIIIIIII!!!
	const int RSTC_KEY = 0xA5;
20070046:	23a5      	movs	r3, #165	; 0xa5
20070048:	607b      	str	r3, [r7, #4]
	RSTC->RSTC_CR =
2007004a:	4b04      	ldr	r3, [pc, #16]	; (2007005c <banzai+0x5c>)
		RSTC_CR_KEY(RSTC_KEY) |
		RSTC_CR_PROCRST |
		RSTC_CR_PERRST;
2007004c:	4a04      	ldr	r2, [pc, #16]	; (20070060 <banzai+0x60>)
2007004e:	601a      	str	r2, [r3, #0]

	while (true);
20070050:	e7fe      	b.n	20070050 <banzai+0x50>
20070052:	bf00      	nop
20070054:	400e0a00 	.word	0x400e0a00
20070058:	5a00010c 	.word	0x5a00010c
2007005c:	400e1a00 	.word	0x400e1a00
20070060:	a5000005 	.word	0xa5000005

20070064 <__dso_handle>:
20070064:	00000000                                ....

20070068 <EndPoints>:
20070068:	00002032 00003936 00003066 00003166     2 ..69..f0..f1..
	...

20070090 <SystemCoreClock>:
20070090:	003d0900                                ..=.

20070094 <_ZN8DueTimer9callbacksE>:
20070094:	00000001 00000000 00000001 00000001     ................
200700a4:	00000001 00000001 00000000 00000000     ................
200700b4:	00000000                                ....

200700b8 <_ZN8DueTimer10_frequencyE>:
200700b8:	00000000 bff00000 00000000 bff00000     ................
200700c8:	00000000 bff00000 00000000 bff00000     ................
200700d8:	00000000 bff00000 00000000 bff00000     ................
200700e8:	00000000 bff00000 00000000 bff00000     ................
200700f8:	00000000 bff00000                       ........

20070100 <_ZL5ticks>:
20070100:	ffffffff                                ....

20070104 <g_interrupt_enabled>:
20070104:	00000001                                ....

20070108 <_ZL12_usbLineInfo>:
20070108:	0000e100 00080000                       ........

20070110 <_ZL10breakValue>:
20070110:	ffffffff                                ....

20070114 <_ZN8SdVolume17cacheBlockNumber_E>:
20070114:	ffffffff                                ....

20070118 <uxCriticalNesting>:
20070118:	aaaaaaaa                                ....

2007011c <__fdlib_version>:
2007011c:	00000001                                ....

20070120 <impure_data>:
20070120:	00000000 2007040c 20070474 200704dc     ....... t.. ... 
	...
20070154:	0009b170 00000000 00000000 00000000     p...............
	...
200701c8:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
200701d8:	0005deec 0000000b 00000000 00000000     ................
	...

20070548 <_impure_ptr>:
20070548:	20070120                                 .. 

2007054c <__malloc_av_>:
	...
20070554:	2007054c 2007054c 20070554 20070554     L.. L.. T.. T.. 
20070564:	2007055c 2007055c 20070564 20070564     \.. \.. d.. d.. 
20070574:	2007056c 2007056c 20070574 20070574     l.. l.. t.. t.. 
20070584:	2007057c 2007057c 20070584 20070584     |.. |.. ... ... 
20070594:	2007058c 2007058c 20070594 20070594     ... ... ... ... 
200705a4:	2007059c 2007059c 200705a4 200705a4     ... ... ... ... 
200705b4:	200705ac 200705ac 200705b4 200705b4     ... ... ... ... 
200705c4:	200705bc 200705bc 200705c4 200705c4     ... ... ... ... 
200705d4:	200705cc 200705cc 200705d4 200705d4     ... ... ... ... 
200705e4:	200705dc 200705dc 200705e4 200705e4     ... ... ... ... 
200705f4:	200705ec 200705ec 200705f4 200705f4     ... ... ... ... 
20070604:	200705fc 200705fc 20070604 20070604     ... ... ... ... 
20070614:	2007060c 2007060c 20070614 20070614     ... ... ... ... 
20070624:	2007061c 2007061c 20070624 20070624     ... ... $.. $.. 
20070634:	2007062c 2007062c 20070634 20070634     ,.. ,.. 4.. 4.. 
20070644:	2007063c 2007063c 20070644 20070644     <.. <.. D.. D.. 
20070654:	2007064c 2007064c 20070654 20070654     L.. L.. T.. T.. 
20070664:	2007065c 2007065c 20070664 20070664     \.. \.. d.. d.. 
20070674:	2007066c 2007066c 20070674 20070674     l.. l.. t.. t.. 
20070684:	2007067c 2007067c 20070684 20070684     |.. |.. ... ... 
20070694:	2007068c 2007068c 20070694 20070694     ... ... ... ... 
200706a4:	2007069c 2007069c 200706a4 200706a4     ... ... ... ... 
200706b4:	200706ac 200706ac 200706b4 200706b4     ... ... ... ... 
200706c4:	200706bc 200706bc 200706c4 200706c4     ... ... ... ... 
200706d4:	200706cc 200706cc 200706d4 200706d4     ... ... ... ... 
200706e4:	200706dc 200706dc 200706e4 200706e4     ... ... ... ... 
200706f4:	200706ec 200706ec 200706f4 200706f4     ... ... ... ... 
20070704:	200706fc 200706fc 20070704 20070704     ... ... ... ... 
20070714:	2007070c 2007070c 20070714 20070714     ... ... ... ... 
20070724:	2007071c 2007071c 20070724 20070724     ... ... $.. $.. 
20070734:	2007072c 2007072c 20070734 20070734     ,.. ,.. 4.. 4.. 
20070744:	2007073c 2007073c 20070744 20070744     <.. <.. D.. D.. 
20070754:	2007074c 2007074c 20070754 20070754     L.. L.. T.. T.. 
20070764:	2007075c 2007075c 20070764 20070764     \.. \.. d.. d.. 
20070774:	2007076c 2007076c 20070774 20070774     l.. l.. t.. t.. 
20070784:	2007077c 2007077c 20070784 20070784     |.. |.. ... ... 
20070794:	2007078c 2007078c 20070794 20070794     ... ... ... ... 
200707a4:	2007079c 2007079c 200707a4 200707a4     ... ... ... ... 
200707b4:	200707ac 200707ac 200707b4 200707b4     ... ... ... ... 
200707c4:	200707bc 200707bc 200707c4 200707c4     ... ... ... ... 
200707d4:	200707cc 200707cc 200707d4 200707d4     ... ... ... ... 
200707e4:	200707dc 200707dc 200707e4 200707e4     ... ... ... ... 
200707f4:	200707ec 200707ec 200707f4 200707f4     ... ... ... ... 
20070804:	200707fc 200707fc 20070804 20070804     ... ... ... ... 
20070814:	2007080c 2007080c 20070814 20070814     ... ... ... ... 
20070824:	2007081c 2007081c 20070824 20070824     ... ... $.. $.. 
20070834:	2007082c 2007082c 20070834 20070834     ,.. ,.. 4.. 4.. 
20070844:	2007083c 2007083c 20070844 20070844     <.. <.. D.. D.. 
20070854:	2007084c 2007084c 20070854 20070854     L.. L.. T.. T.. 
20070864:	2007085c 2007085c 20070864 20070864     \.. \.. d.. d.. 
20070874:	2007086c 2007086c 20070874 20070874     l.. l.. t.. t.. 
20070884:	2007087c 2007087c 20070884 20070884     |.. |.. ... ... 
20070894:	2007088c 2007088c 20070894 20070894     ... ... ... ... 
200708a4:	2007089c 2007089c 200708a4 200708a4     ... ... ... ... 
200708b4:	200708ac 200708ac 200708b4 200708b4     ... ... ... ... 
200708c4:	200708bc 200708bc 200708c4 200708c4     ... ... ... ... 
200708d4:	200708cc 200708cc 200708d4 200708d4     ... ... ... ... 
200708e4:	200708dc 200708dc 200708e4 200708e4     ... ... ... ... 
200708f4:	200708ec 200708ec 200708f4 200708f4     ... ... ... ... 
20070904:	200708fc 200708fc 20070904 20070904     ... ... ... ... 
20070914:	2007090c 2007090c 20070914 20070914     ... ... ... ... 
20070924:	2007091c 2007091c 20070924 20070924     ... ... $.. $.. 
20070934:	2007092c 2007092c 20070934 20070934     ,.. ,.. 4.. 4.. 
20070944:	2007093c 2007093c 20070944 20070944     <.. <.. D.. D.. 

20070954 <__malloc_trim_threshold>:
20070954:	00020000                                ....

20070958 <__malloc_sbrk_base>:
20070958:	ffffffff                                ....

2007095c <lconv>:
2007095c:	0009b214 0009b13c 0009b13c 0009b13c     ....<...<...<...
2007096c:	0009b13c 0009b13c 0009b13c 0009b13c     <...<...<...<...
2007097c:	0009b13c 0009b13c ffffffff ffffffff     <...<...........
2007098c:	ffffffff 0000ffff                       ........

20070994 <lc_ctype_charset>:
20070994:	49435341 00000049 00000000 00000000     ASCII...........
	...

200709b4 <__mb_cur_max>:
200709b4:	00000001                                ....

200709b8 <__wctomb>:
200709b8:	00098f5d                                ]...
