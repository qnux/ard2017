/*
 * TeleopThread.cpp
 *
 *  Created on: 20 oct. 2016
 *      Author: wix
 */

#include "TeleopThread.h"
#include "Robot2017.h"

using namespace ard;

void TeleopThread::init()
{
    //create the thread
    g_ArdOs.createThread_Cpp("Teleop", *this, STACK_LOG, PRIO_LOG);
}

void TeleopThread::run()
{
    //use this function to shortcut the google protobuf layer in case you want a simple way of commanding the robot.
    //simpleSerialRun();

    //hldc local vars
    yahdlc_control_t control;
    char serial_framebuffer[200];
    unsigned int serial_index = 0;
    char hdlc_framebuffer[200];
    unsigned int hdlc_length = 0;
    INIT_TABLE_TO_ZERO(serial_framebuffer);
    INIT_TABLE_TO_ZERO(hdlc_framebuffer);
    while (2)
    {
        while (Serial.available())
        {
            // get the new byte:
            serial_framebuffer[serial_index] = (char)Serial.read();
            serial_index++;
            ardAssert(serial_index <= 200, "Serial framebuffer overshoot");

            //as a simple solution we filter char by char, for performance improvments we could modify the Arduino UARTClass
            //and add a ReadAll function to get a longer buffer. As long as only non-operational action is
            //done here, there is no need for performance
            if( 0 < yahdlc_get_data(&control, serial_framebuffer, serial_index , hdlc_framebuffer, &hdlc_length) )
            {
                //TODO frame received : treat it and reset buffer
                LOG(INFO, "HDLC frame received size=" + String(hdlc_length) + " msg=[" + String(hdlc_framebuffer) + "]");
                INIT_TABLE_TO_ZERO(serial_framebuffer);
                INIT_TABLE_TO_ZERO(hdlc_framebuffer);
                serial_index = 0;
            }
        } //end while serial available
        vTaskDelay(1);
    } //end while(2)
}

void TeleopThread::simpleSerialRun()
{
    while (2)
    {
        while (Serial.available())
        {
            auto cmd = Serial.read();
            LOG(INFO, "Command received : " + cmd);
            switch (cmd)
            {
            case 's': //Stats
            {
                g_ArdOs.displayStats();
                break;
            }

            case 'c': //configure
            {
                LOG(INFO, "configure match request received.");
                ROBOT.strategy.configureMatch(0, eColor::PREF);
                events[EVT_CONFIGURE].publish();
                break;
            }

            case 'g': //go
            {
                LOG(INFO, "start match request received.");
                events[EVT_START_MATCH].publish();
                break;
            }

            default:
            { //nothing done for now as pollution is generated by end of line characters
                LOG(DEBUG, "Teleop cmd " + String(cmd) + " unknown.");
                break;
            }
        }
    } //end while serial available
    vTaskDelay(1);
} //end while(2)
}

IEvent* TeleopThread::getEvent(eTeleopEvtId id)
{
    return &events[id];
}
